v4.4.5 (2016-02-14)
 Bugfixes:
  - bitbucket issue #15: constants of type type (given as their type name) work now in the compiled sequences
  - bitbucket issue #16: fixed implicit casts when accessing attributes of numeric types in the sequence expressions
                         by unboxing to a values of their exact type first 
  - bitbucket issue #17: method calls in sequence computations now support more than 2 arguments
  - bitbucket issue #18: container constructors used in (function or procedure) methods in the model work now

v4.4.4 (2015-11-01)
 Bugfixes / language constraint removals:
  - bitbucket #2: _external_ functions can now be called also from sequence expressions,
                  _external_ procedures can now be called also from sequence computations
  - bitbucket #12: global variable declarations and package definitions can be mixed with action definitions now,
                   previously they had to be given in the order global variables then packages then actions
  - bitbucket #3 related: writing attributes now also works for _variables_ of node/edge type
  - bitbucket #10: it is now ensured elements needed in index access expressions are available in the pattern
                   (when they are not contained/directly mentioned in the nesting pattern)
  - some further improvements/fixes in error handling

v4.4.3 (2015-10-12)
 Bugfixes:
  - bitbucket #3: typeof now also works for _variables_ of node/edge type (not the same as nodes/edges)
  - bitbucket #4: control characters are now correctly escaped in constants of expressions and yields
  - bitbucket #5, #6: fixed usage of node/edge types from a package under certain conditions (esp. in containers)
  - bitbucket #7: fixed comparison of a container with null (container type with null type)
  - bitbucket #8: reachableEdges loop now really iterates the reachable edges instead of the nodes
    related: reachableEdges and its incoming/outgoing versions now lock the root node at start,
             so each edge is visited at most twice (once for incoming/outgoing)
  - bitbucket #9: emithere, evalhere, eval don't add elements explicitly deleted to right pattern anymore,
                  just because they are mentioned in a RHS expression
    related: added semantic check that causes an error message if deleted elements are emitted
             (the emit comes after the delete, so zombie elements would be/are accessed;
              the emithere in contrast comes before the delete, so it can be used instead)

v4.4.2 (2015-09-06)
 Changed incidence count index declaration to use the counted function names
   so "countIncident" | "countIncoming" | "countOutgoing" instead of "incident" | "incoming" | "outgoing"
 Node and edge classes are generated as partial now
   so that they can be extended with own code, and thus integrated into own programs in an easier way
 Now hinting at maybe missing Java and printing search path when executing java/javaw fails
 Some user manual polishings

v4.4.1 (2015-03-26)
 Bugfixes and language construct polishings:
  - fixed grgen compiler not working under Windows 8 because of a failing ShellExecute of javaw
  - iterateds in subpatterns without a top-level/outermost modify part work now
  - local variable declarations and computation language casts support now package prefixed types
  - for loops over containers support now iteration variables of subtypes of the container type (for nodes/edges),
    an exception will be thrown if that type is not really contained (same as for loops over graph access functions)

v4.4 (2014-07-29)
 Rule all calls now return for *each* match its return values, 
  instead of the return values of an arbitrarily chosen one.
 They are returned in the form of array<T> for each return parameter of type T,
  the output arguments assigned to must be of a corresponding array type,
  this is checked at compile time (or runtime for untyped global variables).
 An all-call always returns an array for each out parameter, even if there is exactly one match,
  a normal rule always returns a scalar as before; so r : (Node, int) must be called with
  (a:array<Node>,i:array<int>)=[r] for all calls, instead of (a:Node,i:int)=r for normal calls

 Added new array methods:
  - array<T>.reverse() 
    which returns a reversed version of the array
  - array<T>.orderAscending() 
    which returns a sorted version of the array 
    (not available for arrays of graph,node,edge,container type)
  - array<T>.indexOfOrdered(.) 
    which returns the index of an occurence of the given element in the array;
    the array must be sorted, otherwise results returned by the binary search will be wrong;
    in case of multiple occurences, an arbitray one is returned.

 Added new array methods on arrays of node or edge types bearing attributes:
  - indexOfBy<attribute-name>(value [, startIndex]):int 
    returns the index of the first occurence of the attribute value in the array as seen from the begin on (or the start index)
  - lastIndexOfBy<attribute-name>(value [, startIndex]):int 
    returns the index of the first occurence of the attribute value in the array as seen from the end on (or the start index)
  - indexOfOrderedBy<attribute-name>(value [, startIndex]):int
    returns the index of an occurence of the attribute value in the array as found by a binary search
  - orderAscendingBy<attribute-name>():array<T>
    returns the array ordered ascendingly alongside the given attribute of the contained graph elements

 Added/changed several container transformation methods:
  - added set<T>.asArray() 
    which returns an array<T> filled with the content of the set (in enumeration order)
  - added array<T>.asMap() 
    which returns a map<int,T> filled with the content of the array, mapped-to by the index
  - added array<T>.asDeque() 
    which returns a deque<T> filled with the content of the array (in same order)
  - added deque<T>.asArray() 
    which returns an array<T> filled with the content of the deque (in same order)
  - added map<int,T>.asArray()
    which returns an array<T> with the content of the map,
    gaps are filled with the default value, up the maximum index available in the map
  - renamed string.explode(.) to string.asArray(.)
  - renamed array.implode(.) to array.asString(.)

 Added external methods to external attribute types:
  they are declared similar to normal functions or procedures, but with their signature only
  external class Foo {
    external function foo(int) : int;
    external procedure bar(int) : (int); 
  }
  
 Added a function to register own undo items to the transaction manager, 
  which will be called on rollback
  this allows to integrate changes to external attribute types to transaction handling.

 Added external change recording and replaying, with
  - a special command line of the grs files, starting with "external", ending with line end
  - in grs reading (by shell replay and grs import) the content in between is munched,
    and sent to a user-supplied external handler 
    void External(string line, IGraph graph)
    whose interface is emitted when the "external emit class" specification is given in the model,
    in addition to Parse, Serialize, Emit
  - support for external line writing in the recorder (to be called from external methods)
    intended for fine grain changes from method calls on external types,
    in contrast to coarse grain changes from assignments (to variables of external types)

 Added switch-case statement to rule language:
  with syntax: switch(expr) { cases },
  and cases being either: case constexpr { statements }
  or: else { statements }
  - every branch is enclosed in an block, at block end execution of the block ends,
    no implicit fall-through, a fall-through is not even available
  - only one else branch is allowed, it is hit in case no other branch was executed
  - only available for byte, short, int, long, string, boolean, enum types
  
 Added functions to retrieve the minimum and maximum numbers of the numeric types:
  - Math::byteMin(), Math::byteMax() for type byte
  - Math::shortMin(), Math::shortMax() for type short
  - Math::intMin(), Math::intMax() for type int
  - Math::longMin(), Math::longMax() for type long
  - Math::floatMin(), Math::floatMax() for type float
  - Math::doubleMin(), Math::doubleMax() for type double

 Extended array<T> and string lastIndexOf to support a second optional startIndex
 
 Improved quoted text handling in the sequences by
  - allowed escaped quotes in quoted texts
  - allowed single quoted string constants

 The grs importer is now able to import a recording
  (again, feature was lost in rewriting importer for higher performance)

 Extended profiling information to search steps occuring in evals, and in execs
 
 The debugger only listens to post attribute change events now,
  the pre attribute change events are now only used by the transaction manager and the recorder
 
 Some small and medium bugfixes

 
v4.4RC (2014-06-22)
 Grammar cleaning:
 - removed container literals without type prefix (they don't work well with other language features)
 - removed annotations for anonymous elements
 - external declarations must come with the external keyword, now mandatory
 - removed separate, non-nested pattern block in rules, deprecated since a long time
 - removed actions name declaration and keyword, deprecated since a long time
 - removed model name declaration and keyword, deprecated since a long time
 - removed usage of "->" in connection assertions, deprecated since a long time

 Further procedures modularization with builtin packages Transaction and Debug:
 - moved procedures startTransaction, pauseTranscation, resumeTransaction, 
   commitTransaction, rollbackTransaction to Transaction
 - renamed them to start, pause, resume, commit, rollback;
   sufficient as access must be qualified with "Transaction::" package prefix
 - moved procedure highlight to Debug
 - renamed File::deleteFile to File::delete and File::existsFile to File::exists

 Added index access loops to rule language statements:
 - offering the same functionality as the index access from the pattern,
   just as for loops in the yields, evals, functions, procedures
 - for(element:type in { index-name == expr })
   to iterate the elements from the index equal to the expression
 - for(element:type in { ascending(index-name [relop expr [, index-name relop expr]]) }
   to iterate ascendingly the elements from the index in between the specified bounds
 - for(element:type in { descending(index-name [relop expr [, index-name relop expr]]) }
   to iterate descendingly the elements from the index in between the specified bounds
   
 Added index access loops to sequences:
 - offering the same functionality as the index access loops from the rule language statements,
   just being a sequence and executing a sequence as body
 - for{element:type in { index-name == expr }; seq }
   to iterate the elements from the index equal to the expression
 - for{element:type in { ascending(index-name [relop expr [, index-name relop expr]]) }; seq }
   to iterate ascendingly the elements from the index in between the specified bounds
 - for{element:type in { descending(index-name [relop expr [, index-name relop expr]]) }; seq }
   to iterate descendingly the elements from the index in between the specified bounds

 Completed index support in the sequences with the sequence expression functions:
 - uniqueof(Node|Edge|graph):string, nameof(Node|Edge|graph):string
 - nodeByName(string):Node, edgeByName(string):Edge
 - nodeByUnique(string):Node, edgeByUnique(string):Edge
 Same semantics as the correspondingly named functions in the rule language.
 
 Added function equalsAny(graph, set<graph>):boolean to rule and sequence expressions:
 - returns whether the graph is isomorphic to any of the graphs in the set
   a sibling is available with equalsAnyStructurally neglecting the attributes (~~ instead of ==)
 - they are a bit more convenient than the loop,
   but most important offer a parallelized implementation
 - a "for equalsAny[parallelize=2];" in the model causes the usage of a
   parallelized version of equalsAny employing 2 worker threads (up to 64 possible)
   
 Added reachability functions that tell about the distance from the start:
 - boundedReachableWithRemainingDepth, 
 - boundedReachableWithRemainingDepthIncoming,
 - boundedReachableWithRemainingDepthOutgoing 
 yielding a map<Node,int>, that tells about the remaining depth of a search from the start node on
 (of the minimum distance path)
 
 The emit in the sequence computations now supports an arbitrary number of parameters,
  separated by commas, as supported by the emit in the rule language
  This form is to be prefered over + for string concatenation because of better performance.

 Added operators *, /, % to the sequence expressions
  for integer or floating-point multiplication, division, remainder-computation
  same semantics as their counterparts in the rule language expressions
  
 Added typeof(entity):string to the sequence expressions
  is mapping to string (not to type, there's no type type in the sequences)
 
 Added some string-related methods (in rule language expressions only):
 - string.startsWith(needle:string):string
   telling whether the string starts with the needle string
 - string.endsWith(needle:string):string
   telling whether the string ends with the needle string
 - needle in haystack
   telling whether string needle is contained in string haystack
 - string.toUpper():string
   returning the original string transformed to uppercase characters
 - string.toLower():string
   returning the original string transformed to lowercase characters
 - string.substring(startindex:int)
   returns the original string from start index on, until full length
   (overloaded version of string.substring(startindex:int, length:int) not requiring a length)
 - string.explode(separator:string):array<string>
   returns the original string exploded to an array of substrings at the separators,
   the separators are not included, if separator is empty, you get the original string
   exploded to an array of single-character strings
 
 Added some array/deque-related methods:
 - added array<string>.implode(separator:string):string
   returns the original array imploded to a string with the separator in between the substrings
 - added array<T>.asSet():set<T>
   returning the array content as set
 - added deque<T>.asSet():set<T> methods 
   returning the deque content as set
 - extended array<T>.indexOf(needle:T, startIndex:int) 
   to support an optional second startIndex parameter, to start the search at
 - extended deque<T>.indexOf(needle:T, startIndex:int) 
   to support an optional second startIndex parameter, to start the search at

 Added subrule debugging support with new procedures and debug trace events,
  to allow debugging of functions and procedures, and improve debugging of embedded execs:
 
 New procedures in rule language as well as sequence computations:
 - added Debug::add(message:string, params:object*) procedure,
   allows to communicate a computation entry to the debugger, from user code
 - added Debug::rem(message:string, params:object*) procedure ,
   allows to communicate a computation exit to the debugger, from user code
 - added Debug::emit(message:string, params:object*) procedure,
   allows to report a debug trace to the debugger, from user code
 - added Debug::halt(message:string, params:object*) procedure,
   allows to halt execution in the debugger, reporting a debug trace, from user code
 - changed/added Debug::highlight(message:string, (param:object, annotation:string)*) procedure,
   allows to halt execution in the debugger and highlight the parameters in the graph, 
   with the given annotations; this replaces the old highlight from sequences,
   and extends the rule version with the mandatory message string
   e.g. Debug::highlight("foo", x, "x", stor, x.str, 0, "visited flag 0") 
   highlights with the message/event/action "foo" in the graph
   - the node x with the annotation "x"
   - all nodes from stor:set<Node> with the string found in x.str
   - all nodes marked with visited flag 0 with "visited flag 0"

 Those procedures fire in the graph processing environment the events:
 - OnDebugEnter
 - OnDebugExit
 - OnDebugEmit
 - OnDebugHalt
 - OnDebugHighlight
 
 The debugger listens to the events, updating its knowledge of the computations currently carried out,
  and halting on the latter two commands, visually showing the graphs elements in case of the highlight.
 To this end it stores the computations entered and not yet left again on a stack.
  (As well as the debug emits that occured up to that point until their frame is left again.)

 The code generated by the compiler automatically fires add(=entry) and rem(=exit) events 
  for embedded sequences, including the sequence body as string parameter;
  and for compiled sequences and procedures, including the input and output values.

 Utilizing them, during detail mode debugging, the debugger shows the embedded sequence executed,
  or the compiled sequence calls, or the procedure calls, as context for the rules;
  the same holds when a halt or highlight is hit.

 The "dum(p) graph" of the debugger now writes an undo.log in addition to the graph dump
  in case a transaction is pending, with the contents of the undo log of the transaction manager
  (i.e. the commands to reverse the changes that occured, not the changes themselves)
  
 Added watchpoint / subrule debugging support and configuration rules to the shell/debugger.
 They can be edited interactively, or preconfigured with the following rules.
 - The rules allow to configure the behaviour of the debugger (break/continue)
   when a subrule debugging or graph change or action match event occurs.
 - For this the debugger stores a list of configuration rules,
   which are executed one after the other in case a debugging event occurs,
   in case they match their decision is applied, influencing debugging.

 The subrule debugging events configuration rules are:
 - "on" "add" <messageFilter> "break"
 - "on" "rem" <messageFilter> "break"
 - "on" "emit" <messageFilter> "break"
 - "on" "halt" <messageFilter> "continue"
 - "on" "highlight" <messageFilter> "continue"
 with messageFilter ::= ("equals"|"startsWith"|"endsWith"|"contains") "(" string ")"
 The string specified must match the message of the event with the mode given.
 The rules tell the debugger to break execution when a subrule is entered/exited/emitted,
 which normally occurs silently, is only defining the context for the breaking operations,
 which are halt/highlight, they can be configured to be skipped, not breaking execution.

 The action match event configuration rules are:
 - "on" "match" actionname "break"|"continue" ("if" <sequence-expression>)?
 The rules tell the debugger to break execution when an action is matched,
 which is of interest for actions executed from execs,
 as normal breakpoints don't apply to them,
 or to continue execution when an action is matched,
 which allows to leave out uninteresting actions from detail mode debugging,
 skip over actions in execs without the need to acknowledge them.
 The sequence-expression allows to do this conditionally,
 the "this" entity is overloaded in this context to give access to the match,
 the rule is executed for all matches, if one fires, the decision is carried out.

 The graph change event configuration rules are:
 - "on" "new" ( ("only")? Type | "@" "(" Name ")" ) "break"  ("if" <sequence-expression>)?
 - "on" "delete" ( ("only")? Type | "@" "(" Name ")" ) "break"  ("if" <sequence-expression>)?
 - "on" "retype" ( ("only")? Type | "@" "(" Name ")" ) "break"  ("if" <sequence-expression>)?
 - "on " "set" "attributes" ( ("only")? Type | "@" "(" Name ")" ) "break" ("if" <sequence-expression>)?
 The rules tell the debugger to break execution when a graph element is created,
 or deleted, or retyped, or one of its attributes is assigned.
 The first form does so when the element is of the specified type,
 in case of "only" if it is of exactly that type and not a subtype.
 The second form does so when the element is of the specified name (static string).
 The sequence-expression allows to do this conditionally,
 the "this" entity is overloaded in this context to give access to the node/edge 
 that is created/deleted/retyped/assigned-to.
 (So here we find support for conditional data breakpoints/watchpoints.)
   
 Added attribute post-change event(s):
 - fired after the attribute was changed, meant for debugging,
   telling only about the owning element and the attribute;
   the attribute is to be read by the code listening to the event
   much simpler than reacting to the detailed change type
 - complements the pre-change event that is meant for graph processing,
   esp. transaction rollback, and that tells about the detailed change
   (a container element change must be handled as a single element change,
   as processing an entire container would be prohibitively wasteful)

 Changed compiler switches for event firing configuration to:
 - events in general, with mostly attribute change events as base (like before)
 - events for debugging on top of it, mostly action match events,
   but also the new post-change-event
 The compiler switch for inlining prevention now includes independent inlining.
   
 Added support for rendering external types as graphs in the debugger:
 - this allows to inspect opaque-to-GrGen external types in yComp as graphs
 - must be declared with "external emit graph class;" in the model
 - implemented by calling INamedGraph AsGraph(object attribute, AttributeType attrType, IGraph graph),
   which is forwarding to a AsGraphImpl,
   to be supplied by the user in the external attribute types implementation file
 - employed in the debugger with the new "as (g)raph" command

 Added "recordflush" to shell commands to flush the graph change recorder streams.
 Finally removed the outdated "grs" shell command.

 Improved code structure by adding a new SubactionAndOutputAdditionEnvironment,
  in between the ActionExecutionEnvironment and the GraphProcessingEnvironment.
  It enriches the former with subaction debugging, subgraph nesting, and output 
  (textual emit plus graph change recording).
  The latter then adds sequence-, variable-, and transaction-handling.
 
 Bugfixes:
 - fixed graph switch introduced with nested graph support, the names were wrong in the debugger.
 - fixed code generation bugs regarding container method usage from emit, and double constants.
 - fixed name/attribute initialization list at a first anonymous node (missing in grammer).
 - some smaller other bugfixes.


v4.3bms2 (2014-04-30)
 Added bounded-reachable functions for depth-limited reachability computations:
 - boundedReachable, boundedReachableIncoming, boundedReachableOutgoing
   with max. parameters (startNode:Node, depth:int, incidentEdgeType:EdgeType, adjacentNodeType:NodeType)
   returning set<Node> filled with nodes reachable within given depth
 - boundedReachableEdges, boundedReachableEdgesIncoming, boundedReachableEdgesOutgoing
   with max. parameters (startNode:Node, depth:int, incidentEdgeType:EdgeType, adjacentNodeType:NodeType)
   returning set<Edge> filled with edges reachable within given depth
 - isBoundedReachable, isBoundedReachableIncoming, isBoundedReachableOutgoing
   with parameters (startNode, endNode:Node, depth, incidentEdgeType, adjacentNodeType)
   returning boolean value, true iff end node is reachable from start node within given depth
 - isBoundedReachableEdges, isBoundedReachableEdgesIncoming, isBoundedReachableEdgesOutgoing
   with parameters (startNode, endEdge:Edge, depth, incidentEdgeType, adjacentNodeType)
   returning boolean value, true iff end edge is reachable from start node within given depth

 Added corresponding loops (rule language statements only for now):
 - for(. in boundedReachable|boundedReachableIncoming|boundedReachableOutgoing)
   iterates the nodes instead of filling a set
 - for(. in boundedReachableEdges|boundedReachableEdgesIncoming|boundedReachableEdgesOutgoing)
   iterates the edges instead of filling a set
 
 Added countXXX functions for all available graph query functions:
 - they return the size of the set that would be yielded by the function without count, supported are:
   - countNodes, countEdges,
   - countAdjacentOutgoing, countAdjacentIncoming, countAdjacent
   - countOutgoing, countIncoming, countIncident
   - countReachableOutgoing, countReachableIncoming, countReachable
   - countReachableEdgesOutgoing, countReachableEdgesIncoming, countReachableEdges
   - countBoundedReachableOutgoing, countBoundedReachableIncoming, countBoundedReachable
   - countBoundedReachableEdgesOutgoing, countBoundedReachableEdgesIncoming, countBoundedReachableEdges
 - more convenient than using .size() on the set, commonly with better performance, too
 
 Added for loop iterating over an integer range:
 - in rule language: "for" "(" var "in" "[" left ":" right "]" ")" "{" body "}"
 - in sequences: "for" "{" var "in" "[" left ":" right "]" ";" body "}"
   first left and right are evaluated,
   if left <= right var is incremented from left on in steps of one until right is reached (inclusive),
   if left > right var is decremented from left on in steps of one until right is reached (inclusive),
   the body is executed with var assigned for every value in between left and right

 Added new auto-supplied filters for removing, complementary to the keeping filters already available:
 - removeFirst(k:int) removes the first k entries from matches list
 - removeLast(k:int) removes the last k entries from matches list
 - removeFirstFraction(f:double) removes the first fraction f of entries from matches list
 - removeLastFraction(f:double) removes the last fraction f of entries from matches list

 Diverse:
 - Extended copy function to containers (from graph and match already supported),
   as remedy for the problem that containers iterated over must stay unchanged
 - Added <,<=,>,>= for type string to the rule language expressions
   comparing alongside lexicographic order with InvariantCulture
 - Extended indexOf method on strings with an optional start index:
   s.indexOf("question", 42) will return the first occurence of "question" in s from index 42 on,
   but no previous occurence
 - Floating point serialization, to-string-casting, and parsing with InvariantCulture now
   to get everywhere the same results
 - Added parameterless functions Math::pi() and Math::e() returning their corresponding constants

 Performance Improvements:
 - Optimized Performance with independent inlining
   - gives match planning more material to work with, leading to improved matchers,
     in case the pattern was disconnected before it yields high speedups
   - at the cost of local post-matches filtering
     for already found matches modulo the inlined part
 - Optimized automorphy filters (typically a reduction of O(n*n) to O(n))

 Considerable extensions of profiling information instrumentation:
  All graph element accesses now count up the search steps,
  i.e. graph query expressions and statements, too,
  instead of only the candidate variable bindings during pattern matching

 GrShell:
 - Extended "new graph" command by a "new new graph" version,
   which ensures that things are generated even if the sources did not change
   - this is needed if only the statistics file or the profiling flag were changed,
     without a rebuild you would get misguided by the use of the old assemblies
 - Improved the output of the explain command 
 - The import command now supports a line break with ";;", too
 - "-C" is still only of limited use, as bash splits the command given inside "" alongside spaces
   -> "here documents" piping script parts to stdin are the medium of choice for automatization
 
 Set heap size for yComp to java maximum (640MB)

 GRS import/export now supports escaped \ and " with \\ and \" in attribute initialization strings

 Added MovieDatabase case from TTC2014 to examples
 
 Bugfixes:
 - bugfix for dump add graph exclude command, the context of the match(es) is now really added
 - exec contained in nesting statement inside eval works now
 - fixed code generation bug on for loop over map with only key, without value
 - fixed code generation bug on remove from untyped array/deque
 - fixed div by zero in graph statistics loading
 - fixed bugs related to profiling
 - bugfix regarding inlining of conditions
 - fixed (and optimized) set/map intersection
 - fixed incidence count index takeover in case of graph cloning
 - fixed bug regarding containers with a constant constructor


v4.3beta (2014-03-24)
 Implemented attribute indices:
 - declared in the model with syntax 
   "index" name "{" Type"."attribute "}"
   to specify the type and attribute whose values are to be indexed with a binary search tree,
   so that an O(log(n)) lookup of graph elements based on the index value is possible,
   (and an O(1) access of following elements)
   instead of an O(n)-traversal of all graph elements with post-filtering based on the attribute value
 - used in the pattern with syntax 
   elem":"ElemType "{" name "==" valueExpr "}"
   to bind the pattern element in succession to all elements with an attribute value equalling the value
   or a directed index access suffix behind the pattenr element declaration
   "{" direction "(" [ name relop valueExpr ["," name relop valueExpr] ] ")" "}"
   with direction ::= "ascending" | "descending" and relop ::= "<", "<=", ">", ">="  
   to bind the pattern element in succession to all elements from max to min element, or min to max element,
   where min and max are the lowest and highest attribute values if not specified otherwise,
   or the lowest or highest value as given with a single bound specification,
   or the lowest and highest value as given with a double bound specification
 - for this index as for the incidence count and the unique index holds:
   they give very quick access, but must be maintained on element addition or removal to the graph,
   switching them from an O(1) to an O(log(n)) operation -> use them selectively
 
 Implemented incidence count indices:
 - they store nodes ordered alongside their number of incident edges,
   and allow to access them quickly in that order
 - declared in the model with syntax 
   "index" name "{" direction "(" NodeType ["," EdgeType ["," NodeType]] ")" "}"
   with direction ::= "incident" | "incoming" | "outgoing"
   the first mandatory parameter specifies for what node types the index information is to be stored,
   the optional second parameter allows to further constrain the incident edge types,
   the third optional parameter allows to further constrain the adjacent node types,
   only node-edge-node triples satisfying the type constraints are counted
 - used in the pattern with the syntax already known from attribute indizes
   i.e. { indexname==value }, { ascending(indexname...) }, { descending(indexname...) }
 - the count may be further queried from the rule language expressions,
   with syntax: indexname "[" node-expr "]", expecting a node, returning an int,
   the return value is the number of incident edges for the node, as stored in the index

 Added support for unique integer ids for graph elements:
 - declared in the model with "node edge unique;"
 - the unique id can be retrieved in the expressions of the rule language (in O(1))
   with the function uniqueof(graphelement):int
 - uniqueof() may be used on (sub)graphs, too, returning the unique identifier of the graph;
   for a (sub)graph argument, or zero arguments, which amounts to the host graph
 The unique integer ids are graph to id only, they may be completed to an unique index:
 - declared in the model with "index unique;"
 - it allows to access graph elements in the pattern by their unique id (in O(1)), with syntax
   elem":"ElemType "{" "unique" "[" int-expr "]" "}"
   in contrast to attribute and incidence indices, the lookup will yield at most one element
 - the unique index may be further queried from the rule language expressions,
   with the functions nodeByUnique(int):Node or edgeByUnique(int):Edge

 Extended support for the name index, as implemented by named graphs:
 - graph elements may be accessed in the pattern by their unique name (in O(1)), with syntax
   elem":"ElemType "{" "@""(" string-expr ")" "}"
   the lookup will yield at most one element, as for unique indices
 - the name index may be further queried from the rule language expressions,
   with the functions nodeByName(string):Node or edgeByName(string):Edge
 - in contrast to the unique ids that are auto-assigned and cannot be changed,
   the name may be re-assigned by the user, it only must be ensured it is not already in use,
   with a nameof assignment available in the rule language, with syntax
   "nameof" "(" elem ")" "=" string-expr
 - the same syntax may be used to assign the name of a (sub)graph, a missing elem amounts to the host graph
 
 Implemented matcher parallelization:
 - a rule or test annotated with a [parallelize=k] will be matched with k worker threads from a thread pool
   more exactly: at most k worker threads, clipped by the number of available processors,
   on a single core the sequential matcher will be used
 - work is split alongside the first loop binding a pattern element to a candidate graph element,
   if that branches only once nothing is gained,
   if each branch only executes very few search work following candidate assignment,
   things just become slower because of threading and locking overhead;
   you better profile before deciding what matchers to parallelize
  
 Profiling: 
 - increased accuracy of execution time calculation
 - added "-profile" command line option to GrGen to enable generation of profiling information,
   counting the bindings of host graph elements to pattern elements (search steps) carried out during the search
 - added "set profile on" shell command, maps to -profile compiler option
 - if on, the number of search steps executed are printed out in the shell after sequence execution
 - further, more detailed per-action profiles can be displayed on demand in the shell
   with "show" "profiles" [ actionname ]
   for the action whose name is specified, or all actions

 Added builtin packages Math, File, Time to structure builtin functions/procedures:
 - moved functions min, max, sin, cos, tan, arcsin, arccos, arctan, pow, log, abs to package Math
 - added new functions ceil, floor, round, truncate and sgn, to package Math
   all expecting one parameter of type double, returning a value of type double
   semantics as what can be expected by the names
 - moved export, deleteFile procedures to package File
   moved existsFile, import functions to package File
 - added new function now() for retrieving a timestamp, to package Time
   no parameters, returns the current UTC time as long,
   given as windows file time (i.e. 100ns ticks since 1601-01-01)
 - the File and Time functions/procedures are available in the sequence computations, too
   whereas the Math functions are only available in the rule language expressions
 - the global versions of the functions/procedures moved don't work any more!
   the functions/procedures have to be accessed in known package notation,
   e.g. Math::sin(x), Time::now(), File::existsFile("filename.grs")

 Name/attribute initialization:
 - a name or attribute initialization can be given at a node or edge creation now,
   with a syntax similar to the grs, 
   "$" "=" string-expr for name initialization, and
   attribute-name "=" expr for attribute initialization, 
   with expr being of the type of the attribute;
   attached with "@" "(" ... ")" to a node or edge declaration in a modify or replace part
 - example: n:N@($="foo", intAttr = 42);
   
 API:
 - IActions, ISequenceDefinition, IFunctionDefinition, IProcedureDefinition 
   define the actions interface of the API, now
 - extended graph element interface by GetUniqueId():int function,
   to retrieve the unique id for a graph element
 - extended graph interface by GetGraphElement(int unique)
   to retrieve the graph element for a unique id, only implemented in case of a unique index
 - added IndexSet and Index interfaces to the graph

 Misc.:
 - Includes are now interpreted (first) relative to the including file
 - Removed "-noperfinfo" command line option
 - Manual: Split performance optimization into own chapter, combined with indices
 - some bugfixes carried out, esp:
   - embedded sequences now call the latest dynamically generated matcher, too
   - fixes subpattern using a subpattern with dangling edges
	
--------------------------------------------------------------------------------------------------------
	
v4.2 (2014-01-12)
 Added packages to the model:
  - declared with package <pname> { <stuff> }
    (stuff are node type declarations, edge type declarations, enum declarations)
  - the stuff inside can be used with <pname>::name
    (the pname prefix is mandatory outside of the very package)
    so an enum value from a package must be referenced by <pname>::<enumname>::<enumvalue>

 Added packages to the actions:
  - declared with package <pname> { <stuff> }
    (stuff are subpattern declarations, rule/test declarations, filter function declarations,
     sequence declarations, function declarations, procedure declarations)
  - the stuff inside can be used with <pname>::name
    (the pname prefix is mandatory outside of the very package)

 Adapted the ecore/XMI importer to model package,
  it now maps packages to GrGen packages, instead of name mangling
  (but still all names are prefixed with an underscore to prevent keyword-name clashes)

 Added XMI exporter (assuming the model stems from a previous ecore/XMI import)
 
 Fixed bugs in grs export regarding graph elements used as attributes
 Fixed bugs in grs import regarding (attribute) names containing underscores
 Some smaller improvements in user manual
  
v4.2beta (2013-12-15)
 Added path-based model inclusion statement #using "<path>" as new default:
  - it allows to reference a model file by a full path, so models can be organized in directories
  - in exchange it only allows for one model file per statement, similar to #include
 
 Added user-defined post-match filter functions to the rule language:
  - complementing the auto-generated and auto-supplied filters (or the external filter functions)
  - filter foo<bar>(params) { eval-stmt } specifies filter function foo for rule bar
   - within filter, "this" allows to access the matches, as this:array<match<bar>>
   - the this-matches-array can be iterated over,
     an array entry comprising a match can be read and written by index,
     a match entity can be read and written with member access notation (in the rule language, with correct types),
      (in combination with an index lookup it can be only read, 
 	  writing requires an intermediate assignment to a variable tmp:match<bar>)
     matches can be added to the array, matches can be removed from the array,
     a high-performance way of removing is assigning null to a matches array index
   - the copy function can be used now on matches, too,
      this allows to insert new matches derived from clones of old matches to the matches array
   - for external filter functions syntax is now: external filter foo<bar>(params);

 Added new global functions and procedures:
  - empty():boolean returns whether the graph is empty, i.e. contains no nodes and edges
  - size():int returns the number of elements (nodes plus edges) in the graph
  - existsFile(path:string):boolean returns whether the path exists
  - deleteFile(path:string) deletes the path given
  
 Added numerous examples for the more recent parts of the languages to the user manual
 
 Several bugs fixed

--------------------------------------------------------------------------------------------------------

v4.1.0 (2013-09-07)
 Methods are now supported (user-defined, in contrast to some built-in methods already available before): 
  - methods are declared in the model as functions or procedures nested inside node or edge classes
  - a "this" node or edge is declared implicitely inside the method functions or procedures
    to access the members or call the methods of the element (needed for dot notation)
  - method calls occur in dot notation, with an expression or variable or the "this" element before the dot,
    denoting the element to apply the method on; otherwise they look like a function or procedure call;
    it is not possible inside a method to access elements or methods of the class without dot notation
  - procedure methods are callable from rule language statements and sequence computations
  - function methods are callable from rule language expressions and sequence expressions
  - dynamic dispatch: the implementation of the exact type of the current element is called,
    irrespective of the statically known base type of the pattern element or variable
  - if a method name comes in from different parents, the method must be overriden in the joining class
    (GrGen supports multiple inheritance, forming a DAG-structured inheritance relationship)
  - a method name that comes in from only one parent can be kept unimplemented,
	the nearest implementation in the inheritance hierarchy is then used

 Supporting methods required changes regarding the sequence computations:
  - sequence expressions used as sequence computations must be enclosed in braces from now on,
    so in sequence "if { {{def(x)}}; ... }" all opening braces are required,
	the second "{" is for opening a computation, and the third "{" is for opening an expression
  - chained method calls are not possible any more

 Changes to improve readability:
  - external entities must be prefixed with an "external" keyword at their declaration
  - sequence expressions used as sequence computations must be enclosed in braces from now on,
    so the only computation that returns a value is visually differentiated from the other computations
 
 The support for filtering of the matches list (of rule all calls) was extended considerably:
 - allowed multiple chained filters per rule application with syntax r\f1\f2\...
 - added new def var based filters, they must be specified beforehand, as code is generated for them,
   available for def vars of the pattern, of integer, floating point, and string type:
   - orderAscendingBy<var> for ordering the matches list ascendingly alongside the def var
   - orderDescendingBy<var> for ordering the matches list descendingly alongside the def var
   - groupBy<var> for ensuring matches of equal def var values are neighbours 
     or only separated by matches of equal def var values, in the matches list
   - keepSameAsFirst<var> for filtering away all matches of def var values not equal 
     to the def var value of the first match
   - keepSameAsLast<var> for filtering away all matches of def var values not equal 
     to the def var value of the last match
   - keepOneForEach<var> for filtering away all matches of duplicate def var values, 
     i.e. only one prototypical match is kept per def var value in the matches list
 - added new pre-implemented filters (callable without a filter declaration at the rule declaration):
   - keepFirst(count) for keeping the first count matches, at the begin of the matches list
   - keepLast(count) for keeping the last count matches, at the end of the matches list
   - keepFirstFraction(fraction) for keeping the fraction of the matches specified (0.0 - 1.0),
     from the begin of the matches list
   - keepLastFraction(fraction) for keeping the fractin of the matches specified (0.0 - 1.0),
     from the end of the matches list

 Bugfixes:
  - fixed bug in set/map add in yielding statements
  - referenced assemblies are now included when building the actions, too
  - the external action files are now expected and generated where the rules reside, too
  - some minor improvements / fixes (e.g. error messages and error checks)

--------------------------------------------------------------------------------------------------------

v4.0.1 (2013-08-12)
 More consistent and easier readable function/procedure definitions:
 - function or external function declarations must start with the "function" keyword now
 - procedure or external procedure declarations must start with the "procedure" keyword now

 Bugfixes:
 - completed support for the for(x:T in nodes(S)/edges(S)) loop,
   esp. handling of S != T, missing support for for-function loops in the debugger 
 - fixed bug regarding function calls in execs in the rules
 - fixed bug regarding omission of execution of yielding statements
   when only ref containers are used

v4.0 (2013-07-29)
 Subgraph support regarding built-in functionality completed:
 - The debugger now listens to graph switch events,
   prints out notifications on a switch and changes display to the new graph focused
 - GRS export and import are now capable of serializing and parsing nested graphs
   i.e. attributes which contain/reference subgraphs are now saved and restored again
   - subgraphs are introduced with an "add new graph <graphname>" command
   - with an "in <graphname>" command the current graph is set for the following commands
   - the exporter renames the graphs if needed to enforce unique names
 - The recorder is now able to record subgraph changes
   exporting subgraphs (transitively) on first sight, renaming them as needed
 - GrShell is now able to process the
   "add new graph <graphname>" command to create a subgraph, and the
   "in <graphname>" command to switch the current (sub)graph to the graph given
   assignments to subgraph typed attributes
   - thus the shell can import GRS exported or recorded graphs including subgraphs now
   - support limited to level 2 (main host graph plus one subgraph) in contrast to the sequences,
     more would not be helpful in the shell
 - Extended graph isomorphy checking to attributes of graph type, comparing them for isomorphy, too
    generalizing equality comparison from flat to nested graphs
 - Extended transaction handling to cover subgraph switches
    switching processing to a subgraph and returning processing from a subgraph (as reported by events)
    is recorded to the undo log now in case a transaction is underway,
    so the graph change effects are rolled back on the graph that was really changed
   -> transactions now cover changes in any of the processed graphs/contained subgraphs

 Added operations for working with subgraphs, and closed some gaps in node/edge operations:
 - In sequence expressions and rule expressions are now available:
    import(filepath:string) : graph   - for importing a graph stored in a file as subgraph 
                                        (the main graph is not replaced)
    copy(original:graph) : graph   - for creating a clone of an original subgraph
    nameof() : string   - for retrieving the name of the current host graph
    nameof(entity:node or edge or graph) : string   - for retrieving the name 
                                                      of a node or edge or subgraph
 - In sequence computations and rule statements are now available:
    addCopy(original:node) : (node)   - for adding a clone of the original node to the current graph
    addCopy(original:edge, src:node, tgt:node) : (edge)   - for adding a clone of the original edge 
                                                            to the current graph
    insert(original:graph)   - for inserting a subgraph to the current host graph,
      i.e. computing a disjoint union of the nodes and edges; 
      the original graph is destroyed by this (move semantics)
    insertCopy(original:graph,root:node) : (clone:node)   - for inserting a clone
      of the original subgraph to the current host graph
      i.e. computing a disjoint union of the nodes and edges; the original subgraph stays untouched
    merge(target:node, other:node)   - for merging the other node into the target node
    redirectSource(edge:edge, newsrc:node)   - for redirecting the edge to the new source
    redirectTarget(edge:edge, newtgt:node)   - for redirecting the edge to the new target
    redirectSourceAndTarget(edge:edge, newsrc:node, newtgt:node)   - for redirecting the edge 
                                                                     to the new source and new target
    export(filepath:string)   - for exporting the current host graph to a file with the given path
    export(graph:graph, filepath:string)   - for exporting the given subgraph to a file 
                                             with the given path
 - In sequence expressions and rule expressions is now available:
    this expression, used as a readonly variable of type graph, for accessing the current graph 
	(by default the host graph, or the most current subgraph switched to)	
 - The sequence in graph { seq } was extended to allow to relocate to a subgraph attribute,
    with syntax in element.attr { seq } (attr must be an attribute of type graph contained in element)
 
 Replaced for(x:T) graph lookup loop by for(x:T in nodes(T)) or for(x:T in edges(T)) 

 The functions returning a set of graph elements now yield always set<Node> or set<Edge>,
  irrespective of the concrete type queried.

 Variables can now be declared in a return assignment of a procedure call in the rule statements,
  e.g. (def var visID:int)=valloc()

 Added count operator to sequences and rules
 - to all-rule calls in sequences: count[r]=>c assigns the count of matches of r to the variable c,
   and applies r on all the matches
   with count[?r]=>c the matches are only counted, no rewrites are carried out
 - to expressions in rule language: count(it) returns the amount of iterated pattern instances found
   can only be used in yield or eval block (not in if), on named iterateds
   
 Added graph statistics serialization and parsing
 - added "custom graph statistics save <filepath>" shell command
   to write the statistics of the last analyze to the given statistics file
 - added "-statistics <filepath>" option to grgen compiler command line parameters
   to read the given statistics file and build matchers optimized for a graph of those statistics
 - added "new set statistics <filepath>" command to GrShell
   which does the same as calling the grgen compiler with "-statistics <filepath>"
   whenever a new graph command is executed with an action filename given,
   causing a compilation of the actions (thus creating matchers adapted to the statistics)

 Extended transaction handling to cover visited flags
  visited flag writing, allocation, and freeing (as reported by events)
  are now recorded to the undo log and undone on rollback
  (by overwriting with the old value, (reserved) freeing, and reallocation)
  -> transactions now cover visited flag changes in addition to topology and attributation changes

 The user can define compare and copy functions for external objects (plus type object) now
 - they allow to compare attribute types not known to GrGen, during graph isomorphy checking,
   and in the expressions of the rule language and the sequences
   (with value semantics, instead of only checking for identical references)
 - and to copy values of types not known to GrGen, in the copy commands
   (with value semantics, instead of only copying the references, making objects identical)
 - == and != in the expressions of the rule language and the sequences, as well as graph isomorphy checking,
   are overwritten if "== class;" is specified in the model, to use IsEqual
 - <,<=,>,>= in the expressions of the rule language and the sequences 
   are overwritten if "< class;" (requiring "== class;") is specified in the model, to use IsLower (and IsEqual)
 - copy and addCopy in the patterns of the rule language and the procedures of the rule language and the sequences
   are overwritten if "copy class;" is specified in the model, to use Copy
 - they need to be implemented by the user in the external types and functions implementation file

 The user defined parser for attributes of object or user defined type is used from GrShell now, too
  insofar as possible, shell parses a single or double quoted text or a word or a number
  and hands that over then to the user defined parser

 Model generalization: 
 - allowed attributes of node or edge type,
   and allowed attributes of node/edge or container of node/edge type, 
   to reference subtypes of the type they are contained in
 - multiple using statements may now be given in a rule file, 
   as well as in a model file -- so transitive using is supported by now

 The compiler driver checking if a recompilation is needed now takes into account:
 - whether an external functions implementation file of the model is newer than the compiled binaries
 - whether an external functions implementation file of the actions is newer than the compiled binaries
 - whether the graph statistics file to be used for generating the actions is newer than the compiled binaries
 - whether nested or multiple used model files are newer than the compiled binaries
 
 API additions/changes:
 - external function calls receive the action environment and the graph as first parameters by now
   so the processing environment is directly available, without the need for static variables manually filled
   same as for the external procedure calls, and a better fit to potential subgraph switches
 - added events for visited flag assignment and allocation/freeing
 - added convenience method for fetching the current graph as named graph
   to the graph processing environment (returning null if it is in fact no named graph)
 - allowed to set the name of a graph and to get the backend
 - graph statistics code is now located in own class LGSPGraphStatistics
 - the available external types are now given in the XGraphModel

 Fixes:
 - fixed bug in visited flag handling 
   that showed in case the amount of graph element based visited flags was exhausted
 - fixed neglectance of containers of subgraphs in grs exporter
 - fixed bug with == and ~~, only the operator used first was applied for a graph,
   irrespective of the operator really requested
 - fixed bugs in compiled sequence regarding: in graph { sequence }, graph.rule(), 
    copy(subgraph), and the ==, !=, ~~ operators
 - fixed performance bug regarding graph comparisons with changes counter not written correctly
 - fixed for function loops and some set returning functions
 - fixed assignments in evals/yields
 - some more just forgotten

 Some improvements in the user manual:
 - reduced the sequence computations chapter to a diff 
   against the graph type chapter and the container type chapter
 - added section on Graph Nesting and Graph Oriented Programming
 - revised the Introduction and the Overview
 - multiple improvements in various other sections

 
v4.0alpha3 (2013-05-05)
 Replaced the CSharpCC generated parser/lexer for grs import by a hand written one
   yielding a speedup of 5x (esp. no LookaheadSuccess exceptions any more) for M$ .NET
   and allowing to extend the grs importer by user defined functions, enabling:

 The user can defined parse, serialize and emit functions for external objects now
   they allow to grs export and import types not known to GrGen,
   and to emit values of types not known to GrGen, esp. in the debugger (incl. yComp)
  - they are emitted if "emit class;" is specified in the model,
    and need to be implemented by the user in the external types and functions implementation file
  - the model interface makes the new functions parse/serialize/emit for object types available,
    with a dummy implementation forcing objects to null in case "emit class;" is not specified
  - extended AttributeType with the .NET type, 
    so it's possible for kind object to determine the real type of the attribute

 It's now possible to match and rewrite in subgraphs
  - made available by adding support for switching the current graph to a subgraph
  - in the sequences with an execute sequence in subgraph block ("in" subgraph-var "{" sequence "}"),
  - or with rule, rule all and sequence calls in method call notation on a subgraph variable 
    (e.g. (v)=sg.r(v) on "sg:graph=inducedSubgraph(adjacent(node))")
    giving rise to graph based programming on nested graphs
    promoting subgraphs to a noteworthy language and data structuring construct
  - data is strongly encapsulated by this hierarchical graph abstraction,
    the contents of the graphs are hidden from each other,
    information can only be shared or exchanged by rules/sequence calls
    operating on the different subgraphs, with the aforementioned change-focus facilities
  - this is in contrast to defining "contains" edges to build hierarchical data structures 
    in an otherwise flat graph
  - and similar to object-based programming with its data hiding, supporting programming-in-the-large
   
 Global var declarations changed to resemble local var or parameter declarations 
   i.e. ref for containers, var for non-node/edge variables,
   instead of only always ref, which maybe fits better to semantics but is unintuitive
 
 - Added castability of all external types to type object
 - Added arcsin, arccos, arctan functions to complement sin, cos, tan
 - Some smaller bugfixes and polishings,
   esp. copying of external attributes interface files to parent folder is working now

   
v4.0alpha2 (2013-04-21)
 Split computation abstraction into functions and procedures
   Functions are not allowed to manipulate the graph, and return exactly one result.
   Procedures may manipulate the graph, and can return 0-k results.
   (Computations are the general concept, split into side-effect-free ones and the others.)
 - You may declare functions with syntax
   name(parameters) : return-type { statements }
 - And procedures with syntax
   name(parameters) : (return parameters) { statements }
 - The declared functions can be used from rule language expressions and from sequence expressions
   with syntax name(arguments), yielding the computed value.
 - The declared procedures can be used from rule language evaluations and from sequence computations
   with syntax (out-variables) = name(arguments), assigning the output values to the out-variables,
   (i.e. similar to rule calls in the sequence);   
   or just name(arguments), throwing away output values 
   (in case there are some, a procedure may be declared without output parameters)
 - Generalized return statements to versions with 0 - k return values to be used for computations
 
 The previously built-in special side-effect-functions
  add, retype, insertInduced, insertDefined, valloc, startTransaction
  are _only_ available as procedure calls from now on, as well as to the old "procedures"
  emit, highlight, record,
  clear, remove, merge, redirectSource, redirectTarget, redirectSourceAndTarget,
  vfree, vfreenonreset, vreset,
  pauseTransaction, resumeTransaction, commitTransaction, rollbackTransaction.
  (So (id)=valloc() instead of id=valloc(), and only as statement,
   or def var id:int; (id)=valloc() instead of def var id:int = valloc())

 Implemented retype procedure in sequence computations:
  (node-var)=retype(old-node-var, new-node-type)
  (edge-var)=retype(old-edge-var, new-edge-type)

 Implemented external procedures in addition to external functions (and external sequences)

 Syntax of the one-of-set/some-of-set changed from {(...)} to {<...>}
  (because it would otherwise collide with {(...)=p(...)} for a procedure call

 Implemented graph comparison operators (==,!=,~~) in rule language
  
 Added highlight statement to computations:
  highlights the nodes/edges or visited flags or storages in the graph that are given as arguments,
  similar to the highlight statement of the sequences/of the debugger.
 Highlighting extended:
  - if a string typed value is given, it is used as annotation for the previous value
  - the same exclude graph (layout) rules that apply to matches apply to highlighting
 
 Added commands to suppress graph display during debugging
  instead only the match of the current rule is shown,
  plus some context up do a configured depth,
  plus the parent nodes according to the nesting commands;
  these commands allow to still use the debugger if the graph as such is too large to be layed out.

 Shell comments are not terminated at # any more, this just feels awkward;
  instead § can be used as shell comment terminator.
  (For usage with "-C" commands given as argument to GrShell, to break out of an exec.)

 Added show includes "-SI" option to shell to print entry and exit of include.

 Fixes: 
  - sequence computations in frontend now open a scope
  - canonize used from rule language had internally a wrong type
  - some error message improvements
  - added checks for correct usage of return, break, continue

  
v4.0alpha (2013-03-29)
 Extended attribute evaluations to general computations 
 -- with general control flow constructs:
 - Allowed to declare attribute evaluation functions (computations) with syntax
   name(parameters) : return-type { statements }
   The function must end with a return(expr); statement returning the function value.
 - The declared computations can be used from rule language expressions and from sequence expressions
   with syntax name(arguments), yielding the computed value
   The declared computations may call other computations, or themselves recursively.
 - Added if condition to computations, with syntax
   if(expr) { stmts } [ else if(expr) { stmts } ]* [else { stmts }]?
 - Added loops to yields/evals/computations, with syntax
   while(expr) { stmts } for a pre-test loop
   do { statements } while(expr) for a post-test loop
   no semicolon needed at post-test loop, but all constructs require the braces
 - Functions can be called as statements
 - Embedded sequences can be specified in the computations with the syntax 
   exec(sequence)
   (Similar to the rule language, entities from outside can be read, and written to with yield.)
 -- with local variable declarations:
   Added local variable declarations to yields/evals/computations,
   with the syntax known from def variables in pattern (def var, def ref, def).
   They have to be assigned without yield prefix, that one is only for pattern entities.
   Allowed initialization of def entities of graph element type,
   with parameters, or elements from the outer pattern.
 Have a look at test/should_pass/DfsBfsSearch.grg or the computations_*.grg for an example.
 
 Extended attribute evaluations and sequences - where not already available - with multiple iteration loops:
 - for(val in container) { stmts }, or for(index->val in container) { stmts },
   where val, index are variable declarations of type compatible to the container.
   Added to computations for iterating over containers
 - for(n:NodeType) { statements } a loop over all nodes of the given node type in the graph
 - for(e:EdgeType) { statements } a loop over all edges of the given edge type in the graph
 - for(function(params)) { statements} a loop over all neighbouring nodes or edges of a start node,
   under the given type constraints, where function is one of incident, incoming, outgoing, for edges;
   or adjacent, adjacentIncoming, adjacentOutgoing for nodes.
   Params consist only of a node for the start node,
   or additionally an EdgeType for the type the incident edges must be of,
   or then additionally an NodeType for the type the adjacent nodes must be of.
 - Added reachability for loops, encapsulating a depth first walk in an iterator
   with for(n:Node in reachableNodes(start node, incident edge type, adjacent node type))
        { statements } as prototype
   and additionally reachableNodesIncoming, reachableNodesOutgoing for nodes,
   and reachableEdges, reachableEdgesIncoming, reachableEdgesOutgoing for edges.
 - Changed syntax of for command for accumulation of iterated to
   for(val in iterated) { stmts }  (only in rule language available)
   Here val is an entity from the iterated pattern, and comes without type.

 Added direct and transitive graph neighbourhood queries to attribute evaluations and sequence expressions
 - added isAdjacent, isAdjacentOutgoing, isAdjacentIncoming functions,
   behaving basically like an efficient "end-node in adjacent(start-node, ...)", ...,
 - and isIncident, isOutgoing, isIncoming functions,
   behaving basically like an efficient "end-edge in incident(start-node, ...)", ...,
 - and isReachable, isReachableOutgoing, isReachableIncoming functions,
   behaving basically like an efficient "end-node in reachable(start-node, ...)", ...,
 - and isReachableEdges, isReachableEdgesOutgoing, isReachableEdgesIncoming functions,
   behaving basically like an efficient "end-edge in reachableEdges(start-node, ...)", ...,
 - all for parameters (start-node, end-node, incident edge type, adjacent node type).
 - the isReachable predicates return whether the end-node can be reached from the start-node,
   by incident edges of the specified kind;
   they additionally come in the extended versions
   -...(start:Node, end:Node, incidentEdgeType:EdgeType) 
   that constrains the edges to the given EdgeType, and
   -...(start:Node, end:Node, incidentEdgeType:EdgeType, adjacentNodeType:NodeType)
   that additionally constrains the nodes to the given NodeType.
   This iterated path searching is implemented with a manually coded depth first search, 
   which is for one more efficient and for the other more convenient to use 
   than programming the same with subpatterns/controlled tests, but limited to simple type conditions.
 
 Extended the expressions and computation statements of the attribute evaluation language:
 
 -- with basic graph manipulation functions
 - add(NodeType):Node and add(EdgeType, SrcNode, TgtNode):Edge,
   for adding a node or edge to the graph, returning the added entity
 - rem(Node) and rem(Edge) procedures, for removing from the graph
 - retype(node,NodeType):NodeType retypes node to the new node type, returns the retyped node
 - retype(edge,EdgeType):EdgeType retyped edge to the new edge type, returns the retyped edge
 - clear() procedure for clearing the graph

 -- with advanced graph manipulation functions
 - merge(tgt,src) merges the source node with/into the target node, redirecting incident edges
 - redirectSource(edge,newSrc) redirects the edge to the new source node
 - redirectTarget(edge,newTgt) redirects the edge to the new target node
 - redirectSourceAndTarget(edge,newSrc,newTgt) redirects the edge to the new source and the new target node
  Those functions require a named graph as they fetch the debug display name from the old element.
  In addition, they are available in versions with an additional string as parameter,
  giving the name of the old element; in that case an unnamed graph is sufficient
  (the redirectSourceAndTarget requires two strings).

 -- with induced subgraph computations and insertions:
 - inducedSubgraph(set<NodeType>):graph returning the induced graph of the node set
 - definedSubgraph(set<EdgeType>):graph returning the defined graph of the edge set
 - insertInduced(set<NodeType>,node):node inserts a copy of the graph induced by the node set,
   returns the copy of the node given as second argument
 - insertDefined(set<EdgeType>,edge):edge inserts a copy of the graph defined by the edge set,
   returns the copy of the edge given as second argument

 -- with numeric functions
 - abs(numeric):numeric returning the absolute value of the input
 - sin(double):double returning the sine of the input
 - cos(double):double returning the cosine of the input
 - tan(double):double returning the tangent of the input
 - log(double,double):double returning the logarithm of the first argument 
   to the base given by the second argument
 - log(double):double returning the logarithm of the argument to the base e
 - pow(double,double):double returning the first argument
   to the power of the second argument (was already available)
 - pow(double):double returning e to the power of the argument

 -- with visited flag management
 - added valloc() function, for allocating a visited flag, returning it
 - added vfree(flag), vfreenonreset(flag), vreset(flag) procedures 
   for freeing a flag and resetting it in all graph elements

 -- with global functions for transaction handling:
 - startTransaction():int returning transaction id,
 - pauseTransaction() pausing transaction handling so changes are not recorded and can't be undone
 - resumeTransaction() resuming paused transaction handling
 - commitTransaction(int) keeping the changes of the transaction of given id in the graph, 
   removing the undo information
 - rollbackTransaction(int) reverting the changes by executing the undo log

  -- with text output procedures
 - added emit(string) procedure for emitting to stdout or a file
 - added record(string) procedure for writing to a graph change record

 -- with equitable partition computation
 - canonize(graph):string returning a canonical string representation of the graph input

 Container constructors are now available in the sequences, too
 - only the explicit ones, as expression, esp. in variable initialization
 - allowed empty container constructors again in rules language,
   but only for the explicit ones, i.e. set<int>{}, map<int,float>{}, array<Node>[], deque<string>][;
   not for the implicit ones: {3}, {3->3.141593}, [x], ]"foo"[.
   Had to disallow nesting of the implicit ones in exchange.

 Added a changes counter to the graph, increased at each graph structure changing operation:
 - used to find out about about the outdatedness of 
  graph analyzation results, isomorphy checkers, and canonical representations,
  thus allowing to keep them as long as they are still valid, 
  and preventing bugs from changes that occured after those were computed.
 - the changes counter is printed as additional statistics during shell execution
  (non-debugging, at the once-per-second sign-of-life-timer)

 Smaller extensions:
 - Implemented opposite(edge, node):other-node in rule language and sequences,
   in addition to source(edge) and target(edge).
 - Container constructors are now supported in initialization of def elements 
   in lhs and rhs of rules, tests, subpattern; and in computations.
 - The .empty() method on container types is now supported in the rule expressions, too.
 - Generalized entity arguments for esp. neighbourhood (but also other) functions 
   to compositional expression arguments
 - Added USE_NET_3_5 flag for letting GrGen target .NET 3.5;
   not needed for the generated code, but maybe for the user extensions.
 - The external attributes interface file was only created in tmpgrgenX folder,
   where it was deleted afterwards unless -keep was used;
   now FooModelExternalFunctions.cs is copied to parent folder (where rules reside),
   so that users required to implement that interface get to see it.
 
 Adaptation of user manual to computations extension:
 - added a dedicated chapter on the by-now massively extended computations,
   offering esp. control flow and computation definitions over simple assignments
 - split (and removed) the overly heterogenous storagesvisited chapter into
   - a massive extension of chapter container, now including everything container related
   - a new chapter graph containing everything graph type related,
     esp. global functions, visited flags, transactions
 - split chapter sequencecomputation out of chaper sequencesadvanced
  
 Bugfixes: 
 - allowed rule/sequence calls with empty parenthesis again
   (after some grammar refactoring in the past zero argument calls had to be given without parenthesis)
 - fixed off-by-one in SimpleGraphCanonizer
 - fixed bug in type balancing of graph comparisons of untyped global variables
 - fixed bug in compiled version of "interpretation plan" used for isomorphy checking
 - several other/smaller bugs fixed

 Release is only an alpha because of the missing static semantic checks 
 regarding the new computation constructs, which need to be constrained.

 
v3.6.ms2 (2013-01-28)
 Generic datatype deque<T> introduced:
  - mapping to custom C# Deque implemented with a ringbuffer doubled in size as needed,
    so insertion and removal from front and back in amortized O(1)
  - supporting operations added, in types and expressions, in model and rules, in sequences, in shell:
    - deque<T>] el, el2, el3 [ constructor
    - d.add(x) to add x to the end of the deque, d.add(x,i) to insert x at index i
    - d.rem() to remove element from begin of deque, d.rem(i) to remove element at index i
    - d.clear() clears deque
    - d.size() gives size of deque, d.subdeque(i,l) returns subdeque from start i on of length l
    - d.indexOf(x), d.lastIndexOf(x) give index of first/last occurence of value x in the deque
    - x in d returns whether x is contained in d
    - d[i] returns value at index position i, same does d.peek(i)
    - d[i] = x overwrites element at position i by x
    - a==b, a!=b checking equality of size and of the elements at their respective positions
    - a<b, a<=b, a>b, a>=b checking order of size and equality of elements
	   at their respective positions up to the size of the smaller deque
    - a+b returning a concatenation of deque a followed by b, compound version a+=b supplied, too
    - storage access in rules n{d} or n{m.d} of deque elements
  - The primary usage as FIFO queue for breadth first search can be seen in tests/DfsBfs
    (together with depth first search, based on LIFO stack implemented by an array or the call stack)

 Extended the set returning graph query convenience functions:
 - added functions incident, adjacent, adjacentIncoming, adjacentOutgoing, source, target
   to the expressions in the rules, in addition to the already implemented incoming and outgoing functions 
   (same semantics as their already implementd counterparts in the sequences).
 - added a kind of generalization of the adjacent/incident functions with reachable/reachableEdges:
   they return a set of nodes/edges as the adjacent/incident ones, but in surplus to the direct neighbours
   they add the neighbours of the neighours, and so on, too.
   Available are:
   -reachable(startNode, NodeType, EdgeType):set<Node>
   -reachableOutgoing(startNode, NodeType, EdgeType):set<Node>
   -reachableIncoming(startNode, NodeType, EdgeType):set<Node>
   -reachableEdges(startNode, NodeType, EdgeType):set<Edge>
   -reachableEdgesOutgoing(startNode, NodeType, EdgeType):set<Edge>
   -reachableEdgesIncoming(startNode, NodeType, EdgeType):set<Edge>
   The types are optional, if EdgeType is missing Edge is used, if NodeType is missing Node is used.
   These functions are avaiable in the rule expressions, and in the sequence computations.
 - added the functions
   -nodes(NodeType):set<Node> - returns all nodes of given type, or all nodes if type is omitted
   -edges(EdgeType):set<Edge> - returns all edges of given type, or all edges if type is omitted
   to the rule expressions and the sequence computations.

 Global variables can now be accessed in the expressions of the rules:
  - to this end they need to be declared at the beginning of the rule file
    with e.g. syntax "::g_n:Node;" for nodes, "-::g_e:Edge->;" for edges, and "ref ::g_s:string;" for variables.
  - the if and eval parts can then access the global variables from the processing environment,
    with e.g. syntax "::g_n", "::g_e", "::g_s"
    the values of the untyped variables are casted to the statically declared types.

 Added function canonize(g:graph):string to sequence expressions,
  delivering a canonical representation of the graph, reducing graph comparison to string comparison.
  The method supposedly doesn't work on isospectral graphs.

 Added new indeterministic choice sequence "weighted one" $.(w1 s1, ..., wn sn):
  the weights w1-wn (numbers of type double) are added into a series of intervals,
  then a random number (uniform distribution) is drawn in between 0.0 and w1+...+wn,
  the sequence of the interval the number falls into is executed,
  the result of the sequence is the result of the chosen part sequence.

 Added minus operator to the sequence expressions, operates only on numbers

 Indexed assignments to maps m[k] = v are now available in rule evals and sequence computations

 The value at an index of an array,deque,map-valued attribute can be accessed directly from the sequences now:
 - added "element.attribute[index]" container access to sequences expressions
 - added "element.attribute[index] = value" container assignment to sequence assignments
 
 Container methods in the sequences can now be called on container-valued attributes of graph elements, too
  e.g. node.arrayattr.add(x) can now be used in the sequences, too
  (this means esp. that the corresponding attribute change events of the graph get fired)

 Allowed peek() on array and deque, as 0 parameter shorthand for the 1 parameter versions:
 - array.peek() = array.peek(array.size()-1)
 - deque.peek() = deque.peek(0)
 i.e. peek returns the value that is removed by a rem() with 0 parameters,
 in rules as well as in sequences (notice the LIFO/FIFO semantics)

 The external attributes/attribute computation file is now generated and expected
  where the rules reside, instead of in the current working directory

 Bugfixes:
  - external types were emitted inheriting from all super types, not only the direct super type
    that resulted in "multiple base classes not allowed" compiler errors
  - some bugs with incident/adjacent functions in rules
  - several issues regarding indexed assignment to containers, esp. maps
  - fixed some array issues  
 
 
v3.6.ms1b (2012-10-26)
 Bugfixes:
  - fixed bug on importing ecore or GXL in the GrShell
    (another occurence of split-brain GrGen with two graphs)
  - fixed inlining bug which occured when subpatterns were used anonymously at different nesting levels
  - shell comments are now terminated at line end or at #
     so ## gives an empty comment which can be used for terminating a sequence
     when it appears in a shell input parameter string separated by ;; instead of line breaks
  
v3.6.ms1 (2012-08-27)
 Added automorphic pattern filtering / symmetry reduction of matches:
  - a rule declaration may now be annotated with a special filter auto, this
    makes GrGen.NET generate a matches filter auto which can be applied to calls of that rule
  - when applied it removes matches which are only permutations of other available matches,
    which is the case when the pattern is automorphic (and multiple matches are requested)
   (This renders GrGen much better suited to molecule matching for chemistry applications.)

 Improved random support in the sequences:
    (now that we got comparison operators to decide based on them)
  - added a random(upperBound:int):int function to the sequence expressions, 
    returning a random value in between 0 and upper bound exclusive
  - added a random():double function to the sequences expressions, 
    returning a random value in between 0.0 and 1.0 exclusive
  - added $(1.0) to the sequences returning a random value in between 0.0 and 1.0 exclusive;
    it is choicepointable like the $%(upperBound:int) available since a while now

 Visited flag handling changed / improved:
  - visited flags are reset on deallocation now, instead of on (re-)allocation
  - added deallocation procedure vfreenonreset without flag resetting to the sequence computations,
    this gives better performance on large graphs, leaving it at the responsibility of the user 
    to ensure the corresponding visited flag is unset/false on deallocation for all graph elements

 Bugfixes and API improvements: 
  - entries in the matches list handed out on request may now be overwritten with null, 
    they then count as deleted entries when materializing the matches collection again from the list 
    (this saves subarray copying on entry deletion in a user implemented filter)
  - replacing the matches with the changed list handed out was buggy in case the list was empty
  - the filter applied to a rule call is now displayed in debugger

--------------------------------------------------------------------------------------------------------

v3.5.2 (2012-08-12)
 Added "custom actions explain <actionname>" command to the GrShell/Actions in API
  printing the currently used scheduled search plan to the console
  (should be useful in optimizing performance, similar to the mysql/sqlite explain commands)

 Added printing of match statistics during non-debug sequence execution every second
  can be disabled (or enabled again) with the shell command silence exec off (/on)
  
 Bugfixes:  
  - fixed bug on importing ecore or GXL in the GrShell (split-brain GrGen with two graphs)
  - fixed bug in inlining of subpatterns yielding outwards
  - fixed bug in scheduling of inlined negative/independent
  - fixed crash when a set/map/array-constructor was used in an inlined subpattern
  - fixed crash in connectedness analysis for inlining
  - give error message on wrong usage of def arguments for normal subpattern parameters,
    and of normal arguments for def subpattern parameters, instead of failing later internally 
  - assigning the top priority to an edge in the rule file did not cause an edge lookup, fixed
 
v3.5.1 (2012-08-05)
 Multiple improvements in the user manual in various sections

 Added "dum(p) graph" command to the debugger

 Bugfix: abstract nodes/edges could not be referenced in the rewrite specification of a nested pattern, 
  until the matching graphlet was directly contained by that nested pattern  

v3.5 (2012-07-29)
 Some improvements in the user manual:
  - split several chapters into better digestible, more coherent parts
  - better explanation of the bracktracking angles, the central construct for crawling search spaces
 
 Bugfix: abstract nodes/edges could not be referenced in the rewrite specification of a nested pattern, 
  until the matching graphlet was directly contained by that nested pattern

 Performance optimization: isomorphy checking, i.e. the graph comparison operators are much faster now

  
v3.5 RC (2012-07-08)
 Improved graph querying from the sequences with for matches loop:
  - added for{m:match<r> in [?r]; sequence} looping over matches found
  - added m.n access to elements of match, distinguished from attribute access by type of the variable
  - the loop variable must be of type match<r>
 
 Improved graph querying from the sequences with neighbourhood iteration loops:
  - basic form is for{var in function(parameters); sequence}
  - var iterates over the incident edges in case of the incidency functions,
    which are incident, incoming, outgoing
  - var iterates over the adjacent nodes in case of the adjacency functions,
    which are adjacent, adjacentIncoming, adjacentOutgoing
  - the parameters are (source:Node) or (source:Node, incident:EdgeType)
    or (source:Node, incident:EdgeType, adjacent:NodeType)
  - the nodes or edges returned are filtered according to the incident/adjacent types if given
  - in contrast to the functions in the sequence expressions of the same name,
    these functions enumerate nodes/edges multiple times in case of reflexive or multi edges

 Added (h)ighlight command to the debugger:
  - it accepts one or multiple comma separated variables or visited flag ids
    and then highlights the variable content (must reference graph elements) in the graph
  - for plain variables and sets the contained elements are annotated with the variable name
  - for arrays the contained elements are annotated with the variable name and index
  - for maps the contained elements are annotated with the variable name and the Domain/Range role,
    for node to node maps edges are inserted pointing from the source to the target elements
  - for visited flags all elements visited according to that flag are annotated 
    with the id or the variable containing the id

 Added highlight command to sequences:
  - highlight("text") behaves like the (h)ighlight command in the debugger, 
    just that it's called from a sequence instead of being interactively applied with (h)
 
 Bugfixes:
  - fixed bug in backtracking (cloning of matches list)
  - the user choice constructs from the sequences crashed without a debugger session before their execution
  - fixed bug: select actions command was broken since the graph processing environment introduction

 Further additions:
  - simple Emacs syntax highlighting added
  - added support in debugger for cycling through the matches found, 
    of transaction double angles and the for-matches-loop
  - the print (v)ariables command in the debugger now additionally prints the allocated visited flags


v3.5 beta3 (2012-06-23)
 Fixed massive bug in graph comparison: now taking connectedness into account
 Fixed crash in interpreted sequences when calling a sequence containing an all-bracketed rule

 Added export command to sequences:
  export(filename) exports the current graph as file of the name given, in the format given
  export(graph, filename) exports the graph specified as file of the name given, in the format given
  
 Added statespace chemistry test which shows how to model chemical reactions,
 enumerating all possible reaction results

 
v3.5 beta2 (2012-06-18)
 Improved customization, extension of GrGen with C# code:
 - External match filter functions added, declared with a backslash after a rule/test body,
   plus match filter function applications at a rule application, with a backslash, too.
   To be executed after matching and before rewriting, allowed to alter the matches list.
   With them, external code may be notified about, inspect, and filter, matches of rule applications.
 - External sequences added, declared as sequences without sequence body,
   plus external sequence applications in a sequence as any other application of a defined sequence.
   With them, arbitrary external code may be called from the sequences, passing parameters.
 - The match filter and external sequence functions need to be implemented 
   in a <Name>ActionsExternalFunctionsImpl.cs file.

 Bugfixes/Improvements:
 - Some fixes/generalizations in sequence application parameter passing, def elements, and yields.
 - Inlining fix (bad negative / inlined subpattern interaction).

 
v3.5 beta (2012-06-03)
 Subpattern inlining supported now:
  - potential to speed up transformations with subpattern usages dramatically,
    esp. when subpatterns were used for extracting common parts, structuring transformations,
	causing the containing patterns to become disconnected
  - required some hefty internal changes, as a quick workaround against bugs in case some show up
    it can be disabled with the -noinline parameters to the grgen compiler, 
    and a corresponding shell command: set noinline on|off

 Bugfixes/misc. stuff:
  - generate FooModelExternalFunctions.cs even when only external classes (and no external functions) are declared
  - copy external functions when adding models to models
  - clear method on set/map/array was only implemented in parser, now complete
  - allowed to yield to non-node/edge variables in exec (of rules)
  - parameters occuring only in deferred execs but not their containing pattern now work
  - the detection for a recursion of empty subpatterns now assumes a recursion will eventually terminate
    if conditions which are not statically known to be true are found on such an otherwise empty recursive path
  - enough fundamental technical changes to call the child v3.5 instead of v3.1 by now

  
v3.1 beta 4 (2012-04-06)
 Several procedures for basic graph manipulation added to sequence computations:
  - add(:NodeType):Node - creates node of given type and adds it to the graph
  - add(:EdgeType, src:Node, tgt:Node):Edge - creates edge of given type 
     from src to tgt and adds it to the graph
  - rem(node:Node) - removes node from graph
  - rem(edge:Edge) - removes edge from graph
  - clear() - clears graph

 Several procedures for graph element neighborhood queries added to sequence computations:
  - source(edge:Edge):Node - returns the source node of the edge
  - target(edge:Edge):Node - returns the target node of the edge
  - adjacentIncoming, adjacentOutgoing - in addition to adjacent, restricted to incoming or outgoing edges
     of type (source:Node):set<Edge> or (source:Node, incident:EdgeType):set<Edge> 
     or (source:Node, incident:EdgeType, adjacent:NodeType):set<Edge>
  - incident, incoming, outgoing returning the edges incident to the source given the constraints specified
     of type (source:Node):set<Edge>, or (source:Node, incident:EdgeType):set<Edge>,
     or (source:Node, incident:EdgeType, adjacent:NodeType):set<Edge>

 Several procedures for computing and cloning induced graphs added to sequence computations:
  - inducedSubgraph(:set<Node>):Graph - returns the subgraph induced from the node set given
     inducedSubgraph replaces induced
  - definedSubgraph(:set<Edge>):Graph - returns the subgraph defined by the edge set given
  - insertInduced(:set<Node>,anchor:Node):Node - adds a clone of the induced subgraph to the host graph,
     returns the clone of the anchor node given
  - insertDefined(:set<Edge>,anchor:Edge):Edge - adds a clone of the defined subgraph to the host graph,
     returns the clone of the anchor edge given

 Some further miscellaneous procedures and operators added to sequence computations:
  - binary operator ~~, checks for structural equality of graphs,
     i.e. isomorphy but does not check attributes for value equality as == does
  - added cast operator "(type)element" for node and edge types
  - added .peek(n) method for container types, returning the nth element of a container

 Bugfixes:
  - edge redirection and thus node merging was broken when used in transactions/backtracking
  - compiling external attribute evaluation functions from dynamic search plans gave a compiler error
  - one-of/some-of-set operator ${(...)}, {(...)} now handled correctly in compiled sequences, too
  - further small fixes and improvements


v3.1 beta 3 (2012-02-12)
 Isomorphy checking for state space enumeration now supported (to purge duplicate graphs/states):
  - Added subgraph typed variables and attributes, which allow to store and retrieve IGraph values,
    (they are for coping with subgraphs of the host graph, not multiple host graphs,)
    declared e.g. as gr:graph
  - Comparison operators == and != offered for (sub)graphs (the only operations on the graph type),
    they check whether the graphs are isomorphic to each other
  - for loop without container added to sequence, looping over the compatible graph elements 
    of the statically declared type of the iteration variable, e.g. for{x:Bar; do_sth()}
  - added adjacent operation to collect the nodes adjacent to a source node into a set of nodes
    e.g. adjacent(source), or adjacent(s, incidentEdgeType), or adjacent(s, iET, adjacentNodeType)
  - added induced operation to create an induced subgraph given a set of nodes
    e.g. induced(set), or sequence {gr:graph=induced(adjacent(src, contains))}
  - the statespace test now gives an example of state space enumeration including isomorphy checking,
    cutting equivalent graphs/states (i.e. mapping isomorphically regarding structure and attributes)
 

v3.1 beta 2 (2012-01-22)
 Added comparison operators ==,!=,<,<=,>,>= to sequence expressions, as well as + operator;
  same semantics as in rule language expressions, for the various types they apply to

 Added pause insertion / s / to transaction and backtracking angles:
  The effects of the sequences are kept in the graph even if the (backtracking) transaction is rolled back.
  This behaviour allows to generate a spate space by iterating all matches with nested backtracking brackets 
  (dynamically nested via sequence calls, with the body of the sequence called containing one backtracking step),
  copying during the backtracking pauses the states which are reached 
  during the backtracking enumeration and which should be kept.
 
 Backtracking brackets expect now a double semicolon in between the rule and the sequence,
  is much better readable that way: << r ;; s >>  (old simple semicolon still available)
  
 Refactoring of the graph: split out the graph processing stuff into a graph processing environment
  the graph itself is now clean and easy; for sequence execution and variables an environment is needed
  consequences:
   - variables can't be exported (and therefore imported) any more, "withvariables" option removed
     only shell save/include emit them/read them
   - on API level you need an additional graph processing environment object for most tasks,
     an LGSPGraphProcessingEnvironment to be constructed from the graph and the actions
 Refactoring of the named graphs: named graph is now an interface and an lgsp implementation,
  instead of a wrapper; that's easier to handle, and naming now works more reliable, in more situations,
  esp. the naming operator can now we be used in embedded sequences, too
 Some further refactorings to clean and improve the code, 
  partly moving functionality, partly removing unused functionality
 
 Improved External Function Handling:
  - introduced -lazynic parameters to the grgen compiler, 
    so one can access external assemblies in the user defined function/class implementation
  - and lazynic to the shell, too:
    new set lazynic on|off
 
 Several bugs fixed, esp. regarding transactions and (compiled) sequences, most imporant:
  - the matches of a rule found during handling of nested backtracking don't get destroyed any more
    if the same rule is matched again at a deeper nesting level (they get now cloned)
  - allowed sequence expressions as parameters of rule/sequence calls in the embedded sequences, too
  
 
v3.1 beta 1 (2011-12-12)
 Refactoring of the sequences: split old sequences into sequences and sequence computations
  (plus the sequence computation sub parts sequence expressions and assignment targets)
  - sequences are now pretty pure, control operators over rule applications plus basic variable handling
  - computations must be be given in the sequences enclosed in { },
    return true if computation has no result value or it is a non-default value

 Refactoring of variable handling: global variables must be prefixed with ::
  so we have typed local variables declared with name:Type and used with name,
  and untyped first-usage-is-definition global variables used with ::name.
  Optional in shell and grs importer, as all variables there are global,
  mandatory in sequences and sequence computations, with a deprecation warning if prefix is missing.
  Parsing and symbol tables now allow global and local variables with same name.
 
 A lot of further refactorings in sequence handling 
  - to improve the code, 
  - to allow for more powerful sequences and sequence computations in the future 
  - to fix old issues, e.g. binary operators are now left associative, as they should be
 
 (Negative) side effects of sequence computation introduction: 
  - the rule-set-sequence must be given with syntax {(.,.)} now instead of {.,.}
  - several constructs must be given in { } now as they are computations
  - container access out of bounds yield runtime crash instead of sequence application result false
 
 New sequence computation constructs:
  - chaining of statements with then operator ";", e.g. {x=y; x.add(3); x.empty()} 
  - chaining of assignments, e.g. {a=b=0}
  - chaining of method calls on the state object, useful for container changing methods, e.g. {s.add(1).add(2)}
 New sequence expression constructs:
  - boolean operators &&,||,&,|,^
  - conditional ternary operator, e.g. a ? b : c
 New sequence construct: 
  - plain variable declaration, later on initialized explicitely in a computation

 Improvements:
  - print line number of sequence when sequence parsing fails, in .grs and in .grg
  - sequences can now be called in shell with exec, too
  - orientation layout option now affects not only the debugger, but the .vcg dumps, too
  - a few bug fixes
  
 Adapted user manual to mainly sequence handling changes,
  split off storages and visited to own chaper, split off external stuff into extensions chapter.

--------------------------------------------------------------------------------------------------------

v3.0.1 (2012-04-06)
 - Added -deprecated option to grshell and grgen (as migration helper towards 3.1):
    When sequence constructs are found which are only available as sequence computations in 3.1
	a deprecation warning message is printed to stderr (in case this option is given)
 - Some minor fixes
 - Note: when using transactions or backtracking, you are strongly recommended to switch to 3.1,
    they contain bugs which won't be fixed on 3.0 any more
	
v3.0 (2011-07-29)
 New datatypes introduced:
  byte - 8bit signed, literals are denoted by Y-suffix, e.g. 42y
  short - 16bis signed, literals are denoted by S-suffix, e.g. 0x4242s
  long - 64bit signed, literals are denoted by L-suffix, e.g. 0xDEADBEEFl
  the operators expect int or long, byte and short are automatically casted upwards
 
 Node merging:
  Extended the retype operator by the ability to merge nodes in,
  e.g. x:T<u,v,w> creates x as a retype of u to T, with v and w merged in,
  i.e. the edges incident to v and w are redirected to x and then the nodes are deleted
  - as T may be typeof(u) a pure merge can be achieved
  
 Edge redirection:
  Edges can be requested in the rule language rewrite part to get redirected,
  e.g. an edge declared as x -e:T-> y in the pattern can be redirected in the rewite part with
    x -e->! z; or x !-e-> z; or y !-e->! x; i.e. the end to be redirected is marked by !
	(an exclamation mark at the end to change as seen from the center to state "make this happen!")
  Edges can be requested in the shell to get redirected by the
    redirect <edge> (source|target) <node>      command, redirecting <edge> to the new <node>

  Misc:
  - Debug appearance polished, esp. unintuitive red -> green for newly created elements
  - HelloWorld! in examples\HelloWorld-TTC2011 made simpler by utilizing independent
  - Syntaxhighlighting adapted
 
 
v3.0beta3 (2011-07-04)
 LHS retyping:
  - allowed retype operator on lhs, x:T<y> tries to cast y to T, 
    if successful x allows to access y as T (attributes!), otherwise matching fails for this y

 Totally homomorphic matching:
  - with syntax independent(name) pattern elements may be requested to be matched homomorphic to any other element
  - isomorphy exceptions may be specified with syntax independent(name\name)
    or independent(name\(name+name+...+name))
  - this allows to match the already matched target node of a use-def backlink in a program graph,
    but is potentially dangerous as conflicting rewrites may be specified

 Iteration breaking:
  - iterated { X; break negative { Y; } }
    if the negative matches, not only the current iteration instance is prevented from matching, 
    but the entire iterated is failing to match
  - iterated { X; break independent { Y; } }
    if the independent does not match, not only the current iteration instance is prevented from matching,
    but the entire iterated is failing to match
  - this allows to check that "every pattern X must also satisfy Y" holds on single-rule level

 Visualization and Debugging:
  - added debug set node|edge mode matched|created|deleted|retyped command
     it allows to configure the same visualization options as the dump set node|edge command,
     but for the debugging visualization effects instead of for the types
     (so one can configure a debugging display which is better visible with regard to the normal graph display)
  - added ability to configure linestyle continuous|dotted|dashed in dump set edge command
  - added ability to configure thickness 1|2|3|4|5 in dump set edge command
  - added missing .vcg colors lightyellow and yellowgreen to color enum/parsing, fixed turqouise -> turquoise

 Improved External Function Handling:
  - allowed to give assembly references as parameters to the grgen compiler (grgen -r <name>.dll), 
    so one can access external assemblies in the user defined function/class implementation
  - allowed to add/register assembly references in grshell used at the invocations of the compiler:
    new add reference "<path to dll>"
  - and a keepdebug flag for improved debugging:
    new set keepdebug on|off

 Syntactical convenience: in case a top level rewrite part is missing a default empty modify is assumed

 Improved Import: EMF/ecore/XMI adapted to TTC live contest input

 Bugfixes:
  - fixed issue when parsing (pat1 | ... | patn) construct
  - fixed compilation error for iterated in negative/independent
  - bugfix for elements to be deleted but referenced in a typeof

 Syntax highlighting: adapted to latest changes

 
v3.0beta2 (2011-05-19)
 Solutions of Transformation Tool Contest 2011 tasks added to examples:
  - HelloWorld! in examples\HelloWorld-TTC2011
  - ProgramUnderstanding in examples\Reengineering-TTC-2011
  - CompilerOptimization in examples\CompilerOptimization-TTC2011
 Export/Import:
  - Model override can now be a rule file, e.g. import Foo.gxl Rules.grg
    imports Foo.gxl using the model(s) from Rules.grg and selects the actions for usage.
  - EMF/ecore/XMI importer extended, can now handle references by url fragments instead of ids
  - GrgExport is now writing a rule creating the graph and a test matching the graph
 New searchplans are created for all actions when no rule name is given,
   i.e. custom actions gen_searchplan is recompiling all the matchers
 Syntax highlighting improvements
 Fixed several bugs:
  - crash in vcg dumper on a certain combination of exclude and group by
  - wrong emitting of tuple attributes in GXL export
  - problems due to elements referenced not being available in the pattern,
      for typeof and emithere
  - unsigned shift right >>> semantics fixed, and now correctly explained in manual

  
v3.0beta (2011-04-17)
 Local variables, ordered evaluation, and yielding outwards:
  - added def entity declarations, which on RHS do not get created, on LHS do not get matched,
    but are yielded to from evals, evalheres, subpattern rewrites, or execs on RHS,
    or are yielded to from yields, subpattern usages on LHS,
    out of the same pattern, but especially out of nested patterns and called subpatterns.
	They can be uses as local and output variables;
	def vars may receive an initialization assignment.
  - added yield block which is an eval on the LHS constrainded to not assigning to /
     not changing graph element attributes, only parameters or def entities allowed
  - added yielding assignments to evals, evalheres, execs
  - added yielding assignments to yields, esp. including iterated yield accumulation with for
  - added yield arguments to def parameters in subpattern calls and subpattern rewrite calls
  - added evalhere command to evaluate attributes in between the subpattern rewrite calls
  - added alternative/iterated rewrite usage specification to trigger an alternative/iterated
    rewrite usage in between the subpattern rewrite calls
  - was made possible by: every nested pattern can be given a name,
     for the anonymous ones a counted makeshift name is assigned

 Generic datatype array<T> introduced:
  - mapping to C# list (misnamed dynamic array)
  - supporting operations added, in types and expressions, in model and rules, in sequences, in shell:
    - array<T>[ el, el2, el3 ] constructor
    - a.add(x) to add x to the end of array, a.add(x,i) to insert x at index i
    - a.rem() to remove element from end of array, a.rem(i) to remove element at index i
    - a.clear() clears array
    - a.size() gives size of array, a.subarray(i,l) returns subarray from start i on of length l
    - a.indexOf(x), a.lastIndexOf(x) give index of first/last occurence of value x in the array
    - x in a returns whether x is contained in a
    - a[i] returns value at index position i, same does a.peek(i)
    - a[i] = x overwrites element at position i by x
    - a==b, a!=b checking equality of size and of the elements at their respective positions
    - a<b, a<=b, a>b, a>=b checking order of size and equality of elements
	   at their respective positions up to the size of the smaller array
    - a+b returning a concatenation of array a followed by b, compound version a+=b supplied, too
    - storage access in rules n{a} or n{m.a} of array elements

 Expressions extended by incoming/outgoing edge function:
  - incoming(node, EdgeType, NodeType) returns a set of the edges incoming to the node,
     only if of the given EdgeType, only if originating from a node of given node type
	 NodeType is defaultet to Node if omitted; EdgeType is defaulted to Edge if omitted
  - outgoing(node, EdgeType, NodeType) does the same for the edges going out from node

 Changed syntax of storage access in pattern from "<" storage ">" suffix to "{" storage "}" suffix
   because "<" ">" is already used for retyping, input parameter type, copy; was too overloaded

 GrShell extended by pwd, cd, ls commands:
  - pwd: prints working directory
  - cd <path>: changes working directory to <path>
  - ls: lists the content of the working directory with files relevant to GrGen highlighted

 Bugfixes:
  - the mono csharp compiler yields errors for unicode escaping in identifiers,
    changed attribute implementation suffix
  - fixed code generation for calls in compiled sequences which do not assign return values,
    but the rule/sequence called returns some
  - if grgen is called with "path/file" then by now the path is only prepended
    when opening an "#include i-path" to the i-path, if the i-path is not absolute
  - added error messages in case edges created are referenced in evalhere,
    in case edges from nesting pattern are referenced in nested pattern (instead of compiler crash)
  - fixed assertion when using node/edge valued set/map types

 Optimizations by better/global data flow analyses allowing for cheaper runtime implementations:
  - reduced overhead of runtime neg level checking to the very seldom cases it is really needed
  - reduced overhead of patternpath setup to the very seldom cases it is really needed

 Minor:
  - refactorings of iterated patterns in API
  - syntaxhighlighting adapted
  - enough changes to call the child v3.0 instead of v2.7 by now


v2.7.ms4 (2011-02-07)
 Added procedural abstraction for graph rewrite sequences with sequence definitions:
 - added support for compiled named sequence definitions in rules file with syntax:
    sequence name(input variables):(output variables) { sequence }
 - added support for interpreted named sequence definitions in shell with syntax:
    def name(input variables):(output variables) { sequence }
 - for both: input and output variables are local variables,
    they get filled with the input values,
    and define the output values in case of success,
	where success is defined by the sequence.
 - they can be called from other sequences (or even the same) with
   (output parameters)=name(input parameters) syntax,
   as for rule calls the output parameters of sequence calls are only written on success

 Added debugger commands
  - "(v)ariables" which prints out all global variables and all local variables
      of the currently executed sequence (up to the point focussed)
  - "stack (t)race" which prints the call stack of the sequences currently executed
      (including sequence content and execution state)
  - "(f)ull dump" which prints the call stack of sequences including all their variables

 User manual restructuring and extension:
  - split chapter "Understanding and Extending GrGen.NET" out of API chapter,
    added a lot of content there explaining how GrGen.NET works
  - split chapter "Visualization and Debugging" out of GrShell chapter,
    to decrease shell chapter size and emphasize visualization and debugging

 Further minor:
   - added support for sequence result postfix assignment s => v, s |> v, s &> v


v2.7.ms3 (2011-01-17)
 Added support for storage attributes, i.e. attributes typed with set/map of node/edge,
  can now be declared in model, handled by all the other set/map constructs already available,
  furthermore added an extension of the storage access constructs on the LHS by:
   x:T<n.a> with n being a node or edge and a an attribute of it,
   yielding a pattern element picked from the storage attribute

 Added compound assignment statement which allows for efficient set/map operations,
  especially for efficient data flow analysis with the optional change assignment:
   -set/map union |=, intersection &=, difference \= assignments are available
   -change assignment operators assign-to =>, union-to |=, intersect-to &> are available
     examples: v |= w => changed; n.s &= m.s |> e.changed; n.m \= w &> n.visited[2];

 Improved user manual:
  - split off exec/emit and storage handling (+visited)
    into an own chapter "Embedded Sequences and Storages",
    meant as an introduction into combining rules to build transformations.
  - added subsection on data flow analysis explaining how to compute reachability.

 Bugfixes:
  - transaction handling (thus backtracking too) now capable of nested processing,
    i.e. a committed nested transaction gets rolled back if the enclosing transaction fails
  - deferred execs used from rules contained in deferred execs
    don't execute pending execs from their parent any more

 Further minor features:
  - added pow operator to expressions, pow(x,y) computes x to the power of y (only for double)
  - intersection changed to retain first element for maps


v2.7.ms2 (2011-01-03)
 Added copy operator:
 - new-node:copy<old-node> creates a clone of the old node
   (type and attribute values are same, incident edges are not taken care of)
 - -new-edge:copy<old-edge>-> creates a clone of the old edge,
   the source and target nodes of the new edge must be specified (otherwise edge would dangle)

 Added deferred exec:
 - allowed exec from nested alternatives or iterateds, and from subpatterns
 - when used closures for the exec applications are put into a to-be-processed queue,
   which gets executed at the end of the root rule using them

 Added storage access clauses:
 - on LHS one can write x:T<s> with s being a storage;
   the storage elements are iterated, the ones which are of type T are accepted as a match of x
 - on LHS one can write x:T<s[y]> with s being a storage-map and y being an element from the pattern;
   the value of y in s is looked up and if it exists and is of type T it is accepted as a match of x

 Improved user manual with some pragmatics explanations, some fixes
  "Merge and Split, Node Replacement Grammars, and Subgraph Copying"

 Fixes:
  - values of variables are now transmitted into nested iterateds/alternatives
  - anonymous subpatterns are now named "sub"_X,
    so that nodes don't get blown up that much in debugger detail mode


v2.7.ms1b (2010-12-20)
 Bugfixes:
  Compiler:
  - generation error when attribute named A had a sibling attribute named _A (i.e. "_" prefix) fixed
  - rewrite parameters not being available for attribute assignment fixed
  - emit error on attempt to rewrite a rhs declared subpattern usage, i.e. a subpattern which gets instantiated
  Shell/Debugger:
  - fixed debugger/named graph mismatch on retyping (retyped elements stayed in debugger)
  - allowed every place which expects a word (e.g. a type name) to contain a single or double quoted text,
     so user can reference shell keyword named entities by escaping
  - prevent computer from going into sleep mode while a sequence gets executed (windows only)

v2.7.ms1 (2010-12-05)
 Added record and replay feature (plus supporting instructions):
 - record shell command for writing the current graph and then the changes applied to it into a .grs
    for replaying later on, with comments telling about the events causing them as debugging help
 - replay shell command for replaying previously recorded changes
    with capability to define begin and end lines to replay only certain change sets/states
 - record operator in sequences for emitting to the currently ongoing recordings
    e.g. record("\# label1\n") for labeling a state (2 such labels can be used to mark a changeset)
 - retype shell command, e.g. retype (@"$1")<NT> for a node and retype -e<ET>-> for an edge
 - commands to add/remove elements to/from graph element attributes of set/map type, e.g. (@"$4").m1.rem(42)

 Added capability for using external, user defined functions and types in attribute computations (if/eval):
 - added external function declarations, with the GrGen compiler type checking them
 - added external type declarations(with inheritance relationsships but without attributes),
    which can be used from the external attribute computation functions (only)
 - the user must implement the external functions and types in a <X>ModelExternalFunctionsImpl.cs file
    where <X> stands for the model/rule files name, by supplying further parts of partial classes

 Other changes:
 - min(.,.)/max(.,.) functions added to the expressions
 - compiled version of backtracking brackets <<r;s>> now available
 - ability to specify lower bound for random match selection, e.g. $v1,v2[r], $v1,*[r];
     otherwise (when only an upper bound is given as e.g. in $v2[r]) fixed to value 1
 - added askfor shell command just waiting for enter to be pressed
 - further smaller fixes and improvements
 - purged deprecated shell constructs for set handling, map handling, visited flags handling

--------------------------------------------------------------------------------------------------------
 
v2.6.4 (2010-10-30)
 Fixes for bugs introduced in 2.6.3:
 - certain pattern elements were deleted when using patterns with more than 2 nesting levels; fixed
 - subpattern deletion erased the subpattern parameters; fixed

v2.6.3 (2010-10-11)
 Changes:
 - allowed pattern elements to get deleted(/retyped) in nested alternative/iterated blocks or even in subpatterns
    compiler checks that only one delete/retype is ever happening for any pattern element
    this behaviour is only specifiable in modify mode with explicit delete
 - added backtracking brackets: <<r;s>> computes all matches of the rule r (for given inputs), then
    foreach match: apply rewrite (assigning outputs), then execute s
                   if s failed: rollback effects of r and s, continue with next match, fail if exhausted
                   if s succeeded: commit effects, succeed
 - annotations are now available on API level (transmitted from .gm/.grg to code)
 - semantic change: the parameters/attachment points of a subpattern now get deleted
    if not mentioned in the _replace_ part of the subpattern, as was always the case with rules
 - bugfix: allow abstract node types as replacement parameters
 - fixed crash in debugger on printing a rule call with a constant argument (instead of a variable)
 - improved FiniteStateMachine and ProgramGraphs examples,
    split into a succession of examples building on each other, giving a nice overview of the capabilities of GrGen
 - further minor fixes/improvements

v2.6.2 (2010-09-19)
 Changes:
 - bugfixes/improvements for debugger detail mode annotations
 - improved compiler checks, esp. against non-terminating subpattern recursions
    and iterated empty graph matching
 - fixed crash on printing the <var>=null assignment to console in debugger

v2.6.1 (2010-09-12)
 Changes:
 - debugger detail mode now annotates in yComp all the pattern elements matching on a host graph node
 - debugger detail mode annotations now show in addition to the pattern element name the path to the name
   (with symbols from the regular expression syntax, and the subpattern entity names,
    clipped from nesting level 3 on, only showing nesting depth due to display size constraints)
 - removed the rule rewrite part reuse optimization (reuse optimization still there on graph level),
    was source of too many errors over time, esp. when used with transactions
 - some smaller fixes (regarding independents and subpattern rewrite parameters)

v2.6 (2010-09-05)
 Single most important change:
  - user manual updated (including all the changes from 1.4->2.6)

 New sequencing constructs in xgrs:
  - operator then-left l <; r executing l then r, returning the execution result of l
  - operator then-right l ;> r executing l then r, returning the execution result of r
  - decision if{cond; truecase; falsecase} executing cond,
     on success truecase is executed and its result returned,
     on failure falsecase is executed and its result returned
  - if{cond; truecase} which equals if{cond;truecase;true} thus giving a lazy implication
  - n-ary random all of operators (currently only available in the interpreted sequences),
     in function call notation with the operator symbol as function name:
	 - the strict $|(s1,s2,s3) and $&(s1,s2,s3) evaluate all their subsequences in random order
	 returning the disjunction resp. conjunction of their truth values.
     - the lazy versions || and && evaluate the subsequences in random order
	 as long as the outcome is not fixed or every subsequence was evaluated,
	 returning the disjunction resp. conjunction of their truth values.
  - some-of-set braces {r,[s],$[t]} matching all contained rules
     and then executing the ones which matched; true if one of the rules matched
  - one-of-set braces ${r,[s],$[t]} matching all contained rules
     and then executing at random one of the rules which matched; true if one of the rules matched

 Uniform variable handling in xgrs:
  - now the compiled and the interpreted sequences both always support
    i) graph global variables, untyped, i.e. type errors are only detected at runtime,
     live from first assignment/implicit declaration on, written to file on save and restored on load
    ii) sequence local variables, typed thus statically type checked,
     only live until sequence execution ends (thus no persistency available)

 Handling of set<T>/map<S,T> in xgrs:
  - in contrast to the set/map in models and rules, S/T may be of node/edge typ, giving storages/storagemaps
  - set/map addition st.add(el)/mp.add(el,val) always succeding
  - set/map removal st.rem(el)/mp.rem(el) always succeding
  - set/map clearing sm.clear() always succeeding
  - set/map iteration for{el in st; seq} / for{el->val in mp; seq},
     failing iff seq fails for at least one el/el->val in the set/map
  - set/map membership query el in sm succeeding iff el is contained in the set/map
  - map lookup assignment val=mp[el] assigning the result of a map lookup to a variable,
     succeeding iff el is contained in mp, otherwise failing, not touching the variable
  - set/map size assignment sz=sm.size() assigning size to the variable, always succeeding
  - set/map emptyness query result assignment se=sm.empty() assigning to the variable
     whether set/map is empty, always succeeding
  - set/map creation st=set<T>/mp=map<S,T>, and variable declarations of explicit set/map type,
     st:set<S>, mp:map<S,T>,  e.g. st:set<Node>=set<Node>

 Handling of set<T>/map<S,T> in rules, to ease the processing of storages:
  - ref st:set<T>, ref mp:map<S,T> parameters, call-by-reference, including S/T of node/edge type
  - rule rewrite part extension, new statements besides emit/exec:
   - set/map addition st.add(el)/mp.add(el,val);
   - set/map removal st.rem(el)/mp.rem(el);

 Visited flags handling:
  - visited flags processing in rules in function notation deprecated
    visited flags processing in rules now by syntax:
      e.visited[f] = b  or  e.visited = b
      e.visited[f]  or  e.visited
  - visited flags management in shell deprecated
    (allocvisitflag, isvisited, setvisited, freevisitflag, resetvisitflag)
    visited flags management now by xgrs operations instead of shell commands:
      f=valloc() for visited flags allocation
      vfree(f) for visited flags deallocation
      vreset(f) for resetting visited flag in all graph elements
      e.visited[f] for query whether graph element was visited
      e.visited[f] = b for setting whether graph element was visited

 New assignments in xgrs:
  - attribute reading in xgrs: toVar = fromVar.attributeName (value semantics)
  - attribute writing in xgrs: toVar.attributeName = fromVar (value semantics)
  - constant value/literal assignment: toVar = int|float|double|string|boolean|enum|set|map - constants/literals
  - random number assignment: v = $(Number) assigning a value from 0 up to excluding Number to v
  - user input assignment: v = $%(Type) querying the user for a value of given type and assigning it to v
     only in interpreted xgrs, as shell input required; only in debug mode if a node/edge type is requested

 Improved debugging:
  - blue > at sequence start
  - renamed (n)ext to (u)p (going one level up in the sequence tree)
  - added (n)ext command focusing the rule which matches next in green
     (instead of normal/other step commands focusing the rule which will be tried next)
  - the rules which matched during sequence execution are shown on dark green background,
    the rules which failed during sequence execution are shown on dark red background;
	at the end of a loop iteration the old highlighting state is displayed,
    at the begin of a new loop iteration the highlighting state of the contained rules is reset.
  - choice points similar to break points added; denoted by % appended to the random operator $
     transforming the random choice to a user choice, triggered when execution reaches the choice point
	 applicable to the random binary operators, random match selection, random number assignment
	 user input assignments are choice points which can't be toggled off
  - debug support for all the new and changed xgrs constructs

 Rewrite part handling of nested patterns:
  - modify/replace graph elements of nesting pattern
     are now available in modify/replace of nested alternative/iterated/multiple/optional-patterns
  - modify/replace of nested alternative/iterated/multiple/optional-patterns can't take parameters any more,
     better: no need to give them any more, as they can access the rhs elements of the nesting pattern
  - the modify/replace parameter declaration of the subpattern has to be given at the subpattern head / interface,
     not in the subpattern body any more

 Retyping:
  - graph elements matched outside alternative case now can get retyped in alternatives cases
  - graph elements matched outside optional pattern now can get retyped in optional pattern

 Export/Import:
  - GRS(I) import/export (of .grs, .grsi files; and GrShell) now support set/map attribute initialization
    (example: new :N1($="$0", a = set<int>{1,2,3}, b = map<string,boolean>{"foo"->true,"bar"->false})
  - withvariables parameter for grs export causing variables to get exported; default is nodes/edges only
  - GRS(I) import/export now writes and reads persistent names correctly
       (instead of variables; only if a non named graph is given fallback to hash names)
  - GXL import/export now supports enum attributes (set/map not supported)
  - support for importing/exporting .gz compressed .gxl/.grs
  - add parameter for .gxl/.grs import, adding the graph from the file to import to the current host graph
  - ecore/XMI importer extended to support a larger class of inputs (plus nopackagenameprefix parameter)

  Set/Map comparison in rewrite rules:
  - new set/map comparison operators in rewrite rules:
     sm1 == sm2 is true iff sm1 equals sm2 (sm1<=sm2 && sm2<=sm1)
  	 sm1 != sm2 is true iff sm1 unequal sm2 (at least one entry not available/same in the other set/map)
 	 sm1 <= sm2 is true iff sm1 is subset/submap of sm2 (every entry from sm1 is available in sm2)
	 sm1 < sm2  is true iff sm1 is proper subset/submap of smp (sm1<=sm2 && !sm1==sm2)
	 sm1 >= sm2 is true iff sm1 is superset of sm2 (sm2<=sm1)
	 sm1 > sm2  is true iff sm1 is proper superset of sm2 (sm2<sm1)
	maps require key and value to be same for the equality, (proper) sub/supermap relationships to hold

 EBNF/regular expression-like notation for nested patterns added:
  - (P)* = iterated { P }
  - (P)+ = multiple { P }
  - (P)? = optional { P }
  - (P1|P2) = alternative { L1 { P1 } L2 { P2 } }
  - ~(P) = negative { P }
  - &(P) = independent { P }
  The notation supports additionally (P)[k], (P)[k:l], (P)[k:*] for matching a bounded number of times.

  The rewrite part can be given in embedded action style:
  - {+ R } = modify { R }
  - {- R } = replace { R }

 Connection assertions:
  - nodes without incident edges were ignored in validation, now the lower bound 0 vs. 1 is always checked
  - the default if no multiplicity is given is now [*] instead of [1], i.e. no constraint specified
  - support for "validate strict only specified" mode, doing a strict validation,
    but only of edge types for which connection assertions were specified
  - support for "copy extends" to copy the connection assertions of the direct supertypes
  - support for undirected edges with -- syntax
  - support for arbitrary edges with ?--? syntax

 Fixes:
  - escaping of quotation marks in VCG files
  - escaping of quotation marks and newlines in communication with yComp
  - escaping of XML language elements in GXL export
  - escaping of some parameters to the call of grgen.jar containing paths
  - nameof(element) now working correctly, i.e. returning persistent name as announced
      (instead of variable name; only in case of a non-named graph a hash value name is returned)
  - typeof(element of abstract type) now working
  - bad interference of transactions with the reuse optimization removed
  - several cases of use before definition in rule language now working
  - Mono compiler error (MS.NET warning) when using alternatives removed
  - initialization overwrite in model (on inheritance paths of depth >2; for sets/maps)
  - fixes for nesting hierarchies of right hand side declared elements
  - dump into .vcg format now handles nesting as declared by "dump add group" commands correctly
  - name collision between shell and rule generated graph elements causing debug display corruption
  - directed/undirected edges (as given by edge syntax) can extend arbitrary edges
    without being forces to explicitely extend Edge/UEdge, too
  - removed check against homomorphy of retyped elements not needed
  - lazy or operator parsing priority bug
  - ResetVisitedFlag/vreset now reliably working on edge types, too
  - code generation for conditions in nested patterns
  - code generation for alternatives nested in negatives/independents
  - subpattern creation/instantiation with parameters from rewrite part
  - runtime cast exception when calling a subpattern modification with an argument being a subtype of the parameter type
  - wrong matching of iterated consisting of only a terminal pattern not requiring a candidate iteration loop
  - endless loop prevention by checking against unbounded pattern cardinality constructs
      containing no locally defined nodes or edges (not being homomorphic to enclosing elements)
  - several bugs in code generation for iterated fixed
  - usage of rhs elements on lhs
  - further minor fixes

 Further changes:
  - null arguments must be declared beforehand if they should be used,
    causing the element to be searched by its own search plan,
	thus every null-capable argument doubles the number of matchers;
    declaration syntax example: rule r(x:Node<null>, y:T<S+null>)
	  (y is example for inexactly typed input which may be null in addition)
  - the deprecated old grs were removed
  - new shell construct <Var> = askfor <Type> prompting the user to enter a value of given type
     - if the type is a graph element type the user is asked to select a graph element
       by double clicking in yComp (debug mode must be enabled)
     - if the type is a value type the user is asked to enter a value of this type on the keyboard
    the older debug apply with wildcard elements is deprecated now, succeeded by this construct
  - assignment of sequence result to variable is now always true (independent of sequence result)
  - execs may yield elements which can be used in return statements; yield statement in compiled xgrs
  - replaced emitpre by emithere, which is emitted before regular emits,
    at the position syntax-relative to the subpattern modification invocations and the other emitheres
  - the random match selector now expects a variable instead of a number
  - new rule modifiers dangling (only apply rule if all incident edges of a node to be deleted
     are specified in the pattern), and identification (don't apply rule if a node to be deleted
     was matched homomorphically to a node to be kept), allowing to pick from the dpo conditions
	 (dpo = dangling + identification)
  - new method .peek(num:int) on set<S> and map<S,T> types, returning the element/the key of the element
      at the position num in the sequence of enumeration
  - new function random() returning a double random value in between 0.0 and 1.0
      and random(sup:int) returning an integer random value in between 0 and sup, sup exclusive
  - added emit to xgrs: emit(double-quoted-text|variable)
      example: xgrs emit("foo\n") && emit(v)
  - same literal/constant syntax now in assignments and attribute initializations of
      model, rules, sequences, shell, grs (ex/)importer
      (e.g. Foo::bar for enum, 3.141593f for float, 0x11 for hex integer, map<string,double>{"42"->42.0})
  - the graph with model combined class is now named FooGraph instead of Foo for Foo.grg
  - set/map commands in GrShell are deprecated (succeeded by xgrs set/map operators)
  - set/map-valued attributes are now displayed in yComp, too
  - now error reported on attempt to delete and return elments allowed to be matched homomorphically
  - added exitonfailure to GrShell validate command leaving GrShell on failed validation with error code
  - undirected edge creation in GrShell with -name:type- syntax and type UEdge if no type given
  - Added GrGen syntax highlighting for vim (model, rules, shell)
  - Extended GrGen syntax highlighting for Notepad++ to GrShell files
  - added GrGen-solution for ModelMigration case from TTC2010
  - added GrGen-version of "Repotting the Geraniums: On Nested Graph Transformation Rules" to examples
  - user manual now under Creative Commons Attribution-Share Alike 3.0 Germany license
  - further minor improvements

--------------------------------------------------------------------------------------------------------

v2.5.1 (2009-09-09)
 Additions:
  - subpatterns now support var parameters, too
  - GrShell now with non-debug/gui-mode and return value
  - additional checks and warnings in GrGen compiler
  - GraBaTs 2009 Live Contest Winning Solution ConveyorBeltSystem added
  - some renaming in examples folder to show case origins
 Fixes:
  - usage of var parameters in alternative, iterated - blocks
  - nested iterated, alternative blocks
  - elements of enclosing lhs pattern only mentioned in eval of rhs
  - gxl export (showing in mono glx import exception)
  - several examples work again (not all, though)
  - some previously failing tests

v2.5 (2009-06-28)
 Advanced subpattern/subrule features:
  - iterated block matching contained subpattern as often as possible implemented
  - multiple block as an iterated block requiring at least one match added
  - optional block matching contained subpattern (eagerly) at most once implemented
  - independent block for specifiying positive application conditions implemented
  - emitpre (before emitting from subpatterns) and emitpost(=emit; after emitting from subpatterns)

 Im/Export:
  - import/export commands added to GrShell, porter module added to LibGr
  - GXL importer and exporter added
  - EMF / ECore importer added
  - GRS importer and exporter added

 New API:
  - Generation of an action interface per action, implemented by the action class,
    plus an action-interface-typed member per action in actions class instance
  - Action interface with exactly typed input parameters, matches object, output parameters
    (for the match / modify / apply methods)
  - Old input parameters semantics - silently failing rule application on wrong type -
    now only available with syntax r(x:ExactType<InexactType>)

 Semantic changes:
  - Semantics of negative regarding subpatterns/subrules changed:
    negative pattern elements get matched independent from the subpatterns utilizing them
	(explicit patternpath/pattern statement in the negative/independent needed for old behaviour)
  - hom declarations are inherited into nested negatives/independents now
  - hom delarations are non-transitive by now (hom(a,b) and hom(b,c) don't cause hom(a,c) unless specified)

 Examples:
  - Solution to the GraBaTs 2009 Program Comprehension case study added
    (including EMF import)
  - Completed JavaProgramGraphs sample (Grabats 2008 refactoring case solution),
	including GRS import/export in source code sample
  - Rewritten ProgramGraphs sample with new iterated construct,
    added corresponding source code sample
  - Updated source code samples to the new 2.5 API

 libGr:
  - Added short infotags (without displaying attribute name)
  - The labels of elements can now be removed or set to a constant string

 GrShell/yComp:
  - Improved interactivity: debug apply <rule with ? as placeholders>
    allows to select wildcard elements ? by double clicking at elements in graph viewer yComp
  - Debugging much more robust to unexpected connection loss
  - show var <variable> implemented
  - Shell / debugger now showing match parts due to all forms of subpatterns in debug mode / with %
  - Finally implemented the help command and improved the error handling
  - Replaced "dump edge labels (on | off)" by "dump edge [only] <type> labels (on | off | <text>)"
  - Added "dump set node [only] <type> labels (on | off | <text>)"
  - Added "dump add (node | edge) [only] <type> shortinfotag <member>"

 Misc:
  - Changed License to LGPL v3
  - Added GrGen syntax highlighting for Notepad++
  - Shorthand visited(el) for visited(el, 0)

 Bugs:
  - Several smashed

--------------------------------------------------------------------------------------------------------

v2.1.2 (2009-02-16)
 Fixes:
  - don't create elements declared outside alternative if only appearing in modify/replace part

v2.1.1 (2009-02-06)
 Features/API changes/Fixes/Examples:
  - Added icons for GrGen, GrShell
  - Added conference scheduling/grabats2008 live contest solution to examples
  - Added IsAbstract and IsConst to GrGenType, catch attempts to create abstract elements in GrShell

v2.1 (2008-12-19)
 Features:
  - Added string methods (indexOf, lastIndexOf, length, substring, replace)
    (see frontend/should_pass/strfunc_001.grg in source release)
  - Added set<K> and map<K,V> attribute types (using value semantics)
  - Inline condition evaluation code to improve performance
  - Const attributes are now implemented as static to improve performance

 GrShell:
  - Added support for set/map variables
  - Added "setvisited <elem> <vis_id> <visited>" command
  - Added "isvisited <elem> <vis_id>" command
  - Removed silent modifier from node/edge creation commands
  - Added "silence (on|off)" command

 API changes:
  - Changed interface of changing-node/edge-attribute handlers because of
    set/map feature
  - Provide metainfo about declared enum types

 Fixes:
  - Improved compilation time of specifications for large amount of actions
  - Fixed comment parser in .grg dependency checker
  - Improved several error messages
  - Use an own namespace for alternative names
  - Entity (node/edge/subpattern usage) names now overwrite type names
    in expressions
  - Allow <element>.<attr> with attr being an GrShell keyword

 Examples:
  - Improved layout of Transcription examples
  - Added (parts of) the petri-net-benchmark from the paper "A Benchmark
    Evaluation of Incremental Pattern Matching in Graph Transformation"
	by Varró et al.
  - Added "Object to Relational Mapping" by Varró et al.

 Other changes:
  - Increase stack size of Java frontend and GrShell

--------------------------------------------------------------------------------------------------------

v2.0 (2008-07-28)
 Features:
  - Added support for literals as parameters for XGRSs
  - Improved performance of matching a bit
  - Improved performance of rules with return statements
  - Improved performance of compiled XGRSs (exec statement)
  - Added -noevents and -noperfinfo options for GrGen.exe disabling firing
    of events in generated code and counting of matches/rewrites for a small
    speedup
  - Added GXL (Graph eXchange Language) to GRS (GrShell script) converter
    (gxl2grs.exe; an according model must be generated by hand)

 API changes:
  - Improved debugger support by using some DebuggerStepThrough and
    DebuggerDisplay attributes on GraphElements and Types
  - Allow newlines in XGRS strings (enables use of verbatim strings in user
    source code to reduce noise caused by string concatenation)

 Fixes:
  - Elements used by nameof()-operator if not mentioned otherwise in modify
  - Allow boolean literals as attribute initializers in "new node/edge"
    GrShell commands
  - Retyping in subpattern or alternative case
  - Do not reserve several libGr/lgspBackend class names

 Examples:
  - Added JavaProgramGraphs example, a partial solution of Program
    Refactoring case of GraBaTs 2008
    (contains rules for a specialized GXL dumper making use of the nameof
     operator and rules inserting helper edges for a nested layout of the
     program graph assisting the GrShell "group by" dump commands)
  - Added AntWorld version passing integer constants in exec (_NoGammel)

 Other changes:
  - Updated GrShellBenchmarker


v2.0 beta 2 (2008-06-24)
 Features:
  - Allow assignments of the success of a sequence to a variable
    (e.g. "res:boolean=(r1 || r2[5])")
  - Allow boolean variables as sequences (only works in execs, yet)
    (e.g. "res && r1")
  - Added visited flags
  - Added random-match-selector
    (e.g. "$7[r1]" searches for all matches and then randomly selects
     7 of them to be rewritten. "$[r1]" is equivalent to "$1[r1]")
  - Added nameof()-operator
    (e.g. "nameof(blub)" yields the name of the graph entity "blub";
     "nameof()" yields the name of the graph)

 Features for GrShell:
  - Added "silent"" keyword to new node/edge commands to prevent
    "element successfully created"-messages
    => Shell scripts creating a lot of elements run much faster when
       using this keyword
    (e.g. "new state:State silent" or "new a1 -:Edge-> a2 silent")
  - Added post build step to grshell to increase stack size to 16MB
    (so that matching engine can handle much larger recursive structures)
  - Added visited flags support
  - Support assignments of "true" and "false" to variables
  - Added "randomseed" command
    (e.g. "randomseed 13" sets the random seed to 13 for reproducible
     results when using the $-operator-prefix or the random-match-selector;
     "randomseed time" sets the random seed to the current time in ms)
  - Reduced GrShell overhead of XGRS execution significantly

 API changes:
  - Moved PerformanceInfo, MaxMatches, Replace, ApplyRewrite,
    ApplyGraphRewriteSequence(Sequence), ValidateWithSequence(Sequence)
    and the events from BaseActions to IGraph
  - Sequence.Apply now takes an IGraph instead of a BaseActions instance
  - Removed BaseActions.ApplyGraphRewrite
  - Added GetNewestActionVersion and SetNewestActionVersion to IGraph
    (perhaps only temporarily...)
  - Added AddNode and AddEdge variants to IGraph to allow adding
    e.g. cloned elements to the graph
  - Added INode.Adjacent, INode.GetCompatibleAdjacent,
    INode.GetExactAdjacent and IEdge.GetOther
  - PerformanceInfo.MatchesFound is now always changed after firing the
    IGraph.OnMatched event

 Fixes:
  - Allow identifiers to begin with an underscore
  - yComp: Remove related reference nodes, when a node is moved to
    another subgraph
  - Don't generate pattern creation functions, when the pattern contains
    abstract members
  - Fixed inheritance of same attribute over multiple inheritance paths
  - Fixed crash of SequenceParser on lexer error
  - Don't ignore wrong text after correct sequence prefix
  - Allow to write "r1*" instead of "r1[*]" in execs
  - Fixed range specifications of the form "[200]" in .gm and .grg files
  - Fixed the performed rewrites counter for compiled XGRSs (exec)
  - Replaced exponential constant folding algorithm in Java frontend
    by a linear-time one

 Examples:
  - Updated BusyBeaver API example
  - Added TranskriptionAbstrakt example
    (doing transcription on chains instead of chemical structure graphs;
     Viatra2 R2 solution included)
  - Added TranskriptionAbstraktNachAtom example
    (transforming the abstract dna chains of TranskriptionAbstrakt into
     the chemical structure graphs of Transkription)
  - Added ProgramGraphs example and API example
    (implementing program graphs as specified in "Adaptive Star Grammars
     for Graph Models" plus PullUpMethod refactoring on these program
     graphs)
  - Added WeakComponents examples and VisitedExample API example
    (using visited flags)
  - Added AntWorld example for GraBats 2008
    (using the random-match-selector)

 Other changes:
  - Return statements now only allowed after all normal statements;
    exec/emit statements only as last statements


v2.0 beta (2008-04-28)
 Features:
  - Introduced subpatterns, alternative patterns, and recursive patterns
  - Introduced dependent replacement and recursive rules
  - Introduced "var" parameters and return values for basic types
    like int and string
  - Allow expressions as return arguments
  - Added "arbitrary" and optional "directed" keywords for edge classes
  - Added "using" statement for models
  - Implemented dpo/exact/induced also for the new edge kinds
  - Graph variables are objects now, and not only graph elements anymore

 Features for GrShell:
  - Added support for variable assignments with literals
  - Variable to variable assignments
  - "show graph" and "dump graph" now use the layouter configured
    via "debug set layout"

 API changes:
  - The classes for Node/Edge and for elements inheriting from Node/Edge
    now inherit from INode/IEdge directly instead of the IAttributes
  - Removed obsolete IAttributes
  - Renamed IGraphModel.Name to IGraphModel.ModelName
  - Special classes being a graph an a model at the same time
    are now generated for each model. They also contain specialized
    element creation methods for each element type
  - Removed deprecated IDumperFactory
  - The VCGDumper can now specify a layouter to be used
  - Added static type property "TypeInstance" to element classes
    for easier access to the appropriate type instance
  - Generated C# element class names are not prefixed anymore as long
    as the would be no name clash (a warning is generated then, too)
  - Added EdgeType.Directedness property
  - Renamed Condition to PatternCondition
  - Added IGraph.Actions property as a currently associated actions object
    (perhaps only temporarily...)

 Fixes:
  - Dangling edges in nested negative patterns
  - Fixed several frontend tests

 Examples:
  - Updated examples
  - Added "Recursive" example
  - Added "Transkription" example
  - Continued Firm-IFConv example (now also using var parameters and return values)

 Other changes:
  - Changed License to GPL v3
  - The names of the generated model files now depend on the model name

--------------------------------------------------------------------------------------------------------

v1.4 (2008-03-20)
 Features:
  - Introduced the imperative statement "emit" in RHS printing text
    to the console or to files (see UML2CSP2 example)
  - Introduced the imperative statement "exec" in RHS executing xgrs'
  - Introduced abstract members in element types
    (these members do not have a declared type,
    hence containing classes are abstract)
  - Introduced "dpo", "induced" and "exact" modifiers for rules
  - Introduced "induced" and "exact" statements in rule patterns
  - "null" is a keyword, now. It represents the default object value
  - Member initializers in model specification
  - Added support for external implementations of element types
  - Updated implicit and explicit casts (see user manual section 5.1)
  - Nested negative patterns
  - Undirected edges
  - Directed "-->" or "<--", undirected "--", arbitrary directed "<-->"
    and arbitrary "?--?" edges in patterns
  - Added "maybeDeleted" element annotation to ignore warnings claiming
    that a returned element could be deleted due to a hom statement

 Features for GrShell:
  - Enhanced grouping support:
    "dump add node [only] <NodeType> group [by [hidden] <GroupMode>
    [[only] <EdgeType> [with [only] <NodeType>]]]",
    where <GroupMode> can be "no", "incoming", "outgoing", or "any".
  - Allow setting layout options without starting the debugger first
  - Remember layout options during a session
  - Save layout options when using "save graph"

 API changes:
  - Redesign of type architecture
  - Direct access to element attributes
  - Changed namespaces of generated code
  - Introduced IGraphElement.Valid, IGraphElement.ReplacedByElement,
    INode.ReplacedByNode, and IEdge.ReplacedByEdge to check, whether
    elements were deleted or retyped during a rewrite
  - Removed unused dump fields from BaseActions

 Fixes:
  - Returns for test actions
  - Enums are now allowed as values in '?:'-operators
  - Fixed dependency calculation for includes in grg-files
  - GrShell "save graph" command
  - GrShell debugging of sequences containing "[SomeRule]"
  - GrShell debugging of element retyping
  - GrShell "dump (node|edge) only <nodeType> exclude" command
  - GrShell debugging with grouped nodes
  - Problems with edge parameters
  - Handling of abstract element classes
  - Several cases involving combinations of hom, retype, delete, and return
  - Output compile warnings also when compilation did not fail

 Examples:
  - Added Sierpinksi3 (with parallel rewrite semantics)
  - Added FiniteStateMachine example
  - Added UML2CSP2 example using the new emit statement
  - Added DebugExec example

 Other changes:
  - "pattern" part is now directly embedded in rules and tests
  - Added XML documentation files for Intellisense help in IDEs
  - Replaced 'include "<grg-file>";' by '#include "<grg-file>"'
  - ycomp.bat does not need to be edited anymore
  - Changed syntax for rule application in xgrs:
    e.g. "%?[(a,b)=R(a,c)]" to "(a,b)=[?%R(a,c)]"


v1.3.1 (2007-12-07)
 Features:
  - Added "-gensp" option to spBench allowing generation of dynamic
    searchplans after execution of the initialization xgrs
  - Stabilized content of generated C# files for better version control
  - Test actions work now

 Fixes:
  - spBench acted on the original graph instead of the cloned version
  - Clone variables and all statistical information when cloning a graph
  - Clear variables when clearing a graph
  - Disabled buggy node reusing as a workaround
  - Reflexive pattern edges were not always matched correctly

--------------------------------------------------------------------------------------------------------

v1.3 (2007-11-06)
 Features:
  - The reuse optimization reusing deleted elements can now be disabled
  - Infotags with null values are not displayed anymore
  - Speedup transactions a bit
  - GrGen.exe: Renamed -d option to -keep, added -debug and -usefull option
  - Added options for dumping and commenting generated matcher programs
    (accessible through properties and "Custom")
  - Reimplemented LGSPGraph.Clone via copy constructor to allow derived
    classes to support cloning
  - Added convenience methods BaseGraph.GetNodeType and BaseGraph.GetEdgeType

 Features for GrShell:
  - Added "debug layout" to relayout the graph in yComp
  - Added "debug get layout options" and "debug set layout option" allowing
    access to the parameters of the current layouter in yComp

 Examples:
  - Added HelloMutex api example
  - Added YCompExample api example
  - Added GrIO example
  - Added AGTIVE example UML2CSP
  - Added another Sierpinski triangle implementation

 Tools:
  - Added spBench, an application to benchmark all possible searchplans for
    a rule pattern

 Fixes:
  - Fixed ASTdapter
  - Fixed multiline custom commands for GrShell
  - Fixed xgrs parser not allowing "somerule[1:*]"
  - Fixed node reusing causing a crash
  - Disabled debug output of yComp
  - Fixed NACs only containing an if
  - Fixed attributes output of VCGDumper
  - Fixed infotags
  - Fixed homomorphic matching (testcase hom1 and hom2)
  - Includes in GRG-files are now also considered as dependencies

 Specification processing (grgen.jar):
   Changes:
    - Improved processing time
    - Improved error messages
    - Added new attribute type "object"
      (only operators '=', '==', and '!=' are allowed)
    - Warn if a graph element occurs inside and outside a delete statement
    - Warn if a returned graph element may be matched homomorphically to the
      same element as an element within a delete statement
    - "actions" and "model" keywords are now deprecated
    - Enum declarations may now use already existing enum entries

   Fixes:
    - Fixed '?' operator
    - Fixed errors with C# keywords in models and rules
    - Fixed rule specification files without any rules
    - Fixed crash when using a non-existing model

--------------------------------------------------------------------------------------------------------

v1.2 (2007-07-19)
 Features:
  - Introduced xgrs as replacement for grs (GrShell can still handle grs, but
    prints the new xgrs version for a given grs).
    See "Developing Graph Transformations with GrGen.NET" for a description
    of the new graph rewrite sequence syntax.
  - Restructured directories
  - Added test bench
  - GrGen now places the generated libraries into the directory of the spec
    files by default (can be overridden with -o)
  - Updated examples

 Features for GrShell:
  - The LGSPBackend is the default backend now. So the "select backend ..."
    line is not necessary anymore in the normal case.
  - Introduced 'new graph <grgfile>' which builds the libraries if neccessary
    and creates graph and actions, superceeding 'new graph <modellibrary>'
    plus 'select actions <actionslibrary>'. The latter commands stay
    available, though.
  - Added "validate xgrs <sequence>" which is successful, if the given
    sequence can be applied successfully on a clone of the current graph
    (implemented by BaseActions.ValidateWithSequence)
  - Added "dump add edge <type> exclude"
  - Added breakpoint support (% flag for rules, true and false in debug mode)
  - Added breakpoint toggling while debugging (use the 'b' key)
  - Fixed infotags
  - Added element exclusion for debug mode
  - Added support for multiline commands using '\' at the end of a line
  - Guess .grg extension for "new graph <specfile>" when <specfile>
    does not exist
  - Guess .grs extensions for files given via commandline

 API changes:
  - Renamed GetOutgoing/Incoming to GetCompatibleOutgoing/Incoming
  - Added GetExactOutgoing/Incoming
  - Added Apply, ApplyStar, ApplyPlus and ApplyMinMax to IAction

 Fixes:
  - Fixed problems with dangling edges in patterns
  - Fixed retyping with typeof operator
  - Newly created edges could not be returned
  - Fixed wrongly reported invalid reuse of nodes and edges in modify part
  - Annotations on anonymous elements did not work
  - Fixed error detection for return statements
  - Fixed comparisons with constant enum expressions
  - Fixed attributes with names of reserved C# keywords
  - Fixed casts to strings
  - Fixed conditions containing casts
  - Fixed float constants

--------------------------------------------------------------------------------------------------------

v1.1 (2007-07-02)
 - Base of change log
