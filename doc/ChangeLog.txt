v6.6 (2022-04-01)
 Introduced a graphViewerAndSequenceDebugger library
  - to be employed from user code/at API level for graph display and sequence debugging
  - containing esp. a GraphViewer class and DumpAndShowGraph as well as ShowGraph and EndShowGraph methods
  - containing the Debugger class that can now be used from API level (utilizing some environment classes) (without GrShell)
  - introduced a ConstantParser so constant parsing as required by the debugger can be done without resorting to GrShell
    requires genparser.bat/genparser.sh to be executed in the graphViewerAndSequenceDebugger folder

 Introduced a libGrShell library
  - to be included in an own application project in order to gain GrShell-like functionality,
    and/or graph rewrite shell script interpretation ability

 Added examples to examples-api showing how to use the new libraries
  - adapted and fixed the YCompExample
  - added a DebuggerExample project showing how to employ a Debugger from API level
    (utilizing the new graphViewerAndSequenceDebugger library)
  - added a ShellExample project showing how to employ the GrShell embedded into/from within an own application
    (based on the libGrShell library)
  - also added a Windows Forms based ApplicationExample
    (showing how to use GrGen-functionality from a Non-Console-App)

 Many fixes and improvements in sequence error reporting
  e.g. errors in compiled sequences don't cause a crash anymore
  (happened previously for some error kinds),
  and now also the prototypes of mismatching sequences/functions/procedures are printed
  (in addition to the prototypes of mismatching rules/tests)

 Also (re-)allowed a rule/sequence usage while a variable of same name exists
  added a warning for a variable usage while a rule/sequence of same name exists
 - result: a name with parenthesis means rule/sequence call, without a warning even if a variable of same name exists
   a name without parenthesis is resolved to a variable read with higher priority than a parameterless rule call (yielding a warning)
 - consequences: a parameterless rule call is still possible when no variable of that name exists,
   while a rule call can be enforced by applying parenthesis

 A few further bugfixes, especially:
  - adapted/fixed parameter passing of procedures with inputs(/outputs) of array of match (class) types 
  - fixed procedure method calls in compiled sequences
  - added missing check of builtin procedure calls

 User manual adaptations
 
--------------------------------------------------------------------------------------------------------
 
v6.5 (2022-01-06)
 Introduced a parallel (var1, var2, ...) = in subgraph-expr1, value-expr1 { seq1 }, in subgraph-expr2, value-expr2 { seq2 }, ... 
  construct to the interpreted sequences
  it executes the sequences in parallel (given sufficient execution resources),
  on the specified subgraphs,
  and evaluates the optional value expressions, making their result available as a local variable named value
    (in the sequences that are executed in parallel)
  optionally assigning the results of sequence execution
 Introduced a parallel array (var) = in subgraph-array-expr, value-array-expr { seq } - construct to the interpreted sequences
  it executes the sequence in parallel (subgraph-array.size() times, given sufficient execution resources),
  on the specified subgraphs, and optionally values, optionally assigning the results of parallel sequence execution
  the amount of subgraphs in the subgraphs array and values in the values array must be the same,
  the array<boolean> in the return-var will be of the same size
 Implemented with a thread pool, also using the parent(/main) thread for execution
  in case the amount of threads from the thread pool is exceeded,
  the single tasks in the parallel execution construct are executed in sequence
  (by the parent thread) (at least one - the syntactically last - task is executed by the parent thread)
 Introduced a for sequence[parallelize=k]; configuration option to the model language,
  allowing to define the amount of threads in the sequences thread pool
 Added debugger support with a choice of the sequence-to-be-debugged at construct execution begin

 Added synchronization statement and methods to the sequences and rule language statements allowing to implement critical sections:
 - added lock(lock-object-expression) { sequences } construct to the sequences,
   entering the specified synchronization object when the sequences are entered and exiting it when the sequences are left
   (yielding the result of the contained sequences)
 - added lock(lock-object-expression) { statements } construct to the rule language statements, with same semantics
 - added Synchronization::enter(lock-object) procedure to the sequence computations and the rule language statements,
   entering the specified synchronization object (waiting for entry if it is already occupied by another thread 
    (re-entering it in case it was already entered by the same thread))
 - added Synchronization::tryenter(lock-object) : (boolean) procedure  to the sequence computations and the rule language statements,
   trying to enter the specified synchronization object, returning false if it was already occupied, or entering it, returning true
 - added Synchronization::exit(lock-object) procedure to the sequences computations and the rule language statements,
   exiting the specified synchronization object (crashing if it was not already taken by the same thread,
    otherwise decreasing the entry counter, releasing other threads if the counter reaches 0)
 - introduced a corresponding lock keyword to the sequences and rule language
 
 Added a getEquivalentOrAdd(graph, array<graph>) procedure that returns the graph from the array of graphs 
  that is isomorphic to the graph given as first argument, or null if no such graph exists,
  in that case the graph is added to the array of graphs (to the rule language as well as the sequence computations)
 Added a getEquivalentStructurallyOrAdd(graph, array<graph>) procedure that returns the graph from the array of graphs
  that is isomorphic neglecting attributes (so only structurally) to the graph given as first argument,
  or null if no such graph exists (even when neglecting attributes), in that case the graph is added to the array of graphs
 Both procedure(s) can be used concurrently from sequences executed in parallel,
  the array is processed atomically and consistently, i.e. only one thread will add a graph
  that is (not isomorphic to the existing ones yet) isomorphic to another graph concurrently processed by another thread
  (the other thread will then return this one); it is (/they are) implemented in a way so that the majority of graph comparison work
  (and array reading) can occur in parallel, outside of array locking

 Added a custom graph optimizereuse_poolsize <int-value> configuration option
  that allows to set the size of the pool storing deleted elements for reuse
  replaced corresponding hard-coded constant values; extended a test

 Added assert(condition:boolean, [message:string, parameter:object]*) and assertAlways (with same parameters) procedures
  to the rule language statements and the sequence computations
  - the former fires when the condition yields false and assertions are enabled
    (only in that case is the condition evaluated, the same holds for the other arguments),
  - the latter fires always when the condition yields false
  - a firing aborts program execution by default, or allows the user to choose in the debugger
    (in between program abort, external debugging, and execution continuation)
  - for the rule language statements, a default message reporting the file/line/column
    is supplied by the compiler in case of a missing message

 Added a custom actions enable_assertions <boolean> command (available via GrShell)

 Added array<T>.addAll(array<T>) and set<T>.addAll(set<T>) procedure methods to the rule language statements and the sequence computations
  they add (/append) the argument container to the target container (only supported on variables, not on attributes)

 Generalized the looping brackets in the sequences from number constants to expressions
  i.e. r[min-num:max-num] to r[min-expr:max-expr] where the expressions must be of type int (also r[min-num] to r[min-expr])

 Extended switch to subgraph construct in graph { sequence } from graph input via variable/attribute access only to a general expression

 Debugger improvements:
 - extended s(k)ip mode in debugger from interpreted to compiled pattern matching constructs
 - extended skipping of on-matched user query if only a single match exists from interpreted to compiled rule calls
 - added (d) to random choice continue options (extending (s)/(n))
 
 API changes:
 - introduced SpawnSequences and JoinSequences events to the graph processing environment (to report parallel execution begins and ends)
 - changed ClearGraph event so that the graph is expected as an argument
 - added ConstructType to IPatternMatchingConstruct (allowing to differentiate the different kinds of pattern matching constructs
   in the begin/end execution events, now including compiled constructs)
 - added an enableAssertions flag to the action execution environment -- it allows to enable/disable assertion handling at runtime
 - split global variables (including object id sources) out of the graph processing environment (and the graph)
   contains variable management and object id handling -- causing a semantic change: object ids are assigned globally instead of per-graph
   to be fed to the graph when the latter gets constructed, pointed to by the/each graph
 - purged the special variables management (from the global variables and the graph processing environment)

 Bugfixes:
 - fixed bug in implementation of adaptvariables command - disabling was not possible
 - the custom graph optimizereuse command applies now to all graphs, i.e. also to subgraphs
 - added missing emitting of finished selected match event firing to rule call, count all call and non-random all call rewriting
   in compiled sequences (fixing missing removal of highlighting in debugger display)
 - fixed github issue #3: bug while emitting the code for an exec nested in an eval
 - fixed github issue #4: System could not be used as a node class
 - fixed printing of some sequences in the debugger
 - static typing fix
 - some further smaller fixes (including github #2)

 User manual adaptations, corrections, and improvements
  and added semantic tests showing how to unfold a statespace in parallel
  (one tree-structured, one including isomorphic graphs coalescing(/pruning), so graph-structured)
  (computed breadth-first, compared to the depth-first approach chosen for the other tests in statespaceMapping)
  (with a top-level statespace graph bearing the statespace structure, readily available for visualization purpose, 
   with nodes representing states in the statespace, containing an attribute containing the subgraph the node stands for)

--------------------------------------------------------------------------------------------------------

v6.1.1 (2021-08-28)
 Added getEquivalent(graph, set<graph>) function that returns the graph from the set of graphs that is isomorphic to the first given graph,
  or null if no isomorphic graph exists (to rule language as well as sequence expressions)
 Added getEquivalentStructurally(graph, set<graph>) function that returns the graph from the set of graphs
  that is isomorphic neglecting attributes (so only structurally) to the first given graph, 
  or null if no isomorphic graph exists (even when neglecting attributes)

 Added a 'k suffix to the rule prefix of a pattern element in debugger display
  in order to disambiguate multiple occurrences of a single rule in a multi rule construct
  (e.g. [[r,r]] leading to match annotations r'1.n for a node n from a match of the first occurrence of r,
  and r'2.e for an edge e from a match of the second occurrence of r in the multi rule construct)

 Bugfixes:
 - allowed empty argument list for sequence definitions (in addition to skipping the argument list altogether)
 - applying multi rule constructs containing multiple instances of the same rule works now for all constructs
   in the compiled sequences and the interpreted sequences
 - allowed the attribute method call statement in the sequence computations of the compiled sequences,
   i.e. attribute-bearer.attribute.method-call()
 - accessing attributes of class objects via a container access works now (in the interpreted sequences)
 - allowed usage of object constructors in compiled sequence definitions (in addition to container constructors)
 - container add/rem/clear on attributes of graph elements or internal class objects works now in compiled sequences
 - object ids are mapped per graph to objects instead of globally in grs importing 
   (fitting to the current model of assigning object ids per-graph with its consequence
   that all objects in an object data structure must be from the same graph)
 - parallelized IsIsomorph comparison works now in more scenarios
 - firing of changing attribute events only for class objects (and nodes/edges) but not transient class objects
 - the switch to subgraph construct from the interpreted sequences now also works correctly
   with a switch target given in a graph global variable (in addition to a sequence local variable) (e.g. in ::var { r })
 - added compatibility of the graph type to the untyped type
   (fixing e.g. an indexed access to an untyped map with a graph argument in the compiled sequences)
 - this reference appearing in compiled sequences works now (as argument of a call, led to a null pointer crash)
 - re-added the Notepad++ syntax highlighting configuration file (mistakenly deleted)

 API changes:
 - extended IGraph and LGSPGraph by GetIsomorph and GetSameStructure (delegating IsIsomorph and HasSameStructure to the new functions)

 User manual adaptations, corrections, and improvements
  and extended statespaceMapping tests to showcase non-trivial statespace enumerations with the mapping clause

v6.1 (2021-07-29)
 Added mapping clause [:for{r;seq}:] (returning an array<graph>) to the expressions of the sequences
 - it returns the graphs for which executing seq yielded true, after applying a match of r, on a clone of the current host graph,
   and that for all matches found
 - it can be extended to multiple rules and sequences [:for{r;seq},for{r;seq}:],
   similar to the (multi) rule prefixed sequence [[for{r;seq}],[for{r;seq}]]
 - conceptually, it can be seen as a kind of graph-branching sequence transformation brackets [: construct :],
   returning new graphs upon construct execution thus graph changes, instead of modifying the old host graph
 
 Allowed debugging of sequence expressions (extended the very limited capabilities previously existing)
  this means the pattern matching constructs from the sequence expressions (rule query, multi rule query, mapping clause)
  are now supported, and esp. that nested pattern matching constructs are supported (arguments evaluation can now be traced)

 Some usability improvements in debugging in general,
  esp. the execution of all bracketed rules is now shown match by match, which reflects their real execution semantics

 Improved emitting of objects of graph type

 Bugfixes:
 - fixes for filters (esp. in generation of compiled sequences, e.g. enabled chainability)
 - fixes for nested (multi) rule queries (rules appearing as arguments)
 - fixed sequence definition overwriting in sequence expressions
 - fixed bugs in code generation for rule prefixed sequence and sequence computation emitting
 - fixed bugs in the debugger, e.g. statistics printing while debugger is alive, and incorrect display of multi rule queries
 
 API changes:
 - changed action events and action events handling, esp. split into all-matches and match-by-match events:
  - OnMatchedAfter now delivers an array of IMatches, but not a single match anymore,
    added an OnMatchSelected event to report single matches one-by-one instead
  - OnFinishing and OnRewritingNextMatch were replaced by a new OnRewritingSelectedMatch event (allowing for some code simplifications)
  - added an OnSelectedMatchRewritten event fired before the embedded sequences are executed,
    and an OnFinishedSelectedMatch event fired after the embedded sequences were executed
 - introduced OnBeginExecution and OnEndExecution events fired when a pattern matching construct is started/ended
 - introduced an IPatternMatchingConstruct interface to report the pattern matching construct in the events
    and the enclosing complex pattern matching construct in the SequenceRuleCalls via a Parent member 
 - the EnterSequence and ExitSequence event were generalized from Sequence to SequenceBase,
   in order to allow debugging sequence expressions (so were other parts of the execution infrastructure)
 - also the purpose of the event changes was to allow for the (sequence expression) debugging improvements (see api changes)

 User manual adaptations, corrections, and improvements

--------------------------------------------------------------------------------------------------------

v6.0 (2021-03-28)
 Brought sequence computations to the level of the rule language (with exception of change assignments):
 - completed sequence operators: added support for <<, >>, >>>, ~ and unary + (on numeric types),
   as well as &,^,| on numeric types and in on string type
 - implemented package Math in sequences (i.e. the functions of package math like min,abs,sqrt,...)
 - added support for all string methods (e.g. .length(), .indexOf(), .replace())
 - added support for indexOfBy, lastIndexOfBy, and indexOfOrderedBy array by member methods in sequences
 - extended match type support in sequences with container constructors for containers of match value type
 Fixed sequence grammar: x-1 works now, not requiring a whitespace before the number as before (x- 1)

 Implemented the structural comparison operator ~~ for node/edge/object/transient object types (i.e. attribute bearing types) 
   and container types, with deep value equality semantics
 - it compares the attributes of attribute bearing types ignoring identity (deep by-value comparison),
   the equality comparison operator == in contrast is now checking reference identity only
   Note that an object must not appear multiple times (e.g. due to a cycle), only tree-like object structures are supported
    (in contrast to the structural comparison supported on graphs/graph type).
 - it checks the members of containers memberwise for deep value equality,
   the equality comparison operator in contrast is checking memberwise for identity (only for value types by value)

 Implemented string to object mapping/de-serialization with scan and tryscan:
 - added a scan<T>(string):T function returning a value from a string representation
   (for container types, basic types, enum types, and node/edge types) (to rule language and sequences)
 - added a tryscan<T>(string):boolean function returning whether the given string can be mapped to an object of the specified type
   (to rule language and sequences)

 Allowed (up/down-)casts of object/transient object types

 Extended indexOfBy, lastIndexOfBy, and indexOfOrderedBy array by member methods by support for match and match class types
  (in rule language and sequences)

 Extended deque<T> .lastIndexOf() method by an optional startIndex parameter (in rule language and sequences)
 
 Extended the copy and clone functions by support for external object types
 Deprecated the "external == class;" declaration --- use "external ~~ class;" instead
 The == and != operators check external object types now only for reference identity
  ~~ has to be used for deep value equality

 API changes/extensions:
 - added ArrayIndexOfBy, ArrayLastIndexOfBy, ArrayIndexOfOrderedBy to the array processing helpers section in the graph model,
   and in the actions, as well as MatchInterfaceName and MatchClassName members in IRulePattern and IMatchClass
 - the Copy method whose skeleton gets generated when "external copy class;" is specified now receives the old-to-new mapping 
   (null in case of clone) plus the graph as parameter, so that it can supply the deep copy/shallow clone functionality
 - extended the IsEqual and IsLower functions of the AttributeTypeObjectCopierComparer
   (which are generated when "external ~~ class;" or "external < class;" are declared, respectively)
   by support for deep comparisons with a visited (sub-)objects dictionary parameter
   -- the real deep comparison (of the external objects) has to be implemented by the user
 - introduced an OnObjectCreated event to the graph that gets fired when a class object was created

 Bugfixes:
 - external object types are now adjusted to type object as required
 - fixed deque comparison in compiled sequences
 - fix for array by member methods in sequences getting applied to untyped variables
 - error message corrections


v6.0beta (2021-02-08)
 Carried out a massive data modelling improvement with the introduction of internal object types and internal transient object types;
   they allow to group data and build linked data structures like lists and trees (without graph index overhead)

 Introduced classes describing (internal) object types
 - they are declared with a syntax similar to the one of node and edge classes, but without the node/edge prefix
   example: class Foo extends Bar { val:int; }
 - their values can be instantiated by a newly introduced new operator (in rule language and sequence expressions)
   (they are not part of the graph directly, but may occur in attributes of nodes/edges)
   example: new Foo()
 - an attribute initializer may be given with the new operator:
   example: new Foo@(a=42, b="Hallo Welt", c=x-1), for a class Foo { a:int, b:string, c:double }
 - a unique id is assigned to them automatically
   it can be accessed by a uniqueof(.:Object):long (in rule language and sequence expressions)
   returning the uniqueId of the internal class object (as long value)
 - all internal object types (classes) inherit from a predefined base class Object
   (coming without attributes, and playing a similar rôle like the Node and Edge base classes)
   (not to be mistaken for type object, which is a base type for all GrGen-types)
 - they are reference types, i.e. variables are assigned a reference, and parameter passing occurs by-reference,
   thus the ref modifier is used at their declarations, e.g. def ref o:Foo, and in action signatures, e.g. rule r(ref param:Foo)
 - their attributes can be read and written with obj.attr syntax, like it is used for nodes and edges,
   as well as with obj.attr[index] in case the attribute is a container (in rule language and sequences)
 - an object type variable can be assigned a null value
 - array by member and lambda expression methods can be employed on arrays of object types
 
 Introduced classes describing (internal) transient object types
 - they are declared with a syntax similar to the one of object classes, but with an additional transient prefix
   example: transient class Foo extends Bar { val:int; }
 - their values can be instantiated by a newly introduced new operator (in rule language and sequence expressions)
   example: new Foo()
 - an attribute initializer may be given with the new operator:
   example: new Foo@(a=42, b="Hallo Welt", c=x-1), for a transient class Foo { a:int, b:string, c:double }
 - all internal transient object types (classes) inherit from a predefined base class TransientObject
   (coming without attributes, and playing a similar rôle like the Object base class)
 - they are reference types, i.e. variables are assigned a reference, and parameter passing occurs by-reference,
   thus the ref modifier is used at their declarations, e.g. def ref o:Foo, and in action signatures, e.g. rule r(ref param:Foo)
 - their attributes can be read and written with obj.attr syntax, like it is used for non-transient objects,
   as well as with obj.attr[index] in case the attribute is a container (in rule language and sequences)
 - a transient object type variable can be assigned a null value
 - array by member and lambda expression methods can be employed on arrays of transient object types
 - a value of a transient class object cannot appear as an attribute in an object class / node class / edge class
   (thus it cannot appear in the graph (and its serialization format) -- it is a data type only of importance to processing)

 Introduced a clone operation in addition to the already existing copy operation, 
  both support the newly introduced object types and transient object types (in rule language as well as in sequences)
  and predominantly show a different behaviour regarding these types;
  besides, only the clone function supports match (class) types (removed match (class) types from the admissible types of copy)
  in contrast, only the copy function supports the (sub-)graph type 
 - implemented a new_elem:clone<old_elem> rewrite pattern operator
   it works like the new_elem:copy<old_elem> rewrite pattern operator,
   with exception of the handling of internal class objects in attributes
   clone just copies the surrounding graph element and assigns the object attributes by-reference (shallow clone) (thus they aliase),
   the copy operator copies the objects deeply (replicating pointer structures)
 - added an addClone procedure (to rule language and sequences, supplementing the already existing addCopy procedure)
   (both are working like their according rewrite pattern operators, i.e. adding a clone of the graph element to the graph,
   with internal class objects in attributes being taken over in case of the first and being copied in case of the second)
 - added a clone(obj:T):T function (to rule language as well as sequences)
   it works like the already existing copy(obj:T):T function, with exception of the handling of internal (transient) class objects
     in attributes or container elements
   clone only clones the attribute bearer or container and assigns the contained attributes or elements (shallow clone),
   copy clones the attribute bearer or container and assigns copies of contained internal (transient) class objects
     (deep copy replicating pointer structures)   
   (attribute bearer = node/edge/class object/transient class object, container = array/deque/set/map)
   (cloning as well as copying of an internal non-transient class object fetches and assigns a unique id to the clone/copy 
     (but only copy does so deeply))
   attributes of container type in non-transient object classes are always at least cloned (instead of only assigned)
   attributes of container type in transient object classes are always only assigned by-reference
     (in contrast to a top-level container which always gets at least cloned)

 Internal class objects are supported by transaction manager rollback, graph change recording and replaying,
   and graph exporting to .grs format and importing from .grs format, as well as GrShell inclusion
   this is supported by the unique id acting as a "persistent name", it is written as e.g. a %="%0" entry 
     at the begin of the attribute initializer list of a class object constructor -- example: new Foo@(%="%0", a=42)
     it defines an entry "%0" in a temporary dictionary mapping to the just created object,
     which is then used with a @@("%0") to obtain the object by name later on 
  
 Extended query support with an optional array access variable, and a lambda expression filter and array per-element method
  that allows to accumulate the array values.
 
 Implemented an optional array access variable for lambda expression methods and filters
  given as first variable declaration in the lambda expression, separated by a semicolon,
  it references the original input array, allowing to access it in order to obtain further information
  Example: [?r\removeIf{this_:array<match<r>>; m:match<r> -> m.a < this_.extract<a>().avg()}]
  
 Added a lambda expression filter \assign<elem>StartWith{init-expr}AccumulateBy{accumulation-var:T, m:match<X> -> expr}
  to rule, match class, and iterated filter calls in sequences and rule language 
    (X=r, class mc, r.it; in case of a match class mc a mc. prefix is required before the filter name)
  init-expr is an expression of type T,
  accumulation-var:T a variable that carries forward the computation/accumulation result,
  m:match<X> a variable that gives access to the match from the matches array currently iterated over,
  and expr an expression of type T (with access to accumulation-var and m);
  in each iteration step, m.elem is assigned the evaluation result of expr,
  and accumulation-var the result of expr of the previous iteration / of the preceding m.elem,
  or the evaluation result of init-expr in case of the first iteration / no preceding m.elem exists
  init-expr as well as expr support an array access variable prefix separated by a semicolon

 Added an array per-element lambda expression method .map<T>StartWith{init-expr}AccumulateBy{accumulation-var:T, elem:S -> expr}
  in rule language and sequences, mapping an array<S> to an array<T>
  init-expr is an expression of type T,
  accumulation-var:T a variable that carries forward the computation/accumulation result,
  elem:S a variable that gives access to the element from the array currently iterated over,
  and expr an expression of type T (with access to accumulation-var and elem);
  the resulting array is built stepwise from the evaluation results of expr;
  the accumulation-var gives access to the outcome of the previous iteration step,
  or the evaluation result of init-expr in case of the first iteration / element
  init-expr as well as expr support an array access variable prefix separated by a semicolon

 Container and match type extensions:
 - containers and match classes can now be created with the new operator
   (instead of the plain constructor; in rule language and sequences)
 - allowed match class construction in the sequences (e.g. new MC() for match class MC;)
 - extended match type support in sequence container types (from only arrays to sets, deques, and map ranges)
 - allowed comparison against null for match types in rule language
 - added support for null as value of a container type variable or attribute

 Sequence generalizations:
 - allowed visited flag access without brackets also in sequences (defaulting to visited flag 0 as in rule language)
 - grammar workaround/fix for m:match<r>=expr parsing in sequences (so >= is accepted / user is not forced to separate the > from the =)
 - allowed () after a filter call with members

 Set encoding to utf-8 for .grs files (they are written including the BOM)

 Added a Debugger command "show class ob(j)ect" to inspect an object by unique-id/name / crawl the network of objects
  starting at root variables or non-transient objects defined by their unique-id
  it is also available for transient objects, then a unique-id is generated on-the-fly 
  
 API changes/extensions: 
 - runtime objects follow now the inheritance hierarchy:
     IAttributeBearer <-- IGraphElement <-- INode and IEdge
                      <-- IBaseObject <-- IObject and ITransientObject
 - runtime types (reflection/meta information) follow now the inheritance hierarchy:
     InheritanceType <-- GraphElementType <-- NodeType and EdgeType
	                 <-- BaseObjectType <-- ObjectType and TransientObjectType
 - type models follow now the inheritance hierarchy:
     ITypeModel <-- IGraphElementTypeModel <-- INodeModel and IEdgeModel
                <-- IBaseObjectTypeModel <-- IObjectModel and ITransientObjectModel
 - added an OnChangingObjectAttribute event to the graph
   (automatically fired by GrGen code when an attribute of internal class object type is assigned to)
 - added a Copy method in addition to the already existing Clone method to the interfaces
     of the nodes/edges/class objects/transient class objects (executing the according functionality)
 - IObject offers a uniqueId field, it is/has to be filled upon creation by the uniqueId source located in the graph
 - extended EmitHelper to:
   - optionally collect the unique-ids defining a name of the visited internal class objects in a name to object dictionary
   - optionally assign internal transient class objects temporary unique-ids (also used for emitting), 
     via the graph processing environment storing/fetching them
   - an internal (transient) class objects attribute emitting limit, to prevent emit information overload and endless recursions

 Bugfixes:
 - carried out some bugfixes related to variables and constructors of match (class) type, lambda expression methods/filters,
   further minor fixes here and there (esp. in code generation), and error message improvements
 - added type checks for lambda expression variables and the container access key expression

 User manual adaptations, corrections, and improvements

--------------------------------------------------------------------------------------------------------
  
v5.2 (2020-11-22)
 Introduced two per-element-by-lambda-expression-filters to the sequences
 - \assign<member>{element:match<r> -> lambda-expr:T} assigns to the member:T of a match of a rule r 
   the result of the sequence lambda expression fed by the element of the match, for each element in the matches yielded by the rule
   no declaration is needed, the lambda expression is to be given with the filter call
   the match class version \mc.assign<member>{element:match<class mc> -> lambda-expr:T} does so for a match class mc
   the iterated version \assign<member>{element:match<r.it> -> lambda-expr:T} does so for an iterated it of a rule r in the rule language
 - \removeIf{element:match<r> -> lambda-expr:boolean} removes the matches 
   for which the predicate given by the sequence lambda expression yields true; no declaration is needed
   the match class version \mc.removeIf{element:match<class mc> -> lambda-expr:boolean} does so for a match class mc
   the iterated version \removeIf{element:match<r.it> -> lambda-expr:boolean} does so for an iterated it of a rule r in the rule language
 - they all come with an optional index: the variable index:int iterates the indices [0,matches.size()-1] 
   of the corresponding values in the matches (array) in the \assign<elem>{index:int -> element:T -> lambda-expr:T} and 
   \removeIf{index:int -> element:T -> lambda-expr:boolean} expressions

 Introduced two per-element-by-lambda-expression-array-methods to the rule language expressions and sequence expressions
 - array<T>.map<S>{element:T -> lambda-expr:S}:array<S> returns a new array<S>,
   created by mapping each element of the original array<T> with the lambda expression to its resulting counterpart
 - array<T>.removeIf{element:T -> lambda-expr:boolean}:array<T> returns a new array<T>,
   created by removing each element of the original array<T> for which the predicate given by the lambda-expr yields true
 - both come with an optional index: the variable index:int iterates the indices [0,a.size()-1] 
   of the corresponding elements in the array a:array<T> in the a.map<S>{index:int -> element:T -> lambda-expr:S}:array<S> and
   a.removeIf{index:int -> element:T -> lambda-expr:boolean}:array<T> expressions

 Introduced further array (accumulation) methods to the rule language expressions and sequence expressions:
 - array<T>.shuffle():array<T> returns an array with permuted values
 - array<boolean>.and():boolean returns the conjunction of the boolean values in the array (true in case of an empty array)
 - array<boolean>.or():boolean returns the disjunction of the boolean values in the array (false in case of an empty array)

 Slightly generalized the conditional operator in sequence expressions regarding the admissible types

 Improved debugging of filtering and query evaluation: 
 - added a step in detail mode debugging in the debugger, displaying the prematched entities (before the matches and the rewrites)
   defining a kind of lookahead, so that matches before and after filtering can be inspected and thus compared
 - added debug eval <sequence-expression> command to GrShell
 - added debugger configuration options to the shell language:
   - debug set match mode pre enable|disable (default disable)
     with pre-match enabled, the matches of a (multi) rule before filtering/selection are displayed in detail steps
   - debug set match mode post enable|disable (default enable)
     with post-match enabled, the matches of rules in embedded execs are displayed in detail steps
     (with post-match disabled, only the match(es) of the very rule followed by the rewrite of the rule)

 API changes:
 - introduced PreMatch event fired after all requested matches of a multi rule or rule have been found,
   yet before filtering/selection of the matches
   (a single event even for multi rule applications, in contrast to the series of Matched events)
 - fired by the single/compound rule application constructs in the sequences
   (and by some helper methods in the processing environments)
 - implemented Filter methods in the graph processing environment and match class filterer classes
   (allowing to execute a FilterCallWithLambdaExpression on an IMatches object and a List<IMatch>, respectively
 - turned FilterCall into a base class for the FilterCallWithArguments and the new FilterCallWithLambdaExpression
 - renamed IMatches.ToList() to ToListCopy(), better reflecting what it does, and introduced a ToList() plus its FromList() counterpart
   (that work like their ToListExact() and FromListExact() pendants)
 - extended match interface by methods that allow to set a member (a general one and dedicated ones for nodes, edges, and variables)

 Bugfixes:
 - allowed to access a member of a match class in the sequence expressions (in extension to a member of a match of an action)
 - allowed to access a member of an iterated match in the expressions
 - further minor bugfixes

 User manual adaptations, corrections, and improvements

--------------------------------------------------------------------------------------------------------

v5.1 (2020-07-29)
 More demanding prerequisites:
  Increased required .NET version from 2.0 to 4.0 (or mono 3.8.0)
  Increased required JAVA version from 1.5 to 1.8

 Implementation of keepOneForEach<X>Accumulate<Y>By<Z> auto-generated filter 
  for action (r), iterated in action (r.it), match class (mc)
  removes entries in array<match<r/r.it/class mc>> that are duplicates in/of entity X,
  the entity Y of the remaining entry receives the result of accumulating the array of all entries of Y of the same X,
  by array accumulation method Z (equivalent of SQL GROUP BY with accumulation function)
  (take a look at quarantine tests showing how to use it for "fusing" results, summing scores of entries that fall together)
 Implementation of according auto-generated function body for array-of-match functions, 
  noted down with auto(target.keepOneForEach<X>Accumulate<Y>By<Z>)
  generating a function with same semantics as the corresponding filter function 
  supported on array<match<T>>/array<match<class T>> (but not node/edge type,
  because of the side effect of accumulation on the accumulation attribute of the graph element, thus the graph)

 Implementation of auto-generated function bodies for array-of-match join functions
  noted down with auto(join<natural>(leftArray, rightArray)) for a "natural join"
   (cartesian product requiring value equivalence for common names in matches of left array and right array)
  and with auto(join<cartesian>(leftArray, rightArray) for a "cartesian join"
   (modulo merging of common names, left takes precedence)
  both are supported on array<match<T>>/array<match<class T>>
 Implementation of auto-generated match class body
  noted down with auto(match<T> | match<S>)
  combining specified match types under name merging, to be used for the results of "natural joins" of matches

 Array member processing method extensions:
  Added support for array<T>.groupBy<member>() for T being an (iterated) match (class) or node/edge type
   to rule language, returning an array with equal elements grouped together (in no specific order)
  Added support for .orderAscendingBy<member>(), .orderDescendingBy<member>(), .groupBy<member>(), .keepOneForEach<member>() methods
   to array<T> in sequence expressions, where T = match<r> or match<class mc> or a node/edge class owning the member (attribute)

 Filter extensions:
  Allowed groupBy filter on variables of node/edge type and nodes and edges
   switched implementation to hash-map based equality comparison instead of sorting requiring an order relation 
   (O(n) instead of O(n*log(n))
  Allowed keepSameAsFirst and keepSameAsLast filter on variables of node/edge type and nodes and edges
  Allowed keepOneForEach filter and array method on variables of node/edge type and nodes and edges
  Allowed orderAscendingBy/orderDescendingBy/keepOneForEach filter and array method variables of boolean type and enum type

 Added a match class constructor match<class T>() that allows to create a value of a match class
  (normally created by a matched pattern/action; with default values according to the type for attributes)

 Added support for array<T>:group() to rule language and sequence expressions
  returning a new array with equal elements grouped together (in no specific order)

 Language generalizations / Syntax "fixes":
  Allowed functions with parameters of array of match type
  Allowed matches accumulation yield loop to iterate over arbitrary variables of array of match type instead of only this
  Allowed to declare global variables of match type and array of match type
  Allowed selectors (esp. method calls) after a function call in sequence expressions
  (allowing to process the function call result further)
  Alternative now opens a scope so that alternative case labels of different alternatives can be given the same name
  Allowed return statements of a test/rule for an output parameter of node/edge type to comprise a full expression
   instead of consisting only of a single element reference
  Comparison and conditional operators of node/edge/external type expect and return now exact types
  Allowed usage of >> and >= instead of previously required > > and > = workaround in some more places
   (esp. auto-generated filter call end before transaction end, container initialization)
  map, set, array, deque are no keywords anymore (only checks in the context of a generic type)
  match is no keyword in the interpreted sequences (only) anymore 
   (only a check in the context of a type, still a keyword in rule language due to match class)

 Re-introduced auto keyword to rule language grammar

 Extended error checks
  - added check against multiple local retypes
  - generalized no-ambiguous-retype check from old node to mergees (stemming from a node merge-retype)
  - implemented input type checking for the array accumulation methods
  - improved output type computation of the array accumulation methods
  - added check for incorrect edge (re)use in independents
  - added check against edge declarations with linked nodes in match classes

 Some error message fixes

 API changes:
  - introduced INamed base interface for named entities/types that may be global or may be contained in a package
  - added MatchForQuery to action execution environment interface, with non-exact matches object fitting to the environment,
    and adapted return type of corresponding implementation method
  - extended matches interface in API by a member giving the match class
    (non-null for constructed match class values in contrast to pattern matching results, for those a member giving the pattern is set)
  - added array processing helper methods ArrayOrderAscendingBy(IList array, string member)
    as well as ArrayOrderDescendingBy, ArrayGroupBy, ArrayKeepOneForEach to IGraphModel and IActions
  - added PatternElements Enumerable that allows to iterated over pattern nodes, edges, and variables in a single run 
    to IMatchClass and IPatternGraph

 Performance optimization: improved constant folding

 Bugfixes:
  - several bugfixes for compiled multi rule queries with match class filters and compiled rule queries with filters
    esp.: the filter methods now return the filtered list (so they can be "chained" / used to build expressions)
  - several bugfixes for (esp. auto-generated and auto-supplied) (match class) filters calls
    esp.: fix for filtering by node/edge instead of variable, and 
    match class filters are now really executed for interpreted multi rule all call
  - usage of InvariantCulture for string comparisons for filtering and array of match type comparison
  - fix for initialization of def element of edge type
  - bugfix in array orderAscendingBy/orderDescendingBy/keepOneForEach member type checking

 User manual adaptations, corrections, and improvements

--------------------------------------------------------------------------------------------------------

v5.0 (2020-04-27)
 A --- separator is now needed in between top-down pattern matching/rewriting and bottom-up yielding for result accumulation,
 in the rules and tests of the rule language (it splits the LHS and RHS patterns into two parts)
 - on LHS appear to the left of the separator the elementary pattern entities, nested patterns, and subpattern usages, 
   and to the right of the separator the def elements and yield blocks
   in subpattern usages, the input and output arguments are separated by the ---, too, 
   the same holds for the input and output parameters in the subpattern specifications
   the return (in tests) has to come right of the separator in case that one is given
 - on RHS appear to the left of the separator the pattern rewrite specifications and attribute changing eval blocks, 
   and to the right of the separator the def elements, eval blocks supporting all computations, 
   emit and exec statements, and the ordered statements (telling when the rewrite which nested/subpattern, emithere, evalhere)
   in subpattern usages, the rewrite input and output arguments are separated by the ---, too, 
   the same holds for the rewrite input and output parameters in the subpattern specifications
   the return (in rules) has to come right of the separator in case that on is given
 - the attribute changing eval block supports only a subset of the available computations, related to attribute assignment
 - introduced a subpattern replacement (only-)ordering statement to be given in the imperative part
   in between the other ordered statements, with syntax pattern <name>;
   the subpattern replacement usage in the declarative part specifies that the subpattern is to be applied and the arguments
   (without giving additionally its ordering, as before)

 Changed deque constructor syntax from deque<T>]...[ to deque<T>[...] (in rule language as well as sequences)

 Changed resolving so that package content comes before global content (was only partially the case before)
 - extended package prefixed entity access (package::name) by the possibility to specify a fake package "global" (global::name) 
 - it allows to access a global name from inside a package even if an entity with the same name is available locally
 - resolving rules: 1) content from the package specified with the prefix, if that is "global" then global content,
                    2) content from package context (which thus overrides global content),
                    3) global content (regarding 2: there is no package context available for interpreted sequences
                                        - they only appear in shell/api outside of any packages of the rule language)
 - resolving rules for filters: in between rule 1 and 2 additionally:
   content from the package the rule or match class is contained in to which the filter applies (so a dependent entity)
 - auto-supplied and auto-generated filters are special cases fully relying on the rule/match class (no package prefix)

 Added rule prefixed sequence to sequences:
  [for{r;s}] computes all matches for r, then, for each match (one-by-one): rewrites it, and then executes the sequence s
  the result of the rule prefixed sequence is true when at least one of the executions of sequence s yielded true
  (which is only possible in case a match was found for the rule)

 Added match classes to the rule language defining a kind of pattern interface that can be implemented by the actions 
  (acting as a view/common part), with syntax: match class <name> { def-variable | def-node | def-edge | variable | node | edge }
  used in a test/rule with an "implements <name>" after the signature before the body
  They allow to define match class filter functions that make it possible to filter the matches of multi rule constructs,
  similar to regular single-rule filter functions, with syntax filter f<class mc> { function computations }
  These post-matches filter functions can be called from the multi rule constructs in the sequences,
  a primary use case is to bring matches of multiple rules into a global order (with auto-generated filters)

 Added multi rule all call and multi rule prefixed sequence to the sequences:
 - [[r,t]] searches for all matches of all contained rules and rewrites the found ones
 - [[for{r;s},for{t;q}]] computes all matches for the contained rules (here: r,t), then for each match (one-by-one):
   rewrites it, and then executes the corresponding sequence (s for a match of r, q for a match of t)
   the result of the multi rule prefixed sequence is true when at least one of the executions 
   of one of the contained sequences yielded true (which is only possible in case a match was found for one of the rules)
 - filters may be applied to the rules in the constructs (e.g. r\f), 
   match class filters may be applied to the multi rule prefixed sequence ([[...]\mc.f])
   (removing matches, or reordering them, the rewrites are performed in order 
   - so applications r then t then r are possible for the multi rule prefixed sequence)

 Added multi rule backtracking and multi rule prefixed sequence backtracking to the sequences:
 - <<[[r,t]];;s>> finds all matches of all contained rules and executes then the sequence for each one of them,
   rolling back the changes in case the sequence fails, continuing with the next match,
   or committing the changes in case the sequence succeeds, ending the execution of the sequence (as success)
 - <<[[for{r;s},for{t;q}]]>> computes all matches for the contained rules (here: r,t), then for each match (one-by-one):
   starts a transaction, rewrites the match, and then executes the corresponding sequence (s for a match of r, q for a match of t),
   if the result is false, the effects on the graph are rolled back and the next match is tried,
   otherwise the changes are committed and the overall sequences succeeds
   (without processing further matches; if all matches lead to a failing sequence, the overall sequence fails)
 - filters may be applied to the rules in the constructs (e.g. r\f),
   match class filters may be applied to the multi rule prefixed sequence ([[...]\mc.f])
   (removing matches, or reordering them, the rewrites are performed in order 
   - so applications r then t then r are possible for the multi rule prefixed sequence)

 Added notational shorthand of in-place yielding at a def variable declaration in rule language,
  with the syntax def var v:T = yield(expr); 
  resulting in a def variable declaration and a yield block: def var v:T; yield { v = expr; }
  not to be confused with separate initialization, combined: def var v:T = init-expr = yields(expr)
  the init-expr is evaluated before the yields of nested patterns and can thus be used to give a start value 
  for bottom-up accumulation; the in-place yielding is evaluated after nested and subpatterns were matched and yielded 
  (only then are iterated matches available)

 Allowed match types (match<r>, match<class mc>) as array value types (in rule language as well as sequences)

 Added a rule query [?r] to the sequence expressions,
   returning an array<match<r>> to be processed by filters and array methods
 Added a multi rule query [?[r,...]\<class mc>] to sequence expressions,
   returning an array<match<class mc>> to be processed by filters and array methods

 Allowed iterated match types match<r.it> as array value types in rule language 

 Added an iterated query expression [?it]:array<match<r.it>> to rule language, 
   returning an array<match<r.it>>
   with it being the name of a named iterated block (declared by: iterated it { content })

 Added iterated filtering to rule language, with syntax iterated it\f; (for named iterated it)
  noted down in LHS yielding part (but outside yield block); limited to top-level iterateds for now

 Added support for accessing non-def variables in actions (thus in match objects) during filtering

 Allowed chains of selecting expressions (like .attr, container[key], .method(), .visited[flag]) in sequence expressions

 Extended sequence expressions by support for new operators:
 - unary minus - (computing negation of numeric type)
 - binary &, |, \  (computing intersection, union, difference on set<T> and map<S,T>)

 Added Math::sqr(double):double and Math::sqrt(double):double methods (computing square / square root) to rule language

 Added new array accumulation methods to rule language, on array<T> where T=numeric type: 
  .sum():T, .prod():T, .min():T, .max():T, (sum, product, minimum value, maximum value)
  .avg():double, .med():double, .medUnordered():double (average/mean, median, median of not ordered array)
  .var():double, .dev():double (variance, deviation)
  
 Added new array methods to rule language, on array<T> where T=numeric type or string:
  .orderDescending(), .keepOneForEach() (orders descendingly, frees of duplicates)

 Added new member of value type in array accessing methods to rule language, on array<T>, where
  T=match<r>, or T=match<r.it>, T=match<class mc>, T=node/edge class,
  and member:S is a member from the match type (pattern element/match class member), or an attribute from the node/edge type:
  .extract<member>():array<S>
  .orderDescendingBy<member>():array<T>
  .keepOneForEach<member>():array<T>
 Extended old array member of value type in array accessing methods supporting node/edge types 
  to also support the match types/match classes 

 Extended array type support in sequence expressions to capture now all array methods and operations (including new ones),
  with exception of the member of value type in array accessing methods -- from them only extract is supported
  (the targeted query matches processing is: filters for ordering or duplicate removal by member of value type, 
   followed by extract for projection, followed by the array accumulation methods to reduce to a scalar value)

 Added support for all set methods to sequence expressions,
  missing was set<T>.asArray():array<T> 
 Added support for all map methods to sequence expressions,
  missing were map<S,T>.domain():set<S>, map<S,T>.range():set<T>, map<int,T>.asArray():array<T>
 Added support for all deque methods to sequence expressions,
  missing were deque<T>.subdeque(.,.):deque<T>, deque<T>.asArray():array<T>, deque<T>.asSet():set<T>, 
  deque<T>.indexOf(.):int, deque<T>.indexOf(.,.):int, deque<T>.lastIndexOf(.):int to sequence expressions
 Added support for all copy constructor to sequence expressions,
  missing were map<S,T>(that), array<T>(that), deque<T>(that)
 Added support for string.asArray(separator:string):array<T> to sequence expressions

 Implemented eval command in GrShell that allows to evaluate a sequence expression 

 Allowed .visited[flag] as element in the chains of selecting expressions in rule language expressions

 Matches count (from performance info) now returns the number of matches found,
  instead of the number of matches left after filtering (rewrites performed tells about that)

 Removed auto keyword from rule language

 All def (to be yielded to) elements and variables (esp. container variables) are now initialized after the pattern elements 
 (and preset elements), as these may be used in the def initialization
 Ensured order of def variables is kept like in source code so initialization order is predictable

 Backtracking double angles (<<r;;s>>) define a scope now, so variables declared inside are not visible from the outside
 
 Bugfixes:
 - fix for iterated pattern yielding 
   (top-down initialization was broken, expression from nesting pattern was emitted in nested pattern; 
    and the iterateds were yielded to strictly independently, 
    with a single match getting picked from the iterated matches afterwards, 
    instead of bottom-up accumulation into the nesting pattern entity, as intended)
 - bugfixes for keepSameAsFirst, keepSameAsLast, keepOneForEach auto-generated filter functions
 - allowed entity in package with same name as global entity also if global entity comes before package entity in program code

 - bugfix for containers of match types that occur with the same match type name in a package and the global namespace
 - match type name resolving bug fix
 - fix for package resolving/checking
 - name resolving fix for variable declarations
 - fixed bugs regarding package handling of match filter functions
 - bugfix for nested named nested patterns (e.g. iterated)

 - fix for for-reachable loop in sequences
 - fix for for-matches-loop (missing type checks)
 - bugfix regarding matched event for random selection rule all calls with lower bound
 - bugfix for container expressions in exec statements
 - bugfix for container constructor appearing in initialization of pattern variable 
 - the accessed container in container expressions was not correctly checked
 
 - fixes for some sequence strings displayed in the debugger

 - added checks against double-declared auto-generated filters (and match class filters)
 - added error message when an exec is used in a forbidden context
 - added error message in case an iterated is referenced in a nested pattern
 - improved error messages when accessing an unknown member of an action match or a match class
 - an error is returned now when a non-def element is attempted to be written from an exec
 
 - plus some more bug and error message fixes

 API changes: 
 - reduced filter call object, much easier to assemble for an API user now, 
   storing only the arguments and delivering only the filter call string (used for dispatching)
 - extended meta information about filters
   (also added a representation for auto supplied filters to frontend-backend interface)
 - introduced GetMember/GetPatternElement helper functions to IMatch/IPatternGraph/IMatchClass
   to simplify by-name access to match/pattern/match class elements

 User manual adaptations to the breaking changes, addition of new content, reorganization of content

--------------------------------------------------------------------------------------------------------

v4.5.7 (2020-02-08)
 Introduced a "for function[parallelize=true];" declaration to the model
  it causes the creation of (external) (method) functions that can be called from parallelized matchers
  (and implies "node edge unique;", similar to the index declarations and "for equalsAny[parallelize=k];" with k>1;
   previously a uniqueness constraint was added to the model in case actions with the parallelize annotation were existing)
 Actions with [parallelize=k], k>1 annotations causing the creation of parallelized matchers expect a "parallelized" model now
  (i.e. functions callable from parallelized matchers) - an error is reported in case a parallelized rule/test is used 
  with a model without a parallelize (function) declaration 

 Bugfixes:
 - fixed crash on rollback of (indexed) map element assignments
 - fixed crash (because of missing names) when the debugger is running and nodes/edges are added by an add procedure
   (in contrast to the right hand side pattern of a rule)
 - fixed double quotation marks in debugger display of string literals appearing as arguments of emit and record
 - all string values written by emit/record sequence computations are unescaped now (replacing e.g. "\n" by newline, at runtime),
   instead of only single string constants (during sequence computation construction)

 User manual adaptations, corrections, and improvements

 Many code refactorings; and some API and build changes:
 - generated specific graph classes implement only a (named) graph as of now (plus creation convenience helpers), 
   instead of a graph and a model (so the model is only contained instead of implemented and contained)
 - added DEBUG define to debug builds (so that e.g. Assertions really fire)
 - added an AreFunctionsParallelized method to IGraphModel reporting the state of the parallelize (function) declaration
 - introduced a FailAssertion debug helper method into model and actions classes (it fails in debug builds with an assertion,
   this allows to directly inspect the generated model and actions files (in case of keepdebug))
 
v4.5.6 (2020-01-12)
 Extended post matches sorting filters orderAscendingBy and orderDescendingBy to support multiple variables
  e.g. orderAscendingBy<v,w> orders the matches primarily by v and secondarily by w,
  i.e in case the values of the first def variable are equal, the values of the second one decide

 Added conditional interpretation to shell scripts, of the form:
  if SequenceExpression CommandLines (else CommandLines)? endif 
 Example:
  cond = true
  if ::cond
    dump set node Node color red
  else
    dump set node Node color blue
  endif

 Added support for a validityCheck annotation:
  A node/edge annotated by validityCheck=false skips the contained-in-graph checks for that node/edge,
  which are executed in case the compiler flag (or shell option) debug (or keepdebug) is supplied,
  before a match is rewritten, esp. in between matches of an all-bracketed rule execution.
  A rule annotated by validityCheck=false skips the contained-in-graph checks for all nodes/edges in the pattern(s) of the rule.
  
 Changed the semantics of the still-contained-in-graph checking:
  An edge is only reported as invalid if the nodes incident to it are valid;
  so if a node was deleted during the rewrite of one of the matches of an all-bracketed rule,
  the rewrite of another match does not complain about a referenced edge that was incident to that node
  (this may hide bugs, but saves us from littering the code with many checkValidity annotations).

 Missing adaptations (bugfixes):
 - rule all call returns list of values, now also in case random choice is requested (e.g. $[r])
   (in interpreted and compiled sequences)
 - rule all call used from some-from-set now returns list of values (in interpreted sequences)
 - rule count all call used from some-from-set returns list of values, now also in interpreted sequences
 - added missing commands to the help of the shell (and reorganized them)

 Bugfix(es): 
 - in rule all calls in interpreted sequences: create list if untyped return variable does not contain one instead of crashing
 - the generated code was not kept when the shell option keepdebug was supplied
 - fixed bugs in sequence some from set match assignment and match number computation
 - fixed bug in printing match numbers in one-from-set version of some-from-set in debugger
   (minor fix in graph expressions)
 - avoid multiple marking of graph elements in case of a match selection error
 - custom commands of action execution environment (and derived environments) were missing 
   from the custom actions (/graph) command of the shell,
   only the custom commands of the actions (/graph) themselves were available
   (since the graph processing environment was split out of the graph)
   (adaptvariables and set_max_matches are custom actions commands (now - were previously custom graph commands))

 User manual adaptations, corrections, and improvements
 
 Removed outdated ancient ASTdapter and GrIO projects (and MonoILReader.cs),
  and their related shell commands (parse, select parser, sync io)

 Massive code restructuring; and slight API changes:
 - eleminated usage of InvocationParameterBinding classes from the Apply methods of the functions/procedures/sequences 
 - replaced Annotations enumerable/dictionary by explicit class
 - custom command listing and help description separated from execution and error reporting
 - added indexer giving access to the attributes to the graph elements
  
v4.5.5 (2019-11-18)
 Added support for dumping graphs in dot format and rendering with the graphviz programs,
  which are dot, neato, fdp, sfdp, twopi, circo
  Example: show graph dot -- executes dot to render a png image from a dot language dump, 
                              and displays it with the system image viewer
  (you have to install graphviz and have to add it to the search path for this to work)
 Added keep parameter to show graph command, causing the graph dumps to be kept
 
 Improved explain custom action: now also connectedness checks are printed
  (and unnecessary commas in conditions are omitted)
 
 Added cygwin bash compatibility mode to shell debugger
 (so you can interactively debug if really needed, although inconveniently, instead of crashing) 
 
 Fixed crash in container operations on graph element attributes in interpreted sequences

 Some user manual polishings and adaptations to the new features
 
v4.5.4 (2019-07-29)
 Several user manual corrections and improvements.
 (Binaries are the same as in 4.5.3)

v4.5.3 (2018-07-29)
 Fixed a crash in case of retyping of graph elements which have graph global variables pointing to them
 Fixed a crash when using emit in the interpreted sequences
 
 Improved debugging support/understandability with optional validity checks,
  which get emitted when the -debug option is given to grgen.
 The validity checks ensure that:
 - the rule parameters are not null (unless declared as maybe null),
   and throw an early ArgumentNullException specifying the parameter, instead of a NPE from inside the matcher
 - the graph elements handed in to a rule are really contained in the graph (in a graph to be more precise),
   and throw an early ArgumentException specifying the parameter, instead of a NPE from inside some graph modification methods
 - the graph elements in the matches handed in to the rewrite code are still contained in the graph (in a graph to be more precise),
   and throw an early Exception specifying the pattern element, instead of a NPE from inside some graph modification methods
  
v4.5.2 (2017-11-01)
 Added emitdebug command to the rule language and the sequences
  it works like emit, but can't be redirected to a file, it always prints out to the console 
  it allows to display debug messages even while building a text file with emits redirected to a file
  (also added emitheredebug, which works like emithere, but can't be redirected to a file, too)
  
 Extended export command of the GrShell (and on API level) with a nonewgraph parameter for .grs/.grsi format
  when given, the initial new graph command at file begin is omitted
  such a file cannot be imported, but only included, as it is incomplete
  you have to ensure an empty graph of correct model exists before you can include it 

 Extended export command of the GrShell (and on API level) with skip parameters for .grs/.grsi format
  they allow to exclude attributes from the node/edge attribute initializer lists
  the parameter skip/TYPE.attr causes omission of attribute "attr" from node or edge type "TYPE" during graph serialization
  this way you can get an importable graph if you intend to remove some attributes
   - otherwise import fails due to an unknown attribute getting initialized (in the file adhering to the old graph model)
  
 Improved the series of FiniteStateMachine and ProgramGraph examples

 Added new commands/parameters to the user manual
 
v4.5.1 (2017-10-15)
 Bugfixes for bitbucket #32:
  - uniqueness constraint and index are now cleared when their graph is cleared
  - copy(graph):graph is now implemented with IGraph.Clone() (also cloning the indices),
    instead of an element-wise copy from the outside (being unstable regarding indices)
  
  A few user manual polishings and fixes
  
v4.5 (2017-04-09)
 Symmetric behavior of UEdge and Edge instead of Edge primacy
  introduced IDEdge and IUEdge interface types in addition to IEdge (representing AEdge)
  the graph query functions returning a set of edges return by now:
   - set<Edge> in case the requested edge type is a directed edge,
   - set<UEdge> in case the requested edge type is an undirected edge,
   - set<AEdge> in case the requested edge type is an arbitrarily directed edge, or no edge type is specified
  
 The nodeByName, edgeByName, nodeByUnique, edgeByUnique functions support a second type parameter now:
  the node/edge returned is of the requested type in case they are employed, or null if the type does not match
  (so the type of return value of the corresponding untyped function is checked, and null is returned in case of mismatch)
 
 Added container copy constructor to rule language
  for sets: set<S>(o) with o:set<U>
  for maps: map<S,T>(o) with o:map<U,V>
  for arrays: array<S>(o) with o:array<U>
  for deques: deque<S>(o) with o:deque<U>
 A container is created and filled with the elements of the origin container,
  which must be of the same type, or in case of nodes/edges of a node/edge type,
  but not neccessarily the same -- only the elements matching the new type are carried over then

 Added set copy constructor to sequences language
  (the copy constructors of type map<.,.>/array<.>/deque<.> are not available)

 All emit procedures support multiple comma-separated parameters now
 
 Fixes for a few minor bugs

 Some user manual polishings
 
--------------------------------------------------------------------------------------------------------
 
v4.4.8 (2016-11-29)
 Bugfixes:
  - bitbucket #28: switched to the officially supported way of detecting mono
  - bitbucket #29: indices are now cleared when their graph is cleared
  
v4.4.7 (2016-09-21)
 Bugfixes:
  - bitbucket #26: code generation works now for methods of node/edge types nested within a model package,
                   even if the package is only used from a main model not contained in a package (so more general #23)
  - bitbucket #27: copying of attributes of common ancestors during retyping now also works for types nested in packages
  
v4.4.6 (2016-08-28)
 Bugfixes:
  - independents in iterateds that are matched more than once yield their correct/corresponding match object
  - bitbucket #21: the graph query functions involving edge types when the edge type is not specified explicitly
                   default to AEdge now instead of Edge - this way also undirected edges are counted
  - bitbucket #23, #25: code generation works now for methods of node/edge types nested within a model package
                        and for deferred embedded sequences appearing nested within an actions package
  - bitbucket #24: standard syntax @("name") is supported now for deferred assignments of attributes of node/edge type
                   both in the grs exporter as well as in the grs importer
  - bitbucket #20: arguments to GrShell calls going through the shell wrapper are now correctly escaped,
                   meaning spaces are supported, so the -C option of GrShell is usable now
  - bitbucket #19: fixed crash in premature signature check for method overriding
 Some user manual polishings
 
v4.4.5 (2016-02-14)
 Bugfixes:
  - bitbucket issue #15: constants of type type (given as their type name) work now in the compiled sequences
  - bitbucket issue #16: fixed implicit casts when accessing attributes of numeric types in the sequence expressions
                         by unboxing to a values of their exact type first 
  - bitbucket issue #17: method calls in sequence computations now support more than 2 arguments
  - bitbucket issue #18: container constructors used in (function or procedure) methods in the model work now

v4.4.4 (2015-11-01)
 Bugfixes / language constraint removals:
  - bitbucket #2: _external_ functions can now be called also from sequence expressions,
                  _external_ procedures can now be called also from sequence computations
  - bitbucket #12: global variable declarations and package definitions can be mixed with action definitions now,
                   previously they had to be given in the order global variables then packages then actions
  - bitbucket #3 related: writing attributes now also works for _variables_ of node/edge type
  - bitbucket #10: it is now ensured elements needed in index access expressions are available in the pattern
                   (when they are not contained/directly mentioned in the nesting pattern)
  - some further improvements/fixes in error handling

v4.4.3 (2015-10-12)
 Bugfixes:
  - bitbucket #3: typeof now also works for _variables_ of node/edge type (not the same as nodes/edges)
  - bitbucket #4: control characters are now correctly escaped in constants of expressions and yields
  - bitbucket #5, #6: fixed usage of node/edge types from a package under certain conditions (esp. in containers)
  - bitbucket #7: fixed comparison of a container with null (container type with null type)
  - bitbucket #8: reachableEdges loop now really iterates the reachable edges instead of the nodes
    related: reachableEdges and its incoming/outgoing versions now lock the root node at start,
             so each edge is visited at most twice (once for incoming/outgoing)
  - bitbucket #9: emithere, evalhere, eval don't add elements explicitly deleted to right pattern anymore,
                  just because they are mentioned in a RHS expression
    related: added semantic check that causes an error message if deleted elements are emitted
             (the emit comes after the delete, so zombie elements would be/are accessed;
              the emithere in contrast comes before the delete, so it can be used instead)

v4.4.2 (2015-09-06)
 Changed incidence count index declaration to use the counted function names
   so "countIncident" | "countIncoming" | "countOutgoing" instead of "incident" | "incoming" | "outgoing"
 Node and edge classes are generated as partial now
   so that they can be extended with own code, and thus integrated into own programs in an easier way
 Now hinting at maybe missing Java and printing search path when executing java/javaw fails
 Some user manual polishings

v4.4.1 (2015-03-26)
 Bugfixes and language construct polishings:
  - fixed grgen compiler not working under Windows 8 because of a failing ShellExecute of javaw
  - iterateds in subpatterns without a top-level/outermost modify part work now
  - local variable declarations and computation language casts support now package prefixed types
  - for loops over containers support now iteration variables of subtypes of the container type (for nodes/edges),
    an exception will be thrown if that type is not really contained (same as for loops over graph access functions)

v4.4 (2014-07-29)
 Rule all calls now return for *each* match its return values, 
  instead of the return values of an arbitrarily chosen one.
 They are returned in the form of array<T> for each return parameter of type T,
  the output arguments assigned to must be of a corresponding array type,
  this is checked at compile time (or runtime for untyped global variables).
 An all-call always returns an array for each out parameter, even if there is exactly one match,
  a normal rule always returns a scalar as before; so r : (Node, int) must be called with
  (a:array<Node>,i:array<int>)=[r] for all calls, instead of (a:Node,i:int)=r for normal calls

 Added new array methods:
  - array<T>.reverse() 
    which returns a reversed version of the array
  - array<T>.orderAscending() 
    which returns a sorted version of the array 
    (not available for arrays of graph,node,edge,container type)
  - array<T>.indexOfOrdered(.) 
    which returns the index of an occurence of the given element in the array;
    the array must be sorted, otherwise results returned by the binary search will be wrong;
    in case of multiple occurences, an arbitray one is returned.

 Added new array methods on arrays of node or edge types bearing attributes:
  - indexOfBy<attribute-name>(value [, startIndex]):int 
    returns the index of the first occurence of the attribute value in the array as seen from the begin on (or the start index)
  - lastIndexOfBy<attribute-name>(value [, startIndex]):int 
    returns the index of the first occurence of the attribute value in the array as seen from the end on (or the start index)
  - indexOfOrderedBy<attribute-name>(value [, startIndex]):int
    returns the index of an occurence of the attribute value in the array as found by a binary search
  - orderAscendingBy<attribute-name>():array<T>
    returns the array ordered ascendingly alongside the given attribute of the contained graph elements

 Added/changed several container transformation methods:
  - added set<T>.asArray() 
    which returns an array<T> filled with the content of the set (in enumeration order)
  - added array<T>.asMap() 
    which returns a map<int,T> filled with the content of the array, mapped-to by the index
  - added array<T>.asDeque() 
    which returns a deque<T> filled with the content of the array (in same order)
  - added deque<T>.asArray() 
    which returns an array<T> filled with the content of the deque (in same order)
  - added map<int,T>.asArray()
    which returns an array<T> with the content of the map,
    gaps are filled with the default value, up the maximum index available in the map
  - renamed string.explode(.) to string.asArray(.)
  - renamed array.implode(.) to array.asString(.)

 Added external methods to external attribute types:
  they are declared similar to normal functions or procedures, but with their signature only
  external class Foo {
    external function foo(int) : int;
    external procedure bar(int) : (int); 
  }
  
 Added a function to register own undo items to the transaction manager, 
  which will be called on rollback
  this allows to integrate changes to external attribute types to transaction handling.

 Added external change recording and replaying, with
  - a special command line of the grs files, starting with "external", ending with line end
  - in grs reading (by shell replay and grs import) the content in between is munched,
    and sent to a user-supplied external handler 
    void External(string line, IGraph graph)
    whose interface is emitted when the "external emit class" specification is given in the model,
    in addition to Parse, Serialize, Emit
  - support for external line writing in the recorder (to be called from external methods)
    intended for fine grain changes from method calls on external types,
    in contrast to coarse grain changes from assignments (to variables of external types)

 Added switch-case statement to rule language:
  with syntax: switch(expr) { cases },
  and cases being either: case constexpr { statements }
  or: else { statements }
  - every branch is enclosed in an block, at block end execution of the block ends,
    no implicit fall-through, a fall-through is not even available
  - only one else branch is allowed, it is hit in case no other branch was executed
  - only available for byte, short, int, long, string, boolean, enum types
  
 Added functions to retrieve the minimum and maximum numbers of the numeric types:
  - Math::byteMin(), Math::byteMax() for type byte
  - Math::shortMin(), Math::shortMax() for type short
  - Math::intMin(), Math::intMax() for type int
  - Math::longMin(), Math::longMax() for type long
  - Math::floatMin(), Math::floatMax() for type float
  - Math::doubleMin(), Math::doubleMax() for type double

 Extended array<T> and string lastIndexOf to support a second optional startIndex
 
 Improved quoted text handling in the sequences by
  - allowed escaped quotes in quoted texts
  - allowed single quoted string constants

 The grs importer is now able to import a recording
  (again, feature was lost in rewriting importer for higher performance)

 Extended profiling information to search steps occuring in evals, and in execs
 
 The debugger only listens to post attribute change events now,
  the pre attribute change events are now only used by the transaction manager and the recorder
 
 Some small and medium bugfixes

 
v4.4RC (2014-06-22)
 Grammar cleaning:
 - removed container literals without type prefix (they don't work well with other language features)
 - removed annotations for anonymous elements
 - external declarations must come with the external keyword, now mandatory
 - removed separate, non-nested pattern block in rules, deprecated since a long time
 - removed actions name declaration and keyword, deprecated since a long time
 - removed model name declaration and keyword, deprecated since a long time
 - removed usage of "->" in connection assertions, deprecated since a long time

 Further procedures modularization with builtin packages Transaction and Debug:
 - moved procedures startTransaction, pauseTranscation, resumeTransaction, 
   commitTransaction, rollbackTransaction to Transaction
 - renamed them to start, pause, resume, commit, rollback;
   sufficient as access must be qualified with "Transaction::" package prefix
 - moved procedure highlight to Debug
 - renamed File::deleteFile to File::delete and File::existsFile to File::exists

 Added index access loops to rule language statements:
 - offering the same functionality as the index access from the pattern,
   just as for loops in the yields, evals, functions, procedures
 - for(element:type in { index-name == expr })
   to iterate the elements from the index equal to the expression
 - for(element:type in { ascending(index-name [relop expr [, index-name relop expr]]) }
   to iterate ascendingly the elements from the index in between the specified bounds
 - for(element:type in { descending(index-name [relop expr [, index-name relop expr]]) }
   to iterate descendingly the elements from the index in between the specified bounds
   
 Added index access loops to sequences:
 - offering the same functionality as the index access loops from the rule language statements,
   just being a sequence and executing a sequence as body
 - for{element:type in { index-name == expr }; seq }
   to iterate the elements from the index equal to the expression
 - for{element:type in { ascending(index-name [relop expr [, index-name relop expr]]) }; seq }
   to iterate ascendingly the elements from the index in between the specified bounds
 - for{element:type in { descending(index-name [relop expr [, index-name relop expr]]) }; seq }
   to iterate descendingly the elements from the index in between the specified bounds

 Completed index support in the sequences with the sequence expression functions:
 - uniqueof(Node|Edge|graph):string, nameof(Node|Edge|graph):string
 - nodeByName(string):Node, edgeByName(string):Edge
 - nodeByUnique(string):Node, edgeByUnique(string):Edge
 Same semantics as the correspondingly named functions in the rule language.
 
 Added function equalsAny(graph, set<graph>):boolean to rule and sequence expressions:
 - returns whether the graph is isomorphic to any of the graphs in the set
   a sibling is available with equalsAnyStructurally neglecting the attributes (~~ instead of ==)
 - they are a bit more convenient than the loop,
   but most important offer a parallelized implementation
 - a "for equalsAny[parallelize=2];" in the model causes the usage of a
   parallelized version of equalsAny employing 2 worker threads (up to 64 possible)
   
 Added reachability functions that tell about the distance from the start:
 - boundedReachableWithRemainingDepth, 
 - boundedReachableWithRemainingDepthIncoming,
 - boundedReachableWithRemainingDepthOutgoing 
 yielding a map<Node,int>, that tells about the remaining depth of a search from the start node on
 (of the minimum distance path)
 
 The emit in the sequence computations now supports an arbitrary number of parameters,
  separated by commas, as supported by the emit in the rule language
  This form is to be prefered over + for string concatenation because of better performance.

 Added operators *, /, % to the sequence expressions
  for integer or floating-point multiplication, division, remainder-computation
  same semantics as their counterparts in the rule language expressions
  
 Added typeof(entity):string to the sequence expressions
  is mapping to string (not to type, there's no type type in the sequences)
 
 Added some string-related methods (in rule language expressions only):
 - string.startsWith(needle:string):string
   telling whether the string starts with the needle string
 - string.endsWith(needle:string):string
   telling whether the string ends with the needle string
 - needle in haystack
   telling whether string needle is contained in string haystack
 - string.toUpper():string
   returning the original string transformed to uppercase characters
 - string.toLower():string
   returning the original string transformed to lowercase characters
 - string.substring(startindex:int)
   returns the original string from start index on, until full length
   (overloaded version of string.substring(startindex:int, length:int) not requiring a length)
 - string.explode(separator:string):array<string>
   returns the original string exploded to an array of substrings at the separators,
   the separators are not included, if separator is empty, you get the original string
   exploded to an array of single-character strings
 
 Added some array/deque-related methods:
 - added array<string>.implode(separator:string):string
   returns the original array imploded to a string with the separator in between the substrings
 - added array<T>.asSet():set<T>
   returning the array content as set
 - added deque<T>.asSet():set<T> methods 
   returning the deque content as set
 - extended array<T>.indexOf(needle:T, startIndex:int) 
   to support an optional second startIndex parameter, to start the search at
 - extended deque<T>.indexOf(needle:T, startIndex:int) 
   to support an optional second startIndex parameter, to start the search at

 Added subrule debugging support with new procedures and debug trace events,
  to allow debugging of functions and procedures, and improve debugging of embedded execs:
 
 New procedures in rule language as well as sequence computations:
 - added Debug::add(message:string, params:object*) procedure,
   allows to communicate a computation entry to the debugger, from user code
 - added Debug::rem(message:string, params:object*) procedure ,
   allows to communicate a computation exit to the debugger, from user code
 - added Debug::emit(message:string, params:object*) procedure,
   allows to report a debug trace to the debugger, from user code
 - added Debug::halt(message:string, params:object*) procedure,
   allows to halt execution in the debugger, reporting a debug trace, from user code
 - changed/added Debug::highlight(message:string, (param:object, annotation:string)*) procedure,
   allows to halt execution in the debugger and highlight the parameters in the graph, 
   with the given annotations; this replaces the old highlight from sequences,
   and extends the rule version with the mandatory message string
   e.g. Debug::highlight("foo", x, "x", stor, x.str, 0, "visited flag 0") 
   highlights with the message/event/action "foo" in the graph
   - the node x with the annotation "x"
   - all nodes from stor:set<Node> with the string found in x.str
   - all nodes marked with visited flag 0 with "visited flag 0"

 Those procedures fire in the graph processing environment the events:
 - OnDebugEnter
 - OnDebugExit
 - OnDebugEmit
 - OnDebugHalt
 - OnDebugHighlight
 
 The debugger listens to the events, updating its knowledge of the computations currently carried out,
  and halting on the latter two commands, visually showing the graphs elements in case of the highlight.
 To this end it stores the computations entered and not yet left again on a stack.
  (As well as the debug emits that occured up to that point until their frame is left again.)

 The code generated by the compiler automatically fires add(=entry) and rem(=exit) events 
  for embedded sequences, including the sequence body as string parameter;
  and for compiled sequences and procedures, including the input and output values.

 Utilizing them, during detail mode debugging, the debugger shows the embedded sequence executed,
  or the compiled sequence calls, or the procedure calls, as context for the rules;
  the same holds when a halt or highlight is hit.

 The "dum(p) graph" of the debugger now writes an undo.log in addition to the graph dump
  in case a transaction is pending, with the contents of the undo log of the transaction manager
  (i.e. the commands to reverse the changes that occured, not the changes themselves)
  
 Added watchpoint / subrule debugging support and configuration rules to the shell/debugger.
 They can be edited interactively, or preconfigured with the following rules.
 - The rules allow to configure the behaviour of the debugger (break/continue)
   when a subrule debugging or graph change or action match event occurs.
 - For this the debugger stores a list of configuration rules,
   which are executed one after the other in case a debugging event occurs,
   in case they match their decision is applied, influencing debugging.

 The subrule debugging events configuration rules are:
 - "on" "add" <messageFilter> "break"
 - "on" "rem" <messageFilter> "break"
 - "on" "emit" <messageFilter> "break"
 - "on" "halt" <messageFilter> "continue"
 - "on" "highlight" <messageFilter> "continue"
 with messageFilter ::= ("equals"|"startsWith"|"endsWith"|"contains") "(" string ")"
 The string specified must match the message of the event with the mode given.
 The rules tell the debugger to break execution when a subrule is entered/exited/emitted,
 which normally occurs silently, is only defining the context for the breaking operations,
 which are halt/highlight, they can be configured to be skipped, not breaking execution.

 The action match event configuration rules are:
 - "on" "match" actionname "break"|"continue" ("if" <sequence-expression>)?
 The rules tell the debugger to break execution when an action is matched,
 which is of interest for actions executed from execs,
 as normal breakpoints don't apply to them,
 or to continue execution when an action is matched,
 which allows to leave out uninteresting actions from detail mode debugging,
 skip over actions in execs without the need to acknowledge them.
 The sequence-expression allows to do this conditionally,
 the "this" entity is overloaded in this context to give access to the match,
 the rule is executed for all matches, if one fires, the decision is carried out.

 The graph change event configuration rules are:
 - "on" "new" ( ("only")? Type | "@" "(" Name ")" ) "break"  ("if" <sequence-expression>)?
 - "on" "delete" ( ("only")? Type | "@" "(" Name ")" ) "break"  ("if" <sequence-expression>)?
 - "on" "retype" ( ("only")? Type | "@" "(" Name ")" ) "break"  ("if" <sequence-expression>)?
 - "on " "set" "attributes" ( ("only")? Type | "@" "(" Name ")" ) "break" ("if" <sequence-expression>)?
 The rules tell the debugger to break execution when a graph element is created,
 or deleted, or retyped, or one of its attributes is assigned.
 The first form does so when the element is of the specified type,
 in case of "only" if it is of exactly that type and not a subtype.
 The second form does so when the element is of the specified name (static string).
 The sequence-expression allows to do this conditionally,
 the "this" entity is overloaded in this context to give access to the node/edge 
 that is created/deleted/retyped/assigned-to.
 (So here we find support for conditional data breakpoints/watchpoints.)
   
 Added attribute post-change event(s):
 - fired after the attribute was changed, meant for debugging,
   telling only about the owning element and the attribute;
   the attribute is to be read by the code listening to the event
   much simpler than reacting to the detailed change type
 - complements the pre-change event that is meant for graph processing,
   esp. transaction rollback, and that tells about the detailed change
   (a container element change must be handled as a single element change,
   as processing an entire container would be prohibitively wasteful)

 Changed compiler switches for event firing configuration to:
 - events in general, with mostly attribute change events as base (like before)
 - events for debugging on top of it, mostly action match events,
   but also the new post-change-event
 The compiler switch for inlining prevention now includes independent inlining.
   
 Added support for rendering external types as graphs in the debugger:
 - this allows to inspect opaque-to-GrGen external types in yComp as graphs
 - must be declared with "external emit graph class;" in the model
 - implemented by calling INamedGraph AsGraph(object attribute, AttributeType attrType, IGraph graph),
   which is forwarding to a AsGraphImpl,
   to be supplied by the user in the external attribute types implementation file
 - employed in the debugger with the new "as (g)raph" command

 Added "recordflush" to shell commands to flush the graph change recorder streams.
 Finally removed the outdated "grs" shell command.

 Improved code structure by adding a new SubactionAndOutputAdditionEnvironment,
  in between the ActionExecutionEnvironment and the GraphProcessingEnvironment.
  It enriches the former with subaction debugging, subgraph nesting, and output 
  (textual emit plus graph change recording).
  The latter then adds sequence-, variable-, and transaction-handling.
 
 Bugfixes:
 - fixed graph switch introduced with nested graph support, the names were wrong in the debugger.
 - fixed code generation bugs regarding container method usage from emit, and double constants.
 - fixed name/attribute initialization list at a first anonymous node (missing in grammer).
 - some smaller other bugfixes.


v4.3bms2 (2014-04-30)
 Added bounded-reachable functions for depth-limited reachability computations:
 - boundedReachable, boundedReachableIncoming, boundedReachableOutgoing
   with max. parameters (startNode:Node, depth:int, incidentEdgeType:EdgeType, adjacentNodeType:NodeType)
   returning set<Node> filled with nodes reachable within given depth
 - boundedReachableEdges, boundedReachableEdgesIncoming, boundedReachableEdgesOutgoing
   with max. parameters (startNode:Node, depth:int, incidentEdgeType:EdgeType, adjacentNodeType:NodeType)
   returning set<Edge> filled with edges reachable within given depth
 - isBoundedReachable, isBoundedReachableIncoming, isBoundedReachableOutgoing
   with parameters (startNode, endNode:Node, depth, incidentEdgeType, adjacentNodeType)
   returning boolean value, true iff end node is reachable from start node within given depth
 - isBoundedReachableEdges, isBoundedReachableEdgesIncoming, isBoundedReachableEdgesOutgoing
   with parameters (startNode, endEdge:Edge, depth, incidentEdgeType, adjacentNodeType)
   returning boolean value, true iff end edge is reachable from start node within given depth

 Added corresponding loops (rule language statements only for now):
 - for(. in boundedReachable|boundedReachableIncoming|boundedReachableOutgoing)
   iterates the nodes instead of filling a set
 - for(. in boundedReachableEdges|boundedReachableEdgesIncoming|boundedReachableEdgesOutgoing)
   iterates the edges instead of filling a set
 
 Added countXXX functions for all available graph query functions:
 - they return the size of the set that would be yielded by the function without count, supported are:
   - countNodes, countEdges,
   - countAdjacentOutgoing, countAdjacentIncoming, countAdjacent
   - countOutgoing, countIncoming, countIncident
   - countReachableOutgoing, countReachableIncoming, countReachable
   - countReachableEdgesOutgoing, countReachableEdgesIncoming, countReachableEdges
   - countBoundedReachableOutgoing, countBoundedReachableIncoming, countBoundedReachable
   - countBoundedReachableEdgesOutgoing, countBoundedReachableEdgesIncoming, countBoundedReachableEdges
 - more convenient than using .size() on the set, commonly with better performance, too
 
 Added for loop iterating over an integer range:
 - in rule language: "for" "(" var "in" "[" left ":" right "]" ")" "{" body "}"
 - in sequences: "for" "{" var "in" "[" left ":" right "]" ";" body "}"
   first left and right are evaluated,
   if left <= right var is incremented from left on in steps of one until right is reached (inclusive),
   if left > right var is decremented from left on in steps of one until right is reached (inclusive),
   the body is executed with var assigned for every value in between left and right

 Added new auto-supplied filters for removing, complementary to the keeping filters already available:
 - removeFirst(k:int) removes the first k entries from matches list
 - removeLast(k:int) removes the last k entries from matches list
 - removeFirstFraction(f:double) removes the first fraction f of entries from matches list
 - removeLastFraction(f:double) removes the last fraction f of entries from matches list

 Diverse:
 - Extended copy function to containers (from graph and match already supported),
   as remedy for the problem that containers iterated over must stay unchanged
 - Added <,<=,>,>= for type string to the rule language expressions
   comparing alongside lexicographic order with InvariantCulture
 - Extended indexOf method on strings with an optional start index:
   s.indexOf("question", 42) will return the first occurence of "question" in s from index 42 on,
   but no previous occurence
 - Floating point serialization, to-string-casting, and parsing with InvariantCulture now
   to get everywhere the same results
 - Added parameterless functions Math::pi() and Math::e() returning their corresponding constants

 Performance Improvements:
 - Optimized Performance with independent inlining
   - gives match planning more material to work with, leading to improved matchers,
     in case the pattern was disconnected before it yields high speedups
   - at the cost of local post-matches filtering
     for already found matches modulo the inlined part
 - Optimized automorphy filters (typically a reduction of O(n*n) to O(n))

 Considerable extensions of profiling information instrumentation:
  All graph element accesses now count up the search steps,
  i.e. graph query expressions and statements, too,
  instead of only the candidate variable bindings during pattern matching

 GrShell:
 - Extended "new graph" command by a "new new graph" version,
   which ensures that things are generated even if the sources did not change
   - this is needed if only the statistics file or the profiling flag were changed,
     without a rebuild you would get misguided by the use of the old assemblies
 - Improved the output of the explain command 
 - The import command now supports a line break with ";;", too
 - "-C" is still only of limited use, as bash splits the command given inside "" alongside spaces
   -> "here documents" piping script parts to stdin are the medium of choice for automatization
 
 Set heap size for yComp to java maximum (640MB)

 GRS import/export now supports escaped \ and " with \\ and \" in attribute initialization strings

 Added MovieDatabase case from TTC2014 to examples
 
 Bugfixes:
 - bugfix for dump add graph exclude command, the context of the match(es) is now really added
 - exec contained in nesting statement inside eval works now
 - fixed code generation bug on for loop over map with only key, without value
 - fixed code generation bug on remove from untyped array/deque
 - fixed div by zero in graph statistics loading
 - fixed bugs related to profiling
 - bugfix regarding inlining of conditions
 - fixed (and optimized) set/map intersection
 - fixed incidence count index takeover in case of graph cloning
 - fixed bug regarding containers with a constant constructor


v4.3beta (2014-03-24)
 Implemented attribute indices:
 - declared in the model with syntax 
   "index" name "{" Type"."attribute "}"
   to specify the type and attribute whose values are to be indexed with a binary search tree,
   so that an O(log(n)) lookup of graph elements based on the index value is possible,
   (and an O(1) access of following elements)
   instead of an O(n)-traversal of all graph elements with post-filtering based on the attribute value
 - used in the pattern with syntax 
   elem":"ElemType "{" name "==" valueExpr "}"
   to bind the pattern element in succession to all elements with an attribute value equalling the value
   or a directed index access suffix behind the pattenr element declaration
   "{" direction "(" [ name relop valueExpr ["," name relop valueExpr] ] ")" "}"
   with direction ::= "ascending" | "descending" and relop ::= "<", "<=", ">", ">="  
   to bind the pattern element in succession to all elements from max to min element, or min to max element,
   where min and max are the lowest and highest attribute values if not specified otherwise,
   or the lowest or highest value as given with a single bound specification,
   or the lowest and highest value as given with a double bound specification
 - for this index as for the incidence count and the unique index holds:
   they give very quick access, but must be maintained on element addition or removal to the graph,
   switching them from an O(1) to an O(log(n)) operation -> use them selectively
 
 Implemented incidence count indices:
 - they store nodes ordered alongside their number of incident edges,
   and allow to access them quickly in that order
 - declared in the model with syntax 
   "index" name "{" direction "(" NodeType ["," EdgeType ["," NodeType]] ")" "}"
   with direction ::= "incident" | "incoming" | "outgoing"
   the first mandatory parameter specifies for what node types the index information is to be stored,
   the optional second parameter allows to further constrain the incident edge types,
   the third optional parameter allows to further constrain the adjacent node types,
   only node-edge-node triples satisfying the type constraints are counted
 - used in the pattern with the syntax already known from attribute indizes
   i.e. { indexname==value }, { ascending(indexname...) }, { descending(indexname...) }
 - the count may be further queried from the rule language expressions,
   with syntax: indexname "[" node-expr "]", expecting a node, returning an int,
   the return value is the number of incident edges for the node, as stored in the index

 Added support for unique integer ids for graph elements:
 - declared in the model with "node edge unique;"
 - the unique id can be retrieved in the expressions of the rule language (in O(1))
   with the function uniqueof(graphelement):int
 - uniqueof() may be used on (sub)graphs, too, returning the unique identifier of the graph;
   for a (sub)graph argument, or zero arguments, which amounts to the host graph
 The unique integer ids are graph to id only, they may be completed to an unique index:
 - declared in the model with "index unique;"
 - it allows to access graph elements in the pattern by their unique id (in O(1)), with syntax
   elem":"ElemType "{" "unique" "[" int-expr "]" "}"
   in contrast to attribute and incidence indices, the lookup will yield at most one element
 - the unique index may be further queried from the rule language expressions,
   with the functions nodeByUnique(int):Node or edgeByUnique(int):Edge

 Extended support for the name index, as implemented by named graphs:
 - graph elements may be accessed in the pattern by their unique name (in O(1)), with syntax
   elem":"ElemType "{" "@""(" string-expr ")" "}"
   the lookup will yield at most one element, as for unique indices
 - the name index may be further queried from the rule language expressions,
   with the functions nodeByName(string):Node or edgeByName(string):Edge
 - in contrast to the unique ids that are auto-assigned and cannot be changed,
   the name may be re-assigned by the user, it only must be ensured it is not already in use,
   with a nameof assignment available in the rule language, with syntax
   "nameof" "(" elem ")" "=" string-expr
 - the same syntax may be used to assign the name of a (sub)graph, a missing elem amounts to the host graph
 
 Implemented matcher parallelization:
 - a rule or test annotated with a [parallelize=k] will be matched with k worker threads from a thread pool
   more exactly: at most k worker threads, clipped by the number of available processors,
   on a single core the sequential matcher will be used
 - work is split alongside the first loop binding a pattern element to a candidate graph element,
   if that branches only once nothing is gained,
   if each branch only executes very few search work following candidate assignment,
   things just become slower because of threading and locking overhead;
   you better profile before deciding what matchers to parallelize
  
 Profiling: 
 - increased accuracy of execution time calculation
 - added "-profile" command line option to GrGen to enable generation of profiling information,
   counting the bindings of host graph elements to pattern elements (search steps) carried out during the search
 - added "set profile on" shell command, maps to -profile compiler option
 - if on, the number of search steps executed are printed out in the shell after sequence execution
 - further, more detailed per-action profiles can be displayed on demand in the shell
   with "show" "profiles" [ actionname ]
   for the action whose name is specified, or all actions

 Added builtin packages Math, File, Time to structure builtin functions/procedures:
 - moved functions min, max, sin, cos, tan, arcsin, arccos, arctan, pow, log, abs to package Math
 - added new functions ceil, floor, round, truncate and sgn, to package Math
   all expecting one parameter of type double, returning a value of type double
   semantics as what can be expected by the names
 - moved export, deleteFile procedures to package File
   moved existsFile, import functions to package File
 - added new function now() for retrieving a timestamp, to package Time
   no parameters, returns the current UTC time as long,
   given as windows file time (i.e. 100ns ticks since 1601-01-01)
 - the File and Time functions/procedures are available in the sequence computations, too
   whereas the Math functions are only available in the rule language expressions
 - the global versions of the functions/procedures moved don't work any more!
   the functions/procedures have to be accessed in known package notation,
   e.g. Math::sin(x), Time::now(), File::existsFile("filename.grs")

 Name/attribute initialization:
 - a name or attribute initialization can be given at a node or edge creation now,
   with a syntax similar to the grs, 
   "$" "=" string-expr for name initialization, and
   attribute-name "=" expr for attribute initialization, 
   with expr being of the type of the attribute;
   attached with "@" "(" ... ")" to a node or edge declaration in a modify or replace part
 - example: n:N@($="foo", intAttr = 42);
   
 API:
 - IActions, ISequenceDefinition, IFunctionDefinition, IProcedureDefinition 
   define the actions interface of the API, now
 - extended graph element interface by GetUniqueId():int function,
   to retrieve the unique id for a graph element
 - extended graph interface by GetGraphElement(int unique)
   to retrieve the graph element for a unique id, only implemented in case of a unique index
 - added IndexSet and Index interfaces to the graph

 Misc.:
 - Includes are now interpreted (first) relative to the including file
 - Removed "-noperfinfo" command line option
 - Manual: Split performance optimization into own chapter, combined with indices
 - some bugfixes carried out, esp:
   - embedded sequences now call the latest dynamically generated matcher, too
   - fixes subpattern using a subpattern with dangling edges
	
--------------------------------------------------------------------------------------------------------
	
v4.2 (2014-01-12)
 Added packages to the model:
  - declared with package <pname> { <stuff> }
    (stuff are node type declarations, edge type declarations, enum declarations)
  - the stuff inside can be used with <pname>::name
    (the pname prefix is mandatory outside of the very package)
    so an enum value from a package must be referenced by <pname>::<enumname>::<enumvalue>

 Added packages to the actions:
  - declared with package <pname> { <stuff> }
    (stuff are subpattern declarations, rule/test declarations, filter function declarations,
     sequence declarations, function declarations, procedure declarations)
  - the stuff inside can be used with <pname>::name
    (the pname prefix is mandatory outside of the very package)

 Adapted the ecore/XMI importer to model package,
  it now maps packages to GrGen packages, instead of name mangling
  (but still all names are prefixed with an underscore to prevent keyword-name clashes)

 Added XMI exporter (assuming the model stems from a previous ecore/XMI import)
 
 Fixed bugs in grs export regarding graph elements used as attributes
 Fixed bugs in grs import regarding (attribute) names containing underscores
 Some smaller improvements in user manual
  
v4.2beta (2013-12-15)
 Added path-based model inclusion statement #using "<path>" as new default:
  - it allows to reference a model file by a full path, so models can be organized in directories
  - in exchange it only allows for one model file per statement, similar to #include
 
 Added user-defined post-match filter functions to the rule language:
  - complementing the auto-generated and auto-supplied filters (or the external filter functions)
  - filter foo<bar>(params) { eval-stmt } specifies filter function foo for rule bar
   - within filter, "this" allows to access the matches, as this:array<match<bar>>
   - the this-matches-array can be iterated over,
     an array entry comprising a match can be read and written by index,
     a match entity can be read and written with member access notation (in the rule language, with correct types),
      (in combination with an index lookup it can be only read, 
 	  writing requires an intermediate assignment to a variable tmp:match<bar>)
     matches can be added to the array, matches can be removed from the array,
     a high-performance way of removing is assigning null to a matches array index
   - the copy function can be used now on matches, too,
      this allows to insert new matches derived from clones of old matches to the matches array
   - for external filter functions syntax is now: external filter foo<bar>(params);

 Added new global functions and procedures:
  - empty():boolean returns whether the graph is empty, i.e. contains no nodes and edges
  - size():int returns the number of elements (nodes plus edges) in the graph
  - existsFile(path:string):boolean returns whether the path exists
  - deleteFile(path:string) deletes the path given
  
 Added numerous examples for the more recent parts of the languages to the user manual
 
 Several bugs fixed

--------------------------------------------------------------------------------------------------------

v4.1.0 (2013-09-07)
 Methods are now supported (user-defined, in contrast to some built-in methods already available before): 
  - methods are declared in the model as functions or procedures nested inside node or edge classes
  - a "this" node or edge is declared implicitely inside the method functions or procedures
    to access the members or call the methods of the element (needed for dot notation)
  - method calls occur in dot notation, with an expression or variable or the "this" element before the dot,
    denoting the element to apply the method on; otherwise they look like a function or procedure call;
    it is not possible inside a method to access elements or methods of the class without dot notation
  - procedure methods are callable from rule language statements and sequence computations
  - function methods are callable from rule language expressions and sequence expressions
  - dynamic dispatch: the implementation of the exact type of the current element is called,
    irrespective of the statically known base type of the pattern element or variable
  - if a method name comes in from different parents, the method must be overriden in the joining class
    (GrGen supports multiple inheritance, forming a DAG-structured inheritance relationship)
  - a method name that comes in from only one parent can be kept unimplemented,
	the nearest implementation in the inheritance hierarchy is then used

 Supporting methods required changes regarding the sequence computations:
  - sequence expressions used as sequence computations must be enclosed in braces from now on,
    so in sequence "if { {{def(x)}}; ... }" all opening braces are required,
	the second "{" is for opening a computation, and the third "{" is for opening an expression
  - chained method calls are not possible any more

 Changes to improve readability:
  - external entities must be prefixed with an "external" keyword at their declaration
  - sequence expressions used as sequence computations must be enclosed in braces from now on,
    so the only computation that returns a value is visually differentiated from the other computations
 
 The support for filtering of the matches list (of rule all calls) was extended considerably:
 - allowed multiple chained filters per rule application with syntax r\f1\f2\...
 - added new def var based filters, they must be specified beforehand, as code is generated for them,
   available for def vars of the pattern, of integer, floating point, and string type:
   - orderAscendingBy<var> for ordering the matches list ascendingly alongside the def var
   - orderDescendingBy<var> for ordering the matches list descendingly alongside the def var
   - groupBy<var> for ensuring matches of equal def var values are neighbours 
     or only separated by matches of equal def var values, in the matches list
   - keepSameAsFirst<var> for filtering away all matches of def var values not equal 
     to the def var value of the first match
   - keepSameAsLast<var> for filtering away all matches of def var values not equal 
     to the def var value of the last match
   - keepOneForEach<var> for filtering away all matches of duplicate def var values, 
     i.e. only one prototypical match is kept per def var value in the matches list
 - added new pre-implemented filters (callable without a filter declaration at the rule declaration):
   - keepFirst(count) for keeping the first count matches, at the begin of the matches list
   - keepLast(count) for keeping the last count matches, at the end of the matches list
   - keepFirstFraction(fraction) for keeping the fraction of the matches specified (0.0 - 1.0),
     from the begin of the matches list
   - keepLastFraction(fraction) for keeping the fractin of the matches specified (0.0 - 1.0),
     from the end of the matches list

 Bugfixes:
  - fixed bug in set/map add in yielding statements
  - referenced assemblies are now included when building the actions, too
  - the external action files are now expected and generated where the rules reside, too
  - some minor improvements / fixes (e.g. error messages and error checks)

--------------------------------------------------------------------------------------------------------

v4.0.1 (2013-08-12)
 More consistent and easier readable function/procedure definitions:
 - function or external function declarations must start with the "function" keyword now
 - procedure or external procedure declarations must start with the "procedure" keyword now

 Bugfixes:
 - completed support for the for(x:T in nodes(S)/edges(S)) loop,
   esp. handling of S != T, missing support for for-function loops in the debugger 
 - fixed bug regarding function calls in execs in the rules
 - fixed bug regarding omission of execution of yielding statements
   when only ref containers are used

v4.0 (2013-07-29)
 Subgraph support regarding built-in functionality completed:
 - The debugger now listens to graph switch events,
   prints out notifications on a switch and changes display to the new graph focused
 - GRS export and import are now capable of serializing and parsing nested graphs
   i.e. attributes which contain/reference subgraphs are now saved and restored again
   - subgraphs are introduced with an "add new graph <graphname>" command
   - with an "in <graphname>" command the current graph is set for the following commands
   - the exporter renames the graphs if needed to enforce unique names
 - The recorder is now able to record subgraph changes
   exporting subgraphs (transitively) on first sight, renaming them as needed
 - GrShell is now able to process the
   "add new graph <graphname>" command to create a subgraph, and the
   "in <graphname>" command to switch the current (sub)graph to the graph given
   assignments to subgraph typed attributes
   - thus the shell can import GRS exported or recorded graphs including subgraphs now
   - support limited to level 2 (main host graph plus one subgraph) in contrast to the sequences,
     more would not be helpful in the shell
 - Extended graph isomorphy checking to attributes of graph type, comparing them for isomorphy, too
    generalizing equality comparison from flat to nested graphs
 - Extended transaction handling to cover subgraph switches
    switching processing to a subgraph and returning processing from a subgraph (as reported by events)
    is recorded to the undo log now in case a transaction is underway,
    so the graph change effects are rolled back on the graph that was really changed
   -> transactions now cover changes in any of the processed graphs/contained subgraphs

 Added operations for working with subgraphs, and closed some gaps in node/edge operations:
 - In sequence expressions and rule expressions are now available:
    import(filepath:string) : graph   - for importing a graph stored in a file as subgraph 
                                        (the main graph is not replaced)
    copy(original:graph) : graph   - for creating a clone of an original subgraph
    nameof() : string   - for retrieving the name of the current host graph
    nameof(entity:node or edge or graph) : string   - for retrieving the name 
                                                      of a node or edge or subgraph
 - In sequence computations and rule statements are now available:
    addCopy(original:node) : (node)   - for adding a clone of the original node to the current graph
    addCopy(original:edge, src:node, tgt:node) : (edge)   - for adding a clone of the original edge 
                                                            to the current graph
    insert(original:graph)   - for inserting a subgraph to the current host graph,
      i.e. computing a disjoint union of the nodes and edges; 
      the original graph is destroyed by this (move semantics)
    insertCopy(original:graph,root:node) : (clone:node)   - for inserting a clone
      of the original subgraph to the current host graph
      i.e. computing a disjoint union of the nodes and edges; the original subgraph stays untouched
    merge(target:node, other:node)   - for merging the other node into the target node
    redirectSource(edge:edge, newsrc:node)   - for redirecting the edge to the new source
    redirectTarget(edge:edge, newtgt:node)   - for redirecting the edge to the new target
    redirectSourceAndTarget(edge:edge, newsrc:node, newtgt:node)   - for redirecting the edge 
                                                                     to the new source and new target
    export(filepath:string)   - for exporting the current host graph to a file with the given path
    export(graph:graph, filepath:string)   - for exporting the given subgraph to a file 
                                             with the given path
 - In sequence expressions and rule expressions is now available:
    this expression, used as a readonly variable of type graph, for accessing the current graph 
	(by default the host graph, or the most current subgraph switched to)	
 - The sequence in graph { seq } was extended to allow to relocate to a subgraph attribute,
    with syntax in element.attr { seq } (attr must be an attribute of type graph contained in element)
 
 Replaced for(x:T) graph lookup loop by for(x:T in nodes(T)) or for(x:T in edges(T)) 

 The functions returning a set of graph elements now yield always set<Node> or set<Edge>,
  irrespective of the concrete type queried.

 Variables can now be declared in a return assignment of a procedure call in the rule statements,
  e.g. (def var visID:int)=valloc()

 Added count operator to sequences and rules
 - to all-rule calls in sequences: count[r]=>c assigns the count of matches of r to the variable c,
   and applies r on all the matches
   with count[?r]=>c the matches are only counted, no rewrites are carried out
 - to expressions in rule language: count(it) returns the amount of iterated pattern instances found
   can only be used in yield or eval block (not in if), on named iterateds
   
 Added graph statistics serialization and parsing
 - added "custom graph statistics save <filepath>" shell command
   to write the statistics of the last analyze to the given statistics file
 - added "-statistics <filepath>" option to grgen compiler command line parameters
   to read the given statistics file and build matchers optimized for a graph of those statistics
 - added "new set statistics <filepath>" command to GrShell
   which does the same as calling the grgen compiler with "-statistics <filepath>"
   whenever a new graph command is executed with an action filename given,
   causing a compilation of the actions (thus creating matchers adapted to the statistics)

 Extended transaction handling to cover visited flags
  visited flag writing, allocation, and freeing (as reported by events)
  are now recorded to the undo log and undone on rollback
  (by overwriting with the old value, (reserved) freeing, and reallocation)
  -> transactions now cover visited flag changes in addition to topology and attributation changes

 The user can define compare and copy functions for external objects (plus type object) now
 - they allow to compare attribute types not known to GrGen, during graph isomorphy checking,
   and in the expressions of the rule language and the sequences
   (with value semantics, instead of only checking for identical references)
 - and to copy values of types not known to GrGen, in the copy commands
   (with value semantics, instead of only copying the references, making objects identical)
 - == and != in the expressions of the rule language and the sequences, as well as graph isomorphy checking,
   are overwritten if "== class;" is specified in the model, to use IsEqual
 - <,<=,>,>= in the expressions of the rule language and the sequences 
   are overwritten if "< class;" (requiring "== class;") is specified in the model, to use IsLower (and IsEqual)
 - copy and addCopy in the patterns of the rule language and the procedures of the rule language and the sequences
   are overwritten if "copy class;" is specified in the model, to use Copy
 - they need to be implemented by the user in the external types and functions implementation file

 The user defined parser for attributes of object or user defined type is used from GrShell now, too
  insofar as possible, shell parses a single or double quoted text or a word or a number
  and hands that over then to the user defined parser

 Model generalization: 
 - allowed attributes of node or edge type,
   and allowed attributes of node/edge or container of node/edge type, 
   to reference subtypes of the type they are contained in
 - multiple using statements may now be given in a rule file, 
   as well as in a model file -- so transitive using is supported by now

 The compiler driver checking if a recompilation is needed now takes into account:
 - whether an external functions implementation file of the model is newer than the compiled binaries
 - whether an external functions implementation file of the actions is newer than the compiled binaries
 - whether the graph statistics file to be used for generating the actions is newer than the compiled binaries
 - whether nested or multiple used model files are newer than the compiled binaries
 
 API additions/changes:
 - external function calls receive the action environment and the graph as first parameters by now
   so the processing environment is directly available, without the need for static variables manually filled
   same as for the external procedure calls, and a better fit to potential subgraph switches
 - added events for visited flag assignment and allocation/freeing
 - added convenience method for fetching the current graph as named graph
   to the graph processing environment (returning null if it is in fact no named graph)
 - allowed to set the name of a graph and to get the backend
 - graph statistics code is now located in own class LGSPGraphStatistics
 - the available external types are now given in the XGraphModel

 Fixes:
 - fixed bug in visited flag handling 
   that showed in case the amount of graph element based visited flags was exhausted
 - fixed neglectance of containers of subgraphs in grs exporter
 - fixed bug with == and ~~, only the operator used first was applied for a graph,
   irrespective of the operator really requested
 - fixed bugs in compiled sequence regarding: in graph { sequence }, graph.rule(), 
    copy(subgraph), and the ==, !=, ~~ operators
 - fixed performance bug regarding graph comparisons with changes counter not written correctly
 - fixed for function loops and some set returning functions
 - fixed assignments in evals/yields
 - some more just forgotten

 Some improvements in the user manual:
 - reduced the sequence computations chapter to a diff 
   against the graph type chapter and the container type chapter
 - added section on Graph Nesting and Graph Oriented Programming
 - revised the Introduction and the Overview
 - multiple improvements in various other sections

 
v4.0alpha3 (2013-05-05)
 Replaced the CSharpCC generated parser/lexer for grs import by a hand written one
   yielding a speedup of 5x (esp. no LookaheadSuccess exceptions any more) for M$ .NET
   and allowing to extend the grs importer by user defined functions, enabling:

 The user can defined parse, serialize and emit functions for external objects now
   they allow to grs export and import types not known to GrGen,
   and to emit values of types not known to GrGen, esp. in the debugger (incl. yComp)
  - they are emitted if "emit class;" is specified in the model,
    and need to be implemented by the user in the external types and functions implementation file
  - the model interface makes the new functions parse/serialize/emit for object types available,
    with a dummy implementation forcing objects to null in case "emit class;" is not specified
  - extended AttributeType with the .NET type, 
    so it's possible for kind object to determine the real type of the attribute

 It's now possible to match and rewrite in subgraphs
  - made available by adding support for switching the current graph to a subgraph
  - in the sequences with an execute sequence in subgraph block ("in" subgraph-var "{" sequence "}"),
  - or with rule, rule all and sequence calls in method call notation on a subgraph variable 
    (e.g. (v)=sg.r(v) on "sg:graph=inducedSubgraph(adjacent(node))")
    giving rise to graph based programming on nested graphs
    promoting subgraphs to a noteworthy language and data structuring construct
  - data is strongly encapsulated by this hierarchical graph abstraction,
    the contents of the graphs are hidden from each other,
    information can only be shared or exchanged by rules/sequence calls
    operating on the different subgraphs, with the aforementioned change-focus facilities
  - this is in contrast to defining "contains" edges to build hierarchical data structures 
    in an otherwise flat graph
  - and similar to object-based programming with its data hiding, supporting programming-in-the-large
   
 Global var declarations changed to resemble local var or parameter declarations 
   i.e. ref for containers, var for non-node/edge variables,
   instead of only always ref, which maybe fits better to semantics but is unintuitive
 
 - Added castability of all external types to type object
 - Added arcsin, arccos, arctan functions to complement sin, cos, tan
 - Some smaller bugfixes and polishings,
   esp. copying of external attributes interface files to parent folder is working now

   
v4.0alpha2 (2013-04-21)
 Split computation abstraction into functions and procedures
   Functions are not allowed to manipulate the graph, and return exactly one result.
   Procedures may manipulate the graph, and can return 0-k results.
   (Computations are the general concept, split into side-effect-free ones and the others.)
 - You may declare functions with syntax
   name(parameters) : return-type { statements }
 - And procedures with syntax
   name(parameters) : (return parameters) { statements }
 - The declared functions can be used from rule language expressions and from sequence expressions
   with syntax name(arguments), yielding the computed value.
 - The declared procedures can be used from rule language evaluations and from sequence computations
   with syntax (out-variables) = name(arguments), assigning the output values to the out-variables,
   (i.e. similar to rule calls in the sequence);   
   or just name(arguments), throwing away output values 
   (in case there are some, a procedure may be declared without output parameters)
 - Generalized return statements to versions with 0 - k return values to be used for computations
 
 The previously built-in special side-effect-functions
  add, retype, insertInduced, insertDefined, valloc, startTransaction
  are _only_ available as procedure calls from now on, as well as to the old "procedures"
  emit, highlight, record,
  clear, remove, merge, redirectSource, redirectTarget, redirectSourceAndTarget,
  vfree, vfreenonreset, vreset,
  pauseTransaction, resumeTransaction, commitTransaction, rollbackTransaction.
  (So (id)=valloc() instead of id=valloc(), and only as statement,
   or def var id:int; (id)=valloc() instead of def var id:int = valloc())

 Implemented retype procedure in sequence computations:
  (node-var)=retype(old-node-var, new-node-type)
  (edge-var)=retype(old-edge-var, new-edge-type)

 Implemented external procedures in addition to external functions (and external sequences)

 Syntax of the one-of-set/some-of-set changed from {(...)} to {<...>}
  (because it would otherwise collide with {(...)=p(...)} for a procedure call

 Implemented graph comparison operators (==,!=,~~) in rule language
  
 Added highlight statement to computations:
  highlights the nodes/edges or visited flags or storages in the graph that are given as arguments,
  similar to the highlight statement of the sequences/of the debugger.
 Highlighting extended:
  - if a string typed value is given, it is used as annotation for the previous value
  - the same exclude graph (layout) rules that apply to matches apply to highlighting
 
 Added commands to suppress graph display during debugging
  instead only the match of the current rule is shown,
  plus some context up do a configured depth,
  plus the parent nodes according to the nesting commands;
  these commands allow to still use the debugger if the graph as such is too large to be layed out.

 Shell comments are not terminated at # any more, this just feels awkward;
  instead § can be used as shell comment terminator.
  (For usage with "-C" commands given as argument to GrShell, to break out of an exec.)

 Added show includes "-SI" option to shell to print entry and exit of include.

 Fixes: 
  - sequence computations in frontend now open a scope
  - canonize used from rule language had internally a wrong type
  - some error message improvements
  - added checks for correct usage of return, break, continue

  
v4.0alpha (2013-03-29)
 Extended attribute evaluations to general computations 
 -- with general control flow constructs:
 - Allowed to declare attribute evaluation functions (computations) with syntax
   name(parameters) : return-type { statements }
   The function must end with a return(expr); statement returning the function value.
 - The declared computations can be used from rule language expressions and from sequence expressions
   with syntax name(arguments), yielding the computed value
   The declared computations may call other computations, or themselves recursively.
 - Added if condition to computations, with syntax
   if(expr) { stmts } [ else if(expr) { stmts } ]* [else { stmts }]?
 - Added loops to yields/evals/computations, with syntax
   while(expr) { stmts } for a pre-test loop
   do { statements } while(expr) for a post-test loop
   no semicolon needed at post-test loop, but all constructs require the braces
 - Functions can be called as statements
 - Embedded sequences can be specified in the computations with the syntax 
   exec(sequence)
   (Similar to the rule language, entities from outside can be read, and written to with yield.)
 -- with local variable declarations:
   Added local variable declarations to yields/evals/computations,
   with the syntax known from def variables in pattern (def var, def ref, def).
   They have to be assigned without yield prefix, that one is only for pattern entities.
   Allowed initialization of def entities of graph element type,
   with parameters, or elements from the outer pattern.
 Have a look at test/should_pass/DfsBfsSearch.grg or the computations_*.grg for an example.
 
 Extended attribute evaluations and sequences - where not already available - with multiple iteration loops:
 - for(val in container) { stmts }, or for(index->val in container) { stmts },
   where val, index are variable declarations of type compatible to the container.
   Added to computations for iterating over containers
 - for(n:NodeType) { statements } a loop over all nodes of the given node type in the graph
 - for(e:EdgeType) { statements } a loop over all edges of the given edge type in the graph
 - for(function(params)) { statements} a loop over all neighbouring nodes or edges of a start node,
   under the given type constraints, where function is one of incident, incoming, outgoing, for edges;
   or adjacent, adjacentIncoming, adjacentOutgoing for nodes.
   Params consist only of a node for the start node,
   or additionally an EdgeType for the type the incident edges must be of,
   or then additionally an NodeType for the type the adjacent nodes must be of.
 - Added reachability for loops, encapsulating a depth first walk in an iterator
   with for(n:Node in reachableNodes(start node, incident edge type, adjacent node type))
        { statements } as prototype
   and additionally reachableNodesIncoming, reachableNodesOutgoing for nodes,
   and reachableEdges, reachableEdgesIncoming, reachableEdgesOutgoing for edges.
 - Changed syntax of for command for accumulation of iterated to
   for(val in iterated) { stmts }  (only in rule language available)
   Here val is an entity from the iterated pattern, and comes without type.

 Added direct and transitive graph neighbourhood queries to attribute evaluations and sequence expressions
 - added isAdjacent, isAdjacentOutgoing, isAdjacentIncoming functions,
   behaving basically like an efficient "end-node in adjacent(start-node, ...)", ...,
 - and isIncident, isOutgoing, isIncoming functions,
   behaving basically like an efficient "end-edge in incident(start-node, ...)", ...,
 - and isReachable, isReachableOutgoing, isReachableIncoming functions,
   behaving basically like an efficient "end-node in reachable(start-node, ...)", ...,
 - and isReachableEdges, isReachableEdgesOutgoing, isReachableEdgesIncoming functions,
   behaving basically like an efficient "end-edge in reachableEdges(start-node, ...)", ...,
 - all for parameters (start-node, end-node, incident edge type, adjacent node type).
 - the isReachable predicates return whether the end-node can be reached from the start-node,
   by incident edges of the specified kind;
   they additionally come in the extended versions
   -...(start:Node, end:Node, incidentEdgeType:EdgeType) 
   that constrains the edges to the given EdgeType, and
   -...(start:Node, end:Node, incidentEdgeType:EdgeType, adjacentNodeType:NodeType)
   that additionally constrains the nodes to the given NodeType.
   This iterated path searching is implemented with a manually coded depth first search, 
   which is for one more efficient and for the other more convenient to use 
   than programming the same with subpatterns/controlled tests, but limited to simple type conditions.
 
 Extended the expressions and computation statements of the attribute evaluation language:
 
 -- with basic graph manipulation functions
 - add(NodeType):Node and add(EdgeType, SrcNode, TgtNode):Edge,
   for adding a node or edge to the graph, returning the added entity
 - rem(Node) and rem(Edge) procedures, for removing from the graph
 - retype(node,NodeType):NodeType retypes node to the new node type, returns the retyped node
 - retype(edge,EdgeType):EdgeType retyped edge to the new edge type, returns the retyped edge
 - clear() procedure for clearing the graph

 -- with advanced graph manipulation functions
 - merge(tgt,src) merges the source node with/into the target node, redirecting incident edges
 - redirectSource(edge,newSrc) redirects the edge to the new source node
 - redirectTarget(edge,newTgt) redirects the edge to the new target node
 - redirectSourceAndTarget(edge,newSrc,newTgt) redirects the edge to the new source and the new target node
  Those functions require a named graph as they fetch the debug display name from the old element.
  In addition, they are available in versions with an additional string as parameter,
  giving the name of the old element; in that case an unnamed graph is sufficient
  (the redirectSourceAndTarget requires two strings).

 -- with induced subgraph computations and insertions:
 - inducedSubgraph(set<NodeType>):graph returning the induced graph of the node set
 - definedSubgraph(set<EdgeType>):graph returning the defined graph of the edge set
 - insertInduced(set<NodeType>,node):node inserts a copy of the graph induced by the node set,
   returns the copy of the node given as second argument
 - insertDefined(set<EdgeType>,edge):edge inserts a copy of the graph defined by the edge set,
   returns the copy of the edge given as second argument

 -- with numeric functions
 - abs(numeric):numeric returning the absolute value of the input
 - sin(double):double returning the sine of the input
 - cos(double):double returning the cosine of the input
 - tan(double):double returning the tangent of the input
 - log(double,double):double returning the logarithm of the first argument 
   to the base given by the second argument
 - log(double):double returning the logarithm of the argument to the base e
 - pow(double,double):double returning the first argument
   to the power of the second argument (was already available)
 - pow(double):double returning e to the power of the argument

 -- with visited flag management
 - added valloc() function, for allocating a visited flag, returning it
 - added vfree(flag), vfreenonreset(flag), vreset(flag) procedures 
   for freeing a flag and resetting it in all graph elements

 -- with global functions for transaction handling:
 - startTransaction():int returning transaction id,
 - pauseTransaction() pausing transaction handling so changes are not recorded and can't be undone
 - resumeTransaction() resuming paused transaction handling
 - commitTransaction(int) keeping the changes of the transaction of given id in the graph, 
   removing the undo information
 - rollbackTransaction(int) reverting the changes by executing the undo log

  -- with text output procedures
 - added emit(string) procedure for emitting to stdout or a file
 - added record(string) procedure for writing to a graph change record

 -- with equitable partition computation
 - canonize(graph):string returning a canonical string representation of the graph input

 Container constructors are now available in the sequences, too
 - only the explicit ones, as expression, esp. in variable initialization
 - allowed empty container constructors again in rules language,
   but only for the explicit ones, i.e. set<int>{}, map<int,float>{}, array<Node>[], deque<string>][;
   not for the implicit ones: {3}, {3->3.141593}, [x], ]"foo"[.
   Had to disallow nesting of the implicit ones in exchange.

 Added a changes counter to the graph, increased at each graph structure changing operation:
 - used to find out about about the outdatedness of 
  graph analyzation results, isomorphy checkers, and canonical representations,
  thus allowing to keep them as long as they are still valid, 
  and preventing bugs from changes that occured after those were computed.
 - the changes counter is printed as additional statistics during shell execution
  (non-debugging, at the once-per-second sign-of-life-timer)

 Smaller extensions:
 - Implemented opposite(edge, node):other-node in rule language and sequences,
   in addition to source(edge) and target(edge).
 - Container constructors are now supported in initialization of def elements 
   in lhs and rhs of rules, tests, subpattern; and in computations.
 - The .empty() method on container types is now supported in the rule expressions, too.
 - Generalized entity arguments for esp. neighbourhood (but also other) functions 
   to compositional expression arguments
 - Added USE_NET_3_5 flag for letting GrGen target .NET 3.5;
   not needed for the generated code, but maybe for the user extensions.
 - The external attributes interface file was only created in tmpgrgenX folder,
   where it was deleted afterwards unless -keep was used;
   now FooModelExternalFunctions.cs is copied to parent folder (where rules reside),
   so that users required to implement that interface get to see it.
 
 Adaptation of user manual to computations extension:
 - added a dedicated chapter on the by-now massively extended computations,
   offering esp. control flow and computation definitions over simple assignments
 - split (and removed) the overly heterogenous storagesvisited chapter into
   - a massive extension of chapter container, now including everything container related
   - a new chapter graph containing everything graph type related,
     esp. global functions, visited flags, transactions
 - split chapter sequencecomputation out of chaper sequencesadvanced
  
 Bugfixes: 
 - allowed rule/sequence calls with empty parenthesis again
   (after some grammar refactoring in the past zero argument calls had to be given without parenthesis)
 - fixed off-by-one in SimpleGraphCanonizer
 - fixed bug in type balancing of graph comparisons of untyped global variables
 - fixed bug in compiled version of "interpretation plan" used for isomorphy checking
 - several other/smaller bugs fixed

 Release is only an alpha because of the missing static semantic checks 
 regarding the new computation constructs, which need to be constrained.

 
v3.6.ms2 (2013-01-28)
 Generic datatype deque<T> introduced:
  - mapping to custom C# Deque implemented with a ringbuffer doubled in size as needed,
    so insertion and removal from front and back in amortized O(1)
  - supporting operations added, in types and expressions, in model and rules, in sequences, in shell:
    - deque<T>] el, el2, el3 [ constructor
    - d.add(x) to add x to the end of the deque, d.add(x,i) to insert x at index i
    - d.rem() to remove element from begin of deque, d.rem(i) to remove element at index i
    - d.clear() clears deque
    - d.size() gives size of deque, d.subdeque(i,l) returns subdeque from start i on of length l
    - d.indexOf(x), d.lastIndexOf(x) give index of first/last occurence of value x in the deque
    - x in d returns whether x is contained in d
    - d[i] returns value at index position i, same does d.peek(i)
    - d[i] = x overwrites element at position i by x
    - a==b, a!=b checking equality of size and of the elements at their respective positions
    - a<b, a<=b, a>b, a>=b checking order of size and equality of elements
	   at their respective positions up to the size of the smaller deque
    - a+b returning a concatenation of deque a followed by b, compound version a+=b supplied, too
    - storage access in rules n{d} or n{m.d} of deque elements
  - The primary usage as FIFO queue for breadth first search can be seen in tests/DfsBfs
    (together with depth first search, based on LIFO stack implemented by an array or the call stack)

 Extended the set returning graph query convenience functions:
 - added functions incident, adjacent, adjacentIncoming, adjacentOutgoing, source, target
   to the expressions in the rules, in addition to the already implemented incoming and outgoing functions 
   (same semantics as their already implementd counterparts in the sequences).
 - added a kind of generalization of the adjacent/incident functions with reachable/reachableEdges:
   they return a set of nodes/edges as the adjacent/incident ones, but in surplus to the direct neighbours
   they add the neighbours of the neighours, and so on, too.
   Available are:
   -reachable(startNode, NodeType, EdgeType):set<Node>
   -reachableOutgoing(startNode, NodeType, EdgeType):set<Node>
   -reachableIncoming(startNode, NodeType, EdgeType):set<Node>
   -reachableEdges(startNode, NodeType, EdgeType):set<Edge>
   -reachableEdgesOutgoing(startNode, NodeType, EdgeType):set<Edge>
   -reachableEdgesIncoming(startNode, NodeType, EdgeType):set<Edge>
   The types are optional, if EdgeType is missing Edge is used, if NodeType is missing Node is used.
   These functions are avaiable in the rule expressions, and in the sequence computations.
 - added the functions
   -nodes(NodeType):set<Node> - returns all nodes of given type, or all nodes if type is omitted
   -edges(EdgeType):set<Edge> - returns all edges of given type, or all edges if type is omitted
   to the rule expressions and the sequence computations.

 Global variables can now be accessed in the expressions of the rules:
  - to this end they need to be declared at the beginning of the rule file
    with e.g. syntax "::g_n:Node;" for nodes, "-::g_e:Edge->;" for edges, and "ref ::g_s:string;" for variables.
  - the if and eval parts can then access the global variables from the processing environment,
    with e.g. syntax "::g_n", "::g_e", "::g_s"
    the values of the untyped variables are casted to the statically declared types.

 Added function canonize(g:graph):string to sequence expressions,
  delivering a canonical representation of the graph, reducing graph comparison to string comparison.
  The method supposedly doesn't work on isospectral graphs.

 Added new indeterministic choice sequence "weighted one" $.(w1 s1, ..., wn sn):
  the weights w1-wn (numbers of type double) are added into a series of intervals,
  then a random number (uniform distribution) is drawn in between 0.0 and w1+...+wn,
  the sequence of the interval the number falls into is executed,
  the result of the sequence is the result of the chosen part sequence.

 Added minus operator to the sequence expressions, operates only on numbers

 Indexed assignments to maps m[k] = v are now available in rule evals and sequence computations

 The value at an index of an array,deque,map-valued attribute can be accessed directly from the sequences now:
 - added "element.attribute[index]" container access to sequences expressions
 - added "element.attribute[index] = value" container assignment to sequence assignments
 
 Container methods in the sequences can now be called on container-valued attributes of graph elements, too
  e.g. node.arrayattr.add(x) can now be used in the sequences, too
  (this means esp. that the corresponding attribute change events of the graph get fired)

 Allowed peek() on array and deque, as 0 parameter shorthand for the 1 parameter versions:
 - array.peek() = array.peek(array.size()-1)
 - deque.peek() = deque.peek(0)
 i.e. peek returns the value that is removed by a rem() with 0 parameters,
 in rules as well as in sequences (notice the LIFO/FIFO semantics)

 The external attributes/attribute computation file is now generated and expected
  where the rules reside, instead of in the current working directory

 Bugfixes:
  - external types were emitted inheriting from all super types, not only the direct super type
    that resulted in "multiple base classes not allowed" compiler errors
  - some bugs with incident/adjacent functions in rules
  - several issues regarding indexed assignment to containers, esp. maps
  - fixed some array issues  
 
 
v3.6.ms1b (2012-10-26)
 Bugfixes:
  - fixed bug on importing ecore or GXL in the GrShell
    (another occurence of split-brain GrGen with two graphs)
  - fixed inlining bug which occured when subpatterns were used anonymously at different nesting levels
  - shell comments are now terminated at line end or at #
     so ## gives an empty comment which can be used for terminating a sequence
     when it appears in a shell input parameter string separated by ;; instead of line breaks
  
v3.6.ms1 (2012-08-27)
 Added automorphic pattern filtering / symmetry reduction of matches:
  - a rule declaration may now be annotated with a special filter auto, this
    makes GrGen.NET generate a matches filter auto which can be applied to calls of that rule
  - when applied it removes matches which are only permutations of other available matches,
    which is the case when the pattern is automorphic (and multiple matches are requested)
   (This renders GrGen much better suited to molecule matching for chemistry applications.)

 Improved random support in the sequences:
    (now that we got comparison operators to decide based on them)
  - added a random(upperBound:int):int function to the sequence expressions, 
    returning a random value in between 0 and upper bound exclusive
  - added a random():double function to the sequences expressions, 
    returning a random value in between 0.0 and 1.0 exclusive
  - added $(1.0) to the sequences returning a random value in between 0.0 and 1.0 exclusive;
    it is choicepointable like the $%(upperBound:int) available since a while now

 Visited flag handling changed / improved:
  - visited flags are reset on deallocation now, instead of on (re-)allocation
  - added deallocation procedure vfreenonreset without flag resetting to the sequence computations,
    this gives better performance on large graphs, leaving it at the responsibility of the user 
    to ensure the corresponding visited flag is unset/false on deallocation for all graph elements

 Bugfixes and API improvements: 
  - entries in the matches list handed out on request may now be overwritten with null, 
    they then count as deleted entries when materializing the matches collection again from the list 
    (this saves subarray copying on entry deletion in a user implemented filter)
  - replacing the matches with the changed list handed out was buggy in case the list was empty
  - the filter applied to a rule call is now displayed in debugger

--------------------------------------------------------------------------------------------------------

v3.5.2 (2012-08-12)
 Added "custom actions explain <actionname>" command to the GrShell/Actions in API
  printing the currently used scheduled search plan to the console
  (should be useful in optimizing performance, similar to the mysql/sqlite explain commands)

 Added printing of match statistics during non-debug sequence execution every second
  can be disabled (or enabled again) with the shell command silence exec off (/on)
  
 Bugfixes:  
  - fixed bug on importing ecore or GXL in the GrShell (split-brain GrGen with two graphs)
  - fixed bug in inlining of subpatterns yielding outwards
  - fixed bug in scheduling of inlined negative/independent
  - fixed crash when a set/map/array-constructor was used in an inlined subpattern
  - fixed crash in connectedness analysis for inlining
  - give error message on wrong usage of def arguments for normal subpattern parameters,
    and of normal arguments for def subpattern parameters, instead of failing later internally 
  - assigning the top priority to an edge in the rule file did not cause an edge lookup, fixed
 
v3.5.1 (2012-08-05)
 Multiple improvements in the user manual in various sections

 Added "dum(p) graph" command to the debugger

 Bugfix: abstract nodes/edges could not be referenced in the rewrite specification of a nested pattern, 
  until the matching graphlet was directly contained by that nested pattern  

v3.5 (2012-07-29)
 Some improvements in the user manual:
  - split several chapters into better digestible, more coherent parts
  - better explanation of the bracktracking angles, the central construct for crawling search spaces
 
 Bugfix: abstract nodes/edges could not be referenced in the rewrite specification of a nested pattern, 
  until the matching graphlet was directly contained by that nested pattern

 Performance optimization: isomorphy checking, i.e. the graph comparison operators are much faster now

  
v3.5 RC (2012-07-08)
 Improved graph querying from the sequences with for matches loop:
  - added for{m:match<r> in [?r]; sequence} looping over matches found
  - added m.n access to elements of match, distinguished from attribute access by type of the variable
  - the loop variable must be of type match<r>
 
 Improved graph querying from the sequences with neighbourhood iteration loops:
  - basic form is for{var in function(parameters); sequence}
  - var iterates over the incident edges in case of the incidency functions,
    which are incident, incoming, outgoing
  - var iterates over the adjacent nodes in case of the adjacency functions,
    which are adjacent, adjacentIncoming, adjacentOutgoing
  - the parameters are (source:Node) or (source:Node, incident:EdgeType)
    or (source:Node, incident:EdgeType, adjacent:NodeType)
  - the nodes or edges returned are filtered according to the incident/adjacent types if given
  - in contrast to the functions in the sequence expressions of the same name,
    these functions enumerate nodes/edges multiple times in case of reflexive or multi edges

 Added (h)ighlight command to the debugger:
  - it accepts one or multiple comma separated variables or visited flag ids
    and then highlights the variable content (must reference graph elements) in the graph
  - for plain variables and sets the contained elements are annotated with the variable name
  - for arrays the contained elements are annotated with the variable name and index
  - for maps the contained elements are annotated with the variable name and the Domain/Range role,
    for node to node maps edges are inserted pointing from the source to the target elements
  - for visited flags all elements visited according to that flag are annotated 
    with the id or the variable containing the id

 Added highlight command to sequences:
  - highlight("text") behaves like the (h)ighlight command in the debugger, 
    just that it's called from a sequence instead of being interactively applied with (h)
 
 Bugfixes:
  - fixed bug in backtracking (cloning of matches list)
  - the user choice constructs from the sequences crashed without a debugger session before their execution
  - fixed bug: select actions command was broken since the graph processing environment introduction

 Further additions:
  - simple Emacs syntax highlighting added
  - added support in debugger for cycling through the matches found, 
    of transaction double angles and the for-matches-loop
  - the print (v)ariables command in the debugger now additionally prints the allocated visited flags


v3.5 beta3 (2012-06-23)
 Fixed massive bug in graph comparison: now taking connectedness into account
 Fixed crash in interpreted sequences when calling a sequence containing an all-bracketed rule

 Added export command to sequences:
  export(filename) exports the current graph as file of the name given, in the format given
  export(graph, filename) exports the graph specified as file of the name given, in the format given
  
 Added statespace chemistry test which shows how to model chemical reactions,
 enumerating all possible reaction results

 
v3.5 beta2 (2012-06-18)
 Improved customization, extension of GrGen with C# code:
 - External match filter functions added, declared with a backslash after a rule/test body,
   plus match filter function applications at a rule application, with a backslash, too.
   To be executed after matching and before rewriting, allowed to alter the matches list.
   With them, external code may be notified about, inspect, and filter, matches of rule applications.
 - External sequences added, declared as sequences without sequence body,
   plus external sequence applications in a sequence as any other application of a defined sequence.
   With them, arbitrary external code may be called from the sequences, passing parameters.
 - The match filter and external sequence functions need to be implemented 
   in a <Name>ActionsExternalFunctionsImpl.cs file.

 Bugfixes/Improvements:
 - Some fixes/generalizations in sequence application parameter passing, def elements, and yields.
 - Inlining fix (bad negative / inlined subpattern interaction).

 
v3.5 beta (2012-06-03)
 Subpattern inlining supported now:
  - potential to speed up transformations with subpattern usages dramatically,
    esp. when subpatterns were used for extracting common parts, structuring transformations,
	causing the containing patterns to become disconnected
  - required some hefty internal changes, as a quick workaround against bugs in case some show up
    it can be disabled with the -noinline parameters to the grgen compiler, 
    and a corresponding shell command: set noinline on|off

 Bugfixes/misc. stuff:
  - generate FooModelExternalFunctions.cs even when only external classes (and no external functions) are declared
  - copy external functions when adding models to models
  - clear method on set/map/array was only implemented in parser, now complete
  - allowed to yield to non-node/edge variables in exec (of rules)
  - parameters occuring only in deferred execs but not their containing pattern now work
  - the detection for a recursion of empty subpatterns now assumes a recursion will eventually terminate
    if conditions which are not statically known to be true are found on such an otherwise empty recursive path
  - enough fundamental technical changes to call the child v3.5 instead of v3.1 by now

  
v3.1 beta 4 (2012-04-06)
 Several procedures for basic graph manipulation added to sequence computations:
  - add(:NodeType):Node - creates node of given type and adds it to the graph
  - add(:EdgeType, src:Node, tgt:Node):Edge - creates edge of given type 
     from src to tgt and adds it to the graph
  - rem(node:Node) - removes node from graph
  - rem(edge:Edge) - removes edge from graph
  - clear() - clears graph

 Several procedures for graph element neighborhood queries added to sequence computations:
  - source(edge:Edge):Node - returns the source node of the edge
  - target(edge:Edge):Node - returns the target node of the edge
  - adjacentIncoming, adjacentOutgoing - in addition to adjacent, restricted to incoming or outgoing edges
     of type (source:Node):set<Edge> or (source:Node, incident:EdgeType):set<Edge> 
     or (source:Node, incident:EdgeType, adjacent:NodeType):set<Edge>
  - incident, incoming, outgoing returning the edges incident to the source given the constraints specified
     of type (source:Node):set<Edge>, or (source:Node, incident:EdgeType):set<Edge>,
     or (source:Node, incident:EdgeType, adjacent:NodeType):set<Edge>

 Several procedures for computing and cloning induced graphs added to sequence computations:
  - inducedSubgraph(:set<Node>):Graph - returns the subgraph induced from the node set given
     inducedSubgraph replaces induced
  - definedSubgraph(:set<Edge>):Graph - returns the subgraph defined by the edge set given
  - insertInduced(:set<Node>,anchor:Node):Node - adds a clone of the induced subgraph to the host graph,
     returns the clone of the anchor node given
  - insertDefined(:set<Edge>,anchor:Edge):Edge - adds a clone of the defined subgraph to the host graph,
     returns the clone of the anchor edge given

 Some further miscellaneous procedures and operators added to sequence computations:
  - binary operator ~~, checks for structural equality of graphs,
     i.e. isomorphy but does not check attributes for value equality as == does
  - added cast operator "(type)element" for node and edge types
  - added .peek(n) method for container types, returning the nth element of a container

 Bugfixes:
  - edge redirection and thus node merging was broken when used in transactions/backtracking
  - compiling external attribute evaluation functions from dynamic search plans gave a compiler error
  - one-of/some-of-set operator ${(...)}, {(...)} now handled correctly in compiled sequences, too
  - further small fixes and improvements


v3.1 beta 3 (2012-02-12)
 Isomorphy checking for state space enumeration now supported (to purge duplicate graphs/states):
  - Added subgraph typed variables and attributes, which allow to store and retrieve IGraph values,
    (they are for coping with subgraphs of the host graph, not multiple host graphs,)
    declared e.g. as gr:graph
  - Comparison operators == and != offered for (sub)graphs (the only operations on the graph type),
    they check whether the graphs are isomorphic to each other
  - for loop without container added to sequence, looping over the compatible graph elements 
    of the statically declared type of the iteration variable, e.g. for{x:Bar; do_sth()}
  - added adjacent operation to collect the nodes adjacent to a source node into a set of nodes
    e.g. adjacent(source), or adjacent(s, incidentEdgeType), or adjacent(s, iET, adjacentNodeType)
  - added induced operation to create an induced subgraph given a set of nodes
    e.g. induced(set), or sequence {gr:graph=induced(adjacent(src, contains))}
  - the statespace test now gives an example of state space enumeration including isomorphy checking,
    cutting equivalent graphs/states (i.e. mapping isomorphically regarding structure and attributes)
 

v3.1 beta 2 (2012-01-22)
 Added comparison operators ==,!=,<,<=,>,>= to sequence expressions, as well as + operator;
  same semantics as in rule language expressions, for the various types they apply to

 Added pause insertion / s / to transaction and backtracking angles:
  The effects of the sequences are kept in the graph even if the (backtracking) transaction is rolled back.
  This behaviour allows to generate a spate space by iterating all matches with nested backtracking brackets 
  (dynamically nested via sequence calls, with the body of the sequence called containing one backtracking step),
  copying during the backtracking pauses the states which are reached 
  during the backtracking enumeration and which should be kept.
 
 Backtracking brackets expect now a double semicolon in between the rule and the sequence,
  is much better readable that way: << r ;; s >>  (old simple semicolon still available)
  
 Refactoring of the graph: split out the graph processing stuff into a graph processing environment
  the graph itself is now clean and easy; for sequence execution and variables an environment is needed
  consequences:
   - variables can't be exported (and therefore imported) any more, "withvariables" option removed
     only shell save/include emit them/read them
   - on API level you need an additional graph processing environment object for most tasks,
     an LGSPGraphProcessingEnvironment to be constructed from the graph and the actions
 Refactoring of the named graphs: named graph is now an interface and an lgsp implementation,
  instead of a wrapper; that's easier to handle, and naming now works more reliable, in more situations,
  esp. the naming operator can now we be used in embedded sequences, too
 Some further refactorings to clean and improve the code, 
  partly moving functionality, partly removing unused functionality
 
 Improved External Function Handling:
  - introduced -lazynic parameters to the grgen compiler, 
    so one can access external assemblies in the user defined function/class implementation
  - and lazynic to the shell, too:
    new set lazynic on|off
 
 Several bugs fixed, esp. regarding transactions and (compiled) sequences, most imporant:
  - the matches of a rule found during handling of nested backtracking don't get destroyed any more
    if the same rule is matched again at a deeper nesting level (they get now cloned)
  - allowed sequence expressions as parameters of rule/sequence calls in the embedded sequences, too
  
 
v3.1 beta 1 (2011-12-12)
 Refactoring of the sequences: split old sequences into sequences and sequence computations
  (plus the sequence computation sub parts sequence expressions and assignment targets)
  - sequences are now pretty pure, control operators over rule applications plus basic variable handling
  - computations must be be given in the sequences enclosed in { },
    return true if computation has no result value or it is a non-default value

 Refactoring of variable handling: global variables must be prefixed with ::
  so we have typed local variables declared with name:Type and used with name,
  and untyped first-usage-is-definition global variables used with ::name.
  Optional in shell and grs importer, as all variables there are global,
  mandatory in sequences and sequence computations, with a deprecation warning if prefix is missing.
  Parsing and symbol tables now allow global and local variables with same name.
 
 A lot of further refactorings in sequence handling 
  - to improve the code, 
  - to allow for more powerful sequences and sequence computations in the future 
  - to fix old issues, e.g. binary operators are now left associative, as they should be
 
 (Negative) side effects of sequence computation introduction: 
  - the rule-set-sequence must be given with syntax {(.,.)} now instead of {.,.}
  - several constructs must be given in { } now as they are computations
  - container access out of bounds yield runtime crash instead of sequence application result false
 
 New sequence computation constructs:
  - chaining of statements with then operator ";", e.g. {x=y; x.add(3); x.empty()} 
  - chaining of assignments, e.g. {a=b=0}
  - chaining of method calls on the state object, useful for container changing methods, e.g. {s.add(1).add(2)}
 New sequence expression constructs:
  - boolean operators &&,||,&,|,^
  - conditional ternary operator, e.g. a ? b : c
 New sequence construct: 
  - plain variable declaration, later on initialized explicitely in a computation

 Improvements:
  - print line number of sequence when sequence parsing fails, in .grs and in .grg
  - sequences can now be called in shell with exec, too
  - orientation layout option now affects not only the debugger, but the .vcg dumps, too
  - a few bug fixes
  
 Adapted user manual to mainly sequence handling changes,
  split off storages and visited to own chaper, split off external stuff into extensions chapter.

--------------------------------------------------------------------------------------------------------

v3.0.1 (2012-04-06)
 - Added -deprecated option to grshell and grgen (as migration helper towards 3.1):
    When sequence constructs are found which are only available as sequence computations in 3.1
	a deprecation warning message is printed to stderr (in case this option is given)
 - Some minor fixes
 - Note: when using transactions or backtracking, you are strongly recommended to switch to 3.1,
    they contain bugs which won't be fixed on 3.0 any more
	
v3.0 (2011-07-29)
 New datatypes introduced:
  byte - 8bit signed, literals are denoted by Y-suffix, e.g. 42y
  short - 16bis signed, literals are denoted by S-suffix, e.g. 0x4242s
  long - 64bit signed, literals are denoted by L-suffix, e.g. 0xDEADBEEFl
  the operators expect int or long, byte and short are automatically casted upwards
 
 Node merging:
  Extended the retype operator by the ability to merge nodes in,
  e.g. x:T<u,v,w> creates x as a retype of u to T, with v and w merged in,
  i.e. the edges incident to v and w are redirected to x and then the nodes are deleted
  - as T may be typeof(u) a pure merge can be achieved
  
 Edge redirection:
  Edges can be requested in the rule language rewrite part to get redirected,
  e.g. an edge declared as x -e:T-> y in the pattern can be redirected in the rewite part with
    x -e->! z; or x !-e-> z; or y !-e->! x; i.e. the end to be redirected is marked by !
	(an exclamation mark at the end to change as seen from the center to state "make this happen!")
  Edges can be requested in the shell to get redirected by the
    redirect <edge> (source|target) <node>      command, redirecting <edge> to the new <node>

  Misc:
  - Debug appearance polished, esp. unintuitive red -> green for newly created elements
  - HelloWorld! in examples\HelloWorld-TTC2011 made simpler by utilizing independent
  - Syntaxhighlighting adapted
 
 
v3.0beta3 (2011-07-04)
 LHS retyping:
  - allowed retype operator on lhs, x:T<y> tries to cast y to T, 
    if successful x allows to access y as T (attributes!), otherwise matching fails for this y

 Totally homomorphic matching:
  - with syntax independent(name) pattern elements may be requested to be matched homomorphic to any other element
  - isomorphy exceptions may be specified with syntax independent(name\name)
    or independent(name\(name+name+...+name))
  - this allows to match the already matched target node of a use-def backlink in a program graph,
    but is potentially dangerous as conflicting rewrites may be specified

 Iteration breaking:
  - iterated { X; break negative { Y; } }
    if the negative matches, not only the current iteration instance is prevented from matching, 
    but the entire iterated is failing to match
  - iterated { X; break independent { Y; } }
    if the independent does not match, not only the current iteration instance is prevented from matching,
    but the entire iterated is failing to match
  - this allows to check that "every pattern X must also satisfy Y" holds on single-rule level

 Visualization and Debugging:
  - added debug set node|edge mode matched|created|deleted|retyped command
     it allows to configure the same visualization options as the dump set node|edge command,
     but for the debugging visualization effects instead of for the types
     (so one can configure a debugging display which is better visible with regard to the normal graph display)
  - added ability to configure linestyle continuous|dotted|dashed in dump set edge command
  - added ability to configure thickness 1|2|3|4|5 in dump set edge command
  - added missing .vcg colors lightyellow and yellowgreen to color enum/parsing, fixed turqouise -> turquoise

 Improved External Function Handling:
  - allowed to give assembly references as parameters to the grgen compiler (grgen -r <name>.dll), 
    so one can access external assemblies in the user defined function/class implementation
  - allowed to add/register assembly references in grshell used at the invocations of the compiler:
    new add reference "<path to dll>"
  - and a keepdebug flag for improved debugging:
    new set keepdebug on|off

 Syntactical convenience: in case a top level rewrite part is missing a default empty modify is assumed

 Improved Import: EMF/ecore/XMI adapted to TTC live contest input

 Bugfixes:
  - fixed issue when parsing (pat1 | ... | patn) construct
  - fixed compilation error for iterated in negative/independent
  - bugfix for elements to be deleted but referenced in a typeof

 Syntax highlighting: adapted to latest changes

 
v3.0beta2 (2011-05-19)
 Solutions of Transformation Tool Contest 2011 tasks added to examples:
  - HelloWorld! in examples\HelloWorld-TTC2011
  - ProgramUnderstanding in examples\Reengineering-TTC-2011
  - CompilerOptimization in examples\CompilerOptimization-TTC2011
 Export/Import:
  - Model override can now be a rule file, e.g. import Foo.gxl Rules.grg
    imports Foo.gxl using the model(s) from Rules.grg and selects the actions for usage.
  - EMF/ecore/XMI importer extended, can now handle references by url fragments instead of ids
  - GrgExport is now writing a rule creating the graph and a test matching the graph
 New searchplans are created for all actions when no rule name is given,
   i.e. custom actions gen_searchplan is recompiling all the matchers
 Syntax highlighting improvements
 Fixed several bugs:
  - crash in vcg dumper on a certain combination of exclude and group by
  - wrong emitting of tuple attributes in GXL export
  - problems due to elements referenced not being available in the pattern,
      for typeof and emithere
  - unsigned shift right >>> semantics fixed, and now correctly explained in manual

  
v3.0beta (2011-04-17)
 Local variables, ordered evaluation, and yielding outwards:
  - added def entity declarations, which on RHS do not get created, on LHS do not get matched,
    but are yielded to from evals, evalheres, subpattern rewrites, or execs on RHS,
    or are yielded to from yields, subpattern usages on LHS,
    out of the same pattern, but especially out of nested patterns and called subpatterns.
	They can be uses as local and output variables;
	def vars may receive an initialization assignment.
  - added yield block which is an eval on the LHS constrainded to not assigning to /
     not changing graph element attributes, only parameters or def entities allowed
  - added yielding assignments to evals, evalheres, execs
  - added yielding assignments to yields, esp. including iterated yield accumulation with for
  - added yield arguments to def parameters in subpattern calls and subpattern rewrite calls
  - added evalhere command to evaluate attributes in between the subpattern rewrite calls
  - added alternative/iterated rewrite usage specification to trigger an alternative/iterated
    rewrite usage in between the subpattern rewrite calls
  - was made possible by: every nested pattern can be given a name,
     for the anonymous ones a counted makeshift name is assigned

 Generic datatype array<T> introduced:
  - mapping to C# list (misnamed dynamic array)
  - supporting operations added, in types and expressions, in model and rules, in sequences, in shell:
    - array<T>[ el, el2, el3 ] constructor
    - a.add(x) to add x to the end of array, a.add(x,i) to insert x at index i
    - a.rem() to remove element from end of array, a.rem(i) to remove element at index i
    - a.clear() clears array
    - a.size() gives size of array, a.subarray(i,l) returns subarray from start i on of length l
    - a.indexOf(x), a.lastIndexOf(x) give index of first/last occurence of value x in the array
    - x in a returns whether x is contained in a
    - a[i] returns value at index position i, same does a.peek(i)
    - a[i] = x overwrites element at position i by x
    - a==b, a!=b checking equality of size and of the elements at their respective positions
    - a<b, a<=b, a>b, a>=b checking order of size and equality of elements
	   at their respective positions up to the size of the smaller array
    - a+b returning a concatenation of array a followed by b, compound version a+=b supplied, too
    - storage access in rules n{a} or n{m.a} of array elements

 Expressions extended by incoming/outgoing edge function:
  - incoming(node, EdgeType, NodeType) returns a set of the edges incoming to the node,
     only if of the given EdgeType, only if originating from a node of given node type
	 NodeType is defaultet to Node if omitted; EdgeType is defaulted to Edge if omitted
  - outgoing(node, EdgeType, NodeType) does the same for the edges going out from node

 Changed syntax of storage access in pattern from "<" storage ">" suffix to "{" storage "}" suffix
   because "<" ">" is already used for retyping, input parameter type, copy; was too overloaded

 GrShell extended by pwd, cd, ls commands:
  - pwd: prints working directory
  - cd <path>: changes working directory to <path>
  - ls: lists the content of the working directory with files relevant to GrGen highlighted

 Bugfixes:
  - the mono csharp compiler yields errors for unicode escaping in identifiers,
    changed attribute implementation suffix
  - fixed code generation for calls in compiled sequences which do not assign return values,
    but the rule/sequence called returns some
  - if grgen is called with "path/file" then by now the path is only prepended
    when opening an "#include i-path" to the i-path, if the i-path is not absolute
  - added error messages in case edges created are referenced in evalhere,
    in case edges from nesting pattern are referenced in nested pattern (instead of compiler crash)
  - fixed assertion when using node/edge valued set/map types

 Optimizations by better/global data flow analyses allowing for cheaper runtime implementations:
  - reduced overhead of runtime neg level checking to the very seldom cases it is really needed
  - reduced overhead of patternpath setup to the very seldom cases it is really needed

 Minor:
  - refactorings of iterated patterns in API
  - syntaxhighlighting adapted
  - enough changes to call the child v3.0 instead of v2.7 by now


v2.7.ms4 (2011-02-07)
 Added procedural abstraction for graph rewrite sequences with sequence definitions:
 - added support for compiled named sequence definitions in rules file with syntax:
    sequence name(input variables):(output variables) { sequence }
 - added support for interpreted named sequence definitions in shell with syntax:
    def name(input variables):(output variables) { sequence }
 - for both: input and output variables are local variables,
    they get filled with the input values,
    and define the output values in case of success,
	where success is defined by the sequence.
 - they can be called from other sequences (or even the same) with
   (output parameters)=name(input parameters) syntax,
   as for rule calls the output parameters of sequence calls are only written on success

 Added debugger commands
  - "(v)ariables" which prints out all global variables and all local variables
      of the currently executed sequence (up to the point focussed)
  - "stack (t)race" which prints the call stack of the sequences currently executed
      (including sequence content and execution state)
  - "(f)ull dump" which prints the call stack of sequences including all their variables

 User manual restructuring and extension:
  - split chapter "Understanding and Extending GrGen.NET" out of API chapter,
    added a lot of content there explaining how GrGen.NET works
  - split chapter "Visualization and Debugging" out of GrShell chapter,
    to decrease shell chapter size and emphasize visualization and debugging

 Further minor:
   - added support for sequence result postfix assignment s => v, s |> v, s &> v


v2.7.ms3 (2011-01-17)
 Added support for storage attributes, i.e. attributes typed with set/map of node/edge,
  can now be declared in model, handled by all the other set/map constructs already available,
  furthermore added an extension of the storage access constructs on the LHS by:
   x:T<n.a> with n being a node or edge and a an attribute of it,
   yielding a pattern element picked from the storage attribute

 Added compound assignment statement which allows for efficient set/map operations,
  especially for efficient data flow analysis with the optional change assignment:
   -set/map union |=, intersection &=, difference \= assignments are available
   -change assignment operators assign-to =>, union-to |=, intersect-to &> are available
     examples: v |= w => changed; n.s &= m.s |> e.changed; n.m \= w &> n.visited[2];

 Improved user manual:
  - split off exec/emit and storage handling (+visited)
    into an own chapter "Embedded Sequences and Storages",
    meant as an introduction into combining rules to build transformations.
  - added subsection on data flow analysis explaining how to compute reachability.

 Bugfixes:
  - transaction handling (thus backtracking too) now capable of nested processing,
    i.e. a committed nested transaction gets rolled back if the enclosing transaction fails
  - deferred execs used from rules contained in deferred execs
    don't execute pending execs from their parent any more

 Further minor features:
  - added pow operator to expressions, pow(x,y) computes x to the power of y (only for double)
  - intersection changed to retain first element for maps


v2.7.ms2 (2011-01-03)
 Added copy operator:
 - new-node:copy<old-node> creates a clone of the old node
   (type and attribute values are same, incident edges are not taken care of)
 - -new-edge:copy<old-edge>-> creates a clone of the old edge,
   the source and target nodes of the new edge must be specified (otherwise edge would dangle)

 Added deferred exec:
 - allowed exec from nested alternatives or iterateds, and from subpatterns
 - when used closures for the exec applications are put into a to-be-processed queue,
   which gets executed at the end of the root rule using them

 Added storage access clauses:
 - on LHS one can write x:T<s> with s being a storage;
   the storage elements are iterated, the ones which are of type T are accepted as a match of x
 - on LHS one can write x:T<s[y]> with s being a storage-map and y being an element from the pattern;
   the value of y in s is looked up and if it exists and is of type T it is accepted as a match of x

 Improved user manual with some pragmatics explanations, some fixes
  "Merge and Split, Node Replacement Grammars, and Subgraph Copying"

 Fixes:
  - values of variables are now transmitted into nested iterateds/alternatives
  - anonymous subpatterns are now named "sub"_X,
    so that nodes don't get blown up that much in debugger detail mode


v2.7.ms1b (2010-12-20)
 Bugfixes:
  Compiler:
  - generation error when attribute named A had a sibling attribute named _A (i.e. "_" prefix) fixed
  - rewrite parameters not being available for attribute assignment fixed
  - emit error on attempt to rewrite a rhs declared subpattern usage, i.e. a subpattern which gets instantiated
  Shell/Debugger:
  - fixed debugger/named graph mismatch on retyping (retyped elements stayed in debugger)
  - allowed every place which expects a word (e.g. a type name) to contain a single or double quoted text,
     so user can reference shell keyword named entities by escaping
  - prevent computer from going into sleep mode while a sequence gets executed (windows only)

v2.7.ms1 (2010-12-05)
 Added record and replay feature (plus supporting instructions):
 - record shell command for writing the current graph and then the changes applied to it into a .grs
    for replaying later on, with comments telling about the events causing them as debugging help
 - replay shell command for replaying previously recorded changes
    with capability to define begin and end lines to replay only certain change sets/states
 - record operator in sequences for emitting to the currently ongoing recordings
    e.g. record("\# label1\n") for labeling a state (2 such labels can be used to mark a changeset)
 - retype shell command, e.g. retype (@"$1")<NT> for a node and retype -e<ET>-> for an edge
 - commands to add/remove elements to/from graph element attributes of set/map type, e.g. (@"$4").m1.rem(42)

 Added capability for using external, user defined functions and types in attribute computations (if/eval):
 - added external function declarations, with the GrGen compiler type checking them
 - added external type declarations(with inheritance relationsships but without attributes),
    which can be used from the external attribute computation functions (only)
 - the user must implement the external functions and types in a <X>ModelExternalFunctionsImpl.cs file
    where <X> stands for the model/rule files name, by supplying further parts of partial classes

 Other changes:
 - min(.,.)/max(.,.) functions added to the expressions
 - compiled version of backtracking brackets <<r;s>> now available
 - ability to specify lower bound for random match selection, e.g. $v1,v2[r], $v1,*[r];
     otherwise (when only an upper bound is given as e.g. in $v2[r]) fixed to value 1
 - added askfor shell command just waiting for enter to be pressed
 - further smaller fixes and improvements
 - purged deprecated shell constructs for set handling, map handling, visited flags handling

--------------------------------------------------------------------------------------------------------
 
v2.6.4 (2010-10-30)
 Fixes for bugs introduced in 2.6.3:
 - certain pattern elements were deleted when using patterns with more than 2 nesting levels; fixed
 - subpattern deletion erased the subpattern parameters; fixed

v2.6.3 (2010-10-11)
 Changes:
 - allowed pattern elements to get deleted(/retyped) in nested alternative/iterated blocks or even in subpatterns
    compiler checks that only one delete/retype is ever happening for any pattern element
    this behaviour is only specifiable in modify mode with explicit delete
 - added backtracking brackets: <<r;s>> computes all matches of the rule r (for given inputs), then
    foreach match: apply rewrite (assigning outputs), then execute s
                   if s failed: rollback effects of r and s, continue with next match, fail if exhausted
                   if s succeeded: commit effects, succeed
 - annotations are now available on API level (transmitted from .gm/.grg to code)
 - semantic change: the parameters/attachment points of a subpattern now get deleted
    if not mentioned in the _replace_ part of the subpattern, as was always the case with rules
 - bugfix: allow abstract node types as replacement parameters
 - fixed crash in debugger on printing a rule call with a constant argument (instead of a variable)
 - improved FiniteStateMachine and ProgramGraphs examples,
    split into a succession of examples building on each other, giving a nice overview of the capabilities of GrGen
 - further minor fixes/improvements

v2.6.2 (2010-09-19)
 Changes:
 - bugfixes/improvements for debugger detail mode annotations
 - improved compiler checks, esp. against non-terminating subpattern recursions
    and iterated empty graph matching
 - fixed crash on printing the <var>=null assignment to console in debugger

v2.6.1 (2010-09-12)
 Changes:
 - debugger detail mode now annotates in yComp all the pattern elements matching on a host graph node
 - debugger detail mode annotations now show in addition to the pattern element name the path to the name
   (with symbols from the regular expression syntax, and the subpattern entity names,
    clipped from nesting level 3 on, only showing nesting depth due to display size constraints)
 - removed the rule rewrite part reuse optimization (reuse optimization still there on graph level),
    was source of too many errors over time, esp. when used with transactions
 - some smaller fixes (regarding independents and subpattern rewrite parameters)

v2.6 (2010-09-05)
 Single most important change:
  - user manual updated (including all the changes from 1.4->2.6)

 New sequencing constructs in xgrs:
  - operator then-left l <; r executing l then r, returning the execution result of l
  - operator then-right l ;> r executing l then r, returning the execution result of r
  - decision if{cond; truecase; falsecase} executing cond,
     on success truecase is executed and its result returned,
     on failure falsecase is executed and its result returned
  - if{cond; truecase} which equals if{cond;truecase;true} thus giving a lazy implication
  - n-ary random all of operators (currently only available in the interpreted sequences),
     in function call notation with the operator symbol as function name:
	 - the strict $|(s1,s2,s3) and $&(s1,s2,s3) evaluate all their subsequences in random order
	 returning the disjunction resp. conjunction of their truth values.
     - the lazy versions || and && evaluate the subsequences in random order
	 as long as the outcome is not fixed or every subsequence was evaluated,
	 returning the disjunction resp. conjunction of their truth values.
  - some-of-set braces {r,[s],$[t]} matching all contained rules
     and then executing the ones which matched; true if one of the rules matched
  - one-of-set braces ${r,[s],$[t]} matching all contained rules
     and then executing at random one of the rules which matched; true if one of the rules matched

 Uniform variable handling in xgrs:
  - now the compiled and the interpreted sequences both always support
    i) graph global variables, untyped, i.e. type errors are only detected at runtime,
     live from first assignment/implicit declaration on, written to file on save and restored on load
    ii) sequence local variables, typed thus statically type checked,
     only live until sequence execution ends (thus no persistency available)

 Handling of set<T>/map<S,T> in xgrs:
  - in contrast to the set/map in models and rules, S/T may be of node/edge typ, giving storages/storagemaps
  - set/map addition st.add(el)/mp.add(el,val) always succeding
  - set/map removal st.rem(el)/mp.rem(el) always succeding
  - set/map clearing sm.clear() always succeeding
  - set/map iteration for{el in st; seq} / for{el->val in mp; seq},
     failing iff seq fails for at least one el/el->val in the set/map
  - set/map membership query el in sm succeeding iff el is contained in the set/map
  - map lookup assignment val=mp[el] assigning the result of a map lookup to a variable,
     succeeding iff el is contained in mp, otherwise failing, not touching the variable
  - set/map size assignment sz=sm.size() assigning size to the variable, always succeeding
  - set/map emptyness query result assignment se=sm.empty() assigning to the variable
     whether set/map is empty, always succeeding
  - set/map creation st=set<T>/mp=map<S,T>, and variable declarations of explicit set/map type,
     st:set<S>, mp:map<S,T>,  e.g. st:set<Node>=set<Node>

 Handling of set<T>/map<S,T> in rules, to ease the processing of storages:
  - ref st:set<T>, ref mp:map<S,T> parameters, call-by-reference, including S/T of node/edge type
  - rule rewrite part extension, new statements besides emit/exec:
   - set/map addition st.add(el)/mp.add(el,val);
   - set/map removal st.rem(el)/mp.rem(el);

 Visited flags handling:
  - visited flags processing in rules in function notation deprecated
    visited flags processing in rules now by syntax:
      e.visited[f] = b  or  e.visited = b
      e.visited[f]  or  e.visited
  - visited flags management in shell deprecated
    (allocvisitflag, isvisited, setvisited, freevisitflag, resetvisitflag)
    visited flags management now by xgrs operations instead of shell commands:
      f=valloc() for visited flags allocation
      vfree(f) for visited flags deallocation
      vreset(f) for resetting visited flag in all graph elements
      e.visited[f] for query whether graph element was visited
      e.visited[f] = b for setting whether graph element was visited

 New assignments in xgrs:
  - attribute reading in xgrs: toVar = fromVar.attributeName (value semantics)
  - attribute writing in xgrs: toVar.attributeName = fromVar (value semantics)
  - constant value/literal assignment: toVar = int|float|double|string|boolean|enum|set|map - constants/literals
  - random number assignment: v = $(Number) assigning a value from 0 up to excluding Number to v
  - user input assignment: v = $%(Type) querying the user for a value of given type and assigning it to v
     only in interpreted xgrs, as shell input required; only in debug mode if a node/edge type is requested

 Improved debugging:
  - blue > at sequence start
  - renamed (n)ext to (u)p (going one level up in the sequence tree)
  - added (n)ext command focusing the rule which matches next in green
     (instead of normal/other step commands focusing the rule which will be tried next)
  - the rules which matched during sequence execution are shown on dark green background,
    the rules which failed during sequence execution are shown on dark red background;
	at the end of a loop iteration the old highlighting state is displayed,
    at the begin of a new loop iteration the highlighting state of the contained rules is reset.
  - choice points similar to break points added; denoted by % appended to the random operator $
     transforming the random choice to a user choice, triggered when execution reaches the choice point
	 applicable to the random binary operators, random match selection, random number assignment
	 user input assignments are choice points which can't be toggled off
  - debug support for all the new and changed xgrs constructs

 Rewrite part handling of nested patterns:
  - modify/replace graph elements of nesting pattern
     are now available in modify/replace of nested alternative/iterated/multiple/optional-patterns
  - modify/replace of nested alternative/iterated/multiple/optional-patterns can't take parameters any more,
     better: no need to give them any more, as they can access the rhs elements of the nesting pattern
  - the modify/replace parameter declaration of the subpattern has to be given at the subpattern head / interface,
     not in the subpattern body any more

 Retyping:
  - graph elements matched outside alternative case now can get retyped in alternatives cases
  - graph elements matched outside optional pattern now can get retyped in optional pattern

 Export/Import:
  - GRS(I) import/export (of .grs, .grsi files; and GrShell) now support set/map attribute initialization
    (example: new :N1($="$0", a = set<int>{1,2,3}, b = map<string,boolean>{"foo"->true,"bar"->false})
  - withvariables parameter for grs export causing variables to get exported; default is nodes/edges only
  - GRS(I) import/export now writes and reads persistent names correctly
       (instead of variables; only if a non named graph is given fallback to hash names)
  - GXL import/export now supports enum attributes (set/map not supported)
  - support for importing/exporting .gz compressed .gxl/.grs
  - add parameter for .gxl/.grs import, adding the graph from the file to import to the current host graph
  - ecore/XMI importer extended to support a larger class of inputs (plus nopackagenameprefix parameter)

  Set/Map comparison in rewrite rules:
  - new set/map comparison operators in rewrite rules:
     sm1 == sm2 is true iff sm1 equals sm2 (sm1<=sm2 && sm2<=sm1)
  	 sm1 != sm2 is true iff sm1 unequal sm2 (at least one entry not available/same in the other set/map)
 	 sm1 <= sm2 is true iff sm1 is subset/submap of sm2 (every entry from sm1 is available in sm2)
	 sm1 < sm2  is true iff sm1 is proper subset/submap of smp (sm1<=sm2 && !sm1==sm2)
	 sm1 >= sm2 is true iff sm1 is superset of sm2 (sm2<=sm1)
	 sm1 > sm2  is true iff sm1 is proper superset of sm2 (sm2<sm1)
	maps require key and value to be same for the equality, (proper) sub/supermap relationships to hold

 EBNF/regular expression-like notation for nested patterns added:
  - (P)* = iterated { P }
  - (P)+ = multiple { P }
  - (P)? = optional { P }
  - (P1|P2) = alternative { L1 { P1 } L2 { P2 } }
  - ~(P) = negative { P }
  - &(P) = independent { P }
  The notation supports additionally (P)[k], (P)[k:l], (P)[k:*] for matching a bounded number of times.

  The rewrite part can be given in embedded action style:
  - {+ R } = modify { R }
  - {- R } = replace { R }

 Connection assertions:
  - nodes without incident edges were ignored in validation, now the lower bound 0 vs. 1 is always checked
  - the default if no multiplicity is given is now [*] instead of [1], i.e. no constraint specified
  - support for "validate strict only specified" mode, doing a strict validation,
    but only of edge types for which connection assertions were specified
  - support for "copy extends" to copy the connection assertions of the direct supertypes
  - support for undirected edges with -- syntax
  - support for arbitrary edges with ?--? syntax

 Fixes:
  - escaping of quotation marks in VCG files
  - escaping of quotation marks and newlines in communication with yComp
  - escaping of XML language elements in GXL export
  - escaping of some parameters to the call of grgen.jar containing paths
  - nameof(element) now working correctly, i.e. returning persistent name as announced
      (instead of variable name; only in case of a non-named graph a hash value name is returned)
  - typeof(element of abstract type) now working
  - bad interference of transactions with the reuse optimization removed
  - several cases of use before definition in rule language now working
  - Mono compiler error (MS.NET warning) when using alternatives removed
  - initialization overwrite in model (on inheritance paths of depth >2; for sets/maps)
  - fixes for nesting hierarchies of right hand side declared elements
  - dump into .vcg format now handles nesting as declared by "dump add group" commands correctly
  - name collision between shell and rule generated graph elements causing debug display corruption
  - directed/undirected edges (as given by edge syntax) can extend arbitrary edges
    without being forces to explicitely extend Edge/UEdge, too
  - removed check against homomorphy of retyped elements not needed
  - lazy or operator parsing priority bug
  - ResetVisitedFlag/vreset now reliably working on edge types, too
  - code generation for conditions in nested patterns
  - code generation for alternatives nested in negatives/independents
  - subpattern creation/instantiation with parameters from rewrite part
  - runtime cast exception when calling a subpattern modification with an argument being a subtype of the parameter type
  - wrong matching of iterated consisting of only a terminal pattern not requiring a candidate iteration loop
  - endless loop prevention by checking against unbounded pattern cardinality constructs
      containing no locally defined nodes or edges (not being homomorphic to enclosing elements)
  - several bugs in code generation for iterated fixed
  - usage of rhs elements on lhs
  - further minor fixes

 Further changes:
  - null arguments must be declared beforehand if they should be used,
    causing the element to be searched by its own search plan,
	thus every null-capable argument doubles the number of matchers;
    declaration syntax example: rule r(x:Node<null>, y:T<S+null>)
	  (y is example for inexactly typed input which may be null in addition)
  - the deprecated old grs were removed
  - new shell construct <Var> = askfor <Type> prompting the user to enter a value of given type
     - if the type is a graph element type the user is asked to select a graph element
       by double clicking in yComp (debug mode must be enabled)
     - if the type is a value type the user is asked to enter a value of this type on the keyboard
    the older debug apply with wildcard elements is deprecated now, succeeded by this construct
  - assignment of sequence result to variable is now always true (independent of sequence result)
  - execs may yield elements which can be used in return statements; yield statement in compiled xgrs
  - replaced emitpre by emithere, which is emitted before regular emits,
    at the position syntax-relative to the subpattern modification invocations and the other emitheres
  - the random match selector now expects a variable instead of a number
  - new rule modifiers dangling (only apply rule if all incident edges of a node to be deleted
     are specified in the pattern), and identification (don't apply rule if a node to be deleted
     was matched homomorphically to a node to be kept), allowing to pick from the dpo conditions
	 (dpo = dangling + identification)
  - new method .peek(num:int) on set<S> and map<S,T> types, returning the element/the key of the element
      at the position num in the sequence of enumeration
  - new function random() returning a double random value in between 0.0 and 1.0
      and random(sup:int) returning an integer random value in between 0 and sup, sup exclusive
  - added emit to xgrs: emit(double-quoted-text|variable)
      example: xgrs emit("foo\n") && emit(v)
  - same literal/constant syntax now in assignments and attribute initializations of
      model, rules, sequences, shell, grs (ex/)importer
      (e.g. Foo::bar for enum, 3.141593f for float, 0x11 for hex integer, map<string,double>{"42"->42.0})
  - the graph with model combined class is now named FooGraph instead of Foo for Foo.grg
  - set/map commands in GrShell are deprecated (succeeded by xgrs set/map operators)
  - set/map-valued attributes are now displayed in yComp, too
  - now error reported on attempt to delete and return elments allowed to be matched homomorphically
  - added exitonfailure to GrShell validate command leaving GrShell on failed validation with error code
  - undirected edge creation in GrShell with -name:type- syntax and type UEdge if no type given
  - Added GrGen syntax highlighting for vim (model, rules, shell)
  - Extended GrGen syntax highlighting for Notepad++ to GrShell files
  - added GrGen-solution for ModelMigration case from TTC2010
  - added GrGen-version of "Repotting the Geraniums: On Nested Graph Transformation Rules" to examples
  - user manual now under Creative Commons Attribution-Share Alike 3.0 Germany license
  - further minor improvements

--------------------------------------------------------------------------------------------------------

v2.5.1 (2009-09-09)
 Additions:
  - subpatterns now support var parameters, too
  - GrShell now with non-debug/gui-mode and return value
  - additional checks and warnings in GrGen compiler
  - GraBaTs 2009 Live Contest Winning Solution ConveyorBeltSystem added
  - some renaming in examples folder to show case origins
 Fixes:
  - usage of var parameters in alternative, iterated - blocks
  - nested iterated, alternative blocks
  - elements of enclosing lhs pattern only mentioned in eval of rhs
  - gxl export (showing in mono glx import exception)
  - several examples work again (not all, though)
  - some previously failing tests

v2.5 (2009-06-28)
 Advanced subpattern/subrule features:
  - iterated block matching contained subpattern as often as possible implemented
  - multiple block as an iterated block requiring at least one match added
  - optional block matching contained subpattern (eagerly) at most once implemented
  - independent block for specifiying positive application conditions implemented
  - emitpre (before emitting from subpatterns) and emitpost(=emit; after emitting from subpatterns)

 Im/Export:
  - import/export commands added to GrShell, porter module added to LibGr
  - GXL importer and exporter added
  - EMF / ECore importer added
  - GRS importer and exporter added

 New API:
  - Generation of an action interface per action, implemented by the action class,
    plus an action-interface-typed member per action in actions class instance
  - Action interface with exactly typed input parameters, matches object, output parameters
    (for the match / modify / apply methods)
  - Old input parameters semantics - silently failing rule application on wrong type -
    now only available with syntax r(x:ExactType<InexactType>)

 Semantic changes:
  - Semantics of negative regarding subpatterns/subrules changed:
    negative pattern elements get matched independent from the subpatterns utilizing them
	(explicit patternpath/pattern statement in the negative/independent needed for old behaviour)
  - hom declarations are inherited into nested negatives/independents now
  - hom delarations are non-transitive by now (hom(a,b) and hom(b,c) don't cause hom(a,c) unless specified)

 Examples:
  - Solution to the GraBaTs 2009 Program Comprehension case study added
    (including EMF import)
  - Completed JavaProgramGraphs sample (Grabats 2008 refactoring case solution),
	including GRS import/export in source code sample
  - Rewritten ProgramGraphs sample with new iterated construct,
    added corresponding source code sample
  - Updated source code samples to the new 2.5 API

 libGr:
  - Added short infotags (without displaying attribute name)
  - The labels of elements can now be removed or set to a constant string

 GrShell/yComp:
  - Improved interactivity: debug apply <rule with ? as placeholders>
    allows to select wildcard elements ? by double clicking at elements in graph viewer yComp
  - Debugging much more robust to unexpected connection loss
  - show var <variable> implemented
  - Shell / debugger now showing match parts due to all forms of subpatterns in debug mode / with %
  - Finally implemented the help command and improved the error handling
  - Replaced "dump edge labels (on | off)" by "dump edge [only] <type> labels (on | off | <text>)"
  - Added "dump set node [only] <type> labels (on | off | <text>)"
  - Added "dump add (node | edge) [only] <type> shortinfotag <member>"

 Misc:
  - Changed License to LGPL v3
  - Added GrGen syntax highlighting for Notepad++
  - Shorthand visited(el) for visited(el, 0)

 Bugs:
  - Several smashed

--------------------------------------------------------------------------------------------------------

v2.1.2 (2009-02-16)
 Fixes:
  - don't create elements declared outside alternative if only appearing in modify/replace part

v2.1.1 (2009-02-06)
 Features/API changes/Fixes/Examples:
  - Added icons for GrGen, GrShell
  - Added conference scheduling/grabats2008 live contest solution to examples
  - Added IsAbstract and IsConst to GrGenType, catch attempts to create abstract elements in GrShell

v2.1 (2008-12-19)
 Features:
  - Added string methods (indexOf, lastIndexOf, length, substring, replace)
    (see frontend/should_pass/strfunc_001.grg in source release)
  - Added set<K> and map<K,V> attribute types (using value semantics)
  - Inline condition evaluation code to improve performance
  - Const attributes are now implemented as static to improve performance

 GrShell:
  - Added support for set/map variables
  - Added "setvisited <elem> <vis_id> <visited>" command
  - Added "isvisited <elem> <vis_id>" command
  - Removed silent modifier from node/edge creation commands
  - Added "silence (on|off)" command

 API changes:
  - Changed interface of changing-node/edge-attribute handlers because of
    set/map feature
  - Provide metainfo about declared enum types

 Fixes:
  - Improved compilation time of specifications for large amount of actions
  - Fixed comment parser in .grg dependency checker
  - Improved several error messages
  - Use an own namespace for alternative names
  - Entity (node/edge/subpattern usage) names now overwrite type names
    in expressions
  - Allow <element>.<attr> with attr being an GrShell keyword

 Examples:
  - Improved layout of Transcription examples
  - Added (parts of) the petri-net-benchmark from the paper "A Benchmark
    Evaluation of Incremental Pattern Matching in Graph Transformation"
	by Varró et al.
  - Added "Object to Relational Mapping" by Varró et al.

 Other changes:
  - Increase stack size of Java frontend and GrShell

--------------------------------------------------------------------------------------------------------

v2.0 (2008-07-28)
 Features:
  - Added support for literals as parameters for XGRSs
  - Improved performance of matching a bit
  - Improved performance of rules with return statements
  - Improved performance of compiled XGRSs (exec statement)
  - Added -noevents and -noperfinfo options for GrGen.exe disabling firing
    of events in generated code and counting of matches/rewrites for a small
    speedup
  - Added GXL (Graph eXchange Language) to GRS (GrShell script) converter
    (gxl2grs.exe; an according model must be generated by hand)

 API changes:
  - Improved debugger support by using some DebuggerStepThrough and
    DebuggerDisplay attributes on GraphElements and Types
  - Allow newlines in XGRS strings (enables use of verbatim strings in user
    source code to reduce noise caused by string concatenation)

 Fixes:
  - Elements used by nameof()-operator if not mentioned otherwise in modify
  - Allow boolean literals as attribute initializers in "new node/edge"
    GrShell commands
  - Retyping in subpattern or alternative case
  - Do not reserve several libGr/lgspBackend class names

 Examples:
  - Added JavaProgramGraphs example, a partial solution of Program
    Refactoring case of GraBaTs 2008
    (contains rules for a specialized GXL dumper making use of the nameof
     operator and rules inserting helper edges for a nested layout of the
     program graph assisting the GrShell "group by" dump commands)
  - Added AntWorld version passing integer constants in exec (_NoGammel)

 Other changes:
  - Updated GrShellBenchmarker


v2.0 beta 2 (2008-06-24)
 Features:
  - Allow assignments of the success of a sequence to a variable
    (e.g. "res:boolean=(r1 || r2[5])")
  - Allow boolean variables as sequences (only works in execs, yet)
    (e.g. "res && r1")
  - Added visited flags
  - Added random-match-selector
    (e.g. "$7[r1]" searches for all matches and then randomly selects
     7 of them to be rewritten. "$[r1]" is equivalent to "$1[r1]")
  - Added nameof()-operator
    (e.g. "nameof(blub)" yields the name of the graph entity "blub";
     "nameof()" yields the name of the graph)

 Features for GrShell:
  - Added "silent"" keyword to new node/edge commands to prevent
    "element successfully created"-messages
    => Shell scripts creating a lot of elements run much faster when
       using this keyword
    (e.g. "new state:State silent" or "new a1 -:Edge-> a2 silent")
  - Added post build step to grshell to increase stack size to 16MB
    (so that matching engine can handle much larger recursive structures)
  - Added visited flags support
  - Support assignments of "true" and "false" to variables
  - Added "randomseed" command
    (e.g. "randomseed 13" sets the random seed to 13 for reproducible
     results when using the $-operator-prefix or the random-match-selector;
     "randomseed time" sets the random seed to the current time in ms)
  - Reduced GrShell overhead of XGRS execution significantly

 API changes:
  - Moved PerformanceInfo, MaxMatches, Replace, ApplyRewrite,
    ApplyGraphRewriteSequence(Sequence), ValidateWithSequence(Sequence)
    and the events from BaseActions to IGraph
  - Sequence.Apply now takes an IGraph instead of a BaseActions instance
  - Removed BaseActions.ApplyGraphRewrite
  - Added GetNewestActionVersion and SetNewestActionVersion to IGraph
    (perhaps only temporarily...)
  - Added AddNode and AddEdge variants to IGraph to allow adding
    e.g. cloned elements to the graph
  - Added INode.Adjacent, INode.GetCompatibleAdjacent,
    INode.GetExactAdjacent and IEdge.GetOther
  - PerformanceInfo.MatchesFound is now always changed after firing the
    IGraph.OnMatched event

 Fixes:
  - Allow identifiers to begin with an underscore
  - yComp: Remove related reference nodes, when a node is moved to
    another subgraph
  - Don't generate pattern creation functions, when the pattern contains
    abstract members
  - Fixed inheritance of same attribute over multiple inheritance paths
  - Fixed crash of SequenceParser on lexer error
  - Don't ignore wrong text after correct sequence prefix
  - Allow to write "r1*" instead of "r1[*]" in execs
  - Fixed range specifications of the form "[200]" in .gm and .grg files
  - Fixed the performed rewrites counter for compiled XGRSs (exec)
  - Replaced exponential constant folding algorithm in Java frontend
    by a linear-time one

 Examples:
  - Updated BusyBeaver API example
  - Added TranskriptionAbstrakt example
    (doing transcription on chains instead of chemical structure graphs;
     Viatra2 R2 solution included)
  - Added TranskriptionAbstraktNachAtom example
    (transforming the abstract dna chains of TranskriptionAbstrakt into
     the chemical structure graphs of Transkription)
  - Added ProgramGraphs example and API example
    (implementing program graphs as specified in "Adaptive Star Grammars
     for Graph Models" plus PullUpMethod refactoring on these program
     graphs)
  - Added WeakComponents examples and VisitedExample API example
    (using visited flags)
  - Added AntWorld example for GraBats 2008
    (using the random-match-selector)

 Other changes:
  - Return statements now only allowed after all normal statements;
    exec/emit statements only as last statements


v2.0 beta (2008-04-28)
 Features:
  - Introduced subpatterns, alternative patterns, and recursive patterns
  - Introduced dependent replacement and recursive rules
  - Introduced "var" parameters and return values for basic types
    like int and string
  - Allow expressions as return arguments
  - Added "arbitrary" and optional "directed" keywords for edge classes
  - Added "using" statement for models
  - Implemented dpo/exact/induced also for the new edge kinds
  - Graph variables are objects now, and not only graph elements anymore

 Features for GrShell:
  - Added support for variable assignments with literals
  - Variable to variable assignments
  - "show graph" and "dump graph" now use the layouter configured
    via "debug set layout"

 API changes:
  - The classes for Node/Edge and for elements inheriting from Node/Edge
    now inherit from INode/IEdge directly instead of the IAttributes
  - Removed obsolete IAttributes
  - Renamed IGraphModel.Name to IGraphModel.ModelName
  - Special classes being a graph an a model at the same time
    are now generated for each model. They also contain specialized
    element creation methods for each element type
  - Removed deprecated IDumperFactory
  - The VCGDumper can now specify a layouter to be used
  - Added static type property "TypeInstance" to element classes
    for easier access to the appropriate type instance
  - Generated C# element class names are not prefixed anymore as long
    as the would be no name clash (a warning is generated then, too)
  - Added EdgeType.Directedness property
  - Renamed Condition to PatternCondition
  - Added IGraph.Actions property as a currently associated actions object
    (perhaps only temporarily...)

 Fixes:
  - Dangling edges in nested negative patterns
  - Fixed several frontend tests

 Examples:
  - Updated examples
  - Added "Recursive" example
  - Added "Transkription" example
  - Continued Firm-IFConv example (now also using var parameters and return values)

 Other changes:
  - Changed License to GPL v3
  - The names of the generated model files now depend on the model name

--------------------------------------------------------------------------------------------------------

v1.4 (2008-03-20)
 Features:
  - Introduced the imperative statement "emit" in RHS printing text
    to the console or to files (see UML2CSP2 example)
  - Introduced the imperative statement "exec" in RHS executing xgrs'
  - Introduced abstract members in element types
    (these members do not have a declared type,
    hence containing classes are abstract)
  - Introduced "dpo", "induced" and "exact" modifiers for rules
  - Introduced "induced" and "exact" statements in rule patterns
  - "null" is a keyword, now. It represents the default object value
  - Member initializers in model specification
  - Added support for external implementations of element types
  - Updated implicit and explicit casts (see user manual section 5.1)
  - Nested negative patterns
  - Undirected edges
  - Directed "-->" or "<--", undirected "--", arbitrary directed "<-->"
    and arbitrary "?--?" edges in patterns
  - Added "maybeDeleted" element annotation to ignore warnings claiming
    that a returned element could be deleted due to a hom statement

 Features for GrShell:
  - Enhanced grouping support:
    "dump add node [only] <NodeType> group [by [hidden] <GroupMode>
    [[only] <EdgeType> [with [only] <NodeType>]]]",
    where <GroupMode> can be "no", "incoming", "outgoing", or "any".
  - Allow setting layout options without starting the debugger first
  - Remember layout options during a session
  - Save layout options when using "save graph"

 API changes:
  - Redesign of type architecture
  - Direct access to element attributes
  - Changed namespaces of generated code
  - Introduced IGraphElement.Valid, IGraphElement.ReplacedByElement,
    INode.ReplacedByNode, and IEdge.ReplacedByEdge to check, whether
    elements were deleted or retyped during a rewrite
  - Removed unused dump fields from BaseActions

 Fixes:
  - Returns for test actions
  - Enums are now allowed as values in '?:'-operators
  - Fixed dependency calculation for includes in grg-files
  - GrShell "save graph" command
  - GrShell debugging of sequences containing "[SomeRule]"
  - GrShell debugging of element retyping
  - GrShell "dump (node|edge) only <nodeType> exclude" command
  - GrShell debugging with grouped nodes
  - Problems with edge parameters
  - Handling of abstract element classes
  - Several cases involving combinations of hom, retype, delete, and return
  - Output compile warnings also when compilation did not fail

 Examples:
  - Added Sierpinksi3 (with parallel rewrite semantics)
  - Added FiniteStateMachine example
  - Added UML2CSP2 example using the new emit statement
  - Added DebugExec example

 Other changes:
  - "pattern" part is now directly embedded in rules and tests
  - Added XML documentation files for Intellisense help in IDEs
  - Replaced 'include "<grg-file>";' by '#include "<grg-file>"'
  - ycomp.bat does not need to be edited anymore
  - Changed syntax for rule application in xgrs:
    e.g. "%?[(a,b)=R(a,c)]" to "(a,b)=[?%R(a,c)]"


v1.3.1 (2007-12-07)
 Features:
  - Added "-gensp" option to spBench allowing generation of dynamic
    searchplans after execution of the initialization xgrs
  - Stabilized content of generated C# files for better version control
  - Test actions work now

 Fixes:
  - spBench acted on the original graph instead of the cloned version
  - Clone variables and all statistical information when cloning a graph
  - Clear variables when clearing a graph
  - Disabled buggy node reusing as a workaround
  - Reflexive pattern edges were not always matched correctly

--------------------------------------------------------------------------------------------------------

v1.3 (2007-11-06)
 Features:
  - The reuse optimization reusing deleted elements can now be disabled
  - Infotags with null values are not displayed anymore
  - Speedup transactions a bit
  - GrGen.exe: Renamed -d option to -keep, added -debug and -usefull option
  - Added options for dumping and commenting generated matcher programs
    (accessible through properties and "Custom")
  - Reimplemented LGSPGraph.Clone via copy constructor to allow derived
    classes to support cloning
  - Added convenience methods BaseGraph.GetNodeType and BaseGraph.GetEdgeType

 Features for GrShell:
  - Added "debug layout" to relayout the graph in yComp
  - Added "debug get layout options" and "debug set layout option" allowing
    access to the parameters of the current layouter in yComp

 Examples:
  - Added HelloMutex api example
  - Added YCompExample api example
  - Added GrIO example
  - Added AGTIVE example UML2CSP
  - Added another Sierpinski triangle implementation

 Tools:
  - Added spBench, an application to benchmark all possible searchplans for
    a rule pattern

 Fixes:
  - Fixed ASTdapter
  - Fixed multiline custom commands for GrShell
  - Fixed xgrs parser not allowing "somerule[1:*]"
  - Fixed node reusing causing a crash
  - Disabled debug output of yComp
  - Fixed NACs only containing an if
  - Fixed attributes output of VCGDumper
  - Fixed infotags
  - Fixed homomorphic matching (testcase hom1 and hom2)
  - Includes in GRG-files are now also considered as dependencies

 Specification processing (grgen.jar):
   Changes:
    - Improved processing time
    - Improved error messages
    - Added new attribute type "object"
      (only operators '=', '==', and '!=' are allowed)
    - Warn if a graph element occurs inside and outside a delete statement
    - Warn if a returned graph element may be matched homomorphically to the
      same element as an element within a delete statement
    - "actions" and "model" keywords are now deprecated
    - Enum declarations may now use already existing enum entries

   Fixes:
    - Fixed '?' operator
    - Fixed errors with C# keywords in models and rules
    - Fixed rule specification files without any rules
    - Fixed crash when using a non-existing model

--------------------------------------------------------------------------------------------------------

v1.2 (2007-07-19)
 Features:
  - Introduced xgrs as replacement for grs (GrShell can still handle grs, but
    prints the new xgrs version for a given grs).
    See "Developing Graph Transformations with GrGen.NET" for a description
    of the new graph rewrite sequence syntax.
  - Restructured directories
  - Added test bench
  - GrGen now places the generated libraries into the directory of the spec
    files by default (can be overridden with -o)
  - Updated examples

 Features for GrShell:
  - The LGSPBackend is the default backend now. So the "select backend ..."
    line is not necessary anymore in the normal case.
  - Introduced 'new graph <grgfile>' which builds the libraries if neccessary
    and creates graph and actions, superceeding 'new graph <modellibrary>'
    plus 'select actions <actionslibrary>'. The latter commands stay
    available, though.
  - Added "validate xgrs <sequence>" which is successful, if the given
    sequence can be applied successfully on a clone of the current graph
    (implemented by BaseActions.ValidateWithSequence)
  - Added "dump add edge <type> exclude"
  - Added breakpoint support (% flag for rules, true and false in debug mode)
  - Added breakpoint toggling while debugging (use the 'b' key)
  - Fixed infotags
  - Added element exclusion for debug mode
  - Added support for multiline commands using '\' at the end of a line
  - Guess .grg extension for "new graph <specfile>" when <specfile>
    does not exist
  - Guess .grs extensions for files given via commandline

 API changes:
  - Renamed GetOutgoing/Incoming to GetCompatibleOutgoing/Incoming
  - Added GetExactOutgoing/Incoming
  - Added Apply, ApplyStar, ApplyPlus and ApplyMinMax to IAction

 Fixes:
  - Fixed problems with dangling edges in patterns
  - Fixed retyping with typeof operator
  - Newly created edges could not be returned
  - Fixed wrongly reported invalid reuse of nodes and edges in modify part
  - Annotations on anonymous elements did not work
  - Fixed error detection for return statements
  - Fixed comparisons with constant enum expressions
  - Fixed attributes with names of reserved C# keywords
  - Fixed casts to strings
  - Fixed conditions containing casts
  - Fixed float constants

--------------------------------------------------------------------------------------------------------

v1.1 (2007-07-02)
 - Base of change log
