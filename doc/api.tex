\chapter{Application Programming Interface}\indexmainsee{application programming interface}{API} \indexmain{API}
\label{cha:api}

This chapter describes the Application Programming Interface of \GrG, i.e. of the system runtime - the LibGr - and of the assemblies generated from the model and rule specification files.
We'll have a look at
\begin{itemize}
\item the interface to the graph and model
\item the interface to the rules and matches
\item the interface of the graph processing environment (esp. for executing sequences)
\item the porter module for importing and exporting of graphs and miscellaneous stuff
\item implementing external class and function declarations
\item implementing external match filter and external sequence declarations
\item events fired when the graph is changed
\item events fired during action execution
\end{itemize}

\noindent The compiler \texttt{grgen.exe} generates from the input file \texttt{Foo.grg} the output files \texttt{FooModel.cs} for the model and \texttt{FooActions.cs} for the actions,
\begin{itemize}
\item defining the exact interface, 
\item implementing the exact interface with generated code and code from the lgsp backend, i.e. entities from \texttt{de.unika.ipd.grGen.lgsp} available from lgspBackend.dll, 
\item and implementing the generic interface from \texttt{de.unika.ipd.grGen.libGr} using the entities mentioned in both points above.
\end{itemize}

\noindent This generative approach bears a great deal of the responsibility for the high execution speed of GrGen.NET, but it comes at the price of flexibility: you can't extend the existing rule set at runtime with new rules.
What you can do at runtime on the other hand is to generate a new rule set file, apply the compiler, and dynamically link the resulting assemblies/dlls.

When working with the API, you could reference the generated binary dlls in your project, in the same way as you have to reference the \texttt{libGr.dll} and \texttt{lgspBackend.dll}.
For easier debugging though, especially when you are integrating the generated code with own extensions (as described in chapter \ref{chapextensions}), it is recommended to directly include the source code generated (which is thrown away normally after it was compiled into the assemblies lgsp-FooModel.dll and lgsp-FooActions.dll).
For this, use the \texttt{-keep} option when you call \texttt{grgen.exe}, and include the model and the actions file (excluding the intermediate actions file) directly as C\# source code files.

The matcher code generated contains the initial, static search plans.
When you analyze the graph at runtime and generate new matchers, see section \ref{custom} for more on this, you can request the dumping of the source code of the improved matchers.
The custom commands are available at API level via the \texttt{Custom} operation of the \texttt{IGraph} interface for the graph commands and via the \texttt{Custom} operation of the \texttt{BaseActions} class for the actions commands, just handing in the same parameters as otherwise specified on the command line.
If the intended workflow of ``i) loading a typical graph or doing a warm-up run creating a typical graph, ii) analyzing that graph, iii) compiling new matchers that are better suited to the graph'' is not easily achievable, or you want to start with the optimized matchers straight from the beginning, you may copy and paste the dumped dynamic matchers of an example run to the existing static code. 
But this is only a last resort, as the price is that your manual editing is overwritten again with the static search plans at the next time you call \texttt{grgen}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface to the Host Graph}

The generated file \texttt{FooModel.cs} opens the namespace \texttt{de.unika.ipd.grGen.Model\_Foo} containing all the generated entities.
It contains for every node or edge class \texttt{Bar} an interface \texttt{IBar}, which offers C\# properties giving access to the attributes, and is inheriting in the same way as specified in the model file.
This builds the exact interface of the model, it is implemented by a sealed class \texttt{Bar} with generated code and with code from the lgsp backend.
Furthermore, the namespace contains a model class \texttt{FooGraphModel} implementing the interface \texttt{de.unika.ipd.grGen.libGr.IGraphModel},
which supports iteration over the entities defined in the model, using further generic(i.e. inexact) interfaces from libGr.
Finally, the namespace contains a class \texttt{FooGraph} defining an \texttt{LGSPGraph} of a model equivalent to \texttt{FooGraphModel}; 
it contains convenience functions to easily create nodes and edges of exact type in the graph.

In addition, a class \texttt{FooNamedGraph} is available, which defines an \texttt{LGSPNamedGraph} of a model equivalent to \texttt{FooGraphModel}.
The named graph offers persistent names \ref{persistentex} for all of its graph elements, but besides that, it is identical to an \texttt{LGSPGraph}.
The named graph is the one utilized by \GrShell, and the one recommended to be used for its ability to uniquely denote graph elements,
but be aware that the storage of the names requires about the same amount of memory as an unnamed graph as such.

\begin{note}
If you want to use the type-safe interface, your entry points are the \texttt{CreateNodeBar}-methods of the graph class \texttt{FooGraph} or the \texttt{CreateNode}-method of node class \texttt{Bar}, returning a node of the type \texttt{IBar}.
If you want to use the generic interface, your entry point is the \texttt{IGraphModel}, with a call \texttt{INodeModel.GetType("Bar")} returning a \texttt{NodeType}, which is then used in a call \texttt{IGraph.AddNode(NodeType)}, returning a node of the type \texttt{INode}.
\end{note}

The interface types for the node and edge root types are supplied already in libGr and are thus common to all graph rewrite systems (this allows for the generic handling); 
they are available as the \texttt{INode} interface for the \texttt{Node} root node type, 
as the \texttt{IEdge} interface for the \texttt{AEdge} root edge type, 
as well as the \texttt{IDEdge} interface for the directed \texttt{Edge} root edge type and the \texttt{IUEdge} interface for the undirected \texttt{UEdge} root edge type 
(in signatures where \texttt{IEdge} is used, the more concrete interface types allow to obtain directedness information directly from the .NET type).

The interfaces of the types you specified in the model are generated, as well as the backing implementation types of all those interface types.

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface to the Rules}

The generated file \texttt{FooActions.cs} opens the \texttt{namespace de.unika.ipd.grGen.Action\_Foo} containing all the generated entities.
It contains for every rule or test \texttt{bar}
\begin{itemize}
\item a class \texttt{Rule\_bar} inheriting from \texttt{de.unika.ipd.grGen.lgsp.LGSPRulePattern}, which contains
the exact match interface \texttt{IMatch\_bar}, which in turn defines how a match of the rule looks like,
extending the generic rule-unspecific \texttt{IMatch} interface.
Have a look at section \ref{sub:extflt} for an extended introduction to the matches interfaces. 
Furtheron available are (but meant only for internal use): a match class \texttt{Match\_bar} implementing the exact and inexact interface,
a description of the pattern to match, and the modify methods doing the rewriting.

\item an exact action interface \texttt{IAction\_bar}, which contains the methods:
  \begin{itemize}
  \item \texttt{Match}, to match the pattern in the host graph,
     with in-parameters corresponding to the in-parameters of the rule (name and type),
	 returning matches of the exact type \texttt{Rule\_bar.IMatch\_bar}.
  \item \texttt{Modify}, to modify a given match according to the rewrite specification,
     with out-parameters corresponding to the out-parameters of the rule.
  \item \texttt{Apply}, to match and modify the found match,
     with in-parameters corresponding to the in-parameters of the rule,
     and with ref-parameters corresponding to the out-parameters of the rule.
  \end{itemize}
  Furtheron available is (but meant only for internal use) the class \texttt{Action\_bar}, implementing the exact action interface as well as the generic \texttt{IAction} interface from libGr;
  it contains the generated matcher code searching for the patterns.
\end{itemize}

Moreover, the namespace contains an action class \texttt{FooActions}
implementing the abstract class \texttt{BaseActions} from texttt{de.unika.ipd.grGen.libGr} (in fact \texttt{LGSPActions} from \texttt{de.unika.ipd.grGen.lgsp}),
which supports iteration over the entities defined in the actions using further, generic(i.e. inexact) interfaces from libGr.
Additionally, it contains the instances of the actions singletons,
as member \texttt{bar} of the exact type \texttt{IAction\_bar}.

\begin{note}
If you want to use the type-safe interface, your entry point is the member \texttt{bar} of type \texttt{IAction\_bar} from \texttt{FooActions} (or \texttt{Action\_bar.Instance}).
Actions are used with named parameters of exact types.
If you want to use the generic interface, your entry point is the method \texttt{GetAction("bar")} of the interface \texttt{BaseActions} implemented by \texttt{FooActions} returning an \texttt{IAction}.
Actions are used with \texttt{object}-arrays for parameter passing.
\end{note}

\begin{note}
The old generic interface of names specified within strings and entities of node-, edge-, and object-type is implemented with the new interface of named and exactly typed entities.
Thus you will receive runtime exceptions from the generic interface when you carry out operations that are not type-safe, in contrast to \GrG\ $<$ v2.5.
If you need the flexibility of the old input parameter semantics of a silently failing rule application upon receipt of a wrong type,
you must declare it explicitly with the syntax \verb#r(x:ExactType<InexactType>)#;
then the rule parameter in the exact interface will be of type \texttt{InexactType}.
\end{note}

\begin{example}\label{ex:api1}
Normally you want to use the type-safe interface of the generated code as it is much more convenient.
Only if your application has to get along with models and actions that are unknown before it is compiled, do you have to fall back to the generic interface.
An extensive example showing how to cope with the latter is shipped with \GrG\ in form of the GrShell.
Here we'll show a short example on how to use \GrG\ with the type-safe API.
Further examples are given in the examples-api folder of the \GrG-distribution.

We start by including the namespaces of the libGr and the lgsp backend shipped with \GrG\,
plus the namespaces of our actions and models, generated from \texttt{Foo.grg}.
\begin{verbatim}
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_Foo;
using de.unika.ipd.grGen.Model_Foo;
\end{verbatim}

Then we create a graph with a model bound at generation time, followed by the actions to operate on this graph.
Afterwards, we create a single node of type \texttt{Bar} in the graph and save it to the variable \texttt{b}.
Finally, we apply the action \texttt{bar(Bar x) : (Bar)} on the graph, with \texttt{b} as input, also receiving the output.
The rule is taken from the actions via the member named as the action.
\begin{verbatim}
FooGraph graph = new FooGraph();
FooActions actions = new FooActions(graph);
Bar b = graph.CreateNodeBar();
actions.bar.Apply(graph, b, ref b); // input of type Bar, output of type Bar
\end{verbatim}

We could create a named graph instead, offering to access graph elements by persistent names:
\begin{verbatim}
FooNamedGraph graph = new FooNamedGraph();
\end{verbatim}
\end{example}

\begin{example}
This is an example showing how to do mostly the same what was done in the previous example \ref{ex:api1}, in a slightly more complicated way, but allowing for more control.
Here, we create the model separately from the graph, then the graph as instance of the generic \texttt{LGSPGraph}, which has the model not bound at generation time, but gets it handed in.
We create the actions to apply on the graph, and a single node of type \texttt{Bar} in the graph, which we assign again to a variable \texttt{b}.
Then we get the action from the actions and save it to an action variable \texttt{bar}.
Afterwards, we use the action for finding all available matches of \texttt{bar} with input \texttt{b}, and remember the found matches in the exactly typed \texttt{matches} variable.
Finally, we take the first match from the matches and execute the rewrite on it.
We could have inspected the nodes and edges of the match or their attributes before (using element names prefixed with \texttt{node\_/edge\_} or attribute names to get exactly typed entities). 
\begin{verbatim}
IGraphModel model = new FooGraphModel();
LGSPGraph graph = new LGSPGraph(model);
FooActions actions = new FooActions(graph);
Bar b = Bar.CreateNode(graph);
IAction_bar bar = Action_bar.Instance;
IMatchesExact<Rule_bar.IMatch_bar> matches = bar.Match(graph, 0, b);
bar.Modify(graph, matches.First);
\end{verbatim}

We could create a named graph instead offering persistent names for its graph elements:
\begin{verbatim}
LGSPGraph graph = new LGSPNamedGraph(model);
\end{verbatim}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface of the Graph Processing Environment}\label{sec:procenv}

The graph processing environment -- which is used for all but the simplest transformations -- offers all the additional functionality of \GrG~exceeding what is offered by the graph and the actions.
It is made available by the interface \texttt{IGraphProcessingEnvironment}, which is implemented in the \texttt{LGSPGraphProcessing\-Environment} class.

\begin{example}\label{ex:procenv}
The graph processing environment \texttt{procEnv} is constructed on top of the the graph and the actions, both of which are handed in.
It allows to carry out transformations by executing sequences, combining actions with operators (for control-flow) and variables (for data-flow).

\begin{verbatim}
IGraphProcessingEnvironment procEnv = 
    new LGSPGraphProcessingEnvironment(graph, actions);
procEnv.ApplyGraphRewriteSequence("<(::x)=foo && (::y)=bar(::x) | bla(::y)>");
\end{verbatim}
\end{example}

In addition to sequence execution and variable handling, the graph processing environment offers driver or helper objects for transaction management, deferred sequence execution, graph change recording, and output emitting.
The most important of these is the transaction manager which is utilized when \GrG~ is used for crawling through a search space or for enumerating a state space, see section \ref{sec:extctrl}.
The operations mentioned there are implemented by calling the functions given in example \ref{ex:transman}.

\begin{example}\label{ex:transman}
\begin{verbatim}
LGSPGraphProcessingEnvironment procEnv = ...;
ITransactionManager tm = procEnv.TransactionManager;
public interface ITransactionManager
{
    int Start();
    void Pause();
    void Resume();
    void Commit(int transactionID);
    void Rollback(int transactionID);
    void ExternalTypeChanged(IUndoItem item);
}
\end{verbatim}
\end{example}

The \texttt{Start} starts a transaction and returns its id; it may be called multiple times returning different ids for the transactions (i.e. nested transactions are supported, a failing outer one rolls back the changes of an inner transaction which succeeded).
Changes to the graph are recorded thereafter into an undo log, unless a \texttt{Pause} was called not yet followed by a \texttt{Resume}.
When the changes of interest were carried out, the transaction identified by its id is either \texttt{Commit}ed, which causes the changes recorded since the corresponding \texttt{Start} to stay in the graph, or rolled back by calling \texttt{Rollback}, in that case all the changes recorded since the corresponding \texttt{Start} are undone.
The \texttt{ExternalTypeChanged} allows you to include external attribute types in transaction handling, you must supply an undo item capable of rolling back the changes to the transaction manager, for each type a change is to be carried out.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Import/Export and Miscellaneous Stuff}\label{sub:imexport}\indexmain{import}\indexmain{export}

GrGen natively supports the following formats:
\begin{description}
  \item[GRS/GRSI] Graph Rewrite Script files, which are a reduced version of the \GrShell\ script files (also ending with \texttt{.grs}), limited to graph creation commands. They expect a model in a \texttt{.gm} file. This is the recommended standard format.
  \item[GXL] Graph eXchange Language files, ending with \texttt{.gxl}, see \url{http://www.gupro.de/GXL/}.
  \item[ECORE/XMI] Ecore(\texttt{.ecore}) model files and XMI(\texttt{.xmi}) graph files, which are formats defined and used by the Eclipse Modelling Framework. In an intermediate step, a \texttt{.gm} file is generated for the model.
  \item[GRG] A GrGen rule file containing one rule with an empty pattern and a large rewrite part. Export only \footnote{Original German Pisswasser, for export only :)}, not for normal use.
\end{description}

While both GRS and GXL importers expect one file
(the GXL importer allows to specify a model override, see \GrShell\ import, Note \ref{shellgxlimport}),
the EMF/ECORE importer expects first one or more \texttt{.ecore} files,
and following optionally an \texttt{.xmi} file and/or a \texttt{.grg} file (see Note \ref{shellecoreexport} for more on this). 

To import a graph model and/or a graph instance, you can use \texttt{Porter.Import()} from the libGr API (the GrShell command \texttt{import} is mapped to it).
The file format is determined by the file extensions.
To export a graph instance you can use \texttt{Porter.Export()} from the libGr API (the GrShell command \texttt{export} is mapped to it).
For an example of how to use the importer/exporter on API level see \texttt{examples-api/Java\-Program\-Graphs\-Example/Java\-Program\-Graphs\-Example.cs}

The GRS(I) importer (the \texttt{.grsi} ending stands for graph rewrite script include) returns an \texttt{INamedGraph};
if you don't need the persistent names, get rid of them by casting to the \texttt{LGSPNamedGraph} implementing the interface, (copy-)constructing a \texttt{LGSPGraph} from it, and removing any references to the named graph.
You may do so because naming is rather expensive (even though worthwhile in the general case):
a \texttt{LGSPNamedGraph} supplying the name to element and element to name mappings normally uses up about twice the amount of memory of the \texttt{LGSPGraph} defining the graph alone.

\subsection*{External Emitting and Parsing}\label{sub:apiextemitparse}
If \texttt{external emit class;} or \texttt{external emit graph class;} (see \ref{sub:extemitparse}) are specified in the model file \texttt{Foo}, \GrG~generates a file \texttt{FooModelExternalFunctions.cs} located beside the model and rule files,
containing the following functions.

\begin{csharplet}
/// <summary>
/// Called during .grs import, at exactly the position in the text reader where the attribute begins.
/// For attribute type object or a user defined type, which is treated as object.
/// The implementation must parse from there on the attribute type requested.
/// It must not parse beyond the serialized representation of the attribute, 
/// i.e. Peek() must return the first character not belonging to the attribute type any more.
/// Returns the parsed object.
/// </summary>
object Parse(TextReader reader, AttributeType attrType, IGraph graph);

/// <summary>
/// Called during .grs export, the implementation must return a string representation for the attribute.
/// For attribute type object or a user defined type, which is treated as object.
/// The serialized string must be parseable by Parse.
/// </summary>
string Serialize(object attribute, AttributeType attrType, IGraph graph);

/// <summary>
/// Called during debugging or emit writing, the implementation must return a string representation for the attribute.
/// For attribute type object or a user defined type, which is treated as object.
/// The attribute type may be null.
/// The string is meant for consumption by humans, it does not need to be parseable.
/// </summary>
string Emit(object attribute, AttributeType attrType, IGraph graph);
\end{csharplet}

\pagebreak

The \texttt{Parse} function is called when an attribute of an external or object type is to be imported from a grs file.

The \texttt{Serialize} function is called when an attribute of an external or object type is to be exported to a grs file.

The \texttt{Emit} function is called when a value of external or object type is to be emitted, or displayed in the debugger (including yComp).

The functions forward the calls to \texttt{ParseImpl}, \texttt{SerializeImpl}, and \texttt{EmitImpl} functions, respectively, which have to be implemented in a file named \texttt{Foo\-Model\-External\-Functions\-Impl.cs}, located in the folder of the \texttt{Foo\-Model\-External\-Functions.cs} file.
Implementing them is \emph{your} task, in exchange you get a tight integration of your own datatypes into \GrG.
For an example, you may have a look at \texttt{External\-Attribute\-Evaluation} in the \texttt{tests} folder or \texttt{External\-Attribute\-Evaluation\-Example} in the \texttt{examples-api} folder.

The functions are called from \GrShell, too, insofar as possible -- the shell parses a single or double quoted text or a word or a number at an attribute position and hands that over then to the user defined parser.

\begin{csharplet}
/// <summary>
/// Called when the grs importer or the shell hits a line starting with "external".
/// The content of that line is handed in.
/// This is typically used while replaying changes containing a method call of an external type
/// -- after such a line was recorded, by the method called, by writing to the recorder.
/// This is meant to replay fine-grain changes of graph attributes of external type,
/// in contrast to full assignments handled by Parse and Serialize.
/// </summary>
void External(string line, IGraph graph);
\end{csharplet}

The \texttt{External} function is called when a line starting with \texttt{external} is seen by the shell or the grs importer, in this case the content up to the end of the line is munched and handed in to this function.
These lines are typically recorded by calls of the \texttt{public void External(string value)} function supplied in the \texttt{IRecorder} interface, from external attribute method calls (cf. \ref{sub:extcls}), for persisting changes of the external method calls.
For assignments of complete attribute values, you must implement \texttt{Parse} and \text{Serialize}.
The \texttt{External} function is existing to support fine-grain changes of external attribute types.

\begin{csharplet}
/// <summary>
/// Called during debugging on user request, the implementation must return a named graph representation for the attribute.
/// For attribute type object or a user defined type, which is treated as object.
/// The attribute type may be null. The return graph must be of the same model as the graph handed in.
/// The named graph is meant for display in the debugger, to visualize the internal structure of some attribute type.
/// This way you can graphically inspect your own data types which are opaque to GrGen with its debugger.
/// </summary>
INamedGraph AsGraph(object attribute, AttributeType attrType, IGraph graph);
\end{csharplet}

The \texttt{AsGraph} function is called from the debugger on user request, to visually inspect an external attribute type, rendered as graph.
It will be called when \texttt{external emit graph class;} was specified.
It forwards the call to \texttt{AsGraphImpl}, which needs to be implemented by \emph{you}, in the same way as specified above for the the functions called when \texttt{external emit class;} is given.

\subsection*{External Copying and Comparing}\label{sub:apiextcopycompare}

If \texttt{external copy class;} or \texttt{external == class;} or \texttt{external < class;} (see \ref{sub:extcopycompare}) are specified in the model file \texttt{Foo},
\GrG~generates a file \texttt{Foo\-Model\-External\-Functions.cs} located beside the model and rule files,
containing a \emph{partial} class \texttt{Attribute\-Type\-Object\-Copier\-Comparer}.
You have to implement the \texttt{Copy} or the \texttt{IsEqual} or the \texttt{IsLower} functions in the same partial class in \texttt{Foo\-Model\-External\-Functions\-Impl.cs}.
For every external type defined, another function showing that type in the input parameters is expected.

\begin{csharplet}
// Called when a graph element is cloned/copied.
// For attribute type object.
// If "copy class" is not specified, objects are copied by copying the reference, i.e. they are identical afterwards.
// All other attribute types are copied by-value (so changing one later on has no effect on the other).
public static object Copy(object);

// Called during comparison of graph elements from graph isomorphy comparison, or attribute comparison.
// For attribute type object.
// If "== class" is not specified, objects are equal if they are identical,
// i.e. by-reference-equality (same pointer); all other attribute types are compared by-value.
public static bool IsEqual(object, object);

// Called during attribute comparison.
// For attribute type object.
// If "< class" is not specified, objects can't be compared for ordering, only for equality.
public static bool IsLower(object, object);
\end{csharplet}

The \texttt{Copy} function is called when one of the copy operations offered in the rule language or the computation statements is executed, on a node or edge that bears attributes of object or a user-defined external type.

The \texttt{IsEqual} function is called when values (attributes) of object or a user-defined external type are compared with one of the equality operators,
or when two graphs are compared for isomorphy and the graph elements contain attributes of object or a user-defined external type.
The \texttt{IsLower} function is called when values (attributes) of object or a user-defined external type are compared with one of the relational operators.
A comparison for \texttt{u<=v} is mapped to an expression \verb#IsLower(u,v) || IsEqual(u,v)#, for this reason a \verb#< class;# specification requires a preceding \verb#== class;# specification.

Implementing these functions is \emph{your} task, in exchange you get a tight integration of your own datatypes into \GrG.
You may have a look at \texttt{tests/External\-Attribute\-Evaluation} or \texttt{examples\-api/External\-Attribute\-Evaluation\-Example} for an example.

\subsection*{Further Examples}

There are further examples available in the \texttt{examples-api} folder of the \GrG-distribution:
\begin{itemize} 
\item How to use the terse graph rewrite sequences on API level is shown in (cf. also \ref{sec:procenv})\\
\texttt{examples-api/BusyBeaverExample/BusyBeaverExample.cs}.\\
Alternatively, you could directly use your favourite .NET programming language for combining single rule applications, employing the type-safe interface.
\item How to use the old and new interface for accessing a match on API level is shown in\\
\texttt{examples-api/ProgramGraphsExample/ProgramGraphsExample.cs}.
\item How to use the visited\label{apiallocvisitflag} flags on API level is shown in\\
\texttt{examples-api/VisitedExample/VisitedExample.cs}.
\item How to analyze the graph and generate matchers based on this information -- which are (hopefully) performing better -- is shown in\\
\texttt{examples-api/BusyBeaverExample/BusyBeaverExample.cs}.
\item How to compile a \texttt{.grg}-specification at runtime and dump a graph for visualization in \texttt{.vcg} format on API level is shown in\\
\texttt{examples-api/HelloMutex/HelloMutex.cs}.
\item How to access the annotations at API level is shown in\\
\texttt{examples-api/MutexDirectExample/MutexDirectExample.cs}.
\item How to communicate with yComp on API level (from your own code) is shown in\\
\texttt{examples-api/YCompExample/YCompExample.cs} (it may be outdated, you better take a look at \texttt{GrShell/YCompClient.cs} for the real version).
\end{itemize}

\begin{warning}
While C\# allows input argument values to be of a subtype of the declared interface parameter type (OO), 
it requires the argument variables for the \texttt{out} parameters to be of exactly the type declared (non-OO).
Although a variable of a supertype would be fully sufficient -- the variable is only assigned.
So for \texttt{node class Bla extends Bar;} and action \texttt{bar(Bar x) : (Bla)} from the rules file \texttt{Foo.grg}
we cannot use a desired target variable of type \texttt{Bar} as \texttt{out}-argument,
but are forced to introduce a temporary variable of type \texttt{Bla}
and assign this variable to the desired target variable after the call.
\begin{csharplet}
using de.unika.ipd.grGen.libGr;
using de.unika.ipd.grGen.lgsp;
using de.unika.ipd.grGen.Action_Foo;
using de.unika.ipd.grGen.Model_Foo;
FooGraph graph = new FooGraph();
FooActions actions = new FooActions(graph);
Bar b = graph.CreateNodeBar();
IMatchesExact<Rule_bar.IMatch_bar> matches = actions.bar.Match(graph, 1, b);
//actions.bar.Modify(graph, matches.First, out b); // wont work, needed:
Bla bla = null; 
actions.bar.Modify(graph, matches.First, out bla);
b = bla;
\end{csharplet}
\end{warning}

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{External Class, Function and Procedure Implementation}\label{sub:extclsfctimpl}\indexmain{external class implementation}\indexmain{external function implementation}\indexmain{external procedure implementation}

For a model file \texttt{Foo} that contains 
\begin{itemize}
	\item external classes (cf. \ref{sub:extcls}), or
	\item external functions (cf. \ref{sub:extfct}), or 
	\item external procedures (cf. \ref{sub:extproc}), 
\end{itemize}
\GrG~generates a file \texttt{FooModelExternalFunctions.cs} located beside the model and rule files, which contains
\begin{itemize}
	\item within the model namespace public partial classes named as given in the external class declaration,
inheriting from each other as stated in the external class declarations.
	\item within the \texttt{de.unika.ipd.grGen.expression} namespace a public partial class named \texttt{ExternalFunctions} with a body of comments giving the expected function prototypes.
	\item within the \texttt{de.unika.ipd.grGen.expression} namespace a public partial class named \texttt{ExternalProcedures} with a body of comments giving the expected procedure prototypes.
\end{itemize}

\noindent The generated partial classes come without implementation, you must implement them in a file named \texttt{Foo\-Model\-External\-Functions\-Impl.cs}, located in the folder of the \texttt{Foo\-Model\-External\-Functions.cs} file, by replicating them, and fleshing them out:
\begin{itemize}
	\item the partial classes skeletons with attributes containing data of interest and maybe helper methods
	\item the \texttt{ExternalFunctions} partial class skeleton with the functions you declared in the external function declarations, obeying the function signatures as specified;
here you can access the attributes or methods of the external classes (which are known at this point in the code, they are not known in the specification language), or carry out complicated custom computations or graph queries, based on the values you receive with the function call.
	\item the \texttt{ExternalProcedures} partial class skeleton with the procedures you declared in the external procedure declarations, obeying the procedure signatures as specified;
here you can access the attributes or methods of the external classes (which are known at this point in the code, they are not known in the specification language), or carry out complicated custom computations or graph manipulations, based on the values you receive with the procedure call.
\end{itemize}

\noindent Don't forget that the source code file \texttt{Foo\-Model\-External\-Functions\-Impl.cs} is an integral part of your \GrG~graph transformation project, in contrast to the other C\# files that are generated (and get overwritten).
You find a fabricated example showing how to use the external classes and functions in \texttt{examples/External\-Attribute\-Evaluation\-Example} and \texttt{examples-api/External\-Attribute\-Evaluation\-Example}.

When you use third-party assemblies in your source code, you must inform GrGen.NET about them, so references to them are included into the assembly generated; this can be done with the \texttt{-r} parameter when calling \texttt{grgen.exe} directly (cf. \ref{grgenoptions}) or with the \texttt{new add reference} command of \GrShell\~(cf. \ref{sec:compilerconfigshell}). 
Using the \texttt{keepdebug} configuration option of the \texttt{new} command is recommended as it allows for easier debugging.

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{External Filter and Sequence Implementation}\label{sub:extfltseqimpl}\indexmain{external match filter implementation}\indexmain{external sequence implementation}

For an actions file \texttt{Bar} that contains
\begin{itemize}
	\item external match filter declarations (cf. \ref{sub:extflt}), or
	\item external sequence declarations (\ref{sub:extseq}),
\end{itemize}
\GrG~generates a file \texttt{BarActionsExternalFunctions.cs} located beside the model and rule files, which contains within the action namespace 
\begin{itemize}
	\item a public partial class named \texttt{MatchFilters} with a body of comments giving the expected function prototypes, and for the \texttt{auto} filter even the implementation.
	\item public partial classes, named \texttt{Sequence\_foo} for a sequence \texttt{foo}, with a body containing a comment specifying the expected function prototype of the sequence application function.
\end{itemize}

\noindent The partial classes come without implementation, you must implement them in a file named \texttt{Bar\-Actions\-External\-FunctionsImpl.cs}, located in the folder of the \texttt{Bar\-Actions\-External\-Functions.cs} file, by replicating them, and fleshing them out:
\begin{itemize}
	\item the \texttt{MatchFilters} partial class skeleton with the match filter functions you declared, obeying the function signatures as specified; you might want to convert the received matches object to an \texttt{IList} in case you want to reorder the list and reinject it into the matches object afterwards.
	\item the partial class skeletons of the external sequences with the required \texttt{ApplyXGRS\_foo} functions, obeying the signature of the sequence application function as specified.
\end{itemize}

\noindent Don't forget that the source code file \texttt{Bar\-Actions\-External\-Functions\-Impl.cs} is an integral part of your \GrG~graph transformation project, in contrast to the other C\# files that are generated (and get overwritten).
You find a fabricated example showing how to use the external classes and functions in \texttt{examples/External\-Filters\-And\-Sequences\-Example} and \texttt{examples-api/External\-Filters\-And\-Sequences\-Example}.

When you use third-party assemblies in your source code, you must inform GrGen.NET about them, so references to them are included into the assembly generated; this can be done with the \texttt{-r} parameter when calling \texttt{grgen.exe} directly (cf. \ref{grgenoptions}) or with the \texttt{new add reference} command of \GrShell\~(cf. \ref{sec:compilerconfigshell}). 
Using the \texttt{keepdebug} configuration option of the \texttt{new} command is recommended as it allows for easier debugging.

%todo: is this note needed? content from filter chapter?
\begin{note}\label{note:inspect}
\LibGr\ allows to split a rule application into two steps:
Firstly, searching for the subgraphs of the host graph that match the pattern, and secondly rewriting of some of these matches. 

This occurs by employing the following methods of the \texttt{IAction} interface:
\begin{csharplet}
IMatches Match(IGraph graph, int maxMatches, object[] parameters);
object[] Modify(IGraph graph, IMatch match);
\end{csharplet}

In C\#, this might look like:
\begin{csharplet}
IMatches myMatches = myAction.Match(myGraph, -1, null); /* -1: get all the matches */
for(int i=0; i<myMatches.NumMatches; ++i)
{
	if(inspectCarefully(myMatches.GetMatch(i))
	{
		myAction.Modify(myGraph, myMatches.GetMatch(i));
		break;
	}
}
\end{csharplet}

The external match filters are executed in place of the \texttt{inspectCarefully}, in between the calls to the \texttt{Match} and the \texttt{Modify} functions.
They allow you to write a complex inspection routine in a .NET language, that can then still be used from \GrG\~ internal sequences.
An interesting filter can be even generated automatically for you, the \texttt{auto} filter for filtering symmetric matches of automorphic patterns, see \ref{sub:extflt} and \ref{sub:filters} for more on this.
\end{note}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph Events}\label{sec:graphevent}

Before or after the host graph is changed, events are fired, notifying listeners about the changes.
The \GrShell-debugger, the transaction handler, and the graph change recorder implement their functionality by listening and reacting to these events.
You may add own event handlers to insert custom-made, event-based functionality;
or may even implement an event-driven rule execution engine on top of it.

The events are fired automatically by the methods of the graph class on modifications (excluding attribute changes),
and by the actions which get applied.
If you operate with external code, it's your responsibility to fire the events for attribute changes before changing an attribute.
Otherwise the changes won't be visible in the debugger, they won't be rolled back at the end of a transactions or during backtracking, and they won't be recorded in case of change recording.

The events available that are fired automatically on graph changes (excluding attribute value changes) are:

\begin{csharplet}
// Fired after a node has been added
event NodeAddedHandler OnNodeAdded;

// Fired after an edge has been added
event EdgeAddedHandler OnEdgeAdded;

// Fired before a node is deleted
event RemovingNodeHandler OnRemovingNode;

// Fired before an edge is deleted
event RemovingEdgeHandler OnRemovingEdge;

// Fired before all edges of a node are deleted
event RemovingEdgesHandler OnRemovingEdges;

// Fired before the whole graph is cleared
event ClearingGraphHandler OnClearingGraph;

// Fired before the type of a node is changed.
event RetypingNodeHandler OnRetypingNode;

// Fired before the type of an edge is changed.
event RetypingEdgeHandler OnRetypingEdge;

// Fired before an edge is redirected (causing removal then adding again).
event RedirectingEdgeHandler OnRedirectingEdge;
\end{csharplet}

The events available that are fired automatically on attribute value changes of graph elements by the code generated to implement the actions, but not by the graph, and thus need to be fired by you if you change attribute values on API level, are:

\begin{csharplet}
// Fired before an attribute of a node is changed.
event ChangingNodeAttributeHandler OnChangingNodeAttribute;

// Fired before an attribute of an edge is changed.
event ChangingEdgeAttributeHandler OnChangingEdgeAttribute;

// Fired before each rewrite step (also rewrite steps of subpatterns) to indicate 
// the names of the nodes added in this rewrite step in order of addition.
event SettingAddedElementNamesHandler OnSettingAddedNodeNames;

// Fired before each rewrite step (also rewrite steps of subpatterns) to indicate 
// the names of the edges added in this rewrite step in order of addition.
event SettingAddedElementNamesHandler OnSettingAddedEdgeNames;
\end{csharplet}

If you listen to or fire the action application events (cf. \ref{sec:actionevent}), you may be interested in the added names event from the list above, too, which tells about the names of the elements which will get added immediately thereafter (this is used in the debugger to display the names of the elements as defined in the rule modify part).

For a container type this means single element additions or removals, that's the reason why the interface for attribute changes is more complex than what you'd expect intuitively:\\ 
\verb#void ChangingNodeAttribute(INode node, AttributeType attrType,#\\
\verb#AttributeChangeType changeType, Object newValue, Object keyValue)#

The chang\emph{ing} attribute events from above are fired before the attributes are assigned, with the single element change that will occur. 
They are used e.g. by the transaction manager to record the changes (note that rollback of changes of attributes of container type requires single element notifications, complete container copies would be prohibitively costly).

The conditional watchpoints that may be configured in the debugger in contrast hook into the chang\emph{ed} attribute events that are fired after an attribute was assigned. These are:

\begin{csharplet}
// Fired after an attribute of a node is changed; for debugging purpose.
event ChangedNodeAttributeHandler OnChangedNodeAttribute;

// Fired after an attribute of an edge is changed; for debugging purpose.
event ChangedEdgeAttributeHandler OnChangedEdgeAttribute;
\end{csharplet}

The events available that are fired automatically on visited flag changes are:

\begin{csharplet}
/// Fired after a visited flag was allocated.
event VisitedAllocHandler OnVisitedAlloc;

/// Fired after a visited flag was freed.
event VisitedFreeHandler OnVisitedFree;

/// Fired before a visited flag is set.
event SettingVisitedHandler OnSettingVisited;
\end{csharplet}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Action Events}\label{sec:actionevent}

When actions (esp. rules) are executed, events are fired, notifying listeners about the changes.
The \GrShell-debugger implements its functionality by listening and reacting to these events.
You may add own event handlers to insert custom-made, event-based functionality.

The events are fired automatically by the code generated by GrGen for the actions or sequences.
If you operate with external code, it's your responsibility to fire the events -- in case you want to simulate rules or sequences.
Otherwise the changes won't be visible in the debugger.

The action based events that are declared by the \texttt{IActionExecutionEnvironment} are:

\begin{csharplet}
// Fired after all requested matches of a rule have been matched.
event AfterMatchHandler OnMatched;

// Fired before the rewrite step of a rule, when at least one match has been found.
event BeforeFinishHandler OnFinishing;

// Fired before the next match is rewritten. It is not fired before rewriting the first match.
event RewriteNextMatchHandler OnRewritingNextMatch;

// Fired after the rewrite step of a rule.
// Note, that the given matches object may contain invalid entries,
// as parts of the match may have been deleted!
event AfterFinishHandler OnFinished;
\end{csharplet}

The subrule based events that are declared by the \texttt{ISubaction\-And\-Output\-Addition\-Environment} extending the \texttt{IActionExecutionEnvironment} are:

\begin{csharplet}
// Fired when a debug entity is entered.
event DebugEnterHandler OnDebugEnter;

// Fired when a debug entity is left.
event DebugExitHandler OnDebugExit;

// Fired when a debug emit is executed.
event DebugEmitHandler OnDebugEmit;

// Fired when a debug halt is executed.
event DebugHaltHandler OnDebugHalt;

// Fired when a debug highlight is executed.
event DebugHighlightHandler OnDebugHighlight;
\end{csharplet}

A special kind of sequence based events are the graph change events that are fired when processing enters a subgraph or leaves a subgraph (fired when the subgraph usage stack is altered):

\begin{csharplet}
// Fired when graph processing (rule and sequence execution) is switched to a (sub)graph.
// (Not fired when the main graph is replaced by another main graph, or initialized.)
event SwitchToSubgraphHandler OnSwitchingToSubgraph;

// Fired when graph processing is returning back after a switch.
// (To the main graph, or a subgraph previously switched to.)
event ReturnFromSubgraphHandler OnReturnedFromSubgraph;
\end{csharplet}

The sequence based events that are declared by the \texttt{IGraph\-Processing\-Environment} extending the \texttt{ISubaction\-And\-Output\-Addition\-Environment} are:

\begin{csharplet}
// Fired when a sequence is entered.
event EnterSequenceHandler OnEntereringSequence;

// Fired when a sequence is left.
event ExitSequenceHandler OnExitingSequence;

// Fired when a sequence iteration is ended.
event EndOfIterationHandler OnEndOfIteration;
\end{csharplet}
