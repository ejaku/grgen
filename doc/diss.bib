This file was created with JabRef 2.2.
Encoding: UTF-8

@INPROCEEDINGS{CHHK:06,
  author = {Andrea Corradini and Tobias Heindel and Frank Hermann and Barbara
	K{\"o}nig},
  title = {Sesqui-Pushout Rewriting.},
  booktitle = {ICGT},
  year = {2006},
  pages = {30-45},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  crossref = {ICGT:2006},
  ee = {http://dx.doi.org/10.1007/11841883_4}
}

@INPROCEEDINGS{GBGHS:06,
  author = {Rubino Gei{\ss} and Gernot Veit Batz and Daniel Grund and Sebastian
	Hack and Adam Szalkowski},
  title = {{GrGen: A Fast SPO-Based Graph Rewriting Tool.}},
  booktitle = {ICGT},
  year = {2006},
  pages = {383-397},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  crossref = {ICGT:2006},
  ee = {http://dx.doi.org/10.1007/11841883_27}
}

@INPROCEEDINGS{DBLP:conf/wadt/Rosu04,
  author = {Grigore Rosu},
  title = {From Conditional to Unconditional Rewriting.},
  booktitle = {WADT},
  year = {2004},
  pages = {218-233},
  note = {betrachten nur termrewriting, die conditions sind komplexere als
	die in grgen},
  abstract = {An automated technique to translate conditional rewrite rules into
	unconditional ones is presented, which is suitable to implement,
	or compile, conditional rewriting on top of much simpler and easier
	to opti- mize unconditional rewrite systems. An experiment performed
	on world's fastest conditional rewriting engines shows that speedups
	for conditional rewriting of an order of magnitude can already be
	obtained by applying the presented technique as a front-end transformation.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  crossref = {DBLP:conf/wadt/2004},
  ee = {http://springerlink.metapress.com/openurl.asp?genre=article{\&}issn=0302-9743{\&}volume=3423{\&}spage=218}
}

@INPROCEEDINGS{AV:96:SGI,
  author = {Steffen Abraham and Klaus Voss},
  title = {Erweiterte diskrete Relaxationsalgorithmen zum Subgraph-Isomorphie-Problem},
  booktitle = {DAGM-Symposium},
  year = {1996},
  pages = {323-330},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  url = {http://portal.acm.org/citation.cfm?id=648281.754826}
}

@BOOK{Allen02Optimizing,
  title = {Optimizing compilers for modern architectures: a dependence-based
	approach},
  publisher = {Morgan Kaufmann Publishers},
  year = {2002},
  author = {Randy Allen and Ken Kennedy},
  pages = {790},
  address = {Los Altos, CA 94022, USA},
  isbn = {1-55860-286-0},
  lccn = {QA76.6 .A46 2002}
}

@PHDTHESIS{andries96graph,
  author = {M. Andries},
  title = {Graph Rewrite Systems and Visual Database Languages},
  year = {1996},
  url = {citeseer.nj.nec.com/andries96graph.html}
}

@ARTICLE{AndriesETAL96b,
  author = {Marc Andries and Gregor Engels and Annegret Habel and Berthold Hoffmann
	and Hans-J{\"o}rg Kreowski and Sabine Kuske and Detlef Plump and
	Andy Sch{\"u}rr and Gabriele Taentzer},
  title = {Graph Transformation for Specification and Programming},
  journal = {Science of Computer Programming},
  year = {1999},
  volume = {34},
  pages = {1--54},
  number = {1}
}

@BOOK{Appel98,
  title = {{Modern Compiler Implementation in C}},
  publisher = {Cambridge University Press, Cambridge, UK},
  year = {1998},
  author = {A.W. Appel},
  topics = {Optimizations in General}
}

@ARTICLE{assmann00graph,
  author = {Uwe Assmann},
  title = {Graph rewrite systems for program optimization},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  year = {2000},
  volume = {22},
  pages = {583--637},
  number = {4},
  doi = {http://doi.acm.org/10.1145/363911.363914},
  issn = {0164-0925},
  publisher = {ACM Press}
}

@TECHREPORT{Bat:06,
  author = {Gernot Veit Batz},
  title = {An {O}ptimization {T}echnique for {S}ubgraph {M}atching {S}trategies},
  institution = {Universit\"at Karlsruhe, Fakult\"at f\"ur Informatik},
  year = {2006},
  number = {2006-7},
  month = {April},
  issn = {1432-7864},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@MASTERSTHESIS{Bat:05:DA,
  author = {Gernot Veit Batz},
  title = {Graphersetzung f\"ur eine {Z}wischendarstellung im \"{U}bersetzerbau},
  school = {Universit\"at Karlsruhe},
  year = {2005},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@MISC{Bat:05:SA,
  author = {Veit Batz},
  title = {Generierung von {G}raphersetzungen mit programmierbarem {S}uchalgorithmus},
  howpublished = {Studienarbeit},
  year = {2005},
  abstract = {Im Rahmen der vorliegenden Studienarbeit wurde ein neues Backend f{\"u}r
	das generativ arbeitende Graphersetzungswerkzeug GrGen implementiert.
	F{\"u}r das Teilgraphmatching kommt ein programmierbarer Suchalgorithmus
	zum Einsatz, wodurch der nachtr{\"a}gliche Einbau von dynamischen
	Suchplanern vorbereitet ist. Die Datenstruktur f{\"u}r den bearbeiteten
	Graphen folgt dem Prinzip der rahmenbasierten Speicheranordnung,
	das von Heiko D{\"o}rr vorgeschlagen worden ist. {\"U}berlegungen
	zum praktikablen Einsatz der virtuellen Maschine weisen auf eine
	ebenfalls von Heiko D{\"o}rr entwickelte Methode hin, mit der sich
	gï¿½unstigere Matcher-Programme konstruieren lassen. Mit Hilfe der
	besonderen Graphspeicherung geht dies bis hin zu einem Teilgraphmatching,
	dessen asymptotischer Zeitaufwand proportional zur Gr{\"o}{\ss}e
	des zu findenden Graphmusters ist. Wegen der NP-Vollst{\"a}ndigkeit
	des zugrunde liegenden Problems ist dies nat{\"u}rlich nicht immer
	m{\"o}glich. Mit einer naiven Graphspeicherung arbeitete das System
	im Experiment jedoch schneller. Im Vergleich zu dem bisher verwendeten
	Backend, das die anfallenden Aufgaben an eine SQL-Datenbank delegiert,
	bringt das neue Backend einen deutlichen Laufzeitvorteil. Unzusammenh{\"a}ngende
	Graphmuster, negative Anwendungsbedingungen (NACs) und Attributberechnungen
	werden jedoch nicht unterst{\"u}tzt.},
  institution = {Universit{\"a}t Karlsruhe},
  school = {IPD Goos},
  url = {http://www/papers/sa_batz.pdf}
}

@TECHREPORT{blostein95practical,
  author = {D. Blostein and H. Fahmy and A. Grbavec},
  title = {Practical use of graph rewriting},
  year = {1995},
  number = {95-373},
  address = {CDN},
  url = {citeseer.nj.nec.com/blostein95practical.html}
}

@INPROCEEDINGS{Car:02:RDF,
  author = {Jeremy J. Carroll},
  title = {Matching RDF Graphs},
  booktitle = {ISWC '02: Proceedings of the First International Semantic Web Conference
	on The Semantic Web},
  year = {2002},
  pages = {5--15},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-43760-6}
}

@ARTICLE{codd,
  author = {E. F. Codd},
  title = {A relational model of data for large shared data banks},
  journal = {Commun. ACM},
  year = {1970},
  volume = {13},
  pages = {377--387},
  number = {6},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/362384.362685},
  issn = {0001-0782},
  publisher = {ACM Press}
}

@ARTICLE{CFSV:04:30years,
  author = {Donatello Conte and Pasquale Foggia and Carlo Sansone and Mario Vento},
  title = {{Thirty years of Graph Matching in Pattern Recognition}},
  journal = {International Journal of Pattern Recognition and Artificial Intelligence},
  year = {2004},
  volume = {18},
  pages = {265--298},
  number = {3},
  month = {may},
  abstract = {A recent paper posed the question: "Graph Matching: What are we really
	talking about?". Far from providing a definite answer to that question,
	in this paper we will try to characterize the role that graphs play
	within the Pattern Recognition field. To this aim two taxonomies
	are presented and discussed. The first includes almost all the graph
	matching algorithms proposed from the late seventies, and describes
	the different classes of algorithms. The second taxonomy considers
	the types of common applications of graph-based techniques in the
	Pattern Recognition and Machine Vision field.},
  doi = {doi:10.1142/S0218001404003228}
}

@BOOK{CT:04,
  title = {Engineering a Compiler},
  publisher = {Morgran Kaufmann Publishers},
  year = {2004},
  author = {Keith D. Cooper and Linda Torczon},
  abstract = {The proliferation of processors, environments, and constraints on
	systems has cast compiler technology into a wider variety of settings,
	changing the compiler and compiler writer's role. No longer is execution
	speed the sole criterion for judging compiled code. Today, code might
	be judged on how small it is, how much power it consumes, how well
	it compresses, or how many page faults it generates. In this evolving
	environment, the task of building a successful compiler relies upon
	the compiler writer's ability to balance and blend algorithms, engineering
	insights, and careful planning. Today's compiler writer must choose
	a path through a design space that is filled with diverse alternatives,
	each with distinct costs, advantages, and complexities.
	
	Engineering a Compiler explores this design space by presenting some
	of the ways these problems have been solved, and the constraints
	that made each of those solutions attractive. By understanding the
	parameters of the problem and their impact on compiler design, the
	authors hope to convey both the depth of the problems and the breadth
	of possible solutions. Their goal is to cover a broad enough selection
	of material to show readers that real tradeoffs exist, and that the
	impact of those choices can be both subtle and far-reaching.
	
	Authors Keith Cooper and Linda Torczon convey both the art and the
	science of compiler construction and show best practice algorithms
	for the major passes of a compiler. Their text re-balances the curriculum
	for an introductory course in compiler construction to reflect the
	issues that arise in current practice.
	
	Focuses on the back end of the compiler-reflecting the focus of research
	and development over the last decade. Uses the well-developed theory
	from scanning and parsing to introduce concepts that play a critical
	role in optimization and code generation. Introduces the student
	to optimization through data-flow analysis, SSA form, and a selection
	of scalar optimizations. Builds on this background to teach modern
	methods in code generation: instruction selection, instruction scheduling,
	and register allocation. Presents examples in several different programming
	languages in order to best illustrate the concept. Provides end-of-chapter
	exercises, with on-line solutions available to instructors.}
}

@ARTICLE{CFSV:04:SGI,
  author = {Luigi P. Cordella and Pasquale Foggia and Carlo Sansone and Mario
	Vento},
  title = {A (Sub)Graph Isomorphism Algorithm for Matching Large Graphs},
  journal = {IEEE Transactions on Pattern Analysis and Machine Intelligence},
  year = {2004},
  volume = {26},
  pages = {1367-1372},
  number = {10},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/TPAMI.2004.75},
  issn = {0162-8828},
  publisher = {IEEE Computer Society}
}

@INCOLLECTION{dpoapproach,
  author = {A. Corradini and U. Montanari and F. Rossi and H. Ehrig and R. Heckel
	and M. L\"owe},
  title = {Algebraic {A}pproaches to {G}raph {T}ransformation - {P}art {I}:
	{B}asic concepts and double pushout approach},
  booktitle = {\cite{roz}},
  year = {1999},
  volume = {1},
  pages = {163--245},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@ARTICLE{CFR:91,
  author = {Ron Cytron and Jeanne Ferrante and Barry K. Rosen and Mark N. Wegman
	and F. Kenneth Zadeck},
  title = {Efficiently computing static single assignment form and the control
	dependence graph},
  journal = {ACM Trans. Program. Lang. Syst.},
  year = {1991},
  volume = {13},
  pages = {451--490},
  number = {4},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/115372.115320},
  issn = {0164-0925},
  publisher = {ACM Press}
}

@BOOK{doerr,
  title = {Efficient {G}raph {R}ewriting and its {I}mplementation},
  publisher = {Springer-Verlag New York, Inc.},
  year = {1995},
  author = {Heiko D{\"o}rr},
  volume = {922},
  series = {LNCS},
  address = {Secaucus, NJ, USA},
  isbn = {0387600558}
}

@ARTICLE{Dew:84,
  author = {A. K. Dewdney},
  title = {A computer trap for the Busy Beaver, the hardest-working Turing machine},
  journal = {Scientic American},
  year = {1984},
  volume = {251},
  pages = {10--12, 16, 17},
  number = {2},
  month = {8}
}

@BOOK{Doe:95,
  title = {Efficient Graph Rewriting and Its Implementation},
  publisher = {Springer-Verlag New York, Inc.},
  year = {1995},
  author = {Heiko Dorr},
  address = {Secaucus, NJ, USA},
  isbn = {0387600558}
}

@INPROCEEDINGS{Ehrig90DPO,
  author = {Ehrig and Korff and Lï¿½we},
  title = {Tutorial introduction to the algebraic approach of graph grammars
	based on double and single pushouts},
  booktitle = {Graph-Grammars and Their Application to Computer Science},
  year = {1991},
  editor = {Hartmut Ehrig and Hans-J{\"o}rg Kreowski and Grzegorz Rozenberg},
  volume = {532},
  series = {Lecture Notes in Computer Science},
  pages = {24-37},
  publisher = {Springer},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  isbn = {3-540-54478-X}
}

@BOOK{ehrig06,
  title = {Fundamentals of {A}lgebraic {G}raph {T}ransformation},
  publisher = {Springer},
  year = {2006},
  author = {H. Ehrig and K. Ehrig and U. Prange and G. Taentzer},
  series = {Monographs in Theoretical Computer Science.}
}

@INCOLLECTION{spoapproach,
  author = {H. Ehrig and R. Heckel and M. Korff and M. L\"owe and L. Ribeiro
	and A. Wagner and A. Corradini},
  title = {Algebraic {A}pproaches to {G}raph {T}ransformation - {P}art {II}:
	{S}ingle {P}ushout {A}. and {C}omparison with {D}ouble {P}ushout
	{A}.},
  booktitle = {\cite{roz}},
  year = {1999},
  volume = {1},
  pages = {247--312},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@INPROCEEDINGS{EWB:04,
  author = {Alexandre E. Eichenberger and Peng Wu and Kevin O'Brien},
  title = {Vectorization for SIMD architectures with alignment constraints},
  booktitle = {Proceedings of the ACM SIGPLAN 2004 conference on Programming language
	design and implementation},
  year = {2004},
  pages = {82--93},
  publisher = {ACM Press},
  abstract = {When vectorizing for SIMD architectures that are commonly employed
	by today's multimedia extensions, one of the new challenges that
	arise is the handling of memory alignment. Prior research has focused
	primarily on vectorizing loops where all memory references are properly
	aligned. An important aspect of this problem, namely, how to vectorize
	misaligned memory references, still remains unaddressed.This paper
	presents a compilation scheme that systematically vectorizes loops
	in the presence of misaligned memory references. The core of our
	technique is to automatically reorganize data in registers to satisfy
	the alignment requirement imposed by the hardware. To reduce the
	data reorganization overhead, we propose several techniques to minimize
	the number of data reorganization operations generated. During the
	code generation, our algorithm also exploits temporal reuse when
	aligning references that access contiguous memory across loop iterations.
	Our code generation scheme guarantees to never load the same data
	associated with a single static access twice. Experimental results
	indicate near peak speedup factors, e.g., 3.71 for 4 data per vector
	and 6.06 for 8 data per vector, respectively, for a set of loops
	where 75\% or more of the static memory references are misaligned.},
  doi = {http://doi.acm.org/10.1145/996841.996853},
  isbn = {1-58113-807-5},
  location = {Washington DC, USA}
}

@INPROCEEDINGS{Epp:95:SGI,
  author = {David Eppstein},
  title = {Subgraph isomorphism in planar graphs and related problems},
  booktitle = {SODA '95: Proceedings of the sixth annual ACM-SIAM symposium on Discrete
	algorithms},
  year = {1995},
  pages = {632--640},
  address = {Philadelphia, PA, USA},
  publisher = {Society for Industrial and Applied Mathematics},
  isbn = {0-89871-349-8},
  location = {San Francisco, California, United States},
  url = {http://portal.acm.org/citation.cfm?id=313830}
}

@INCOLLECTION{agg,
  author = {C. Ermel and M. Rudolf and G. Taentzer},
  title = {The {AGG} {A}pproach: {L}anguage and {E}nvironment},
  booktitle = {\cite{roz}},
  year = {1999},
  volume = {2},
  pages = {551--603},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@MISC{fujaba,
  author = {{Fujaba Developer Team}},
  title = {Fujaba-{H}omepage},
  howpublished = {\url{http://www.fujaba.de/}},
  year = {2007},
  url = {http://www.fujaba.de/}
}

@ARTICLE{gabow,
  author = {H. N. Gabow and Z. Galil and T. Spencer and R. E. Tarjan},
  title = {Efficient algorithms for finding minimum spanning trees in undirected
	and directed graphs},
  journal = {Combinatorica},
  year = {1986},
  volume = {6},
  pages = {109--122},
  number = {2},
  address = {Secaucus, NJ, USA},
  issn = {0209-9683},
  publisher = {Springer-Verlag New York, Inc.}
}

@BOOK{intractable,
  title = {Computers and {I}ntractability; A {G}uide to the {T}heory of {NP}-{C}ompleteness},
  publisher = {W. H. Freeman \& Co.},
  year = {1990},
  author = {Michael R. Garey and David S. Johnson},
  address = {New York, NY, USA},
  isbn = {0716710455}
}

@MISC{grgen_web,
  author = {R. Gei{\ss}},
  institution = {Institut für Programmstrukturen und Datenorganisation, Universit{"\a}t Karlsruhe},
  title = {{\GrG}},
  howpublished = {\url{http://www.grgen.net}},
  month = {June},
  year = {2007},
}

@MASTERSTHESIS{Ge00Cacheoptimierung,
  author = {Rubino Gei{\ss}},
  title = {Schleifen{\"u}bergreifende Cacheoptimierung},
  year = {2000},
  month = {Oct},
  abstract = {Dies Arbeit zielt auf die Optimierung der Cacheausnutzung bei Ber{\"u}cksichtigung
	mehrerer Schleifenschachteln. Klassische Verfahren hingegen betrachten
	nur einzelnen Schleifen(schachteln). Diese Heuristiken erzeugen in
	der Regel statische Speicherabbildungen. Bei der Anordnung der Datenelemente
	im Speicher f{\"u}r mehrere Schleifenschachteln ist jedoch im Allgemeinen
	eine dynamische Abbildung n{\"o}tig. Der Schritt von einer Schachtel
	zu ein Folge von Schleifenschachteln ist deshalb so schwierig, weil
	es nicht das Problem nicht gierig optimal l{\"o}sbar ist. In dieser
	Arbeit werden klassische Techniken eingepasst und so erweitert, dass
	eine schleifen{\"u}bergreifende Optimierung m{\"o}glich wird. Die
	Idee dabei ist, aus verschiedene Vorschl{\"a}ge zur Speicheranordnung
	zu generieren, diese zu bewerten und dann (obschon nicht gierig optimal
	l{\"o}sbar) zu einer globalen L{\"o}sung zusammenzusetzen. Die Vorschlage
	k{\"o}nnen dabei von unterschiedlichen Verfahren stammen. In der
	Diplomarbeit wird untersucht unter welchen Einschr{\"a}nkungen und
	mit welchen Mitteln ein solches Rahmenwerk konstruiert kann. Die
	Ergebnisse einer prototypischen Implementierung werden pr{\"a}sentiert.},
  organization = {IPD Goos},
  url = {http://www.info.uni-karlsruhe.de/~rubino/Joses/da_ruby.ps.gz}
}

@INPROCEEDINGS{GG:78,
  author = {R. Steven Glanville and Susan L. Graham},
  title = {A New Method for Compiler Code Generation},
  booktitle = {Conference Record of the Fifth Annual ACM Symposium on Principles
	of Programming Languages},
  year = {1978},
  pages = {231--240},
  address = {Tucson, Arizona},
  month = jan
}

@MISC{godbole00performance,
  author = {Vikram Uday Godbole},
  title = {Performance Characterization of Intel's Internet Streaming SIMD Extensions},
  year = {2000},
  abstract = {this report represent an attempt to evaluate the efficacy of the Streaming
	SIMD Extensions in speeding up 3D geometry processing in commercial
	applications },
  url = {citeseer.nj.nec.com/godbole00performance.html}
}

@BOOK{GJSB:05,
  title = {Java\texttrademark Language Specification},
  publisher = {Addison-Wesley Professional},
  year = {2005},
  author = {James Gosling and Bill Joy and Guy Steele and Gilad Bracha},
  edition = {3},
  abstract = {Written by the inventors of the technology, The Java(TM) Language
	Specification, Third Edition, is the definitive technical reference
	for the Java(TM) programming language. If you want to know the precise
	meaning of the language's constructs, this is the source for you.
	The book provides complete, accurate, and detailed coverage of the
	Java programming language. It provides full coverage of all new features
	added since the previous edition, including generics, annotations,
	asserts, autoboxing, enums, for-each loops, variable arity methods,
	and static import clauses.}
}

@MISC{Gru:04,
  author = {Daniel Grund},
  title = {Negative {A}nwendungsbedingungen f\"ur den {G}raphersetzer \grgen\
	({S}tudienarbeit)},
  year = {2004},
  note = {Studienarbeit, Universit\"at Karlsruhe},
  abstract = {Das Graphersetzungssystem GrGen erzeugt Graphersetzer nach dem SPO-Ansatz.
	Die erzeugten Ersetzer sind in das am IPD entwickelte {\"U}bersetzer-Rahmenwerk
	CRS integriert. Die Verwendung von Graphersetzern zur Manipulation
	einer graphbasierten Zwischendarstellung (wie FIRM) stellt besondere
	Anforderungen an den Musterfinder (Matcher) des Graphersetzers. So
	soll das Finden eines Musters unter bestimmten Umst{\"a}nden vom
	Kontext des Mustergraphen im Programmgraphen abh{\"a}ngig gemacht
	werden. Dies leisten sogenannte negative Anwendungsbedingungen (NACs,
	Negative Application Conditions), die im Agg Projekt an der TU Berlin
	entwickelt wurden. Deren Theorie f{\"u}gt sich nahtlos in den SPO-Ansatz
	ein. Ziel der Studienarbeit ist die Erweiterung der GrGen-Musterfinder
	um jene NACs.},
  school = {Universit\"at Karlsruhe},
  url = {http://www.info.uni-karlsruhe.de/papers/sa_grund.pdf}
}

@ARTICLE{Goettler91Graph,
  author = {H. Gï¿½ttler and J. Gï¿½nther and G. Nieskens},
  title = {Use Graph Grammars to Design CAD-Systems!},
  year = {1991},
  volume = {Lecture Notes in Computer Science 532},
  pages = {396 - 410},
  booktitle = {Graph Grammars and Their Application to Computer Science},
  editor = {H. Ehrig et al.},
  publisher = {Springer}
}

@MISC{Goettler90PAGG,
  author = {H. Gï¿½ttler and G. Nieskens},
  title = {PAGG - Softwaremethode und Werkzeug fï¿½r die systematische Entwicklung
	von Diagramm-Editoren},
  year = {1990},
  publisher = {CeBit-Katalog/Presse-Information}
}

@MASTERSTHESIS{Hac:03,
  author = {Sebastian Hack},
  title = {{Graphersetzung f{\"u}r Optimierungen in der Codeerzeugung}},
  school = {IPD Goos},
  year = {2003},
  month = {12},
  abstract = {Diese Diplomarbeit beschreibt die theoretischen und praktischen Eigenschaften
	eines Graphersetzungssystems zur Manipulation von graphbasierten
	Zwischendarstellungen in {\"U}bersetzern. Das Werkzeug und der damit
	verbundene Formalismus wurden besonders f{\"u}r den Einsatz bei der
	Codeerzeugung entwickelt bzw. angepasst. Ein Schwerpunkt der Entwicklung
	wurde auf eine modulare Architektur und genaue Trennung der einzelnen
	Komponenten eines Graphersetzungssystems gelegt um das System flexibel
	erweiterbar bzw. anpassbar zu halten. Das Problem des Findens eines
	homomorphen Teilgraphen wurde mittels Ausdr{\"u}cken der relationalen
	Algebra formuliert. Die eigentliche Graphersetzung beruht auf dem
	etablierten SPO-Ansatz (Single-Pushout-Approach).},
  institution = {Universit{\"a}t Karlsruhe},
  url = {http://www.info.uni-karlsruhe.de/papers/da_hack.pdf}
}

@MASTERSTHESIS{Hof:05,
  author = {Enno Hofmann},
  title = {Regelerzeugung zur maschinenabh{\"a}ngigen Codeoptimierung},
  school = {IPD Goos},
  year = {2004},
  month = {November},
  abstract = {Multimedia-Befehle moderner Prozessorarchitekturen besitzen keine
	unmittelbaren Entsprechungen in Hochsprachen. Auch auf Zwischensprachebene
	werden solche Befehle zun{\"a}chst nicht direkt dargestellt. Sie
	k{\"o}nnen jedoch durch Graphmuster der Zwischensprache repr{\"a}sentiert
	werden. Klassische Codegeneratoren arbeiten nur auf Baumstrukturen,
	so dass komplexe Befehle nicht gefunden werden. Als L{\"o}sungsansatz
	verwenden wir Graphersetzungsregeln, welche die maschinenunabh{\"a}ngigen
	Muster der Befehle in architekturspezifische Baumstrukturen {\"u}berf{\"u}hren.
	Allerdings ist die manuelle Anfertigung der Muster zu aufw{\"a}ndig
	und fehleranf{\"a}llig.
	
	Im Rahmen des Projekts "Graphbasierte maschinenabh{\"a}ngige Codeerzeugung
	f{\"u}r nichttriviale Befehlss{\"a}tze" soll deshalb in dieser Diplomarbeit
	das automatische Generieren von Graphersetzungsregeln f{\"u}r komplexe
	Befehle untersucht werden. Diese Regeln werden durch C-Funktionen
	spezifiziert, um die Wirkung der Maschinenbefehle auszudr{\"u}cken.
	Dadurch wird eine einfache und von der Zwischensprache unabh{\"a}ngige
	Regelbeschreibung erzielt.},
  institution = {Universit{\"a}t Karlsruhe},
  url = {http://www/papers/da_hofmann.pdf}
}

@MASTERSTHESIS{Jak:04,
  author = {Hannes Jakschitsch},
  title = {Befehlsauswahl auf SSA-Graphen},
  school = {IPD Goos},
  year = {2004},
  month = {November},
  abstract = {Diese Diplomarbeit beschreibt den Entwurf und die Implementierung
	eines neuen Code-Generatorgenerators, der Befehlsauswahl auf SSA-Graphen
	durchf{\"u}hrt. Der Generator kann Aspekte der Rematerialisierung
	in den Optimierungsprozess miteinbeziehen. Unter bestimmten Einschr{\"a}nkungen
	k{\"o}nnen neben den {\"u}blichen Befehlen mit baumf{\"o}rmigen Muster
	auch Befehle mit DAG-f{\"o}rmigen Strukturen und mehreren Ergebnissen
	ausgenutzt werden. Alle verwendeten Algorithmen sind linear in Rechenzeit
	und Speicherverbrauch, so dass auch gro{\ss}e Programme mit tausenden
	Zeilen ohne Laufzeit- und Speicherexplosion verarbeitet werden k{\"o}nnen,
	wie unsere Experimente zeigen.},
  institution = {Universit{\"a}t Karlsruhe},
  url = {http://www/papers/da_jakschitsch.pdf}
}

@INCOLLECTION{Joh:79,
  author = {Steven C. Johnson},
  title = {Yacc: Yet Another Compiler Compiler},
  booktitle = {{UNIX} Programmer's Manual},
  publisher = {Holt, Rinehart, and Winston},
  year = {1979},
  volume = {2},
  pages = {353--387},
  address = {New York, NY, USA},
  url = {citeseer.ist.psu.edu/johnson79yacc.html}
}

@INCOLLECTION{Kaplan93Delta,
  author = {S. M. Kaplan and J. P. Loyall and S. K. Goering},
  title = {Specifying Concurrent Languages and Systems with Delta-Grammars},
  booktitle = {Research Directions in Concurrent Object-Oriented Programming},
  publisher = {MIT Press},
  year = {1993},
  editor = {G. Agha and P. Wegner and A. Yonezawa},
  pages = {235-256},
  address = {London}
}

@INPROCEEDINGS{kennedy94context,
  author = {K. Kennedy and G. Roth},
  title = {Context Optimization for {SIMD} Execution},
  booktitle = {Proceedings of the 1994 Scalable High Performance Computing Conference},
  year = {1994},
  address = {Knoxville, TN},
  url = {citeseer.nj.nec.com/kennedy94context.html}
}

@MISC{Kle:05,
  author = {Gerwin Klein},
  title = {JFlex User's Manual},
  howpublished = {\url{http://www.jflex.de/manual.html}},
  year = {2005}
}

@ARTICLE{KL:00,
  author = {Andreas Krall and Sylvain Lelait},
  title = {Compilation techniques for multimedia processors},
  journal = {Int. J. Parallel Program.},
  year = {2000},
  volume = {28},
  pages = {347--361},
  number = {4},
  abstract = {The huge processing power needed by multimedia applications has led
	to multimedia extensions in the instruction set of microprocessors
	which exploit subword parallelism. Examples of these extended instruction
	sets are the Visual Instruction Set of the UltraSPARC processor,
	the AltiVec instruction set of the PowerPC processor, the MMX and
	ISS extensions of the Pentium processors, and the MAX-2 instruction
	set of the HP PA-RISC processor. Currently, these extensions can
	only be used by programs written in assembly language, through system
	libraries or by calling specialized macros in a high-level language.
	Therefore, these instructions are not used by most applications.
	We propose two code generation techniques to produce native code
	using these multimedia extensions for programs written in a high-level
	language: classical vectorization and vectorization by unrolling.
	Vectorization by unrolling is simpler than classical vectorization
	since data dependence analysis is reduced to acyclic control flow
	graph analysis. Furthermore, we address the problem of unaligned
	memory accesses. This can be handled by both static analysis and
	dynamic runtime checking. Preliminary experimental results for a
	code generator for the UltraSPARC VIS instruction set show that speedups
	of up to a factor of 4.8 are possible, and that vectorization by
	unrolling is much simpler but as effective as classical vectorization.},
  doi = {http://dx.doi.org/10.1023/A:1007507005174},
  issn = {0885-7458},
  publisher = {Plenum Press}
}

@MISC{Kro:07,
  author = {Moritz Kroll},
  title = {{GrGen.NET: Portierung und Erweiterung des Graphersetzungssystems GrGen}},
  month = {5},
  year = {2007},
  note = {Studienarbeit, Universit\"at Karlsruhe},
  institution = {IPD Goos},
  school = {Universit{\"a}t Karlsruhe (TH)},
  url = {http://www.info.uni-karlsruhe.de/papers/sa_kroll.pdf}
}

@ARTICLE{KK:04:FSD,
  author = {Michihiro Kuramochi and George Karypis},
  title = {An Efficient Algorithm for Discovering Frequent Subgraphs},
  journal = {IEEE Transactions on Knowledge and Data Engineering},
  year = {2004},
  volume = {16},
  pages = {1038-1051},
  number = {9},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/TKDE.2004.33},
  issn = {1041-4347},
  publisher = {IEEE Computer Society}
}

@TECHREPORT{Les:75,
  author = {M.E. Lesk},
  title = {{LEX} -- {A} {L}exical {A}anlyzer {G}enerator},
  institution = {Bell Telefone Laboratories},
  year = {1975},
  type = {Technical Report},
  number = {39}
}

@ARTICLE{LB:00,
  author = {Rainer Leupers and Steven Bashford},
  title = {Graph-based code selection techniques for embedded processors},
  journal = {ACM Trans. Des. Autom. Electron. Syst.},
  year = {2000},
  volume = {5},
  pages = {794--814},
  number = {4},
  abstract = {Code selection is an important task in code generation for programmable
	processors, where the goal is to find an efficient mapping of machine-independent
	intermediate code to processor-specific machine instructions. Traditional
	approaches to code selection are based on tree parsing which enables
	fast and optimal code selection for intermediate code given as a
	set of data-flow trees. While this approach is generally useful in
	compilers for general-purpose processors, it may lead to poor code
	quality in the case of embedded processors. The reason is that the
	special architectural features of embedded processors require performing
	code selection on data-flow graphs, which are a more general representation
	of intermediate code. In this paper, we present data-flow graph-based
	code selection techniques for two architectural families of embedded
	processors: media processors with support for SIMD instructions and
	fixed-point DSPs with irregular data paths. Both techniques exploit
	the fact that, in the area of embedded systems, high code quality
	is a much more important goal than high compilation speed. We demonstrate
	that certain architectural features can only be utilized by graph-based
	code selection, while in other cases this approach leads to a significant
	increase in code quality as compared to tree-based code selection.},
  doi = {http://doi.acm.org/10.1145/362652.362661},
  issn = {1084-4309},
  publisher = {ACM Press}
}

@ARTICLE{Lev:66:Levenshtein,
  author = {V. Levenshtein},
  title = {Binary Codes Capable of Correcting Deletions, Insertions and Reversals},
  journal = {Soviet Physics Dokl.},
  year = {1966},
  volume = {6},
  pages = {126--136}
}

@TECHREPORT{Lin:02,
  author = {G{\"o}tz Lindenmaier},
  title = {libFIRM -- A Library for Compiler Optimization Research Implementing
	FIRM},
  institution = {Universit{\"a}t Karlsruhe, Fakult{\"a}t f{\"u}r Informatik},
  year = {2002},
  number = {2002-5},
  month = {Sep},
  abstract = {This tutorial describes the Firm library and how to use it. The Firm
	library implements the Firm intermediate representation (ir) as described
	in [TLB:99]. In addition it supplies data structures to represent
	the type structure of the source program, a constant table and other
	modules necessary to represent a complete source program. Further
	it contains interfaces for construction of intermediate code from
	the front end and to access the ir. Several basic optimizations and
	analyses are supplied. },
  chapter = {9},
  organization = {Universit{\"a}t Karlsruhe, Fakult{\"a}t f{\"u}r Informatik},
  pages = {75},
  publisher = {Universit{\"a}t Karlsruhe, Fakult{\"a}t f{\"u}r Informatik},
  url = {http://www/papers/Lind_02-firm_tutorial.ps}
}

@INPROCEEDINGS{LWD:02,
  author = {Markus Lorenz and Lars Wehmeyer and Thorsten Dr"ager},
  title = {Energy aware compilation for DSPs with SIMD instructions},
  booktitle = {Proceedings of the joint conference on Languages, compilers and tools
	for embedded systems},
  year = {2002},
  pages = {94--101},
  publisher = {ACM Press},
  abstract = {The growing use of digital signal processors (DSPs) in embedded systems
	necessitates the use of optimizing compilers supporting special hardware
	features. In this paper we present compiler optimizations with the
	aim of minimizing energy consumption of embedded applications: This
	comprises loop optimizations for exploitation of SIMD instructions
	and zero overhead hardware loops in order to increase performance
	and decrease the energy consumption. In addition, we use a phase
	coupled code generator based on a genetic algorithm (GCG) which is
	capable of performing energy aware instruction selection and scheduling.
	Energy aware compilation is done with respect to an instruction level
	energy cost model which is integrated into our code generator and
	simulator. Experimental results for several benchmarks show the effectiveness
	of our approach.},
  doi = {http://doi.acm.org/10.1145/513829.513847},
  isbn = {1-58113-527-0},
  location = {Berlin, Germany}
}

@PHDTHESIS{Loyall91Delta,
  author = {Joseph P.~Loyall},
  title = {Specification of Concurrent Systems with Graph Grammars},
  school = {University of Illinois at Urbana-Champaign},
  year = {1991}
}

@CONFERENCE{LH2000,
  author = {Andreas Ludwig and Dirk Heuzeroth},
  title = {Metaprogramming in the Large},
  booktitle = {2nd International Conference on Generative and Component-based Software
	Engineering (GCSE). Also available as LNCS 2177 (c) by Springer},
  year = {2000},
  number = {2177},
  month = {Jan},
  publisher = {Springer},
  abstract = {Software evolution demands continuous adaptation of software systems
	to continuously changing requirements. Our goal is to cope with software
	evolution by automating program transformation and system reconfiguration.
	We show that this can be achieved with a static metaprogramming facility
	and a library of suitable metaprograms. We show that former approaches
	of program transformations are not sufficient for large object oriented
	systems and outline two base transformations that fill the gap.},
  url = {http://www.info.uni-karlsruhe.de/papers/gcse2000-mp.ps.gz}
}

@INPROCEEDINGS{Loewe93AGG,
  author = {Lï¿½we and Beyer},
  title = {AGG - an implementation of algebraic graph rewriting},
  booktitle = {Rewriting Techniques and Applications},
  year = {1993},
  volume = {690},
  series = {Lecture Notes in Computer Science},
  pages = {451-456},
  publisher = {Springer}
}

@CONFERENCE{MKC:00,
  author = {Rashindra Manniesing and Ireneusz Karkowski and Henk Corporaal},
  title = {Automatic SIMD Parallelization of Embedded Applications Based on
	Pattern Recognition},
  booktitle = {Euro-Par 2000 - Parallel Processing: 6th},
  year = {2000},
  number = {1900},
  publisher = {Springer},
  abstract = {this paper investigates the potential for automatic mapping oftypical
	embedded applications to architectures with multimedia instructionset
	extensions. for this purpose a (pattern matching based) codetransformation
	engine is used, which involves a three-step process ofmatching, condition
	checking and replacing of the source code. experimentswith dsp and
	the mpeg2 encoder benchmarks, show that about 85\% of the loopswhich
	are suitable for single instruction multiple data (simd)parallelization
	can be automatically recognized and mapped.}
}

@ARTICLE{McB:02:Jena,
  author = {Brian McBride},
  title = {Jena: A Semantic Web Toolkit},
  journal = {IEEE Internet Computing},
  year = {2002},
  volume = {6},
  pages = {55--59},
  number = {6},
  address = {Piscataway, NJ, USA},
  doi = {http://dx.doi.org/10.1109/MIC.2002.1067737},
  issn = {1089-7801},
  publisher = {IEEE Educational Activities Department}
}

@TECHREPORT{McK:90:nauty,
  author = {Brendan D. McKay},
  title = {\textbf{nauty} User's Guide (Version 1.5)},
  institution = {Australian National University, Department of Computer Science},
  year = {1990},
  number = {TR-CS-90-02}
}

@ARTICLE{McK:81:ISO,
  author = {Brendan D. McKay},
  title = {Practical graph isomorphism},
  journal = {Congressus Numerantium},
  year = {1981},
  volume = {30},
  pages = {45--87},
  url = {http://cs.anu.edu.au/people/bdm/nauty/}
}

@BOOK{MW:00,
  title = {Automatic algorithm recognition and replacement: a new approach to
	program optimization},
  publisher = {MIT Press},
  year = {2000},
  author = {Robert Metzger and Zhaofang Wen},
  address = {Cambridge, MA, USA},
  isbn = {0-262-13368-7}
}

@ARTICLE{MWH:00:Levenshtein,
  author = {Richard Myers and Richard C. Wilson and Edwin R. Hancock},
  title = {Bayesian Graph Edit Distance},
  journal = {IEEE Transactions on Pattern Analysis and Machine Intelligence},
  year = {2000},
  volume = {22},
  pages = {628-635},
  number = {6},
  address = {Los Alamitos, CA, USA},
  doi = {http://doi.ieeecomputersociety.org/10.1109/34.862201},
  issn = {0162-8828},
  publisher = {IEEE Computer Society}
}

@BOOK{Nag:79,
  title = {Graph - Grammatiken. Theorie, Anwendung, Implementierungen},
  publisher = {Vieweg},
  year = {1979},
  author = {Manfred Nagl}
}

@INPROCEEDINGS{nguyen99exploiting,
  author = {Huy Nguyen and Lizy Kurian John},
  title = {Exploiting {SIMD} parallelism in {DSP} and multimedia algorithms
	using the AltiVec technology},
  booktitle = {International Conference on Supercomputing},
  year = {1999},
  pages = {11-20},
  abstract = {AltiVec technology is Motorola's high-performance vector parallel
	processing extension to the PowerPC tm RISC microprocessor. It is
	designed to improve the performance of algorithms and applications
	that can exploit data parallelism such as those in digital signal
	processing (DSP) and multimedia. In this paper, we investigate the
	behavior of the AltiVec technology on a set of common DSP and multimedia
	algorithms. These algorithms include digital filters, fast Fourier
	transforms, inverse... },
  url = {citeseer.nj.nec.com/nguyen99exploiting.html}
}

@INPROCEEDINGS{fujaba_pattern,
  author = {J. Niere and J.P. Wadsack and L. Wendehals},
  title = {Handling {L}arge {S}earch {S}pace in {P}attern-{B}ased {R}everse
	{E}ngineering},
  booktitle = {11th {IEEE} {I}ntl. {W}orkshop on {P}rogram {C}omprehension ({IWPC}'03)},
  pages = {274},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@INPROCEEDINGS{Pfaltz:69IJ,
  author = {J. L. Pfaltz and A. Rosenfeld},
  title = {Web Grammars},
  booktitle = {Proc. of the 1st IJCAI},
  year = {1969},
  pages = {609-619},
  address = {Washington, DC}
}

@BOOK{catego,
  title = {Basic {C}ategory {T}heory for {C}omputer {S}cientists},
  publisher = {The MIT Press},
  year = {1991},
  author = {B.C. Pierce},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@ARTICLE{PP:94,
  author = {Shlomit S. Pinter and Ron Y. Pinter},
  title = {Program optimization and parallelization using idioms},
  journal = {ACM Trans. Program. Lang. Syst.},
  year = {1994},
  volume = {16},
  pages = {305--327},
  number = {3},
  abstract = {Programs in languages such as Fortran, Pascal, and C were designed
	and written for a sequential machine model. During the last decade,
	several methods to vectorize such programs and recover other forms
	of parallelism that apply to more advanced machine architectures
	have been developed (particularly for Fortran, due to its pointer-free
	semantics). We propose and demonstrate a more powerful translation
	technique for making such programs run efficiently on parallel machines
	which support facilities such as parallel prefix operations as well
	as parallel and vector capabilities. This technique, which is global
	in nature and involves a modification of the traditional definition
	of the program dependence graph (PDG), is based on the extraction
	of parallelizable program structures ("idioms") from the given (sequential)
	program. The benefits of our technique extend beyond the above-mentioned
	architectures and can be viewed as a general program optimization
	method, applicable in many other situations. We show a few examples
	in which our method indeed outperforms existing analysis techniques.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/177492.177494},
  issn = {0164-0925},
  publisher = {ACM Press}
}

@INPROCEEDINGS{plump98term,
  author = {D. Plump},
  title = {Term graph rewriting},
  booktitle = {Handbook on Graph Grammars},
  year = {1999},
  editor = {G. Rozenberg},
  volume = {Applicationsi, Languages and Tools, Vol. 2},
  pages = {1--62},
  publisher = {World Scientific},
  url = {citeseer.ist.psu.edu/plump98term.html}
}

@INPROCEEDINGS{Rob:01,
  author = {Arch D. Robison},
  title = {Impact of economics on compiler optimization},
  booktitle = {Proceedings of the 2001 joint ACM-ISCOPE conference on Java Grande},
  year = {2001},
  pages = {1--10},
  publisher = {ACM Press},
  abstract = {Compile-time program optimizations are similar to poetry: more are
	written than are actually published in commercial compilers. Hard
	economic reality is that many interesting optimizations have too
	narrow an audience to justify their cost in a general-purpose compiler,
	and custom compilers are too expensive to write. An alternative is
	to allow programmers to define their own compile-time optimizations.
	This has already happened accidentally for C++, albeit imperfectly,
	in the form of template metaprogramming. This paper surveys the problems,
	the accidental success, and what directions future research might
	take to circumvent current economic limitations of monolithic compilers.},
  doi = {http://doi.acm.org/10.1145/376656.376751},
  isbn = {1-58113-359-6},
  location = {Palo Alto, California, United States}
}

@INPROCEEDINGS{agg_pm,
  author = {M. Rudolf},
  title = {Utilizing constraint satisfaction techniques for efficient graph
	pattern matching},
  booktitle = {T{AGT}'98: {S}elected papers from the 6th {I}ntl. {W}orkshop on {T}heory
	and {A}pplication of {G}raph {T}ransformations},
  year = {1998},
  volume = {1764},
  pages = {238--251},
  publisher = {LNCS},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@ARTICLE{progres_formal,
  author = {A. Sch\"urr},
  title = {Logic based programmed structure rewriting systems},
  journal = {Fundamenta {I}nformaticae, {S}pecial {I}ssues on {G}raph {T}ransformations},
  year = {1996},
  volume = {26},
  number = {3/4},
  editor = {G. Engels and H. Ehrig and G. Rozenberg},
  owner = {rubino},
  publisher = {IOS Press},
  timestamp = {2006.04.04}
}

@INCOLLECTION{progres,
  author = {A. Sch\"urr},
  title = {The {P}rogres {A}pproach: {L}anguage and {E}nvironment},
  booktitle = {\cite{roz}},
  year = {1999},
  volume = {2},
  pages = {487--550},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@INPROCEEDINGS{schuerr99progres,
  author = {A. Schï¿½rr and A. Winter and A. Zï¿½ndorf},
  title = {PROGRES: Language and environment},
  booktitle = {Handbook on Graph Grammars},
  year = {1999},
  editor = {G. Rozenberg},
  volume = {Applications, Vol. 2},
  pages = {487--550},
  publisher = {World Scientific},
  url = {citeseer.nj.nec.com/264924.html}
}

@ARTICLE{Slo:95,
  author = {Anthony M. Sloane},
  title = {An Evaluation of an Automatically Generated Compiler},
  journal = {ACM Transactions on Programming Languages and Systems},
  year = {1995},
  volume = {17},
  pages = {691--703},
  number = {5},
  month = {September},
  publisher = {ACM Press},
  url = {citeseer.ist.psu.edu/article/sloane95evaluation.html}
}

@MISC{specCINT2000,
  author = {{Standard Performance Evaluation Corporation}},
  title = {All {SPEC} {CPU}2000 results published by {SPEC} page},
  howpublished = {\url{http://www.spec.org/cpu2000/results/cpu2000.html}},
  month = {September},
  year = {2005},
  owner = {rubino},
  timestamp = {2006.04.04},
  url = {http://www.spec.org/cpu2000/results/cpu2000.html}
}

@BOOK{Sto:77,
  title = {Denotational Semantics: The Scott-Strachey Approach to Programming
	Language Theory},
  publisher = {MIT Press},
  year = {1977},
  author = {Joseph E. Stoy},
  address = {Cambridge, MA, USA},
  isbn = {0262191474}
}

@MISC{alfred01performance,
  author = {Alfred Strey and Martin Bange},
  title = {Performance Analysis of Intel's MMX and SSE: A Case Study},
  year = {2001},
  url = {citeseer.nj.nec.com/497434.html}
}

@INPROCEEDINGS{stuermer02contribution,
  author = {Ingo Stuermer},
  title = {A Contribution of Graph Grammar Techniques to the Specification,
	Verification and Certification of Code Generation Tools},
  booktitle = {Electronic Notes in Theoretical Computer Science},
  year = {2002},
  editor = {Tom Mens, Andy Schï¿½rr and Gabriele Taentzer},
  volume = {72},
  publisher = {Elsevier Science Publishers},
  issue = {2}
}

@MISC{adam,
  author = {Adam M. Szalkowski},
  title = {Negative {A}nwendungsbedingungen f\"ur das suchprogrammbasierte {B}ackend
	von {G}r{G}en},
  year = {2005},
  note = {Studienarbeit, Universit\"at Karlsruhe},
  owner = {rubino},
  school = {Universit\"at Karlsruhe},
  timestamp = {2006.04.04}
}

@ARTICLE{Ten:76,
  author = {R. D. Tennent},
  title = {The denotational semantics of programming languages},
  journal = {Commun. ACM},
  year = {1976},
  volume = {19},
  pages = {437--453},
  number = {8},
  abstract = {This paper is a tutorial introduction to the theory of programming
	language semantics developed by D. Scott and C. Strachey. The application
	of the theory to formal language specification is demonstrated and
	other applications are surveyed. The first language considered, LOOP,
	is very elementary and its definition merely introduces the notation
	and methodology of the approach. Then the semantic concepts of environments,
	stores, and continuations are introduced to model classes of programming
	language features and the underlying mathematical theory of computation
	due to Scott is motivated and outlined. Finally, the paper presents
	a formal definition of the language GEDANKEN.},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/360303.360308},
  issn = {0001-0782},
  publisher = {ACM Press}
}

@TECHREPORT{TBL:99,
  author = {Martin Trapp and G{\"o}tz Lindenmaier and Boris Boesler},
  title = {Documentation of the Intermediate Representation FIRM},
  institution = {Universit{\"a}t Karlsruhe, Fakult{\"a}t f{\"u}r Informatik},
  year = {1999},
  number = {1999-14},
  month = {Dec},
  booktitle = {-},
  chapter = {3},
  pages = {0-40},
  publisher = {Universit{\"a}t Karlsruhe, Fakult{\"a}t f{\"u}r Informatik},
  url = {http://www/papers/firmdoc.ps.gz},
  volume = {-}
}

@MISC{varro_web,
  author = {G. Varr\'o},
  title = {Graph transformation benchmarks page},
  howpublished = {\url{http://www.cs.bme.hu/ \verb+~+gervarro/benchmark/2.0/}},
  month = {August},
  year = {2005},
  owner = {rubino},
  timestamp = {2006.04.04},
  url = {http://www.cs.bme.hu/~gervarro/benchmark/2.0/}
}

@INPROCEEDINGS{varrodb,
  author = {G. Varr{\'o} and K. Friedl and D. Varr{\'o}},
  title = {Graph {T}ransformations in {R}elational {D}atabases},
  booktitle = {Proc. {G}ra{B}a{T}s 2004: {I}ntl. {W}orkshop on {G}raph {B}ased {T}ools},
  year = {2004},
  publisher = {Elsevier},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@INPROCEEDINGS{grabats2004_vfv,
  author = {Gergely Varr{\'o} and Katalin Friedl and D{\'a}niel Varr{\'o}},
  title = {Graph Transformations in Relational Databases},
  booktitle = {Proc. GraBaTs 2004: International Workshop on Graph Based Tools},
  year = {2004},
  address = {Rome, Italy},
  month = {October},
  publisher = {Elsevier},
  note = {In press},
  abstract = { We present a novel approach to implement a graph transformation engine
	based on standard relational database management systems (RDBMSs).
	The essence of the approach is to create database views for each
	rules and to handle pattern matching by inner join operations while
	negative application conditions by left outer join operations. Furthermore,
	the model manipulation prescribed by the application of a graph transformation
	rule is also implemented using elementary data manipulation statements
	(such as insert, delete, update). },
  keywords = { Tool support, Graph transformation, Pattern matching, Relational
	databases},
  optseries = {ENTCS},
  url = {http://www.inf.mit.bme.hu/FTSRG/Publications/varro/2004/grabats2004_vfv.pdf}
}

@TECHREPORT{varro_bench,
  author = {G. Varr{\'o} and A. Sch{\"u}rr and D. Varr{\'o}},
  title = {Benchmarking for {G}raph {T}ransformation},
  institution = {Department of Computer Science and Information Theory, Budapest University
	of Technology and Economics},
  year = {2005},
  month = {March},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@INPROCEEDINGS{gtvmt04_vv,
  author = {Gergely Varr{\'o} and D{\'a}niel Varr{\'o}},
  title = {Graph Transformation with Incremental Updates},
  booktitle = {Proc. GT-VMT 2004, International Workshop on Graph Transformation
	and Visual Modelling Techniques},
  year = {2004},
  series = {ENTCS},
  month = {March},
  publisher = {Elsevier},
  note = {To appear},
  abstract = { We propose an efficient implementation technique for graph transformation
	systems based on \emph{incremental updates}. The essence of the technique
	is to keep track of all possible matchings of graph transformation
	rules in database tables, and update these tables incrementally to
	exploit the fact that rules typically perform only local modifications
	to models.},
  keywords = {graph transformation, graph pattern matching, relational databases},
  url = {http://www.inf.mit.bme.hu/FTSRG/Publications/varro/2004/gtvmt04_vv.pdf}
}

@INPROCEEDINGS{VFV:05,
  author = {Gergely Varrï¿½ and Katalin Friedl and Dï¿½niel Varrï¿½},
  title = {Graph Transformation in Relational Databases},
  booktitle = {Proceedings of the International Workshop on Graph-Based Tools (GraBaTs
	2004)},
  year = {2005},
  editor = {T. Mens and A. Schï¿½rr and G. Taentzer},
  volume = {127, No 1},
  series = {Electronic Notes in Theoretical Computer Science},
  pages = {167--180},
  month = {March},
  publisher = {Elsevier},
  abstract = {We present a novel approach to implement a graph transformation engine
	based on standard relational database management systems (RDBMSs).
	The essence of the approach is to create database views for each
	rules and to handle pattern matching by inner join operations while
	negative application conditions by left outer join operations. Furthermore,
	the model manipulation prescribed by the application of a graph transformation
	rule is also implemented using elementary data manipulation statements
	(such as insert, delete, update).},
  url = {http://www.sciencedirect.com/science/article/B75H1-4G6C78K-J/2/10a04a0263527744bed5bee125686f23}
}

@inproceedings{gramot2005_adapt,
  volume = 152,
  author = {Gergely Varr{\'o} and D{\'a}niel Varr{\'o} and Katalin Friedl},
  series = {ENTCS},
  booktitle = {GraMot 2005, International Workshop on Graph and Model
               Transformations},
  editor = {G. Karsai and G. Taentzer},
  title = {Adaptive Graph Pattern Matching for Model Transformations using
           Model-sensitive Search Plans},
  publisher = {Elsevier},
  pages = {191--205},
  year = 2006,
}

@MISC{Vie:88,
  author = {Bertram Vielsack},
  title = {{Grammar Tools User Manual - LALR and ELL}},
  howpublished = {GMD Forschungsstelle an der {Universit\"{a}t} Karlsruhe},
  month = {April},
  year = {1988}
}

@INPROCEEDINGS{VAS:04,
  author = {Attila Vizhanyo and Aditya Agrawal and Feng Shi},
  title = {Towards Generation of Efficient Transformations},
  booktitle = {Proceedings of the Third International Conference on Generative Programming
	and Component Engineering (GPCE 2004)},
  year = {2004},
  editor = {G. Karsai and E. Visser},
  volume = {3286},
  series = {Lecture Notes in Computer Science},
  pages = {298--316},
  address = {Vancouver, Canada},
  month = {October},
  publisher = {Springer},
  abstract = {In this paper we discuss efficiency related constructs of a graph
	rewriting language, called Graph Rewriting and Transformation (GReAT),
	and introduce a code generator tool, which together provide a programming
	framework for the specification and efficient realization of graph
	rewriting systems. We argue that the performance problems frequently
	associated with the implementation of the transformation can be significantly
	reduced by partial evaluation and adopting language constructs that
	allow algorithmic optimizations.},
  url = {http://www.springerlink.com/openurl.asp?genre=issue&issn=0302-9743&volume=3286}
}

@INPROCEEDINGS{WH:04:Levenshtein,
  author = {Richard C. Wilson and Edwin R. Hancock},
  title = {Levenshtein Distance for Graph Spectral Features},
  booktitle = {ICPR '04: Proceedings of the Pattern Recognition, 17th International
	Conference on (ICPR'04) Volume 2},
  year = {2004},
  pages = {489--492},
  address = {Washington, DC, USA},
  publisher = {IEEE Computer Society},
  doi = {http://dx.doi.org/10.1109/ICPR.2004.540},
  isbn = {0-7695-2128-2}
}

@BOOK{Wolfe95,
  title = {{High-Performance Compilers for Parallel Computing}},
  publisher = {Addison-Wesley, Reading, Massachusetts, USA},
  year = {1995},
  author = {M.J. Wolfe},
  topics = {Optimizations in General,Exploiting Concurrency}
}

@INPROCEEDINGS{progres_pm,
  author = {A. Z{\"u}ndorf},
  title = {Graph {P}attern {M}atching in \progres},
  booktitle = {Proc. 5th. {I}nt. {W}orkshop on {G}raph-{G}rammars and their {A}pplication
	to {C}omputer {S}cience},
  year = {1996},
  volume = {1073},
  series = {LNCS},
  pages = {454--468},
  publisher = {Springer},
  owner = {rubino},
  timestamp = {2006.04.04}
}

@PROCEEDINGS{ICGT:2006,
  title = {Graph Transformations, Third International Conference, ICGT 2006,
	Natal, Rio Grande do Norte, Brazil, September 17-23, 2006, Proceedings},
  year = {2006},
  editor = {Andrea Corradini and Hartmut Ehrig and Ugo Montanari and Leila Ribeiro
	and Grzegorz Rozenberg},
  volume = {4178},
  series = {Lecture Notes in Computer Science},
  publisher = {Springer},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  booktitle = {ICGT},
  isbn = {3-540-38870-2}
}

@PROCEEDINGS{DBLP:conf/wadt/2004,
  title = {Recent Trends in Algebraic Development Techniques, 17th International
	Workshop, WADT 2004, Barcelona, Spain, March 27-29, 2004, Revised
	Selected Papers},
  year = {2004},
  editor = {Jos{\'e} Luiz Fiadeiro and Peter D. Mosses and Fernando Orejas},
  volume = {3423},
  series = {Lecture Notes in Computer Science},
  publisher = {Springer},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  booktitle = {WADT},
  isbn = {3-540-25327-0}
}

@BOOK{roz,
  title = {Handbook of {G}raph {G}rammars and {C}omputing by {G}raph {T}ransformation},
  publisher = {World Scientific},
  year = {1999},
  editor = {G. Rozenberg}
}

@MANUAL{IA32:05,
  title = {IA-32 Intel Architecture Software Developer's Manual -- Instruction
	Set Reference},
  organization = {Intel Corporation},
  address = {O. Box 5937, Denver, CO 80217-9808},
  year = {2005}
}

@MANUAL{Motorola:1998:ATP,
  title = {{AltiVec} Technology Programming Environments Manual},
  organization = pub-MOTOROLA,
  address = pub-MOTOROLA:adr,
  month = nov,
  year = {1998},
  note = {Order number ALTIVECPEM/D 11/1998 Rev. 0.1.},
  acknowledgement = {#ack-nhfb#},
  bibdate = {Tue Jan 09 11:20:43 2001},
  bibsource = {http://a2016.g.akamai.net/7/2016/787/5087c1b5def3b1/www.motorola.com/SPS/PowerPC/teksupport/teklibrary/manuals/altivec_pem.pdf},
  pages = {350}
}


@misc{MB:00,
	author = {H. Marxen and J. Buntrock},
	title = {Old list of record {TMs}},
	howpublished = {\url{http://www.drb.insel.de/\textasciitilde heiner/BB/index.html}},
	year = {2000},
	month = {8},
}

@book{MMJW:91,
 author = {Andrew B. Mickel and James F. Miner and Kathleen Jensen and Niklaus Wirth},
 title = {Pascal user manual and report (4th ed.): ISO Pascal standard},
 year = {1991},
 isbn = {0-387-97649-3},
 publisher = {Springer-Verlag New York, Inc.},
 address = {New York, NY, USA},
 }

@Book{Sch:1990:ANSIC,
  author =       "Herbert Schildt and {American National Standards
                 Institute} and {International Organization for
                 Standardization} and {International Electrotechnical
                 Commission} and {ISO\slash IEC JTC 1}",
  title =        "The annotated {ANSI C} standard: {American National
                 Standard} for Programming Languages {C}: {ANSI}\slash
                 {ISO} 9899-1990",
  pages =        "xvi + 219",
  year =         "1990",
  ISBN =         "0-07-881952-0",
  ISBN-13 =      "978-0-07-881952-0",
  LCCN =         "QA76.73.C15S356 1990",
  bibdate =      "Mon Feb 05 17:59:28 2001",
  price =        "US\$39.95",
  URL =          "http://www.iso.ch/cate/d29237.html",
  acknowledgement = ack-nhfb,
  annote =       "Contains the full text of the ANSI/ISO Standard for
                 the C programming language, which is commonly called
                 the ANSI C Standard. \ldots{} To make the text of the
                 standard more generally accessible and easier to
                 understand, I have provided explanations, comments, and
                 examples on the pages that face the pages of the
                 standard.",
  keywords =     "C (Computer program language); Programming languages
                 (Electronic computers) --- Standards; Standards.;
                 Programming languages",
}

@misc{NET,
	title = {{.NET}},
	howpublished = {\url{http://msdn2.microsoft.com/de-de/netframework/aa497336.aspx}},
	author = {Microsoft},
	year = {2007},
}

@misc{MONO,
	title = {{Mono}},
	howpublished = {\url{http://www.mono-project.com/}},
	author = {The Mono Team},
	year = {2007},
}

@TECHREPORT{vcg,
	author ={Georg Sander},
	title = {{VCG} Visualization of Compiler Graphs---User Documentation V.1.30},
	institution = {Universit{\"a}t des Saarlandes},
	year = {1995},
	howpublished = {\url{ftp://ftp.cs.uni-sb.de/pub/graphics/vcg/doc/vcgdoc.ps.gz}},
}

@conference{BKG:07,
  author={Gernot Veit Batz and Moritz Kroll and Rubino Gei{\ss}},
  title={{A First Experimental Evaluation of Search Plan Driven Graph Pattern Matching}},
  booktitle={Applications of Graph Transformation with Industrial releVancE - AGTIVE 2007},
  year={2007},
  abstract={With graph pattern matching the field of graph transformation (GT) includes an NP-complete subtask. But for real-live applications it is essential that graph pattern matching is performed as fast as possible.
This challenge has been attacked recently by an approach we call search plan driven graph pattern matching. It has been presented independently by Batz as well as by Varro et al. However, until now there has been no experimental evaluation of this approach. We performed first experiments using the well known GT benchmark introduced by Varro et al. To complement this paper, we give an introduction to search plan driven graph pattern matching.},
  note={preliminary version, submitted to AGTIVE 2007},
  url={http://www.info.uni-karlsruhe.de/papers/agtive_2007_search_plan.pdf},
}

@misc{ycomp,
	title = {{yComp}},
	author = {Moritz Kroll and Michael Beck and Rubino Gei{\ss} and Sebastian Hack and Philipp Lei{\ss}},
	institution = {Institut für Programmstrukturen und Datenorganisation, Universit{"\a}t Karlsruhe},
	year = {2007},
	howpublished ={\url{http://www.info.uni-karlsruhe.de/software.php/id=6}}
}

@misc{yfiles,
	title = {{yFiles}},
	author = {yWorks},
	institution = {yWorks GmbH},
	year ={2007},
	howpublished = {\url{http://www.yworks.com}}
}

@conference{KG:07,
  author={Moritz Kroll and Rubino Gei{\ss}},
  title={{Developing Graph Transformations with GrGen.NET}},
  booktitle={Applications of Graph Transformation with Industrial releVancE - AGTIVE 2007},
  year={2007},
  abstract={GrGen.NET is a graph rewrite system enabling elegant andconvenient development of applications with comparable performance to conventionally developed ones. GrGen.NET uses attributed, typed, and directed multigraphs with multiple inheritance on node and edge types. Extensive graphical debugging integrated into an interactive shell complements the feature highlights of GrGen.NET. In this paper, the above claims are illustrated by examples.},
  note={preliminary version, submitted to AGTIVE 2007},
  url={http://www.info.uni-karlsruhe.de/papers/agtive_2007_grgennet.pdf},
}


