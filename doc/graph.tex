\chapter{Graph Type and Computations}
\label{cha:graph}\indexmain{visited flag}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Built-In Types}
\label{sec:builtingenerictypes}
Besides the types already introduced, \GrG\ offers supports for a \texttt{\indexed{graph}} type.
If used explicitly, it denotes a subgraph of the host graph, which can be used for storing and comparing subgraphs of the current host graph. (Because of the "there is only a single host graph"-design of GrGen you must explicitly descend to the nested subgraph if you intend to process it, see \ref{sec:graphnesting}).

But more important are the large number of global functions (with call syntax as already introduced in \ref{sec:primexpr}) and global procedures (with call syntax as already introduced in \ref{sec:proccall}) that implicitly operate on the single host graph (and thus on the graph type).
There are update functions available that allow to manipulate the graph available with \texttt{add}, \texttt{rem} and \texttt{retype}.
The host graph may be queried for all \texttt{nodes} or \texttt{edges} of a given type.
An edge may be queried for its \texttt{source} and \texttt{target} elements,
while a node may be queried for its direct neighbourhood with all \texttt{incident} edges, or all \texttt{adjacent} nodes.
Or even for its transitive neighbourhood with all \texttt{reachable} nodes or edges.
In the form of functions returning \texttt{set}s of nodes or edges, or in the form of iterations with \texttt{for} loops, or in the form of boolean predicates to test the neighbourhood if two elements are given.
The \texttt{induced} subgraph of a set of nodes or edges may be computed, or directly \texttt{insert}ed into the host graph.

Furthermore, \texttt{visited} flags may be used for marking already visited elements during graph walks or for partitioning a graph.
These operations are available in the rule language, as function atoms of the expression sublanguage from \ref{cha:typeexpr}, and as procedure atoms of the statement sublanguage from \ref{cha:computations}; 
most of them are available in the sequence computations language, too
(\ref{sec:seqcomp} will tell about the differences compared to the rule language).

The graph manipulation procedures, the transaction handling procedures, and the visited flag management and assignment procedures are not available in the function abstraction; they may only be called from the procedures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph Functions And Procedures}\indexmain{graph functions}\indexmain{graph procedures}\label{neighbouringelementsfunctions}

%-----------------------------------------------------------------------------------------------
\subsection{Graph Updates / Basic Graph Manipulation}

There are procedures to update the graph by adding or removing or retyping available, on nodes and edges: 

\begin{description}
\item[\texttt{add(.)}] adds a new node of the given node type to the host graph, returns the added node.
\item[\texttt{addCopy(.)}] adds a clone of the original node to the host graph, returns the added node.
\item[\texttt{add(.,.,.)}] adds a new edge of the given edge type to the host graph, in between the source node specified as second argument and the target node specified as third argument, returns the added edge.
\item[\texttt{addCopy(.,.,.)}] adds a clone of the original edge to the host graph, in between the source node specified as second argument and the target node specified as third argument, returns the added edge.
\item[\texttt{rem(.)}] removes the node or edge given from the host graph (no expression, does not return anything).
\item[\texttt{retype(.,.)}] retypes the node or edge given to the node type or edge type given as second argument, returns the retyped entity.
\item[\texttt{clear()}] clears the host graph.
\end{description}

\noindent Besidse those basic graph manipulation functions, some advanced rewriting operations are available as procedures, too:

\begin{description}
\item[\texttt{merge(.,.)}] merges the source node given as second argument into the target node given as first argument.
\item[\texttt{redirectSource(.,.)}] redirects the edge given as first argument to the new source node given as second argument.
\item[\texttt{redirectTarget(.,.)}] redirects the edge given as first argument to the new target node given as second argument.
\item[\texttt{redirectSourceAndTarget(.,.,.)}] redirects the edge given as first argument to the new source node given as second argument and the new target node given as third argument.
\end{description}

The versions introduced above are only available on named graphs, as they fetch the debug display name from the old element.
If you want to use them on unnamed graphs you must supply an additional argument giving the name of the old element; in case of the \texttt{redirectSourceAndTarget} you must supply two additional arguments, first the string to use for the old source node name, then the string to use for the old target node name.

%-----------------------------------------------------------------------------------------------
\subsection{Graph Query by Types}

There are functions to ask for all nodes or edges of a type available: 
\begin{description}
\item[\texttt{nodes(.)}] returns all nodes in the graph compatible to the given node type, as set.
\item[\texttt{nodes()}] returns all nodes in the graph, as set.
\item[\texttt{edges(.)}] returns all edges in the graph compatible to the given edge type, as set.
\item[\texttt{edges()}] returns all edges in the graph, as set.
\end{description}

The same functions can be used from for loops to iterate over the entities, omitting the filling of a set: 
\begin{description}
\item[\texttt{for(n:NodyType in nodes(NodeType)) \{Statements\}} ] iterates over all nodes in the graph compatible to the given node type.
\item[\texttt{for(n:Node in nodes()) \{Statements\}} ] iterates over all nodes in the graph.
\item[\texttt{for(e:EdgeType in edges(EdgeType)) \{Statements\}} ] iterates over all edges in the graph compatible to the given edge type.
\item[\texttt{for(e:Edge in edges()) \{Statements\}} ] iterates over all edges in the graph.
\end{description}

%-----------------------------------------------------------------------------------------------
\subsection{Graph Query by Neighbourhood}\label{sub:querybyneighbourhood}

Multiple functions are available to query the neighbourhood of nodes and edges.

\subsubsection*{Edge Neighbourhood}

The nodes incident to a given edge may be queried by the following functions: 

\begin{description}
\item[\texttt{source(.)}] returns the source node of the given edge.
\item[\texttt{target(.)}] returns the target node of the given edge.
\item[\texttt{opposite(.,.)}] returns the opposite node of the edge and the node (second argument) given.
\end{description}

\subsubsection*{Node Neighbourhood Common Concepts}

The edges \texttt{incident} or the nodes \texttt{adjacent} to a given node may be queried.

The neighbourhood query functions allow to additionally constrain the direction of the edges to \texttt{incoming} or \texttt{outgoing} edges, otherwise both directions are accepted.

The neighbourhood query functions furthermore allow to constrain the accepted situations by optional arguments. The type the incident edges must have to be accounted for can be specified. Or the type the incident edges must have to be accounted for and the type the adjacent nodes must have to be accounted for (cf. \ref{NeighbourhoodFunctionCallTypes}).

\begin{rail}
NeighbourhoodFunctionCall: 
  FunctionName '(' StartNodeExpr ')' |
  FunctionName '(' StartNodeExpr ',' EdgeType ')' |
  FunctionName '(' StartNodeExpr ',' EdgeType ',' NodeType ')'
  ;
\end{rail}\label{NeighbourhoodFunctionCallTypes}

The neighbourhood query function can be used in four possible ways: 
\begin{description}
	\item[Set functions:] The neighbourhood function returns a set of neighbouring entities of the start node. It builds a set that is likely thrown away thereafter, so esp. for large sets this functions is less efficient than the other versions.
\begin{rail}
Expression:
  FunctionName '(' StartNodeExpr ')' ;
\end{rail}
	\item[Iteration loops:] The neighbourhood function is employed from a for loop that allows to iterate the neighbouring entities of the start node. No set needs to be built here. But if the source node has multiple edges to a target node, it might be iterated multiple times. And an edge may be iterated twice in case of the undirected functions.
\begin{rail}
ForLoop: 
  'for' '(' Name ':' Type 'in' FunctionName '(' StartNodeExpr ')' \\ lbrace Statements rbrace;
\end{rail}
	\item[Counted functions:] The counted neighbourhood function returns the count of neighbouring entities of the start node. This is at least as efficient as calling \texttt{size()} on the resulting set of the plain neighbourhood function, often it is more efficient.
\begin{rail}
Expression:
  CountedFunctionName '(' StartNodeExpr ')' ;
\end{rail}
The \emph{CountedFunctionName} is built from the \emph{FunctionName} by prepending \texttt{count} and switching the first charecter of \emph{FunctionName} to upper case.
	\item[Boolean functions:] The neighbourhood function is employed in a boolean predicate version that allows the check whether a second target entity is in the queried neighbourhood of the start node. The computation has the smallest internal processing overhead of the three options and stops as soon as a positive result is obtained.
\begin{rail}
Expression:
  FunctionNamePredicate '(' StartNodeExpr ',' TargetEntity ')' ;
\end{rail}
The \emph{FunctionNamePredicate} is built from the \emph{FunctionName} by prepending \texttt{is} and switching the first charecter of \emph{FunctionName} to upper case.
\end{description}


\subsubsection*{Direct Node Neighbourhood}

Available are queries for the neighbouring edges:

\begin{description}
\item[\texttt{incident(.)}] returns the set of the edges that are incident to the node given as argument value.
\item[\texttt{incoming(.)}] same as the incident above, but restricted to incoming edges.
\item[\texttt{outgoing(.)}] same as the incident above, but restricted to outgoing edges.
\end{description}

In the two argument version, only edges of the type given as second argument are contained.
The three argument version behaves as the two argument version, but additionally only edges incident to an opposite node of the type given as third argument are contained.

\begin{example}
\begin{grgen}
rule foo {
    src:Node -e:Edge->; 
    if(!isIncoming(src, e));
    
    modify {
        eval {
            if(incident(src, NiftyEdge, NiftyNode).size()>2)
            {
	              for(ne:NiftyEdge in outgoing(src, NiftyEdge))
	              {
	                  ne.attr = 42;
	              }
	          }
        }
    }
}
\end{grgen}
Some fabricated example showing how to use the incoming, outgoing, and incident functions in their \emph{boolean predicate}, \emph{set function}, and \emph{for iteration} versions, with and without constraining the edge and node types.
\end{example}

Available are queries for the neighbouring nodes:

\begin{description}
\item[\texttt{adjacent(.)}] returns the set of the nodes that are adjacent to the node given as argument value.
\item[\texttt{adjacentIncoming(.)}] same as the adjacent above, but restricted to nodes reachable via incoming edges.
\item[\texttt{adjacentOutgoing(.)}] same as the adjacent above, but restricted to nodes reachable via outgoing edges.
\end{description}

In the two argument version, nodes incident to an edge of the type given as second argument are contained.
The three argument version behaves as the two argument version, but additionally only nodes of the node type given as third argument are contained.

\begin{example}
An example showing how to program a rule by hand with the graph query operations for matching and the graph update operations for rewriting. This is what GrGen does under the covers, and as you can see from the volume and style of code very helpful -- use the pattern language, don't fall back to the computations language unless really needed.
\begin{grgen}
rule example
{
	x:N -e:E-> y:N <--> z:M;
	if { e.a == 42; }

	modify {
		delete(y);
		xn:NN<x>;
		xn --> yn:N --> z;
	}
}
// this procedure behaves similarily to the rule above
procedure example
{
	// match LHS pattern
	def var leave:boolean = false;
	for(x:N in nodes(N)) // lookup n of type N in the graph
	{
		x.visited = true; // (see 14.5 Visited Flags below)
		for(e:E in outgoing(x, E)) // from x on find outgoing edge e of type E
		{
			if(!(e.a == 42)) { // with e.a == 42
				continue;
			}
			def y:Node = target(e); // and target node y of type N
			if(!(typeof(y)<=N)) {
				continue;
			}
			if(y.visited) { // that is not the same as x
				continue;
			}
			for(z:Node in adjacent(y, Edge, M)) // from y on find adjacent node z of type M
			{ // N and M are disjoint, can't match each other, otherwise visited would be needed
			
				// rewrite according to RHS pattern
				rem(y);
				(def xn:NN)=retype(x,NN);
				(def yn:N)=add(N);
				add(Edge, xn, yn);
				add(Edge, yn, z);

				leave = true; break;
			}
			if(leave) { break; }
		}
		x.visited = false;
		if(leave) { break; }
	}
	return;
}
\end{grgen}
\end{example}

\subsubsection*{Transitive Node Neighbourhood}\label{transitiveneighbour}

Besides direct neighbourhood, transitive neighbourhood can be queried with the reachability functions.

Available are queries for the reachable edges:

\begin{description}
\item[\texttt{reachableEdges(.)}] returns the set of the edges that are reachable from the node given as argument value.
\item[\texttt{reachableEdgesIncoming(.)}] same as the reachableEdges above, but restricted to incoming edges.
\item[\texttt{reachableEdgesOutgoing(.)}] same as the reachableEdges above, but restricted to outgoing edges.
\end{description}

In the two argument version, only edges of the type given as second argument are contained and followed.
The three argument version behaves as the two argument version, but additionally only edges incident to an opposite node of the type given as third argument are contained and followed.

Available are queries for the reachable nodes:

\begin{description}
\item[\texttt{reachable(.)}] returns the set of the nodes that are reachable from the node given as argument value.
\item[\texttt{reachableIncoming(.)}] same as any of the reachables above, but restricted to nodes reachable via incoming edges.
\item[\texttt{reachableOutgoing(.)}] same as any of the reachables above, but restricted to nodes reachable via outgoing edges.
\end{description}

In the two argument version, nodes incident to an edge of the type given as second argument are contained and followed.
The three argument version behaves as the two argument version, but additionally only nodes of the node type given as third argument are contained and followed.

\begin{example}
\begin{grgen}
rule bar {
    src:Node; 
    tgt:Node;
    if(isReachableOutgoing(src, tgt, NiftyEdge));
    
    modify {
        eval {
            if(!(reachableIncoming(src) & reachableOutgoing(src)).empty())
            {
                for(ne:NiftyEdge in reachable(src))
                {
                    ne.attr = 42;
                }
            }
        }
    }
}
\end{grgen}
Some fabricated example showing how to use the \texttt{isReachableOutgoing} function to check for an \indexed{iterated path} between the \texttt{src} and \texttt{target} nodes, how to check for loops by intersecting the sets of nodes reachable by outgoing edges from a node and reachable by incoming edges to a node, and how to iterate with one loop over all edges reachable in either way from a node.

The isReachable functions give the most efficient and most convenient way to check for an iterated path in GrGen, if you need more elaborate checking than constraining the edge type to one type and the target node type to one type you need to program the iterated path with subpattern recursion.

The reachable iteration is the most concise way to note down a depth first walk over a graph, visiting all elements reachable from a source node on.
\end{example}

\subsubsection*{Bounded Transitive Node Neighbourhood}\label{transitiveneighbourbounded}

Transitive neighbourhood can be queried also with a path of bounded length, with the bounded reachability functions (querying for a \indexed{bounded iterated path}).

Available are queries for the reachable-within-bounds edges:

\begin{description}
\item[\texttt{boundedReachableEdges(.,.)}] returns the set of the edges that are reachable from the node given as first argument value, within at most as much steps as specified by the second argument.
\item[\texttt{boundedReachableEdgesIncoming(.,.)}] same as the reachableEdges above, but restricted to incoming edges.
\item[\texttt{boundedReachableEdgesOutgoing(.,.)}] same as the reachableEdges above, but restricted to outgoing edges.
\end{description}

In the three argument version, only edges of the type given as third argument are contained and followed.
The four argument version behaves as the three argument version, but additionally only edges incident to an opposite node of the type given as fourth argument are contained and followed.

Available are queries for the reachable-within-bounds nodes:

\begin{description}
\item[\texttt{boundedReachable(.,.)}] returns the set of the nodes that are reachable from the node given as first argument value, within at most as much steps as specified by the second argument.
\item[\texttt{boundedReachableIncoming(.,.)}] same as any of the reachables above, but restricted to nodes reachable via incoming edges.
\item[\texttt{boundedReachableOutgoing(.,.)}] same as any of the reachables above, but restricted to nodes reachable via outgoing edges.
\end{description}

In the three argument version, nodes incident to an edge of the type given as third argument are contained and followed.
The four argument version behaves as the three argument version, but additionally only nodes of the node type given as fourth argument are contained and followed.

\begin{example}
\begin{grgen}
// iterative deepening is trivial due to boundedReachable (encapsulating a depth-bounded depth first search)
procedure IterativeDeepening(root:Node, var maxdepth:int) : (boolean)
{
    for(depth:int in [0:maxdepth])
    {
        for(n:Node in boundedReachableOutgoing(root, depth))
        { 
            if(foundCondition()) {
                return(true);
            }
        }		
    }
    return(false);
}
\end{grgen}
An example showing how to use \texttt{boundedReachable} in implementing \indexed{iterative deepening}.
You find it and an example for \indexed{depth-first search}, as well as an example for \indexed{breadth-first search} implemented with a \texttt{deque} in \texttt{test/should\_pass}, in \texttt{/DfsBfsSearch.grg}.
\end{example}

Available are queries for the reachable-within-bounds nodes that return the minimum distance to the start node in addition:

\begin{description}
\item[\texttt{boundedReachableWithRemainingDepth(.,.)}] returns the map of the nodes that are reachable from the node given as first argument value, within at most as much steps as specified by the second argument, to the remaining depth.
\item[\texttt{boundedReachableWithRemainingDepthIncoming(.,.)}] same as any of the reachables above, but restricted to nodes reachable via incoming edges, to the remaining depth.
\item[\texttt{boundedReachableWithRemainingDepthOutgoing(.,.)}] same as any of the reachables above, but restricted to nodes reachable via outgoing edges, to the remaining depth.
\end{description}

In the three argument version, nodes incident to an edge of the type given as third argument are contained and followed.
The four argument version behaves as the three argument version, but additionally only nodes of the node type given as fourth argument are contained and followed.
The depth value for the minimum distance of the node to the root node in the result map is counted downwards from the depth requested originally, you must subtract it from the depth requested to get the real distance.

%-----------------------------------------------------------------------------------------------
\subsection{Subtle Points in the Semantics}\label{sub:subtle}

\subsubsection*{Loops versus Containers}
A graph query with a for loop iterates the type and/or incidence ringlists which define the graph.
A graph query returning a set builds a set -- employing the same iteration -- and returns that set.
That yields two differences:
\begin{itemize}
	\item If you iterate the set, this happens in the iteration order of the container that was built -- you'll visit the elements in an order that is different from the original iteration order.
	\item Duplicates during graph iteration are removed -- this holds for reflexive edges that are visited twice during an incident-edges iteration, once in their role of incoming edge, and once in their role of outgoing edge.
\end{itemize}

\subsubsection*{Types}
Graph functions without specified type return a node of type \texttt{Node} or an edge of type \texttt{AEdge}. 
If a type is specified, they return a node or edge of the specified type.

Graph queries which return a set type return for nodes a \texttt{set<Node>}, irrespective of a/the specified node type. 
You won't receive a \texttt{set<N>} with \texttt{N} being a node type from your model that you requested in the query.

Graph queries which return a set type return for edges
\begin{itemize}
	\item a \texttt{set<Edge>} in case the requested edge type is a directed edge.
	\item a \texttt{set<UEdge>} in case the requested edge type is an undirected edge.
	\item a \texttt{set<AEdge>} in case the requested edge type is an arbitrary directed edge, \\or no edge type was specified.
\end{itemize}
You won't receive a \texttt{set<E>} with \texttt{E} being an edge type from your model that you requested in the query, but you get a set of the edge root type matching your requested type. 
This way, you can evade the unspecific \texttt{AEdge}, a recommended practice if you always only use directed edges.

If the behavior regarding set types is not what you want, you can employ a container copy constructor (cf. Chapter~\ref{cha:container}) to obtain a container of your desired type (containing only the elements that match the container element type), see the following two examples.

\begin{example}
\begin{grgen}
def ref snode:set<Node> = nodes(N); // nodes returns set<Node> as static type,
                                    // even if only nodes of type N are returned at runtime
def ref sn:set<N> = set<N>(snode); // use a container copy constructor for getting
                                   // a set of intended type (here more concrete type)
for(n:N in snode) { // this works because the for loop applies an implicit type cast
                    // this will fail at runtime if snode contains a node
                    // that is not of type N or one of its subtypes
}
for(n:N in sn) { // this will not fail as the container copy constructor 
                 // filters out nodes of not matching type (without runtime failure)
}
\end{grgen}
\end{example}

\begin{example}
\begin{grgen}
def ref sedge:set<Edge> = edges(E); // edges returns set<Edge> as static type
                                    // (for E extends Edge), even if only edges 
                                    // of type E are returned at runtime
def ref saedge:set<AEdge> = set<AEdge>(sedge); // use a container copy constructor 
                                               // for getting a set of intended type
                                               // (here more general type)
saedge.add(uedge); // works for uedge:UEdge, 
                   // a set of AEdge can also contain undirected edges
sedge.add(uedge); // fails for the same operation, an undirected edge 
                  // cannot be added to a set of directed edges
\end{grgen}
\end{example}

%-----------------------------------------------------------------------------------------------
\section{Subgraph Operations}\label{sec:subgraphop}

Several functions and procedures returning and accepting subgraphs are available;
they are especially useful in state space enumeration, cf. \ref{sec:statespaceenum}, but also in graph-oriented programming with the structuring and information hiding supported by hierarchically nested graphs, cf. \ref{sec:graphnesting}.

In addition to those computations explained below, you can access the currently processed graph via the  \texttt{\indexed{this}}\ixkeyw{this} variable that is available in the expressions of the sequences and the rules. 
By default it is bound to the host graph, but if processing was relocated in the sequences to a subgraph, it is bound to the currently processed subgraph.

The global functions allow to compute (node-or-edge) induced subgraphs and clone subgraphs:

\begin{description}
\item[\texttt{inducedSubgraph(.)}] returns the induced subgraph (type: \texttt{graph}) of the host graph for the set of nodes given as argument value.
\item[\texttt{definedSubgraph(.)}] returns the defined (edge-induced) subgraph (type: \texttt{graph}) of the host graph for the set of edges given as argument value.
\item[\texttt{copy(.)}] returns a clone of the original subgraph given as argument.
\end{description}

You may furtheron check for subgraph equality against a set of subgraphs at once:

\begin{description}
\item[\texttt{equalsAny(.,.)}] returns whether the (sub)graph given as first argument (type: \texttt{graph}) equals any of the (sub)graphs available in the set of subgraphs given with the second argument (type: \texttt{set<graph>}).
\item[\texttt{equalsAnyStructurally(.,.)}] returns whether the (sub)graph given as first argument (type: \texttt{graph}) is structurally (neglecting attribute values) equal to any of the (sub)graphs available in the set of subgraphs given with the second argument (type: \texttt{set<graph>}).
\end{description}

The first function employs \verb#==# in a loop until a decision is reached, the second function does so with \verb#~~#.
They are a bit more convenient in usage compared to writing the loop by hand, but above all are they amenable to parallelization.
You must specify the (maximum) number of worker threads to enable parallel execution, see section \ref{sec:performanceparallel}.
 
The global procedures allow to insert clones of subgraphs computed with the previously introduced function,
or to insert clones of induced subgraphs directly.

\begin{description}
\item[\texttt{insert(.)}] inserts a given subgraph to the current host graph (disjoint union of the nodes and edges); the original graph is destroyed by this (move semantics).
\item[\texttt{insertCopy(.,.)}] inserts a clone of the given subgraph to the current host graph (disjoint union of the nodes and edges); the original subgraph stays untouched. Returns the copy of the node given as second argument from the host graph.
\item[\texttt{insertInduced(.,.)}] adds a clone of the subgraph induced by the set of nodes given as first argument to the host graph, returns the clone of the anchor node given as second argument.
\item[\texttt{insertDefined(.,.)}] adds a clone of the subgraph defined (edge-induced) by the set of edges given as first argument to the host graph, returns the clone of the anchor edge given as second argument.
\end{description}

%-----------------------------------------------------------------------------------------------
\section{File Operations}\label{sec:fileop}

The functions from the built-in package \texttt{File} allow to import subgraphs and check for file existance (for more on packages see \ref{sub:packageaction}).

\begin{description}
\item[\texttt{File::import(.)}] returns the (sub)graph stored in the \texttt{.grs}-file given by its path (the main graph is \emph{not} replaced, the graph must be compatible to the model of the current host graph).
\item[\texttt{File::exists(.)}] returns whether the file given by its path exists.
\end{description}

The procedures from the built-in package \texttt{File} allow to export subgraphs and delete files.

\begin{description}
\item[\texttt{File::export(.)}] exports the current host graph to a file with the given path.
\item[\texttt{File::export(.,.)}] exports the subgraph given as first argument to a file with the given path.
\item[\texttt{File::delete(.)}] deletes the file with the given path.
\end{description}

% todo: mehr beispiele

\pagebreak % to improve layout later on
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph comparison}\label{sec:relationalgraph}

Here we extend the relational expressions already introduced in \ref{sec:relational} (and already extended in \ref{cha:container} to include container types) with the (sub)graph type.

\begin{table}[htbp]
  \centering
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    \texttt{A == B} & True, iff $A$ is isomorphic to $B$. \\
    \texttt{A != B} & True, iff $A$ is not isomorphic to $B$. \\
    \texttt{A \textasciitilde\textasciitilde{ } B} & True, iff $A$ is structurally the same as $B$ but maybe different regarding the attributes. \\ \hline
  \end{tabularx}
  \caption{Compare operators on graph expressions}
  \label{compandgraph}
\end{table}

The \texttt{graph} type support the \texttt{==}, the \texttt{!=}, and the \texttt{\textasciitilde\textasciitilde} operators;
on (sub)graph types they tell whether the (sub)graphs are isomorphic to each other (\indexed{isomorphy checking}/\indexed{graph isomorphy checking}) or not, including the attributes, or whether the (sub)graphs are isomorphic disregarding the attributes.

These operators consist just of two characters, but don't underestimate their impact on performance:
they do graph isomorphy checking, which is expensive.
They are implemented in an early out style, i.e. the more different the graphs are, the earlier does the check return with the result they are not isomorphic.
But if the graphs you are checking are isomorphic (which will happen easily if you use automorphic patterns), then you have to pay the full price for isomorphy checking; if this occurs often, your solution may become prohibitively costly (including an external graph canonization library or the \texttt{canonize} function may be of interest in that case).

Some notes on the early out implementation: first the number of nodes and edges per type are checked, if they are different the graphs can't be isomorphic. The numbers are directly supplied by the \texttt{lgspBackend}, refuting isomorphy based on them is extremely cheap.
Then the \indexed{V-Structure}s (see \ref{searchplanning}) used in computing better matchers at runtime are first computed and then compared; if they are different the graphs can't be isomorphic. They are a good deal less expensive to compute than trying to match the one graph in the other; on well typed graphs the V-Structure counts are highly discriminating.

If these two pruning methods failed, a matcher is computed from one graph with search planning based on the V-Structure information just computed, and then applied on the other graph.
The matchers are stored in the graphs from which they originated, so if you do repeated comparisons of a subgraph which does not change, take care to extract that subgraph only once, store it, e.g. as an attribute in the graph, and continue to compare against it. 
This will save you from the cost of repeated search planning; in addition, often-used isomorphy matchers get eventually compiled resulting in a further speed-up.


\begin{example}
An example showing how to save a graph exploded into its connected components, and how to load it again from them.
\begin{grgen}
procedure saveConnectedComponents()
{
	def var i:int = 0;
	while(!empty()) {
		def var n:Node = fetchNode();
		def ref connectedComponent:set<Node> = reachable(n) | set<Node>{n};
		def var sub:graph = inducedSubgraph(connectedComponent);
		File::export(sub, "cc"+i+".grs");
		deleteSubgraph(connectedComponent);
		i = i + 1;
	}
	return;
}

procedure loadConnectedComponents()
{
	def var i:int = 0;
	while(File::exists("cc"+i+".grs")) {
		insert(File::import("cc"+i+".grs"));
		i = i + 1;
	}
	return;
}

procedure removeSavedConnectedComponentsFiles()
{
	def var i:int = 0;
	while(File::exists("cc"+i+".grs")) {
		File::delete("cc"+i+".grs");
		i = i + 1;
	}
	return;
}

function fetchNode() : Node
{
	for(n:Node in nodes()) {
		return(n);
	}
	return(null);
}

procedure deleteSubgraph(ref sn:set<Node>)
{
	for(n:Node in sn) {
		rem(n);
	}
	return;
}
\end{grgen}
\end{example}

\begin{example}
An example showing some subgraph extraction, comparison, and insertion operations.
\begin{grgen}
rule init
{
	modify { // creates the host graph our example rule and function are working on
		start1:SN -:contains-> s1x:Node;
		start1    -:contains-> s1y:Node;
		s1x --> s1y;

		start2:SN -:contains-> s2x:Node;
		start2    -:contains-> s2y:Node;
		start2    -:contains-> s2z:Node;
		s2x --> s2y --> s2z --> s2x;
	}
}

function unequalContainedSubgraphs(start1:SN, start2:SN) : boolean
{
	def ref adj:set<Node> = adjacentOutgoing(start1, contains); //adj=={s1x,s2x}
	def var sub1:graph = inducedSubgraph(adj); // sub1==graph(s1x' -->' s1y') -- does not contain s1x,s1y themselves!
	def var sub2:graph = inducedSubgraph(adjacentOutgoing(start2, contains));
	def var res:boolean = sub1 == sub2; // false as graph(s1x' -->' s1y') != graph(s2x' -->' s2y' -->' s2z' -->' s2x'), answered quickly because number of elements different
	def var sub3:graph = copy(sub1);
	def var res2:boolean = sub1 == sub3; // true as graph(s1x' -->' s1y') isomorphic graph(s1x'' -->'' s1y''), answered slowly because isomorphy matching
	return(res); // remark: the original graph is untouched
}

rule example
{
	start1:SN; start2:SN;
	if{ unequalContainedSubgraphs(start1, start2); }
	
	modify {
		eval {
			insert(inducedSubgraph(adjacentOutgoing(start2, contains) | set<Node>{start2}));
				// 1. computes the union of the set of the nodes outgoing from start2 with the set containing start2
				// 2. creates a structurally equal clone of the induced graph of the node set handed in (start2, s2x, s2y, s2z, and all edges in between)
				// 3. inserts the clone into the original graph (disjoint union)
				// the clone was destroyed by insert, can't be accessed further
			(def start2n:SN)=insertInduced(adjacentOutgoing(start2), start2);
				// does the same, just a bit simpler and more efficient, 
				// with start2n you have a node that gives you access to the subgraph just inserted (by computing adjacentOutgoing(start2n, contains)),
				// so you can do further processing of that newly created piece,
				// e.g. link it to other nodes in the original graph
		}
	}
}
\end{grgen}
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Visited Flags} \label{sub:visitedaccess}\indexmain{visited access}

The boolean \texttt{visited} flags are available for/in each graph element; 
they may be used for marking already visited graph elements during graph walks or for partitioning a graph.
They can be queried with a function of the expressions, can be set with an assignment of the statements, and can be reset, allocated, and deallocated with procedures of the statements.
The visited flags are stored in some excess bits of the graph elements, if this pool is exceeded they are stored in additional dictionaries, one per visited flag requested.
This is why the flags must get allocated/deallocated, and all flag related operations require an integer number -- the flag id -- specifying the flag to operate on (with exception of the allocation operation returning this flag id).
If you try to access a not previously allocated visited flag, an exception is thrown.
The following syntax diagram gives an extensions to the \emph{Expression} clause of chapter \ref{cha:typeexpr} and an extension to the computation \emph{Statements} of chapter \ref{cha:computations}:

\begin{rail}
	Expression: VisitedFlag ;
  VisitedAssignment: VisitedFlag '=' BoolExpr ';';
	VisitedFlag: NodeOrEdge '.' 'visited' ('[' IntExpr ']')? ;
\end{rail}\ixnterm{VisitedFlag}\ixnterm{VisitedAssignment}\ixkeyw{visited}

\begin{description}
\item[Flag reading:] By \texttt{e.visited[f]} -- the function returns the \texttt{boolean} visited status of the flag given by the flag id variable \texttt{f} of the graph element \texttt{e} (visited flags are normally read by \texttt{if} conditions of the rule language).
If no \texttt{int} flag number is given, the default number for the first visited flag of 0 is used; it still must have been allocated before.
\item[Flag assignment:] By \texttt{e.visited[f] = b} -- sets the visited status of the flag given by the flag id variable \texttt{f} of the graph element \texttt{e} to the given boolean value \texttt{b} as computed by an expression
(visited flags are normally written by \texttt{eval} parts of the rule language).
If no \texttt{int} flag number is given, the default number for the first visited flag of 0 is used; it still must have been allocated before.
\end{description}

\begin{rail}
  ProcedureName: 'valloc' | 'vfree' | 'vreset' | 'vfreenonreset';
\end{rail}\ixkeyw{valloc}\ixkeyw{vfree}\ixkeyw{vreset}\ixkeyw{vfreenonreset}

The signatures of the procedures \texttt{valloc}, \texttt{vfree}, \texttt{vreset}, \texttt{vfreenonreset} for managing the visited flags are defined in \ref{procstab}.
Their semantics are:
\begin{description}
\item[Flag allocation:] By \texttt{valloc()}\label{allocvisitflag} -- allocates space for a visited flag in the elements of the graph and returns the id of the visited flag (integer number), starting at 0.
Afterwards, the visited flag of the id can be read and written by the \texttt{visited}-expression and the \texttt{visited}-assignment.
The first visited flags are stored in some excess bits of the graph elements and are thus essentially for free,
but if this implementation defined space is used up completely, the information is stored in graph element external dictionaries.
\item[Flag deallocation:] By \texttt{vfree} -- frees the space previously allocated for the visited flag; afterwards you must not access it anymore.
The value passed in \texttt{vfree(IntExpr)} must be of integer type, stemming from a previous allocation.
This function internally calls a \texttt{vreset} to ensure that no corresponding visited flag is set in the graph.
\item[Flag resetting:] By \texttt{vreset} -- resets the visitor flag given by the flag id variable in \emph{all} graph elements.
\item[Flag deallocation without reset:] With \texttt{vfreenonreset} the space previously allocated for the visited flag is freed, too, but the implicit internal \texttt{vreset(id)} of \texttt{vfree} is not executed. It is your duty to ensure the flag is \texttt{false} in all graph elements -- otherwise after a following allocation elements may start as being marked. This saves us an O(n) operation, but opens the door to nasty bugs if you can't design your algorithm in a way which renders unmarking trivial.
\end{description}


\begin{example}
An example showing how to compute the length of the longest path starting at some node.
\begin{grgen}
procedure lengthOfLongestPath(start:Node, var lengthReached:int, var flag:int) : (int)
{
	def var maxLength:int = lengthReached;
	start.visited[flag] = true;
	for(child:Node in adjacent(start)) {
		if(!child.visited[flag]) {
			def var lengthOfLongestPathStartingAtChild:int;
			(lengthOfLongestPathStartingAtChild)=lengthOfLongestPath(child, lengthReached+1, flag);
			maxLength = Math::max(maxLength, lengthOfLongestPathStartingAtChild);
		}
	}
	start.visited[flag] = false;
	return (maxLength);
}

rule getLolp(start:Node) : (int)
{
	modify {
		def var lolp:int;
		eval {
			(def var flag:int) = valloc();
			(yield lolp) = lengthOfLongestPath(start, 0, flag;)
			vfree(flag);
		}
		return(lolp);
	}
}
\end{grgen}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph Processing Environment Procedures}

\subsection{Transaction Handling}\label{sub:transaction}

In addition to the procedures implemented directly in the graph, there are transaction manager procedures available, implemented in the graph processing environment.
While a transaction is underway, an undo log is filled with commands to undo the changes that occurred in the graph in the meantime.
Those transaction handling procedures from the built-in package \texttt{Transaction} (for more on packages see \ref{sub:packageaction}) are:

\begin{description}
\item[\texttt{Transaction::start()}] starts a transaction and returns its transaction id (as number of type \texttt{int}).
\item[\texttt{Transaction::pause()}] pauses transaction handling so changes are not recorded and can't be undone.
\item[\texttt{Transaction::resume()}] resumes paused transaction handling.
\item[\texttt{Transaction::commit(.)}] keeps the changes of the transaction of the given id (of type \texttt{int}) in the graph, removing undo information.
\item[\texttt{Transaction::rollback(.)}] reverts the changes of the transaction of the given id (of type \texttt{int}) in the graph by executing the undo log.
\end{description}

Please note that transactions may be nested; those functions are used in implementing the transaction and backtracking constructs explained in \ref{sec:extctrl}.


\subsection{Misc. Global Procedures}

Besides there are procedures to emit text or record graph changes available: 

\begin{description}
\item[\texttt{emit(.(,.)*)}] writes the argument value, or the comma separated list of argument values, to stdout, or to a file if output was redirected. The argument(s) must be of string type, but any type is automatically casted into its string representation as needed. Prefer comma separated arguments over string concatenation, they are are more efficient as no intermediate strings need to be computed, just to be garbage collected thereafter.
\item[\texttt{emitdebug(.(,.)*)}] writes the argument value, or the comma separated list of argument values, always to stdout, even if file output was redirected. Besides that, the other explanations for \texttt{emit} apply.
\item[\texttt{record(.)}] writes the argument value, typically a text string, to the graph change record.
\end{description}

A remark on the graph global variables: they are in fact global to the graph processing environment.
This difference becomes clear when you store graphs in attributes of graph type of another graph, see \ref{sec:graphnesting} for a discussion of this style of programming.


