\chapter{GrShell Language}\indexmain{GrShell}
\label{chapgrshell}

The console application \GrShell\ and its WindowsForms counterpart, the \GGrShell, are \indexedsee{shell}{GrShell} applications built on top of \LibGr\indexmain{libGr} that offer an execution environment for your generated graph transformations.
They belong to \GrG's standard equipment, and implement nearly everything in common, so we use in the following only the term \GrShell.
\GrShell\ is capable of creating, manipulating, and dumping graphs as well as performing and esp. debugging graph rewriting.
The \GrShell\ provides a line oriented scripting language.
\GrShell\ scripts are structured by simple statements separated by line breaks.

%rewrite stuff to be command based instead of splitting commands over several sections?

The elements of a graph (nodes and edges) can be accessed both by their (graph global) \indexed{variable}\indexmain{graph global variable} identifier and by their \newterm{persistent name} specified through a constructor (see Section~\ref{graphcreationcommands}).

\begin{example}
\label{persistentex}
We insert a node, \indexed{anonymous}ly and with a \indexed{constructor} (see also Section~\ref{graphcreationcommands}):
\begin{grshell}
> new graph "../lib/lgsp-TuringModel.dll" G
New graph "G" of model "Turing" created.

# insert an anonymous node...
# it will get a persistent pseudo name
> new :State
New node "$0" of type "State" has been created.
> delete node @("$0")

# and now with constructor
> new v:State($=start)
new node "start" of type "State" has been created.
# Now we have a node named "start" (via $ assignment) and a variable v assigned to "start"
\end{grshell}
\end{example}

\begin{note}
Persistent names will be saved (\texttt{save graph\dots}, see Section~\ref{outputcmds}) and exported,
and, if you visualize a graph (\texttt{dump graph\dots}, see Section~\ref{outputcmds}),
graph elements will be \indexed{label}ed with their persistent names.
Persistent names have to be unique for a graph (the graph they belong to).
\end{note}

Besides the commands defined in this chapter, you find \GrShell commands in the following chapters \ref{cha:persistentstorage} and \ref{chapdebugger}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Common Commands}
\label{commcommands}

Here and in the following sections we describe the \GrShell\ commands\ixnterm{Command}.

\begin{rail}
  Script: ((Command ('<line break>' | ';;'))+) '<end of file>' ;
\end{rail}\ixnterm{Script}
Commands are assembled from basic elements (see esp. Section \ref{shellbuildingblocks}).
As stated before, commands are terminated by line breaks.
Alternatively commands can be terminated by the \indexed{\texttt{;;}} symbol.
Like an operating system shell, the \GrShell\ allows you to span a single command over $n$ lines by terminating the first $n-1$ lines with a \indexed{backslash}.

\begin{rail}
  'help' (Command)?
\end{rail}\ixkeyw{help}
Displays an information message describing all the supported commands.
A command \texttt{Command} displayed with \texttt{...} has further help available, which can be displayed with \texttt{help Command}.

\begin{rail}
  'quit' | 'exit'
\end{rail}\ixkeyw{quit}\ixkeyw{exit}
Quits \GrShell. If \GrShell\ is opened in debug mode, a currently active graph viewer (such as \yComp) will be closed as well.

\begin{rail}
  'echo' Text
\end{rail}\ixkeyw{echo}
Prints \emph{Text} onto the \GrShell\ command prompt.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph and Graph Element Creation}
\label{graphcreationcommands}

The command most shell scripts start with is graph creation.

\begin{rail}
  'new' (() | 'new') 'graph' Filename (() | Text) (() | PersistenceSuffix)
\end{rail}\ixkeyw{new}\ixkeyw{graph}
Creates a new graph with the model specified in \emph{Filename}\indexmain{graph model}.
Its name is set to \emph{Text} (optional).
The model file can be either source code (e.g.\ \texttt{turing\textunderscore machineModel.cs}) or a .NET assembly (e.g.\ \texttt{lgsp-turing\textunderscore machineModel.dll}).
It's also possible to specify a rule set file as \emph{Filename} (this is the most common usage).
In this case the necessary assemblies will be created on the fly (as needed).

In case of a double \texttt{new}, the actions and model are created anew for sure, and not as needed according to the file change dates.
Use this if you are working with one of the \texttt{new set} or \texttt{new add} commands from Section \ref{sec:compilerconfigshell}.

When a \emph{PersistenceSuffix} is given, a new \indexed{persistent graph} is created, you find more on it in Section \ref{persistentgraphcreationcommands}.

\begin{warning}
You may run into unexpected results because some \texttt{new set} or \texttt{new add} options that you apply and see in the shell file are not the ones actually compiled into the generated code.
This happens easily when you just edit those options, but the actions are not regenerated because the sources did not change.
Use \texttt{new new} in case you are working with the options from below to ensure the actions are regenerated irrespective of the change dates of their sources (at the cost of steady recompilations).
\end{warning}

The following two commands create graph elements, initializing their attributes.
On shell level they are available and mainly used as elementary instructions in creating an initial graph, in exporting and importing a graph, as well as in change recording and replaying.
These are the commands you may find in the GRS export/import files.


\begin{note}
If you need to import data that comes in a format that is not directly supported by \GrG,
we recommend to serialize it into \texttt{GRS} format,
as it can be written easily.
It consists of the few \texttt{new} commands and the attribute initialization lists explained here in \ref{graphcreationcommands}.
\end{note}

\begin{rail}
  'new' (() | Text) (() | ':' NodeType (() | Constructor))
\end{rail}\ixkeyw{new}
Creates a new node within the current graph.
Optionally, the new node is assigned to a variable \emph{Text}.
If \emph{NodeType} is supplied, the new node will be of type \emph{NodeType} and attributes can be initialized by a constructor.
Otherwise the node will be of the base node class type \emph{Node}.

\begin{note}
The \GrShell\ can reassign \indexed{variable}s.
This is in contrast to the rule language (Chapter~\ref{chaprulelang}), where we mainly use \emph{names}\indexmain{name}\indexmain{expression variable}\indexmainsee{expression variable}{name}
(bound once -- with exception of var and ref input variables and def entities).
\end{note}

\begin{rail}
  'new' Node (('-' EdgeEntityConstructor '->') | ('<-' EdgeEntityConstructor '-') | ('-' EdgeEntityConstructor '-')) Node ;
EdgeEntityConstructor:
  (()|Text) (() | ':' EdgeType (() | Constructor)) ;
\end{rail}\ixkeyw{new}
Creates a new edge within the current graph between the specified nodes,
in direction of the first to the second \emph{Node} in case of \texttt{-->},
in direction of the second to the first \emph{Node} in case of \texttt{<--},
or undirected in case of \texttt{--}.
Optionally, the new edge is assigned to a variable \emph{Text}.
If \emph{EdgeType} is supplied, the new edge will be of type \emph{EdgeType} and attributes can be initialized by a constructor.
Otherwise the edge will be of the base edge class type \texttt{Edge} for \texttt{-->} or \texttt{UEdge} for \texttt{--}.

\begin{rail}
  Constructor : '(' (() | (dollar '=' Text (() | ',' Attributes) | Attributes)) ')';
  Attributes : (AttributeName '=' AttributeValue) + (',');
  AttributeValue :  PrimitiveAttributeValue | SetConstr | MapConstr | ArrayConstr | DequeConstr;
  PrimitiveAttributeValue : EnumLit | Number | FloatingNumber | QuotedText | BoolLit | NullLit ;
  SetConstr: 'set' '<' Type '>' lbrace ( Expression*',' ) rbrace ;
  MapConstr: 'map' '<' Type ',' Type '>' \\ lbrace ( (Expression '->' Expression)*',' ) rbrace ;
  ArrayConstr: 'array' '<' Type '>' '[' ( Expression*',' ) ']' ;
  DequeConstr: 'deque' '<' Type '>' ']' ( Expression*',' ) '[' ;
\end{rail}\indexmain{\texttt{\$}}\ixnterm{Constructor}\ixnterm{Attributes}\ixnterm{AttributeValue}\ixnterm{PrimitiveAttributeValue}\ixnterm{SetConstr}\ixnterm{MapConstr}\ixnterm{ArrayConstr}\ixnterm{DequeConstr}
A \indexed{constructor} is used to initialize a new graph element (see \texttt{new \dots} below).
A comma separated list of \indexed{attribute} initializations is supplied to the constructor.
Available attribute names are specified by the graph model of the current working graph.
All the undeclared attributes will be initialized with \indexed{default value}s, depending on their type
(\texttt{int} $\leftarrow$ \texttt{0}; \texttt{long} $\leftarrow$ \texttt{0L}; \texttt{byte} $\leftarrow$ \texttt{0Y}; \texttt{short} $\leftarrow$ \texttt{0S}; \texttt{boolean} $\leftarrow$ \texttt{false}; \texttt{float} $\leftarrow$ \texttt{0.0f}; \texttt{double} $\leftarrow$ \texttt{0.0}; \texttt{string} $\leftarrow$ \texttt{""}; \texttt{set<T>} $\leftarrow$ \texttt{set<T>\{\}}; \texttt{map<S,T>} $\leftarrow$ \texttt{map<S,T>\{\}}; \texttt{array<T>} $\leftarrow$ \texttt{array<T>[]}; \texttt{deque<T>} $\leftarrow$ \texttt{deque<T>][}; \texttt{enum} $\leftarrow$ unspecified;).\\
The \texttt{\$} is a special attribute name: a unique identifier of the new graph element.
This identifier is also called \newterm{persistent name} (see Example~\ref{persistentex}).
This name can be specified by a constructor only.

\begin{rail}
  'add' 'new' 'graph' Text
\end{rail}\ixkeyw{add}\ixkeyw{new}\ixkeyw{graph}
Creates a new subgraph of the same model as the current graph.
Its name is set to \emph{Text}; its unique name as used in exporting or recording may be a variant of this name in case another subgraph of the same name alreay exists.
After execution this graph is the current subgraph.

\begin{rail}
  'in' Text
\end{rail}\ixkeyw{in}
Switches graph processing to the given subgraph (denoted by its unique name).
This command as well as the command above are supplied for importing grs files containing subgraph attributes resulting from a grs export or recording.
Using them directly is discouraged; you would have to ensure unique names in order to use them, a task that is carried out by the exporter remembering the subgraphs already seen.

\begin{rail}
  'new' ObjectType ObjectConstructor
\end{rail}\ixkeyw{new}
Creates a new internal class object (non-transient).
The new object will be of type \emph{ObjectType} and attributes can be initialized by an object constructor.

\makeatletter
\begin{rail}
  ObjectConstructor : ('@')? '(' (() | (percent '=' Text (() | ',' Attributes) | Attributes)) ')';
\end{rail}\indexmain{\texttt{\%}}\ixnterm{ObjectConstructor}
\makeatother
An \indexed{object constructor} is used to initialize a new internal class object.
A comma separated list of \indexed{attribute} initializations is supplied to the constructor.
The \texttt{\%} is a special attribute name: a unique identifier of the new object.
This name can be specified by a constructor only (and is normally automatically assigned upon object construction -- this also occurs when it is left out here).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sequence Execution and Profiles}\label{grsthings}\indexmainsee{action}{graph rewrite sequence}

\begin{rail}
  GraphRewriteSequence: ('exec'|'xgrs') SimpleRewriteSequence ;
\end{rail}\ixkeyw{exec}\ixkeyw{xgrs}\indexmain{graph rewrite sequence}\indexmainsee{GRS}{graph rewrite sequence}\ixnterm{GraphRewriteSequence}
This executes the graph rewrite sequence \emph{SimpleRewriteSequence}.
See Chapter~\ref{cha:xgrs} for graph rewrite sequences.

Additionally to the variable assignment in rule-embedded graph rewrite sequences, you are also able to assign \emph{persistent names} to parameters via  \texttt{Variable = @(Text)}.
Graph elements returned by rules can be assigned to variables\indexmain{variable} using \texttt{(Para\-meters) = \emph{Action}}\indexmain{parameter}.
The desired variable identifiers have to be listed in \emph{Parameters}.
Graph elements required by rules must be provided using \texttt{Action(Para\-meters)}, where \emph{Parameters} is a list of variable identifiers.
For \indexed{undefined variables} see Section~\ref{ruledecls}, \emph{Parameters}.

\begin{rail}
  GraphRewriteSequenceExpression: 'eval' SequenceExpression ;
\end{rail}\ixkeyw{eval}\indexmain{graph rewrite sequence expressione}\ixnterm{GraphRewriteSequenceExpression}
This evaluates the graph rewrite sequence expression \emph{SequenceExpression}.
See Chapter~\ref{seqcomp} for graph rewrite sequences expressions (this command is esp. of interest for rule queries, cf. Chapter~\ref{cha:graphquery}).

\begin{rail}
  GraphRewriteSequence: RewriteSequenceDefinition;
\end{rail}\ixkeyw{def}\indexmain{graph rewrite sequence definition}\indexmain{sequence definition}
This command allows to define a named sequence at runtime, for $RewriteSequenceDefinition$ have a look here  \ref{sec:sequencedefinition} in the rule application control language chapter.
Especially it allows to replace an old sequence definition, but only if the signature is identical.
Compiled sequences defined in rule files can't be replaced.
The defined sequence can then be used from following graph rewrite sequences (or following sequence definitions) in the shell.

\begin{example}
\begin{grgen}
# a sequence definition (of an interpreted sequence) is only available
# after it was registered the first time
# but it can get overwritten with a sequence of the same signature
# -> (self or mutually) recursive sequences must be constructed with empty body first
def chain(first:A):(last:A){ true }
def chain(first:A):(last:A){ if{(next:A)=chainPiece(first); (last)=chain(next); last=first} }
\end{grgen}
\end{example}

An \emph{action} denotes a graph rewrite rule (or test).

\begin{rail}
  'show' 'profile' (Action)?
\end{rail}\ixkeyw{show}\ixkeyw{profile}
Shows the profile for the action specified by its name, or for all rules and tests in the rule set.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variables}

\begin{rail}
  Variable '=' ( Variable | GraphElement | Object | Literal )
\end{rail}
Assigns the variable or by persistent name \emph{GraphElement} or by unique-id based name \emph{Object} or literal to \emph{Variable}.
If \emph{Variable} has not been defined yet, it will be defined implicitly.
As usual for scripting languages, variables have neither static types nor declarations.
The variables known to \GrShell\ are the graph global variables (see Chapter \ref{cha:xgrs} for the distinction between graph global and sequence local variables).

\begin{rail}
'show' 'var' Variable
\end{rail}\ixkeyw{show}\ixkeyw{var}
Prints the content of the specified variable.

\begin{rail}
  'askfor';
  Variable '=' 'askfor' Type
\end{rail}\ixkeyw{askfor}
The \texttt{askfor} command just waits until the user presses enter.
The \texttt{askfor} assignment interactively asks the user for a value of the specified type.
The entered value is type checked against the expected type, and assigned to the given variable in case it matches.
If the type is a value type, the user is prompted to enter a value literal with the keyboard.
If the type is a graph element type, the user is prompted to enter the graph element by double clicking in yComp.
Note that in this case the debug mode must have been enabled before.
(The command is equivalent to \verb#debug exec Variable=$%(Type)#.)

\begin{example}
\begin{grshelllet}
x = askfor int
\end{grshelllet}
asks the user to enter an integer value; pressing 4 then 2 then enter will do fine.
\begin{grshelllet}
x = askfor Node
\end{grshelllet}
asks the user to select a graph element in yComp; double clicking any node will do fine.
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building Blocks}\label{shellbuildingblocks}

\GrShell\ is \indexed{case sensitive}.
A line may be empty, may contain a shell command, or may contain a comment.
A \indexed{comment} starts with a \indexed{\texttt{\#}} and is terminated by end-of-line
 or end-of-file or \texttt{\S}.

The following items are required for representing text, numbers, and rule parameters.\\
\\
\emph{Text}\\
May be one of the following:
\begin{itemize}
  \item A non-empty character sequence consisting of letters, digits, and underscores. The first character must not be a digit.
  \item Arbitrary text enclosed by double quotes (\texttt{""}).
  \item Arbitrary text enclosed by single quotes (\texttt{''}).
\end{itemize}
Shell keywords are not allowed for type names, attribute values and other entities (even if they are legal in the rule language, this is a constraint of the chosen parser generator).
If this hits you, you can enclose the identifier by single or double quotes, i.e. Text can be used everywhere an identifier is required.

\mbox{ }\\
\emph{Number}\\
Is an \texttt{int} or \texttt{float} constant in decimal notation (see also Section~\ref{sec:builtintypes}).

\begin{rail}
 Parameters : Text + ',' ;
 SpacedParameters: Text + ;
\end{rail}\ixnterm{Parameters}\ixnterm{SpacedParameters}

In order to describe the commands more precisely, the following (semantic) specializations of \emph{Text} are defined:
\begin{description}
  \item[Filename]A fully qualified file name without spaces (e.g.\ \texttt{/Users/Bob/amazing\textunderscore file.txt}) or a single quoted or double quoted fully qualified file name that may contain spaces (\texttt{"/Users/Bob/amazing file.txt"}).
  \item[Variable] Identifier of a (graph global) variable that contains a graph element or a value. \indexmainsee{GrShell variable}{graph global variable} A double colon prefix as required in the sequences may be given, but as the shell only knows graph global variables, it is optional (in plain shell commands, not in sequences or sequence expressions appearing within shell commands).
  \item[NodeType, EdgeType] Identifier of a node type resp.\ edge type defined in the model of the current graph.
  \item[AttributeName] Identifier of an attribute.
  \item[Graph] Identifies a graph by its name.
  \item[Action] Identifies a rule by its name.
\end{description}

\makeatletter
\begin{rail}
  GraphElement: Text | ('@' '(' Text ')')
\end{rail}\indexmain{\texttt{"@}}\ixnterm{GraphElement}
\makeatother

\begin{description}
  \item[Node, Edge] The specializations \emph{Node} and \emph{Edge} of \emph{GraphElement} require the corresponding graph element to be a node or an edge respectively.
\end{description}

\makeatletter
\begin{rail}
  Object: Text | ('@@' '(' Text ')')
\end{rail}\indexmain{\texttt{"@"@}}\ixnterm{Object}
\makeatother

\begin{description}
  \item[Object] The \emph{Object} requires the corresponding object to be an internal class object, which is referenced by its unique id.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Attribute Assignment and Graph Manipulation}
\label{mani}
Graph manipulation commands alter existing graphs;
they allow to retype and delete graph elements and change attributes.
Creating elements was already introduced in the previous section.
These are tasks which are or at least should be carried out by the rules of the rule language in the first place.
On shell level they are available and mainly used as elementary instructions in creating an initial graph, in exporting and importing a graph, as well as in change recording and replaying.

\begin{rail}
  GraphElement '.' AttributeName '=' AttributeValue ;
\end{rail}
Set the \indexed{attribute} \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} to the value \emph{AttributeValue} (for the different possible attribute values see above).

\begin{rail}
  GraphElement '.' AttributeName '[' Index ']' '=' AttributeValue ;
\end{rail}
Overwrite the value in the array or deque or map \indexed{attribute} \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} at the integer position or key value \emph{Index} with the value \emph{AttributeValue}.

\begin{rail}
  GraphElement '.' AttributeName '.' 'add' '(' \\
  	PrimitiveAttributeValue (',' PrimitiveAttributeValue)? ')' ;
\end{rail}
Add the value \emph{PrimitiveAttributeValue} (for the different possible primitive attribute values see above) to the set valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} or add the key-value pair consisting of the two \emph{PrimitiveAttributeValue}s to the map valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement}.
Or add the value \emph{PrimitiveAttributeValue} to the end of the array/deque valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} in the one parameter case or insert the \emph{PrimitiveAttributeValue} to the of the array/deque valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} at the index given by the second parameter in the two parameter case.

\begin{rail}
  GraphElement '.' AttributeName '.' 'rem' '(' (PrimitiveAttributeValue)? ')' ;
\end{rail}
Remove the value \emph{PrimitiveAttributeValue} from the set valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} or remove the key \emph{PrimitiveAttributeValue} from the map valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} or remove the index \emph{PrimitiveAttributeValue} from the array valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} or remove the index \emph{PrimitiveAttributeValue} from the deque valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} or remove the end element from the array valued attribute \emph{AttributeName} of the graph element or internal class object \emph{GraphElement} in the zero parameter case or remove the first element from the deque valued attribute \emph{AttributeName} of the graph element or internal class object\emph{GraphElement} in the zero parameter case.


\begin{rail}
  'retype' Node '<' Type '>'
\end{rail}\ixkeyw{retype}
Retypes the node \emph{Node} from its current type to the new type \emph{Type}. Attributes common to initial and final type are kept. Incident edges are kept as well. \indexmain{retype}

\begin{rail}
  'retype' ('-' Edge '<' Type '>' '->' | '-' Edge '<' Type '>' '-')
\end{rail}\ixkeyw{retype}
Retypes the edge \emph{Edge} from its current type to the new type \emph{Type}. Attributes common to initial and final type are kept. Incident nodes are kept as well.

\begin{rail}
  'redirect' Edge ('source'|'target') Node
\end{rail}\ixkeyw{redirect}
Redirects the edge \emph{Edge} from the old source or target node to the new source or target \emph{Node} given.

\begin{rail}
  'delete' 'node' Node
\end{rail}\ixkeyw{delete}\ixkeyw{node}
Deletes the node \emph{Node} from the current graph.
Incident edges will be deleted as well.

\begin{rail}
  'delete' 'edge' Edge
\end{rail}\ixkeyw{delete}\ixkeyw{edge}
Deletes the edge \emph{Edge} from the current graph.

\begin{rail}
  'clear' 'graph' (() | Graph)
\end{rail}\ixkeyw{clear}\ixkeyw{graph}
Deletes all graph elements of the current working graph resp.\ the graph \emph{Graph}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Model and Graph Queries}

\begin{rail}
  'show' (() | 'num') ('nodes' (() | (() | 'only') NodeType) | 'edges' (() | (() | 'only') EdgeType))
\end{rail}\ixkeyw{show}\ixkeyw{num}\ixkeyw{nodes}\ixkeyw{edges}\ixkeyw{only}
Gets the \indexed{persistent name}s and the types of all the nodes/edges of the current graph.
If a node type or edge type is supplied, only elements compatible to this type are considered.
The \texttt{only} keyword excludes subtypes. Nodes/edges without persistent names are shown with a pseudo-name.
If the command is specified with \texttt{num}, only the number of nodes/edges will be displayed.

\begin{rail}
  'show' ('node' | 'edge') 'types'
\end{rail}\ixkeyw{show}\ixkeyw{node}\ixkeyw{edge}\ixkeyw{types}
Gets the node/edge types of the current graph model.

\begin{rail}
'show' ('node' ('super' | 'sub') 'types' NodeType | 'edge' ('super' | 'sub') 'types' EdgeType)
\end{rail}\ixkeyw{show}\ixkeyw{node}\ixkeyw{edge}\ixkeyw{super}\ixkeyw{sub}\ixkeyw{types}\indexmain{inheritance}
Gets the inherited/descendant types of \emph{NodeType}/\emph{EdgeType}.

\begin{rail}
  'show' ('node' 'attributes' (() | (() | 'only') NodeType) | 'edge' 'attributes' (() | (() | 'only') EdgeType))
\end{rail}\ixkeyw{show}\ixkeyw{node}\ixkeyw{edge}\ixkeyw{only}\ixkeyw{attributes}
Gets the available node/edge \indexed{attribute} types.
If \emph{NodeType}/\emph{EdgeType} is supplied, only attributes defined in \emph{NodeType}/\emph{EdgeType} are diplayed.
The \texttt{only} keyword excludes inherited attributes.\\
\begin{warning}
The \texttt{show nodes/edges attributes\dots} command covers types and \emph{inherited} types.
This is in contrast to the other \texttt{show\dots} commands where types and \emph{sub}types are specified or the direction in the type hierarchy is specified explicitly, respectively.
\end{warning}

\begin{rail}
 'show' ('node' Node | 'edge' Edge)
\end{rail}\ixkeyw{show}\ixkeyw{node}\ixkeyw{edge}
Gets the attribute types and values of a specific graph element.

\begin{rail}
  'show' GraphElement '.' AttributeName
\end{rail}\ixkeyw{show}
Displays the value of the specified attribute.

\begin{rail}
  'node' 'type' Node 'is' Node | 'edge' 'type' Edge 'is' Edge
\end{rail}\ixkeyw{node}\ixkeyw{edge}\ixkeyw{type}\ixkeyw{is}
Gets the information whether the first element is \indexed{type-compatible}\indexmainsee{compatible types}{type-compatible} to the second element.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Validation Commands}\label{sec:validate}

\GrG\ offers two different graph validation mechanisms,
the first checks against the connection assertions specified in the model,
the second checks against an arbitrary graph rewrite sequence containing arbitrary tests and rules.

\begin{rail}
  'validate' ('exitonfailure')? ('strict' ('only' 'specified')?)?
\end{rail}\ixkeyw{validate}\ixkeyw{exitonfailure}\ixkeyw{strict}\ixkeyw{only}\ixkeyw{specified}
Validates\indexmain{validate} if the current working graph fulfills the \indexed{connection assertion}s specified in the corresponding graph model (cf. ~\ref{sct:ConnectionAssertions}).
Validate without the strict modifier checks the multiplicities of the connections it finds in the host graph,
it ignores node-edge-node connections which are available in the host graph but have not been specified in the model.
The \emph{strict} mode additionally requires that all the edges available in the host graph must have been specified in the model.
This requirement is too harsh for models where only certain parts are considered critical enough to be checked
or might be a too big step in tightening the level of structural checking in an already existing large model.
So some form of selective strict checking is supported:
The \emph{strict only specified} mode requires strict matching (i.e. that all edges are covered) only of the edges for which connection assertions have been specified in the model.

\begin{rail}
  'validate' ('exitonfailure')? ('exec'|'xgrs') GRS
\end{rail}\ixkeyw{validate}\ixkeyw{exitonfailure}\ixkeyw{xgrs}\ixkeyw{exec}
Validates\indexmain{validate} if the current working graph satisfies the \indexed{graph rewrite sequence} given.
Before the graph rewrite sequence is executed, the instance graph gets cloned;
the sequence operates on the clone, allowing you to change the graph as you want to, without influence on the host graph.
Validation fails iff the sequence fails.
This gives a rather costly but extremely flexible and powerful mechanism to specify graph constraints.
The GrShell is exited with an error code if \texttt{exitonfailure} is specified and the validation fails.

\begin{example}
We reuse a simplified version of the road map model from Chapter~\ref{chapmodellang}:
\begin{grgen}
model Map;

node class city;
node class metropolis;

edge class street;
edge class highway
      connect metropolis [+] --> metropolis [+];
\end{grgen}
The node constraint on \emph{highway} requires all the metropolises to be connected by highways. Now have a look at the following graph:
\begin{center}
  \fbox{\includegraphics[width=8.5cm]{fig/map}}
\end{center}

This graph is valid but not strict valid.
\begin{grshell}
> validate
The graph is valid.
> validate strict only specified
The graph is NOT valid:
  CAE: city "Eppstein" -- highway "A3" --> metropolis "Frankfurt" not specified
> validate strict
The graph is NOT valid:
  CAE: city "Eppstein" -- highway "A3" --> metropolis "Frankfurt" not specified
  CAE: metropolis "Karlsruhe" -- street "trail" --> metropolis "Frankfurt" not specified
>
\end{grshell}
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Inclusion and Conditional Execution}
\label{inclcondexeccommands}

You may include further shell scripts, or execute parts of a shell script conditionally.

\begin{rail}
  'include' Filename ('.gz')?
\end{rail}\ixkeyw{include}
Executes the \GrShell\ script\indexmain{graph rewrite script} \emph{Filename} (which might be zipped).
A \GrShell\ script is just a plain text file containing \GrShell\ commands.
They are treated as they would be entered interactively, except for parser errors.
If a parser error occurs, execution of the script will stop immediately.

\begin{rail}
  'if' SequenceExpression Commands ('else' Commands)? 'endif'
\end{rail}\ixkeyw{if}\ixkeyw{else}\ixkeyw{endif}
If the sequence expression evaluates to true, the following command lines are executed, until the corresponding \texttt{else} or \texttt{endif} is reached.
If the sequence expression evaluates to false, the following command lines are skipped, until the corresponding \texttt{else} or \texttt{endif} is reached. 
In case an \texttt{else} is given, the command lines following the else until the endif are executed in the first case, or skipped in the second case.
The nature of shell execution is command-line based, without syntactic nesting.
The \texttt{if} command is an exception, a corresponding amount of \texttt{endif} commands is required, and applies to its syntactically preceeding if command, as does the \texttt{else} command. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{File System Commands and External Shell Execution}
\label{filesyscommandsextex}

Here we describe commands for inspecting and changing the working directory, and for executing an arbitrary command line in the shell of the hosting OS.

\begin{rail}
  'pwd'
\end{rail}\ixkeyw{pwd}
Prints the path to the current working directory.

\begin{rail}
  'ls'
\end{rail}\ixkeyw{ls}
Lists the directories and files in the current working directory, files relevant to GrGen are printed highlighted.

\begin{rail}
  'cd' Path
\end{rail}\ixkeyw{cd}
Changes the current working directory to the path given.

\begin{rail}
  '!' CommandLine
\end{rail}\indexmain{\texttt{"!}}
\emph{CommandLine}\indexmain{command line} is an arbitrary text, the operating system attempts to execute.
\begin{example}
On a Linux machine you might execute
\begin{grshell}
!sh -c "ls | grep stuff"
\end{grshell}
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shell and Environment Configuration}

\begin{rail}
'silence' ('on'|'off')
\end{rail}\ixkeyw{silence}\ixkeyw{on}\ixkeyw{off}
Switches the new node/edge created/deleted messages on(default) or off.
Switching them off allows for much faster execution of scripts containing a lot of creation commands.

\begin{rail}
'silence' 'exec' ('on'|'off')
\end{rail}\ixkeyw{silence}\ixkeyw{exec}\ixkeyw{on}\ixkeyw{off}
During non-debug sequence execution every second match statistics are printed to the console;
they allow to assess the progress of long-running transformations.
With this command they can be disabled (or enabled again).
Switching them off may be of interest if own debug messages printed via emit from the sequences (or rules) should not be disturbed.

\begin{rail}
'randomseed' (Number | 'time')
\end{rail}\ixkeyw{randomseed}\ixkeyw{time}
Sets the random seed to the given number for reproducible results when using the \$-operator-prefix or the random-match-selector, whereas time sets the random seed to the current time in ms.

\begin{rail}
'redirect' 'emit' Filename
\end{rail}\ixkeyw{redirect}\ixkeyw{emit}
Redirects the output of the emit-statements (but not the emitdebug-statements) in the rules from stdout to the given file.

\begin{rail}
'redirect' 'emit' '-'
\end{rail}\ixkeyw{redirect}\ixkeyw{emit}
Redirects the output of the emit-statements in the rules to stdout (again).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation Configuration}\label{sec:compilerconfigshell}

\begin{rail}
  'new' 'add' 'reference' Filename
\end{rail}\ixkeyw{new}\ixkeyw{add}\ixkeyw{reference}
Configures a reference to an external assembly \emph{Filename} to be linked into the generated assemblies, maps to the \texttt{-r} option of \texttt{grgen.exe} (cf. \ref{grgenoptions}).

\begin{rail}
  'new' 'set' ('keepdebug'|'profile'|'nodebugevents'|'noevents'|'lazynic'|'noinline') ('on'|'off')
\end{rail}\ixkeyw{new}\ixkeyw{set}\ixkeyw{keepdebug}\ixkeyw{profile}\ixkeyw{nodebugevents}\ixkeyw{noevents}\ixkeyw{lazynic}\ixkeyw{noinline}\ixkeyw{on}\ixkeyw{off}
Configures the compilation of the generated assemblies to keep the generated files and to add debug symbols (includes emitting of some validity checking code),
or configures the generation of the matchers.
The latter in order to 
include profiling information,
or not to emit debug event firing (mostly action events),
or not to emit event firing (attribute change events),
or to either execute negatives, independents, and conditions only lazily at the end of matching (normally as soon as possible),
or to never inline subpatterns.
Those flags are mapped to the \texttt{-keep} and the \texttt{-debug} options, or to the \texttt{-profile}, or to the \texttt{-nodebugevents} or the \texttt{-noevents}, or to the \texttt{-lazynic}, or to the \texttt{-noinline} options of \texttt{grgen.exe} (cf. \ref{grgenoptions}).

In addition to setting the compilation flags, the debug events firing flag also changes the debug event firing of the interpreted sequences at runtime (thus also this part of event firing).

When profiling is turned on, the number of search steps carried out is printed to the console after each sequence execution.
A search step is a binding of a graph element to a pattern entity in case there are at least potentially several choices available.
Fetching an element by type chooses from all elements of that type in the graph, following an incident edge chooses from all incident edges of the corresponding node, and matching by storage access chooses from all elements in that storage, whereas getting the source or target node from an edge or mapping with a storage map just grabs the target element from the source element.
(Each binding from a choice counts as one step, the non-choice-bindings are not counted.)
Profiling the search steps allows you to assess the work needed for a transformation, to find the hot spots worth optimizing.
The less search steps are needed to find a match the better (you typically want to efficiently find patterns and minimize the amount of search needed in order to do so). 

The flags are applied when the actions are generated anew because the model or rule files changed. They are not when you just switch them in the shell script. It's your responsibility to delete the old generated dlls when you change those options (by switching them, or by introducing them differently from the compiler options used to generate the dlls)!

\begin{rail}
  'new' 'set' 'statistics' Filename
\end{rail}\ixkeyw{new}\ixkeyw{set}\ixkeyw{statistics}
Configures the compilation of the generated assemblies to use the statistics file specified, yielding pattern matchers adapted to the class of graphs described in that file.
Maps to the \texttt{-statistics} option of \texttt{grgen.exe} (cf. \ref{grgenoptions}, and see \ref{custom} on how to get such statistics).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Backend, Graph, and Actions Selection}\label{backend}\indexmain{action command}

\subsubsection*{Backend}
\GrG\ is built to support multiple backends implementing the model and action interfaces of libGr.
This is roughly comparable to the different storage engines MySQL offers.
Currently only one backend is available, the libGr search plan backend, or short LGSPBackend.

\begin{rail}
  'show' 'backend'
\end{rail}\nopagebreak\ixkeyw{show}\ixkeyw{backend}
List all the parameters supported by the currently selected backend.
The parameters can be provided to the \texttt{select backend} command.

\begin{rail}
  'select' 'backend' Filename ( ( ) | ':' Parameters )
\end{rail}\ixkeyw{select}\ixkeyw{backend}
Selects a \indexed{backend} that handles graph and rule representation.
\emph{Filename} has to be a .NET assembly (e.g.\ \texttt{lgspBackend.dll}\indexmain{LGSPBackend}).
Comma-separated \indexed{parameter}s can be supplied optionally; if so, the backend must support these parameters.
By default the LGSPBackend is used.


\subsubsection*{Graph}

\begin{rail}
  'select' 'graph' Graph
\end{rail}\ixkeyw{select}\ixkeyw{graph}
Selects the current \indexed{working graph}.
This graph acts as \emph{\indexed{host graph}} for graph rewrite sequences (see also Sections~\ref{ov:whatsallabout} and~\ref{grsthings}).
Though you can define multiple graphs, only one graph can be the active ``working graph''.

\begin{rail}
  'show' 'graphs'
\end{rail}\ixkeyw{show}\ixkeyw{graph}
Displays a list of currently available graphs.

\begin{rail}
  'delete' 'graph' Graph
\end{rail}\ixkeyw{delete}\ixkeyw{graph}
Deletes the graph \emph{Graph} from the backend storage.

\begin{rail}
  'custom' 'graph' ( ( ) | SpacedParameters )
\end{rail}\ixkeyw{custom}\ixkeyw{graph}
Executes a command specific to the current backend.
If \emph{SpacedParameters} is omitted, a list of available commands will be displayed (for the LGSP backend see Sections~\ref{custom}).


\subsubsection*{Actions}

\begin{rail}
  'select' 'actions' Filename
\end{rail}\ixkeyw{select}\ixkeyw{actions}
Selects a \indexed{rule set}.
\emph{Filename} can either be a .NET assembly (e.g.\ ``rules.dll'') or a source file (``rules.cs'').
Only one rule set can be loaded simultaneously.

\begin{rail}
  'show' 'actions'
\end{rail}\ixkeyw{show}\ixkeyw{actions}
Lists all the rules of the loaded rule set, their parameters, and their return values.
Rules can return a set of graph elements.

\begin{rail}
  'custom' 'actions' (() | SpacedParameters)
\end{rail}\ixkeyw{custom}\ixkeyw{actions}
Executes an action specific to the current \indexed{backend}.
If \emph{SpacedParameters} is omitted, a list of available commands will be displayed (for the LGSPBackend see Section~\ref{custom}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LGSPBackend Custom Commands}
\label{custom}

%several rail nts are defines resolved to terminal with underscores

Don't be shy to use custom commands just because they are custom.
The search plan generation and explanation offered by them are of outstanding importance for achieving high performance solutions.
Leading directly to high-performance solutions by adapting the pattern matchers to the specifics of the host graph.
Or indirectly by explaining the chosen search plan so you can inspect it for the spots where the planner was not able to circumvent massively splitting passages; you may have to rethink your solutions regarding those, with maybe a change in the modelling, a change in the pattern, or even imperative code with hash set intersections/joins.

The \indexed{LGSPBackend} supports the following custom commands, separated into the realms of the graph and the actions.

\subsubsection*{Graph related custom commands}\label{sec:graphcustomcommands}

\begin{rail}
  'custom' 'graph' 'analyze'
\end{rail}\ixkeyw{custom}\ixkeyw{graph}\ixkeyw{analyze}
Analyzes\indexmain{analyzing graph} the current working graph.
The analysis data provides vital information for efficient \indexed{search plan}s.
Analysis data is available as long as \GrShell\ is running, i.e.\ when the host graph is manipulated, the analysis data is still available but outdated (which does not pose an issue unless the graph was changed massively regarding the relative number of elements per type or the connectedness-by-type relation).

\begin{rail}
  'custom' 'graph' 'statistics' 'save' Filename
\end{rail}\ixkeyw{custom}\ixkeyw{graph}\ixkeyw{statistics}\ixkeyw{save}
Write the statistics of the last analyze to the specified statistics file (the graph must have been analyzed before this command is called).
This way you can save the statistics of a characteristic graph of your domain and compile pattern matchers well adapted to those class of graphs straight from the beginning, saving you the costs of online analysis and matcher compilation.
See \ref{grgenoptions} or \ref{sec:compilerconfigshell} for explanations on how to do this.

\begin{rail}
  'custom' 'graph' 'optimizereuse' BoolLit
\end{rail}\ixkeyw{custom}\ixkeyw{graph}\ixkeyw{optimizereuse}
If set to false it prevents deleted elements from getting reused in a rewrite (i.e. it disables a performance optimization).
If set to true (default), new elements may not be discriminable anymore from already deleted elements using object equality, hash maps, etc.

\begin{rail}
  'custom' 'graph' optimizereusepoolsize Number
\end{rail}\ixkeyw{custom}\ixkeyw{graph}\ixkeyw{optimizereusepoolsize}
Sets the the size of the pool storing deleted elements for reuse to \emph{Number} (default: \texttt{10}).

\subsubsection*{Action related custom commands}

\begin{rail}
  'custom' 'actions' gensearchplan (Action*)
\end{rail}\ixkeyw{custom}\ixkeyw{actions}\ixkeyw{gensearchplan}
Creates a search plan (and executable code from it) for each rewrite rule \emph{Action} using the data from analyzing the graph (\texttt{custom graph analyze}).
Otherwise a \indexed{default search plan} is used.
If no rewrite rule is specified, all rewrite rules are compiled anew.
Analyzing and search plan/code generation themselves take some time, but they can lead to (massively) faster pattern matching, thus overall reduced execution times;
the less uniform the type distribution and edge wiring between the nodes, the higher the improvements.
During the analysis phase the host graph must be in a shape ``similar'' to its shape when the main amount of work is done
(there may be some trial-and-error steps at different time points needed to get the overall most efficient search plan.)
A search plan is available as long as the current rule set remains loaded.
Specify multiple rewrite rules with one command instead of using multiple commands, one for each rule, in order to improve search plan generation performance (this avoids superfluous compilation runs).

\begin{rail}
  'custom' 'actions' 'explain' Action
\end{rail}\ixkeyw{custom}\ixkeyw{actions}\ixkeyw{explain}
Shows the search plan currently in use for the \emph{Action}, plus the subpatterns called by it.
The search plan highlights \emph{how} the pattern gets matched, and thus allows to understand the performance characteristics of executing the action.
It is a list of search commands (with commands not doing real matching work shown in parenthesis), which is executed from top to bottom; for more on the search commands have a look at section \ref{searchplanning}.
The search plan helps in optimizing for performance, as it shows the effects of pattern changes, e.g. the introduction of parameters, or the annotation of pattern elements with priorities (cf. \ref{annotations})), and of changes of the statistical data (stemming from a re-analyzation of a modified graph, or loading of analysis data).
This is an inspection tool comparable to the \texttt{explain} command offered by SQL-databases, which shows the search plan for a query.

\begin{rail}
  'custom' 'actions' dumpsourcecode BoolLit
\end{rail}\ixkeyw{custom}\ixkeyw{actions}\ixkeyw{dumpsourcecode}
If set to true, C\# files will be dumped for the newly generated searchplans (similar to the \texttt{-keep} option of the generator; defaults to \texttt{false}).

\begin{rail}
  'custom' 'actions' setmaxmatches Number
\end{rail}\ixkeyw{custom}\ixkeyw{actions}\ixkeyw{setmaxmatches}
Sets the maximum amount of possible pattern matches to \emph{Number}.
This command affects the expression \texttt{[\emph{Rule}]}.
If \emph{Number} is less or equal to zero, the constraint is reset.

\begin{rail}
  'custom' 'actions' 'adaptvariables' BoolLit
\end{rail}\ixkeyw{custom}\ixkeyw{actions}\ixkeyw{adaptvariables}
If set to true (default), variables are cleared (nulled) if they contain graph elements which are removed from the graph, and rewritten to the new element on retypings (only graph-global variables, not sequence variables).
This saves us from outdated and dangling variables at the cost of listening to node and edge removals and retypings.
Setting it to false improves performance, but can lead to zombie elements hanging out in the graph-global variables (and a lot of confusion in case they are reused, as it is possible when \texttt{optimizereuse} is not set to \texttt{false}, see graph custom commands above).

\begin{rail}
  'custom' 'actions' enableassertions BoolLit
\end{rail}\ixkeyw{custom}\ixkeyw{actions}\ixkeyw{enableassertions}\label{enableassertions}
If set to true, \indexed{assertion}s are enabled (default: \texttt{false}), cf. Section~\ref{sec:assert}.

% todo: beispielshellscripte
