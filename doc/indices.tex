\chapter{Indices}\label{cha:indices} \indexmain{indices}

Matching patterns in a graph is based on searching for the elements of interest.
It is better to find elements with certain characteristics straight ahead without search,
utilizing a data structure that allows to tell the elements that follow the characteristic apart from the ones that do not,
than to search for them, traversing each and every node or edge in the graph, subjecting it to a test for the characteristic.

Welcome to indices as known from database parlance.
In \GrG{} the following types of indices are supported:
\begin{enumerate}
	\item Type indices
	\item Neighbourhood indices
	\item Attribute indices
	\item Incidence count indices
	\item Name index
	\item Uniqueness index
\end{enumerate}

%-----------------------------------------------------------------------------
\section{Type Indices}\label{sec:typeindices}
All the nodes or edges in \GrG{} of a certain type are contained in a list that can be accessed in $O(1)$ and iterated in $O(k)$ with $k$ being the number of elements in that list (the nodes or edges of same type), in contrast to $n$, being the number of nodes or edges in the graph.
The first node or edge in a pattern is typically bound by iterating such a type list.
In case the pattern is disconnected, a lookup is needed per connected component.
In case multiple types have very few members, the search planner may decide to use several lookups even in case of a connected pattern.
(This can be especially the case for reflexive marker edges pointing to the current point of processing/focus of attention in the graph.)

%-----------------------------------------------------------------------------
\section{Neighbourhood Indices}\label{sec:neighbourhoodindices}
All the edges outgoing from a node are contained in a list that can be accessed in $O(1)$ and iterated in $O(k)$ with $k$ being the number of elements in that list (the outgoing edges), in contrast to $n$, being the number of edges in the graph.
All the edges incoming to a node are contained in a list that can be accessed in $O(1)$ and iterated in $O(k)$ with $k$ being the number of elements in that list (the incoming edges).
So following neighbouring elements, crawling alongside the structure is very cheap in \GrG{ } -- and possible in both directions, following the edges as well as in their opposite direction.

It is cheap in graph databases, too, but absolutely not in relational databases.
To follow a relation, there you have to join two complete tables, building the cartesian product of two tables (materializing only the rows where they agree) -- you must inspect all edges in the graph to find the neighbours.
Typically you optimize this with a database index that allows to find the elements of the second table matching your focused element of the first table in $O(log(n))$ -- but for large $n$ or for complex queries this global product is way less efficient than direct local access to exactly the neighbouring elements.
(Furthermore, a table join is conceptually and notationally much heavier than an edge in a graph pattern).

In case of undirected edges, or arbitrary directed edges in the pattern, both directions are searched,
both lists -- the outgoing list as well as the incoming list -- are crawled.

%-----------------------------------------------------------------------------
\section{The Costs}\label{sec:performancememory} 
The type and neighbourhood indices are built into each and every \GrG{} graph, wired into a system of ringlists (cf. \ref{sec:generatedcode}).
They are implicitly used by \GrG{}, pattern matching is carried out alongside them, in an order decided upon by the search planner. 

You always benefit from them during matching (most if you are using statistics-based search planning), but you must always pay their price:
The memory consumption of a \GrG{} node without attributes is 32 bytes using a 32bit CLR (5 pointers a 4 bytes, a 4 bytes flags field/bitvector, plus 8 bytes .NET object overhead), it is 60 bytes for a 64bit CLR (5 pointers a 8 bytes, a 4bytes flags field, plus 16 bytes .NET object overhead).
The memory consumption of a \GrG{} edge without attributes is 48 bytes using a 32bit CLR (9 pointers a 4 bytes, a 4 bytes flags field/bitvector, plus 8 bytes .NET object overhead), it is 92 bytes for a 64bit CLR (9 pointers a 8 bytes, a 4 bytes flags field, plus 16 bytes .NET object overhead).
Attributes are cheap, they only increase this by the .NET-memory-footprint of their underlying objects.

The runtime price of maintaining those indices during graph manipulation is low, adding a graph element is done in $O(1)$, removing a graph element is done in $O(1)$, too. 
Furthermore, those indices allow to optimize loops by letting the pattern matching of the next iteration start where the previous iteration left of (search state space stepping -- a further built-in contribution to the motto "Find, Don't Search")).

We consider this the best you can get for the task of efficient pattern matching and rewriting on typed, attributed multigraphs, with multiple inheritance and attributes on nodes as well as edge types -- those indices are simply worth their price in the general case.
You can only improve on this by exploiting the specifics of a less general graph model, a less general processing strategy supporting less change operations optimally out-of-the box, or by restricting yourself to less general and non-automatic pattern matching.
E.g. by using only single-linked ringlists for the types and incident elements, we could reduce memory consumption considerably and thus increase query performance, but deletion and retyping would require to iterate the full list to get to the predecessor to link it to the new successor, so rewriting would not be $O(1)$ anymore.
Or by always entering the graph at some elsewhere stored root nodes we could save the type ringlists (that give us the modularity of the rules).
Or by using less general edges/edges that appear only with a statically fixed association cardinality, we could reduce them to mere pointers stored in the nodes (not supporting attributes, not allowing to wire nodes at runtime flexibly with an arbitrary number of edges).

\GrG\ was built for general-purpose graph pattern matching and rewriting on a general model, to perform well on \emph{any} task, with \emph{minimum programming effort} for the user; regarding this it is implemented in a way we consider optimal and not improvable.
If you are willing to invest extra programming and understanding effort to exploit the specifics of your task at hand, you \emph{can} manually code a higher-performance solution, by stripping away features from the model you don't need.
Saving on the memory needed for the generality and programming productivity is what gives our competitor FUJABA a lead performance-wise for tasks where a simpler graph model is sufficient and the user is willing to invest more development time into (and no iterative search-replace-operations are carried out, search state space stepping wins then).

%-----------------------------------------------------------------------------
\section{Attribute Indices}\label{sec:attributeindices}
In addition to the built-in type and neighbourhood indices, you may declare attribute indices.
An attribute index allows to execute a graph element lookup based on an attribute value of interest, or a range of attribute values.
This stands in contrast to the default behaviour of carrying out a lookup on a type, visiting all $n$ elements of the type, filtering them down to the elements of interest (within range) with an attribute condition.
If this means you have to inspect a lot of values while searching only for a few ones, you should use an attribute index and benefit from its massively improved selectivity for the lookup.
It requires only $O(log(n))$ to search for the first element, and $O(k)$ for the $k$ elements within the bounds specified.
It is implemented with a balanced binary search tree (an AA-tree\cite{Andersson93balancedsearch} to be exact) that requires three pointers plus one 4 byte integer per element contained in the index (two pointers to the left and right tree nodes, and one to the graph element as value), which is really cheap.
But it must be maintained on graph changes, which is less cheap.
On each and every graph element insertion and removal, but esp. attribute assignment, the index has to be updated, which is an $O(log(n))$ operation.
That's only logarithmic, but clearly worse than the default $O(1)$ behaviour of \GrG{}, so if you do a lot of graph manipulations and only few lookups based on it, an index may in fact degrade performance.

\subsection*{Declaration in the model}
In contrast to type and neighbourhood indices that are always available (they define the core of a \GrG{}-graph) and implicitly used (when matching a specified pattern), all other indices have to be worked with explicitly.

An attribute index must be declared in the model.

\begin{rail}
  AttributeIndexDecl: 'index' IndexName lbrace Type '.' AttributeName rbrace;
\end{rail}\ixnterm{AttributeIndexDecl}

Following the \texttt{index} keyword, a name for the index is specified; in the body of the index, the type and name of the attribute to be indexed are given.

\subsection*{Usage in the rules}\label{sub:indexusage}

In the pattern part you may ask for an element to get bound to an element from an index;
this is syntactically specified by giving the index access enclosed in left and right braces (curly brackets) after the element declaration.
If the type of the element retrieved from the index is not compatible to the type of the pattern element specified, the retrieved candidate is not bound to the pattern element, and matching continues with the next candidate from the index, if the available candidates fitting to the attribute condition are exhausted or if the index is empty, matching fails.
The elements from the index are successively bound to the pattern element, then the rest of the pattern is bound and checked, until the requested number of matches is found.

\begin{rail}
  IndexAccess:
    lbrace IndexName '==' Expression rbrace |
		lbrace ('ascending'|'descending') '(' (IndexBound (',' IndexBound)?)? ')' rbrace;
	IndexBound: IndexName ('<'|'<='|'>'|'>=') Expression;
\end{rail}\ixnterm{IndexAccess}

The pattern element may be bound to the elements from the index with an attribute value equal to a specified value,
or to the elements from the index that lie within up to two bounds, in ascending or descending order (ordered access).
In case of ordered access, you may specify no bound, this is typically only of interest when a single match is requested, the one with the highest or lowest attribute value (satisfying the other constraints of the pattern), or you may specify a lower bound, or an upper bound, or a lower \emph{and} an upper bound.

\begin{rail}
  IndexFunctionCall:
    IndexFunctionName '(' IndexArguments ')' |
    IndexFunctionNamePredicate '(' IndexArgumentsPredicate ')' ;
  IndexArguments: 
    IndexName ( ',' Expression (',' Expression)? )? ;
  IndexArgumentsPredicate: 
    Expression ',' IndexName ( ',' Expression (',' Expression)? )? ;
\end{rail}\ixnterm{IndexFunctionCall}\ixnterm{IndexArguments}

A second way to access an index is from index query functions which are available in the expressions of the rule language, as well as in the expressions of the sequence computations.
There are multiple ones available, the index query functions returning a set of nodes are (the non-index-name arguments are of the type of the indexed attribute):

\begin{description}
\item[\texttt{nodesFromIndex(.)}] returns all nodes from the given index, as set.
\item[\texttt{nodesFromIndexSame(.,.)}] returns all nodes from the given index that are equal to the value specified with the second argument, as set.
\item[\texttt{nodesFromIndexFrom(.,.)}] returns all nodes from the given index that are greater or equal than the second argument, as set.
\item[\texttt{nodesFromIndexFromExclusive(.,.)}] returns all nodes from the given index that are greater than the second argument, as set.
\item[\texttt{nodesFromIndexTo(.,.)}] returns all nodes from the given index that are lower or equal than the second argument, as set.
\item[\texttt{nodesFromIndexToExclusive(.,.)}] returns all nodes from the given index that are lower than the second argument, as set.
\item[\texttt{nodesFromIndexFromTo(.,.,.)}] returns all nodes from the given index that are greater or equal than the second argument and lower or equal than the third argument, as set.
\item[\texttt{nodesFromIndexFromToExclusive(.,.,.)}] returns all nodes from the given index that are greater or equal than the second argument and lower than the third argument, as set.
\item[\texttt{nodesFromIndexFromExclusiveTo(.,.,.)}] returns all nodes from the given index that are greater than the second argument and lower or equal than the third argument, as set.
\item[\texttt{nodesFromIndexFromExclusiveToExclusive(.,.,.)}] returns all nodes from the given index that are greater than the second argument and lower than the third argument, as set.
\end{description}

The very same ones exists also for edges (their name starts then with \texttt{edgesFromIndex} instead of \texttt{nodesFromIndex}, and they return a \texttt{set<AEdge>} instead of a \texttt{set<Node>}).

The index query functions can be used in five possible ways (all functions support/require all the arguments listed above, in the following description we only give the index for brevity): 
\begin{description}
	\item[Set functions:] The index query function returns a set of contained entities. It builds an unordered set that is likely thrown away thereafter, so esp. for large sets this functions as such is less efficient than the other versions that inspect the index directly without building an intermediate data structure.
\begin{rail}
Expression:
  IndexFunctionName '(' IndexName ')' ;
\end{rail}

	\item[Array functions:] The index query function returns an array of contained entities. It builds an ordered array that is likely thrown away thereafter, so esp. for large arrays this functions as such is less efficient than the other versions (with exception of the set version, as set building is more expensive than array building). It allows to specify whether the entities are to be ordered ascendingly alongside the indexed attribute or descendingly.
Please note that the descending version requires the upper bound as first post-index argument and the lower bound as second post-index argument, whereas the ascending version like the unordered versions expects the lower bound as first post-index argument and the upper bound as second post-index argument.
\begin{rail}
Expression:
  IndexArrayFunctionName '(' IndexName ')' ;
\end{rail}
The \emph{IndexArrayFunctionName} is built from the \emph{IndexFunctionName} by appending \texttt{AsArrayAscending} or \texttt{AsArrayDescending}.
In case of the \texttt{nodesFromIndexSame} function only \texttt{AsArray} is appended.

	\item[Iteration loops:] The index function is employed in a for loop that allows to iterate the entities from the index. No set/array needs to be built here (but a statement is used/you must be in statement context).
Please note that the descending version requires the upper bound as first post-index argument and the lower bound as second post-index argument, whereas the ascending version like the unordered versions expects the lower bound as first post-index argument and the upper bound as second post-index argument.

%Such a for function loop is also available for many of the following index functions, defining a general way of accessing the graph elements from an index.
\begin{rail}
  ForIndexFunctionHeader: 'for' '(' Var ':' Type 'in' \\ IndexLoopFunctionName '(' IndexArguments ')' ')';
\end{rail}\ixkeyw{in}\ixkeyw{for}\ixnterm{ForIndexFunctionHeader}

The \emph{IndexLoopFunctionName} is built from the \emph{IndexFunctionName} by appending \texttt{Ascending} or \texttt{Descending}.
In case of the \texttt{nodesFromIndexSame}/\texttt{edgesFromIndexSame} function the original \emph{IndexFunctionName} stays.

So the index can be accessed from the statements of the rule language in the form of a (for function) loop, cf.~\ref{sub:controlflow}.
The iteration variable is bound to the graph element retrieved from the index, and then, for each such element, the body is executed.

	\item[Counted functions:] The counted index function returns the count of entities from the index. This is more efficient than calling \texttt{size()} on the resulting set/array of the plain index function; note that for fetching the count of all the entities in the index, \texttt{indexSize} is most efficient and should be preferred over \texttt{countNodesFromIndex}/\texttt{countEdgesFromIndex} ($O(1)$ instead of $O(n)$).
\begin{rail}
Expression:
  CountedIndexFunctionName '(' IndexName ')' ;
\end{rail}
The \emph{CountedIndexFunctionName} is built from the \emph{IndexFunctionName} by prepending \texttt{count} and switching the first character of \emph{IndexFunctionName} to upper case.

	\item[Boolean functions:] The index function is employed in a boolean predicate version that allows to check whether a target entity is in the queried index. This is more efficient than calling \texttt{in} on the resulting set (and even more so on the resulting array) of the plain index function. The computation stops as soon as a positive result is obtained.
\begin{rail}
Expression:
  IndexFunctionNamePredicate '(' TargetEntity ',' IndexName ')' ;
\end{rail}
The \emph{IndexFunctionNamePredicate} is built from the \emph{IndexFunctionName} by prepending \texttt{isIn} and switching the first character of \emph{IndexFunctionName} to upper case.
\end{description}

Moreover, the index can be queried from the sequence expressions with the same index access functions as in the rule language, and can be iterated over in the sequences with loops utilizing the same access functions.

\begin{rail}
  IndexAccessLoopSequence:
    'for' lbrace Var ':' GraphElementType 'in' \\ IndexLoopFunctionName '(' IndexArguments ')' ';' \\ RewriteSequence rbrace;
\end{rail}\ixnterm{IndexAccessLoopSequence}


\begin{example}\label{ex:indexaccess}
The following index \texttt{foo} allows to quickly fetch nodes of type \texttt{N} (or a subtype) based on the value of its attribute \texttt{i}.

\begin{grgen}
node class N {
  i : int;
}
index foo { N.i }
\end{grgen}

Fetching typically occurs in the rules, binding a pattern element based on the constraints specified with the lookup.
The test \texttt{t} only matches if a node is found whose attribute \texttt{i} matches the parameter \texttt{j}.
The rule \texttt{r} ascendingly binds the nodes whose attribute \texttt{i} is greater than or equal $5$ and lower than $13$.
The ascendingly means that the node \texttt{n} with smallest attribute \texttt{i} is matched that satisfies the other constraints of the pattern (if there are no further constraints like in this example, it is the node with the smallest attribute satisfying the limits of the index access).

\begin{grgen}
test t(var j:int) {
  n:N{foo==j};
}

rule r {
  n:N{ascending(foo>=5, foo<13)};

  modify {
  ---
    emit("The value of attribute i is ", n.i, "\n");
  }
}
\end{grgen}

\end{example}

\begin{example}
A similar index access (similar to the previous Example~\ref{ex:indexaccess}) from the expressions may look like:

\begin{grgen}
test t(var j:int) {
  n:N;
  if { isInNodesFromIndexSame(n, foo, j); }
}

rule r {
  modify {
  ---
    emit("The nodes with 5 <= foo < 13 are: ", nodesFromIndexFromToExclusiveAsArrayAscending(foo, 5, 13), "\n");
  }
}
\end{grgen}

An index may also be queried with a \texttt{for} loop from the statements, accepting the same bounds; 
or with a \texttt{for} loop from the sequences.

\begin{grgen}
rule rd {
  modify {
  ---
    eval {
      for(n:N in nodesFromIndexFromExclusiveToDescending(foo, 13, 5)) {
        emit("The value of attribute i is ", n.i, "\n");
      }
    }
    exec (
      for{n:N in nodesFromIndexFromDescending(foo, 13);
        { emit("The value of attribute i is ", n.i, "\n") }
      }
    );
  }
}
\end{grgen}

\end{example}


\subsubsection*{Non-attribute-comparing functions}

An index may also be queried directly for the entities with the lowest or the highest attribute value, as well as for its size;
with the following index query functions which are available in the expressions of the rule language, as well as in the expressions of the sequence computations.

\begin{description}
\item[\texttt{minNodeFromIndex(.)}] returns the node from the given index with the lowest attribute value (the starting node, which is one of the nodes with the lowest attribute value in case several ones exists), or null if the index is empty.
\item[\texttt{maxNodeFromIndex(.)}] returns the node from the given index with the highest attribute value (the ending node, which is one of the nodes with the highest attribute value in case several ones exists), or null if the index is empty.
\item[\texttt{minEdgeFromIndex(.)}] returns the edge from the given index with the lowest attribute value (the starting edge, which is one of the edges with the lowest attribute value in case several ones exists), or null if the index is empty.
\item[\texttt{maxEdgeFromIndex(.)}] returns the edge from the given index with the highest attribute value (the ending edge, which is one of the edges with the lowest attribute value in case several ones exists), or null if the index is empty.
\item[\texttt{indexSize(.)}] returns the size of the given index, as \texttt{int}.
\end{description}


\subsection*{Multiple index queries and spatial queries}\label{sub:indexusage}

In the pattern you may ask for a pattern element to get bound to a graph element from multiple indices;
the graph element must be contained in all the specified indices, lying within the specified bounds for each of them (i.e. a multi index join is carried out, which can be seen as a result set intersection, implemented in an efficient way).

This is specified syntactically similar to an \emph{IndexAccess} (see above).
If the type of the element retrieved from the indices is not compatible to the type of the pattern element specified, the retrieved candidate is not bound to the pattern element, and matching continues with the next candidate from the indices, if the available candidates fitting to the multiple attribute conditions are exhausted or if the index join is empty, matching fails.
The elements from the indices are successively bound to the pattern element, then the rest of the pattern is bound and checked, until the requested number of matches is found.


\begin{rail}
  MultipleIndexAccess:
    lbrace 'multiple' '(' ((IndexBound ',' IndexBound)+(',')) ')' rbrace;
\end{rail}\ixnterm{MultipleIndexAccess}

You must always specify a lower and an upper bound, for each index queried. You may use the \texttt{minNodeFromIndex}/\texttt{maxNodeFromIndex}/\texttt{minEdgeFromIndex}/\texttt{maxEdgeFromIndex} functions (see above) to obtain lowest lower and highest upper bounds, so you can emulate single index accesses with only one bound or even no bound (the same holds for the following multiple index access functions).

\begin{rail}
  IndexFunctionCall:
    MultipleIndexFunctionName '(' MultipleIndexArguments ')' ;
  MultipleIndexArguments: 
    ( (IndexName ',' Expression ',' Expression) ) + (',') ;
\end{rail}\ixnterm{IndexFunctionCall}\ixnterm{MultipleIndexArguments}

\pagebreak

A second way to access multiple indices is from multiple index access functions which are available in the expressions of the rule language, as well as in the expressions of the sequence computations.

\begin{description}
\item[\texttt{nodesFromIndexMultipleFromTo(.,.,.[,.,.,.]*)}] returns all nodes from the join of the given indices as a set, i.e. the intersection of the result sets of the simple index queries, which are of the form: the indexed attribute of the index given as $k$th argument must be greater or equal than the $k + 1$ argument and lower or equal than the $k + 2$ argument, where $k \in 1, 3, 6, \ldots$
\item[\texttt{edgesFromIndexMultipleFromTo(.,.,.[,.,.,.]*)}] returns all edges from the join of the given indices as a set, i.e. the intersection of the result sets of the simple index queries, which are of the form: the indexed attribute of the index given as $k$th argument must be greater or equal than the $k + 1$ argument and lower or equal than the $k + 2$ argument, where $k \in 1, 3, 6, \ldots$
\end{description}


\begin{example}\label{ex:multiindexaccess}
The following index \texttt{foo} allows to quickly fetch nodes of type \texttt{N} (or a subtype) based on the value of their attribute \texttt{i}, the index \texttt{bar} inspects the value of its attribute \texttt{j} towards this purpose.

\begin{grgen}
node class N
{
  i : int;
  j : string;
}

index foo { N.i }
index bar { N.j }
\end{grgen}

Fetching typically occurs in the rules, binding a pattern element based on the constraints specified with the lookup.
The rule \texttt{r} carries out a \texttt{multiple} index access (multi index join), it binds the nodes whose attribute \texttt{i} is greater than or equal $5$ and lower than or equal $13$, and whose attribute \texttt{j} is greater than or equal "a" and lower than or equal "i".

\begin{grgen}
rule r {
  n:N{multiple(foo>=5, foo<=13, bar>="a", bar<="i")};

  modify {
  ---
    emit("The value of attribute (i,j) is (" + n.i + "," + n.j + ")\n");
  }
}
\end{grgen}

\end{example}

\begin{example}

A similar index access (similar to the previous Example~\ref{ex:multiindexaccess}) from the expressions may look like:

\begin{grgen}
rule r {
  n:N;
  if { n in nodesFromIndexMultipleFromTo(foo, 5, 13, bar, "a", "i"); }

  modify {
  ---
    emit("The nodes with 5 <= foo <= 13 && a <= bar <= i are: ", nodesFromIndexMultipleFromTo(foo, 5, 13, bar, "a", "i"), "\n");
  }
}
\end{grgen}

Multiple indices may also be queried with a \texttt{for} loop from the statements, or with a \texttt{for} loop from the sequences.

\begin{grgen}
rule rd {
  modify {
  ---
    eval {
      for(n:N in nodesFromIndexMultipleFromTo(foo, 5, 13, bar, "a", "i")) {
        emit("The value of attribute (i,j) is (" + n.i + "," + n.j + ")\n");
      }
    }
    exec (
      for{n:N in nodesFromIndexMultipleFromTo(foo, 5, 13, bar, "a", "i");
        { emit("The value of attribute (i,j) is (" + n.i + "," + n.j + ")\n") }
      }
    );
  }
}
\end{grgen}

\end{example}


\subsubsection*{Spatial queries}

The multiple index access can be used to carry out spatial queries (emulating a spatial index by utilizing one index per dimension).

The fabricated index examples geared at testing from which excerpts were shown above can be found in the \texttt{tests/index} directory.
The following more interesting spatial query examples can be found in the \texttt{tests/index\-Spatial\-Query} directory.


\begin{example}\label{ex:spatialquery}
The following indices \texttt{ix}, \texttt{iy}, \texttt{iz} allow to quickly fetch neighboring nodes in a 3 dimensional space (so each coordinate has its own index).

\begin{grgen}
node class Point3dNode {
  x : double;
  y : double;
  z : double;
}

index ix { Point3dNode.x }
index iy { Point3dNode.y }
index iz { Point3dNode.z }

class Point3d {
  x : double;
  y : double;
  z : double;
}
\end{grgen}

You may use them in rules to match pattern elements that are unconnected by nearness in space (fetching all nodes that are within a bounding box around the node of interest; note that the nodes are not matched ordered by distance, you have to apply a post-matches filter in order achieve this goal).

The rule \texttt{matchNeighboring} applied with all-bracketing matches all nodes \texttt{neighbor} that are within
\texttt{delta}-difference to all the coordinates of the node \texttt{n} in $3$-dimensional space.
The \texttt{multiple} indicates a multiple index access.

\begin{grgen}
var ::delta:double;

// match neighbor that is nearby in space even if unconnected
rule matchNeighboring : (Point3dNode, Point3dNode) {
  . --> n:Point3dNode;
  neighbor:Point3dNode{multiple(ix >= n.x - delta, ix <= n.x + delta, iy >= n.y - delta, iy <= n.y + delta, iz >= n.z - delta, iz <= n.z + delta)} --> .;

  modify {
    return(n, neighbor);
  }
}
\end{grgen}

You may use them in the rules to check matched pattern elements for nearness in space with the functions.

\begin{grgen}
// reduce cartesian product of unconnected components to the ones nearby in space
rule checkNeighboring : (Point3dNode, Point3dNode) {
  . --> n:Point3dNode;
  neighbor:Point3dNode --> .;

  if {
    neighbor in nodesFromIndexMultipleFromTo(ix, n.x - delta, n.x + delta, iy, n.y - delta, n.y + delta, iz, n.z - delta, n.z + delta);
  }

  modify {
    return (n, neighbor);
  }
}
\end{grgen}

\end{example}


Table~\ref{indexreturningnodestab} and table~\ref{indexnodestab}, as well as table~\ref{indexreturningedgestab} and table~\ref{indexedgestab} list the global built-in index functions of the rule language at a glance.

%\makeatletter
\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{nodesFromIndexSame(Index,T):set<Node>}\\
\hline
\texttt{nodesFromIndexSameAsArray(Index,T):array<Node>}\\
\hline
\texttt{nodesFromIndex(Index):set<Node>}\\
\texttt{nodesFromIndexFrom(Index,T):set<Node>}\\
\texttt{nodesFromIndexFromExclusive(Index,T):set<Node>}\\
\texttt{nodesFromIndexTo(Index,T):set<Node>}\\
\texttt{nodesFromIndexToExclusive(Index,T):set<Node>}\\
\texttt{nodesFromIndexFromTo(Index,T,T):set<Node>}\\
\texttt{nodesFromIndexFromExclusiveTo(Index,T,T):set<Node>}\\
\texttt{nodesFromIndexFromToExclusive(Index,T,T):set<Node>}\\
\texttt{nodesFromIndexFromExclusiveToExclusive(Index,T,T):set<Node>}\\
\hline
\texttt{nodesFromIndexAsArrayAscending(Index):array<Node>}\\
\texttt{nodesFromIndexFromAsArrayAscending(Index,T):array<Node>}\\
\texttt{nodesFromIndexFromExclusiveAsArrayAscending(Index,T):array<Node>}\\
\texttt{nodesFromIndexToAsArrayAscending(Index,T):array<Node>}\\
\texttt{nodesFromIndexToExclusiveAsArrayAscending(Index,T):array<Node>}\\
\texttt{nodesFromIndexFromToAsArrayAscending(Index,T,T):array<Node>}\\
\texttt{nodesFromIndexFromExclusiveToAsArrayAscending(Index,T,T):array<Node>}\\
\texttt{nodesFromIndexFromToExclusiveAsArrayAscending(Index,T,T):array<Node>}\\
\texttt{nodesFromIndexFromExclusiveToExclusiveAsArrayAscending(Index,T,T):array<Node>}\\
\hline
\texttt{nodesFromIndexAsArrayDescending(Index):array<Node>}\\
\texttt{nodesFromIndexFromAsArrayDescending(Index,T):array<Node>}\\
\texttt{nodesFromIndexFromExclusiveAsArrayDescending(Index,T):array<Node>}\\
\texttt{nodesFromIndexToAsArrayDescending(Index,T):array<Node>}\\
\texttt{nodesFromIndexToExclusiveAsArrayDescending(Index,T):array<Node>}\\
\texttt{nodesFromIndexFromToAsArrayDescending(Index,T,T):array<Node>}\\
\texttt{nodesFromIndexFromExclusiveToAsArrayDescending(Index,T,T):array<Node>}\\
\texttt{nodesFromIndexFromToExclusiveAsArrayDescending(Index,T,T):array<Node>}\\
\texttt{nodesFromIndexFromExclusiveToExclusiveAsArrayDescending(Index,T,T):array<Node>}\\
\hline
\texttt{nodesFromIndexMultipleFromTo(Index,T,T[,Index\_k,T\_k,T\_k]*):set<Node>}\\
\hline
\end{tabular}
\caption{Index functions returning nodes at a glance}
\label{indexreturningnodestab}
\end{table}

\pagebreak

%\makeatletter
\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{countNodesFromIndex(Index):int}\\
\texttt{countNodesFromIndexSame(Index,T):int}\\
\texttt{countNodesFromIndexFrom(Index,T):int}\\
\texttt{countNodesFromIndexFromExclusive(Index,T):int}\\
\texttt{countNodesFromIndexTo(Index,T):int}\\
\texttt{countNodesFromIndexToExclusive(Index,T):int}\\
\texttt{countNodesFromIndexFromTo(Index,T,T):int}\\
\texttt{countNodesFromIndexFromExclusiveTo(Index,T,T):int}\\
\texttt{countNodesFromIndexFromToExclusive(Index,T,T):int}\\
\texttt{countNodesFromIndexFromExclusiveToExclusive(Index,T,T):int}\\
\hline
\texttt{isInNodesFromIndex(Node,Index):boolean}\\
\texttt{isInNodesFromIndexSame(Node,Index,T):boolean}\\
\texttt{isInNodesFromIndexFrom(Node,Index,T):boolean}\\
\texttt{isInNodesFromIndexFromExclusive(Node,Index,T):boolean}\\
\texttt{isInNodesFromIndexTo(Node,Index,T):boolean}\\
\texttt{isInNodesFromIndexToExclusive(Node,Index,T):boolean}\\
\texttt{isInNodesFromIndexFromTo(Node,Index,T,T):boolean}\\
\texttt{isInNodesFromIndexFromExclusiveTo(Node,Index,T,T):boolean}\\
\texttt{isInNodesFromIndexFromToExclusive(Node,Index,T,T):boolean}\\
\texttt{isInNodesFromIndexFromExclusiveToExclusive(Node,Index,T,T):boolean}\\
\hline
\texttt{minNodeFromIndex(Index):Node}\\
\texttt{maxNodeFromIndex(Index):Node}\\
\hline
\texttt{indexSize(Index):int}\\
\hline
\texttt{countFromIndex(Index, Node):int}\\
\hline
\end{tabular}
\caption{Index functions on nodes at a glance}
\label{indexnodestab}
\end{table}

\pagebreak

%\makeatletter
\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{edgesFromIndexSame(Index,T):set<AEdge>}\\
\hline
\texttt{edgesFromIndexSameAsArray(Index,T):array<AEdge>}\\
\hline
\texttt{edgesFromIndex(Index):set<AEdge>}\\
\texttt{edgesFromIndexFrom(Index,T):set<AEdge>}\\
\texttt{edgesFromIndexFromExclusive(Index,T):set<AEdge>}\\
\texttt{edgesFromIndexTo(Index,T):set<AEdge>}\\
\texttt{edgesFromIndexToExclusive(Index,T):set<AEdge>}\\
\texttt{edgesFromIndexFromTo(Index,T,T):set<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveTo(Index,T,T):set<AEdge>}\\
\texttt{edgesFromIndexFromToExclusive(Index,T,T):set<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveToExclusive(Index,T,T):set<AEdge>}\\
\hline
\texttt{edgesFromIndexAsArrayAscending(Index):array<AEdge>}\\
\texttt{edgesFromIndexFromAsArrayAscending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveAsArrayAscending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexToAsArrayAscending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexToExclusiveAsArrayAscending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexFromToAsArrayAscending(Index,T,T):array<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveToAsArrayAscending(Index,T,T):array<AEdge>}\\
\texttt{edgesFromIndexFromToExclusiveAsArrayAscending(Index,T,T):array<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveToExclusiveAsArrayAscending(Index,T,T):array<AEdge>}\\
\hline
\texttt{edgesFromIndexAsArrayDescending(Index):array<AEdge>}\\
\texttt{edgesFromIndexFromAsArrayDescending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveAsArrayDescending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexToExclusiveAsArrayDescending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexToAsArrayDescending(Index,T):array<AEdge>}\\
\texttt{edgesFromIndexFromToAsArrayDescending(Index,T,T):array<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveToAsArrayDescending(Index,T,T):array<AEdge>}\\
\texttt{edgesFromIndexFromToExclusiveAsArrayDescending(Index,T,T):array<AEdge>}\\
\texttt{edgesFromIndexFromExclusiveToExclusiveAsArrayDescending(Index,T,T):array<AEdge>}\\
\hline
\texttt{edgesFromIndexMultipleFromTo(Index,T,T[,Index\_k,T\_k,T\_k]*):set<AEdge>}\\
\hline
\end{tabular}
\caption{Index functions returning edges at a glance}
\label{indexreturningedgestab}
\end{table}

\pagebreak

%\makeatletter
\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{countEdgesFromIndex(Index):int}\\
\texttt{countEdgesFromIndexSame(Index,T):int}\\
\texttt{countEdgesFromIndexFrom(Index,T):int}\\
\texttt{countEdgesFromIndexFromExclusive(Index,T):int}\\
\texttt{countEdgesFromIndexTo(Index,T):int}\\
\texttt{countEdgesFromIndexToExclusive(Index,T):int}\\
\texttt{countEdgesFromIndexFromTo(Index,T,T):int}\\
\texttt{countEdgesFromIndexFromExclusiveTo(Index,T,T):int}\\
\texttt{countEdgesFromIndexFromToExclusive(Index,T,T):int}\\
\texttt{countEdgesFromIndexFromExclusiveToExclusive(Index,T,T):int}\\
\hline
\texttt{isInEdgesFromIndex(Edge,Index):boolean}\\
\texttt{isInEdgesFromIndexSame(Edge,Index,T):boolean}\\
\texttt{isInEdgesFromIndexFrom(Edge,Index,T):boolean}\\
\texttt{isInEdgesFromIndexFromExclusive(Edge,Index,T):boolean}\\
\texttt{isInEdgesFromIndexTo(Edge,Index,T):boolean}\\
\texttt{isInEdgesFromIndexToExclusive(Edge,Index,T):boolean}\\
\texttt{isInEdgesFromIndexFromTo(Edge,Index,T,T):boolean}\\
\texttt{isInEdgesFromIndexFromExclusiveTo(Edge,Index,T,T):boolean}\\
\texttt{isInEdgesFromIndexFromToExclusive(Edge,Index,T,T):boolean}\\
\texttt{isInEdgesFromIndexFromExclusiveToExclusive(Edge,Index,T,T):boolean}\\
\hline
\texttt{minEdgeFromIndex(Index):AEdge}\\
\texttt{maxEdgeFromIndex(Index):AEdge}\\
\hline
\texttt{indexSize(Index):int}\\
\hline
\end{tabular}
\caption{Index functions on edges at a glance}
\label{indexedgestab}
\end{table}

%-----------------------------------------------------------------------------
\section{Incidence Count Indices}\label{sec:incidencecountindices}
Attribute indices can be seen as a general-purpose device, that extends the built-in ability of quick lookup by-type and of quick lookup by-neighbourhood with a quick lookup by-attribute, thus giving complete quick-lookup coverage for all foundational elements of the graph model.
Incidence count indices in contrast are more of a special-purpose device for a certain abstraction that can be applied to a graph -- the \emph{count} of incident edges -- and are beneficial only if that abstraction is of importance.
They allow you to quickly look up nodes based on their number of incident edges.
This is especially beneficial for algorithms that work best when they traverse the nodes from the ones with the highest number of incident edges to the ones with the lowest number of incident edges (or the other way round).

The index furtheron allows to fetch the incidence count for a node quickly with just an index lookup, 
but typically no gain can be made from this, as counting the incident edges of a node is commonly cheap (an $O(log(n)$ index lookup versus an $O(k)$ counting enumeration, with $k$ being the number of edges incident to the focused node).

\subsection*{Declaration in the model}

An incidence count index must be declared in the model.

\begin{rail}
IncidenceCountIndexDecl: 'index' IndexName lbrace CountIncidenceFunction rbrace;
CountIncidenceFunction: 
  CountIncidenceFunctionName '(' NodeType ')' |
  CountIncidenceFunctionName '(' NodeType ',' EdgeType ')' |
  CountIncidenceFunctionName '(' NodeType ',' EdgeType ',' NodeType ')'
  ;
\end{rail}\label{IncidenceCountIndexDecl}

Following the \texttt{index} keyword, a name for the index is specified; in the body of the index, the incidence function and its types are given.
The admissible count incidence functions are \texttt{countIncident}, \texttt{countIncoming}, and \texttt{countOutgoing}, with semantics as already introduced in \ref{sub:querybyneighbourhood}.
(The count of the edges complying to the specified incidence function is stored in an index, for all nodes in the graph of the type of the first node in the count incidence function.)

\subsection*{Usage in the rules}
An incidence count index can be used in the pattern in exactly the same way as an attribute index, see above \ref{sub:indexusage}.

In addition to the index lookup, the count may be queried from the rule language expressions (note that while the attributes can be accessed directly for a pattern element, the incidence count would have to be obtained by counting in contrast, but this only saves time for heavily connected nodes).

\begin{description}
\item[\texttt{countFromIndex(.,.)}] returns the count of incident edges as \texttt{int} of the node given as second argument, obtained from the incidence count index given as first argument.
\end{description}

The index function is also available in the sequence expressions; the indexer notation (similar to an array access) that was available in a previous version of \GrG{} is not available anymore.


\begin{example}
The following index \texttt{bar} allows to quickly fetch nodes based on the number of \texttt{outgoing} edges, \texttt{qux} allows to quickly fetch nodes of type \texttt{N} based on the number of \texttt{incoming} edges of type \texttt{E}, stemming from a source node of type \texttt{N}.

\begin{grgen}
node class N {
	i:int = 0;
}
edge class E;
index bar { countOutgoing(Node) }
index qux { countIncoming(N, E, N) }
\end{grgen}

Fetching typically occurs in the rules, binding a pattern element based on the constraints specified with the lookup.
The test \texttt{t} returns the node \texttt{n} in the graph with the maximum number of outgoing edges.
The rule \texttt{r} ascendingly binds the nodes whose number of incoming edges of type \texttt{E} from a node of type \texttt{N} is greater than or equal the value of attribute \texttt{i} of node \texttt{l} matched before (constrained to values below $42$ by the \texttt{if}); it \texttt{emit}s the count of outgoing edges of \texttt{n}, queried from the index \texttt{bar} with array access notation.

\begin{grgen}
test t() {
	n:Node{descending(bar)};
}

rule r() {
  l:N; if{ l.i<42;}
  n:N{ascending(qux>=l.i)};
	
  modify {
  ---
    emit("count outgoing(Node): ", countFromIndex(bar, n), "\n");
  }
}
\end{grgen}

\end{example}


%-----------------------------------------------------------------------------
\section{Name Index}\label{sec:nameindex}
A named graph is a graph where each element bears a unique name and can be looked up quickly by that name.
So basically it works as a graph with an integrated key-value store from a string to a graph element, and one from a graph element to a string.
It is implemented with two hash maps, one from the names to the elements, and the other from the elements to the names.
Lookup is carried out in $O(1)$ (either way).
Maintaining the index on graph insertions and removals is carried out in $O(1)$, too.
So in contrast to the attribute index and the incidence count index, a name index does not allow multiple elements per indexed property (which is here the name).

\subsection*{No declaration needed}
The name index does not need to be declared, it is implemented with the named graph, which is always generated together with its sibling, the non-named graph.
If you are working with the \GrShell, this is the only kind of graph you'll be working with, as the shell always instantiates the named graph (it delivers the \emph{persistent names} you see in the debugger).
At API level you may opt for the non-named graph that is considerably cheaper regarding memory usage -- a named graph requires not much less than about twice the amount of memory of a plain graph (unless heavily attributed).

But please note in that case that the export and import capabilities require uniquely named elements and thus only work with named graphs.
If given a plain graph, the exporters just create a named graph.
A graph is always created as a named graph by the importers.
So non-named graphs are typically only of interest if you don't need to persist them into a serialization format.

\subsection*{Usage in the rules}
The name index can be used in the pattern to look up graph elements by their name, with the same syntax as used in the GrShell for accessing elements by their (persistent) name.

\makeatletter
\begin{rail}
  NamedIndexAccessExpr:
    lbrace '@' '(' Expression ')' rbrace;
\end{rail}\ixnterm{NamedIndexAccessExpr}
\makeatother

There is at most one element existing with the name asked for; if no graph element with that name exists, matching fails and backtracks, if an element exists, the pattern element is bound to it, and matching continues.
Please note that the (string-)expression used to compute the name is only allowed to reference at most one other pattern element (not handed in as parameter).

The name index may be further queried from the rule language expressions or the sequence expressions with the \texttt{\indexed{nameof}} as well as
the \texttt{\indexed{nodeByName}} and the \texttt{\indexed{edgeByName}} functions:
\begin{description}
\item[\texttt{nameof(.)}] returns the name (type string) of the given node or edge (or (sub)graph, a missing argument amounts to the host graph).
\item[\texttt{nodeByName(.)}] returns the node of the given name, or null if no node of that name exists. Optionally, a target node type may be given as second argument, then you receive a node of that type as result, or null if no node of that name \emph{and type} exists.
\item[\texttt{edgeByName(.)}] returns the edge of the given name, or null if no edge of that name exists. Optionally, a target edge type may be given as second argument, then you receive an edge of that type as result, or null if no edge of that name \emph{and type} exists.
\end{description}

The names are normally automatically assigned (computed from a global counter increased with each element, prepended by the dollar symbol -- unless you specify a name with an attribute initialization list, cf.\ref{sec:attribinitrule}), but you may assign a different name to an attribute element.
This can be only done in an \texttt{eval}-block, or a \texttt{procedure}, with a \texttt{nameof}-assignment.

\begin{rail}
  NameofAssignment:
    'nameof' '(' Element ')' '=' Expression;
\end{rail}\ixnterm{NameofAssignment}\ixkeyw{nameof}

When you do so, it is your responsibility to ensure that the name does not already exist, otherwise the assignment will cause a runtime exception.
The same syntax may be used to assign the name of a (sub)graph, a missing element amounts to the host graph.

\begin{example}
The test \texttt{t} succeeds if there is a node of name "foo" existing in the graph, with a reflexive edge of the name defined by input parameter \texttt{s}, and there is a further node of name "bar" existing the graph.

\begin{grgen}
test t(var s:string) {
  n:Node{@("foo")} -e:Edge{@(s)}-> n;
  if{ nodeByName("bar") != null; }
}
\end{grgen}

The rule \texttt{r} \texttt{yield}s the name of the node matched to \texttt{n} out to \texttt{oldname}, and changes the name of the node in the \texttt{modify} part by prepending the name of the host graph. Furthermore, it prints the name of the edge bound to \texttt{e}.

\begin{grgen}
rule r() {
  n:Node -e:Edge->;
---
  def var oldname:string;
  yield { yield oldname = nameof(n); }
		
  modify {
    eval {
      nameof(n) = nameof() + "_" + oldname;
    }
  ---
    emit("The name of the graph element bound to e is ", nameof(e), "\n");
  }
}
\end{grgen}

\end{example}


%-----------------------------------------------------------------------------
\section{Uniqueness Index}\label{sec:uniqueness}
Uniqueness can be applied in two parts, the i) uniqueness \emph{constraint}, and ii) the uniqueness \emph{index}.

The uniqueness \emph{constraint} ensures that each element in the graph has a unique id. 
It allows in addition to fetch the unique id from a graph element.
You may see it as a key-value store from graph elements to their ids -- it is a very efficient one, as the unique-id is stored in the graph elements. 
This incurs an additional cost of a 4 bytes unique id field per graph element.

The uniqueness \emph{index} allows in addition to fetch a graph element by its unique id, extending the uniqueness property to an index allowing for quick graph element lookup.
You may see it as a key-value store from the unique ids to their graph elements.
This one is realized with an array/list of unique ids to graph elements (thus the cost is at most about twice the number of elements ever held multiplied by 4 bytes on a 32bit CLR and 8 bytes on a 64bit CLR).

So lookup is carried out efficiently in $O(1)$ either way.
Maintaining the uniqueness information is in $O(log(n))$, but much less on average, as the ids of deleted elements have to be stored in a heap (the data structure, not the memory model) for quick reuse of the lowest one upon graph element addition (this way we ensure a maximally packed id range, which keeps the index array and the is-matched-bit-arrays of the parallelized matchers small and packed).

A uniqueness index does not allow multiple elements per indexed property (which is here the unique id), like the name index, and in contrast to the attribute and incidence count indices.

\subsection*{Declaration in the model}
The space for the unique id is always reserved in the graph elements, but unique ids are only assigned if you declare an uniqueness constraint.
Or if you declare another index in the model, as indices depend on the unique ids, or if you use parallelize annotations, as the parallelized matchers depend on the unique ids, too.
If you need to fetch graph elements by their unique ids, you must declare an unique index (in addition or instead).

\begin{rail}
  UniqueConstraintDecl: 'node' 'edge' 'unique' ';';
  UniqueIndexDecl: 'index' 'unique' ';';
\end{rail}\ixnterm{UniqueConstraintDecl}\ixnterm{UniqueIndexDecl}\ixkeyw{unique}


\subsection*{Usage in the rules}
The unique index can be used in the pattern to lookup graph elements by their unique id.

\begin{rail}
  UniqueIndexAccessExpr:
    lbrace 'unique' '[' Expression ']' rbrace;
\end{rail}\ixnterm{UniqueIndexAccessExpr}

There is at most one element existing with the unique id asked for; if no graph element with that unique id exists, matching fails and backtracks, if an element exists, the pattern element is bound to it, and matching continues.
Please note that the expression used to compute the unique id is only allowed to reference at most one pattern element (not handed in as parameter).

The unique constraint may be further queried from the rule language expressions or the sequence expressions with the \texttt{\indexed{uniqueof}} function,
the unique index with the \texttt{\indexed{nodeByUnique}} and \texttt{\indexed{edgeByUnique}} functions:
\begin{description}
\item[\texttt{uniqueof(.)}] returns the unique id (type int) of the given node or edge (or (sub)graph, a missing argument amounts to the host graph).
\item[\texttt{nodeByUnique(.)}] returns the node of the given unique id, or null if no node of that unique id exists. Optionally, a target node type may be given as second argument, then you receive a node of that type as result, or null if no node of that unique id \emph{and type} exists.
\item[\texttt{edgeByUnique(.)}] returns the edge of the given unique id, or null if no edge of that unique id exists. Optionally, a target edge type may be given as second argument, then you receive a edge of that type as result, or null if no edge of that name \emph{and type} exists.
\end{description}

The unique ids are automatically assigned (utilizing an id pool that is enlarged with newly allocated ids when an element is added to the graph but the pool is empty, or reusing an already existing id; when an element is removed from the graph, its id returns to the id pool).
In contrast to the names, you cannot change the id assignment.

\begin{example}

The following model declares a node class \texttt{N}, specifies the uniqueness constraint, and requests the uniqueness index.
 
\begin{grgen}
node class N;
node edge unique;
index unique;
\end{grgen}

The test \texttt{t} succeeds if there is a node of unique id $0$ existing in the graph, with a reflexive edge of the unique id defined by input parameter \texttt{i}, and there is a further node of unique id $42$ existing the graph. It is unlikely you will really use code like that as you cannot assign a unique id.

\begin{grgen}
test t(var i:int) {
  n:N{unique[0]} -e:Edge{unique[i]}-> n;
  if{ nodeByUnique(42) != null; }
}
\end{grgen}

The rule \texttt{r} allows to match \texttt{n} and \texttt{m} to the same graph element \texttt{hom}omorphically, just to forbid it then with the condition requesting that their unique-ids must be different. The point here is that the \texttt{hom} allows the engine to omit the isomorphy check, yielding slightly better performance. By using \verb#<# instead of \verb#!=# we ensure that we get only one match for the automorphic pattern in case of an application with all-bracketing -- the one in which the element with the smaller id is bound to \texttt{n}. Furthermore, the rule prints the unique id of the node bound to \texttt{n}.

\begin{grgen}
rule r() {
  n:N -- m:N;
  hom(n,m);
  if{ uniqueof(n) < uniqueof(m); }
		
  modify {
  ---
    emit("The unique id of the graph element bound to n is ", uniqueof(n), "\n");
  }
}
\end{grgen}

\end{example}


