\chapter{Advanced Modelling (Object-Oriented and Graph-Oriented Programming)}\indexmain{methods}\indexmain{graph-oriented programming}\indexmain{object-oriented programming}
\label{cha:modeladvanced}

%Maybe TODO: explain the difference in between the two parts of GrGen:
%Declarative pattern matching and rewriting, with development support at that abstraction level, versus imperative-OO (minor functional) programming, with code generation, to be debugged at level of generated code.
%(In between post-matches filtering/processing -- Query-Update (with match classes). Also imperative: sequences to control rules, containers, classes internal/external.)

In addition to the node and edge classes (the key features of the \emph{graph models}\indexmain{graph model} of \GrG\ as already introduced in Chapter~\ref{chapmodellang}),
you can define \emph{object classes} and \emph{transient object classes}.
They allow to group attributes that are commonly used together into an own entity.
By means of them, list and tree-like (sub-)data structures can be used within a graph (in a storage efficient way, circumventing the built-in graph indices of the nodes/edges, cf. \ref{sec:performancememory}).

The exact data layout can be even abstracted from with \emph{methods} (i.e. you access by method instead of the attribute directly); or, in general, arbitrary behavior can be implemented by them.
You may specify methods not only in object and transient object classes, but also in the node or edge classes.
Methods are functions or procedures that are declared inside class scope.
In contrast to attributes that do not support overwriting -- each attribute of a type is added to all subtypes, with multiple declarations being forbidden -- methods support overwriting.
Independent of the statically known type of the variable, the method gets executed that was defined nearest to the exact dynamic type of the value, in case a method is called.

This \emph{dynamic dispatch} is the defining feature of object-oriented programming.
For graph-oriented programming, the defining feature is \emph{pattern-matching}.

Graph-oriented programming works based on a global host graph open for pattern-matching, in contrast to object-oriented programming with its heap of objects, which typically hide their innards, separating information into local parts. 
It is thus less scalable out of the box -- it can be made scalable to larger tasks with hierarchically \emph{nested graphs}, allowed-for by attributes of graph type in the model, implemented with switch-to-subgraph and return-from-subgraph operations.

\begin{rail}
  AdvancedModelDeclarations: () + (FunctionMethodDefinition
										 | ProcedureMethodDefinition
  									 | ExternalClassDeclaration
  									 | ExternalFunctionDeclaration
  									 | EmitParseDeclaration
  									 | CopyCompareDeclaration
										 | PackageDefinitionModel
										 | FunctionParallelization
										 | EqualsAnyParallelization);
\end{rail}\ixnterm{AdvancedModelDeclarations}

The \emph{ExternalClassDeclaration} registers an \indexed{external class} with \GrG -- including its subtype hierarchy, excluding any attributes -- which can be used subsequently in attribute computations in \indexed{external function}s.
The \emph{EmitParseDeclaration} declares that the user defines emit and parse functions for external or object type values,
whereas the \emph{CopyCompareDeclaration} declares that the user defines copy and compare functions for external or object type values.
You find more on them in \ref{chapextensions}, here we will take a closer look on the \emph{FunctionMethodDefinition} and \emph{ProcedureMethodDefinition}, followed by the \emph{PackageDefinitionModel}.
The \emph{FunctionParallelization} and \emph{EqualsAnyParallelization} are explained in \ref{sec:performanceparallel}.
%Node/Edge typed attributes are possible.

% massive data modelling improvement, extension compared to pure graph rewriting: Object type, transient Object type
%   allow data grouping, and linked data structures like lists, trees (,graphs) - a lot more efficiently without graph index overhead 
%    (and without internal optimization reducing them to that based on connection assertions) (but with transaction/backtracking without bookkeeping support)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object Types and Transient Object Types}\label{sec:objecttypes}

\subsection{Object Types}

\begin{rail}
  ObjectClass: 'class' IdentDecl (() | 'extends' (ObjectType+',')) \\
    (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{class}\ixkeyw{extends}\ixnterm{ObjectClass}\ixnterm{TransientObjectClass}
Defines a new \indexed{object type}.
Object types can inherit\indexmain{inheritance} from other object types defined within the same file.
If the \texttt{extends} clause is omitted, \emph{ObjectType} will inherit from the built-in type \texttt{\indexed{Object}}, the root type of internal class objects.
Note that \texttt{Object} is not the same as \texttt{object}, the root type of all types, which does not have much semantic meaning but acts as a mere placeholder, also including \texttt{external} class types.
Optionally objects can possess attributes.
The keywords \texttt{abstract} and \texttt{const} have the same meaning as for node and edge types, cf. \ref{nodeandedgetypes}.

Objects of object classes are automatically assigned a unique id upon creation.
This id is used in serialization and parsing of values of object types, it is displayed in the debugger, and can be queryied with the \texttt{uniqueof} function (which has the signature \texttt{uniqueof(.:ObjectType):long}).

\begin{example}
\begin{grgen}
class Bar;
class Foo extends Bar
{
  i:int;
  s:string;
}
node class N
{
  foo:Foo;
}
\end{grgen}
\end{example}


\subsection{Transient Object Types}

\begin{rail}
  TransientObjectClass: 'transient' 'class' IdentDecl (() | 'extends' (TransientObjectType+',')) \\
    (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{class}\ixkeyw{extends}\ixnterm{ObjectClass}\ixnterm{TransientObjectClass}
Defines a new \indexed{transient object type}.
Transient object types can inherit\indexmain{inheritance} from other transient object types defined within the same file.
If the \texttt{extends} clause is omitted, \emph{TransientObjectType} will inherit from the built-in type \texttt{\indexed{TransientObject}}, the root type of internal transient class objects.
Optionally transient objects can possess attributes.
The keywords \texttt{abstract} and \texttt{const} have the same meaning as for node and edge types, cf. \ref{nodeandedgetypes}.

In contrast to object types, transient object types cannot be stored in the graph, i.e. they are not allowed as attributes.
They are meant for processing purpose only (their semantics are geared towards that use case).
Neither are transient classes assigned a unique id.
Transient objects can store non-transient objects, though.

Figure~\ref{fig:alltypes} shows the \indexed{type hierarchy} of \GrG.
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}
		[font=\small,
		 class/.style={rectangle,draw,minimum width=3.5cm,minimum height=0.75cm},
		 inherits/.style={->,>=open triangle 60}]

		\node[class] (object) at (0,0) {\texttt{object}};

		\node[class] (Object) [below left=of object] {\texttt{Object}};
		\node[class] (Node) [below=of object] {\texttt{Node}};
		\node[class] (AEdge) [below right=of object] {\texttt{AEdge}};
		\draw[inherits] (Object.north) -- (object.south west);
		\draw[inherits] (Node.north) -- (object.south);
		\draw[inherits] (AEdge.north) -- (object.south east);
		
		\node (UserObject) [below=of Object] {\parbox{4cm}{\centering$\vdots$\\ user-defined\\Object classes \\$\vdots$}};
		\node (UserNode) [below=of Node] {\parbox{4cm}{\centering$\vdots$\\ user-defined\\Node classes \\$\vdots$}};
		\node (UserEdge) [below=of AEdge] {\parbox{4cm}{\centering$\vdots$\\ user-defined\\Edge classes \\UEdge classes\\$\vdots$}};
		\draw[inherits] (UserObject.north) -- (Object.south);
		\draw[inherits] (UserNode.north) -- (Node.south);
		\draw[inherits] (UserEdge.north) -- (AEdge.south);
		
		\node[class] (TransientObject) [above left=of object] {\texttt{TransientObject}};
		\node (ValueTypes) [above=of object] {\parbox{4cm}{\centering$\vdots$\\ValueTypes \\\texttt{int,double,string,enum}\\$\vdots$}};
		\node (ContainerTypes) [above right=of object] {\parbox{4cm}{\centering$\vdots$\\ContainerTypes \\\texttt{set,map,array,deque}\\$\vdots$}};
		\draw[inherits] (TransientObject.south) -- (object.north west);
		\draw[inherits] (ValueTypes.south) -- (object.north);
		\draw[inherits] (ContainerTypes.south) -- (object.north east);

		\node (UserTransientObject) [above=of TransientObject] {\parbox{4cm}{\centering$\vdots$\\ user-defined\\TransientObject classes \\$\vdots$}};
		\draw[inherits] (UserTransientObject.south) -- (TransientObject.north);
	\end{tikzpicture}
		\caption{Type Hierarchy of \GrG}
	\label{fig:alltypes}
\end{figure}

%The keyword \texttt{abstract} indicates that you cannot instantiate objects of this type.
%Instead non-abstract types must be derived from the type in order to create objects.
%The abstract-property will not be inherited by subclasses.

%The keyword \texttt{const} indicates that rules may not write to attributes (see also Section~\ref{sec:replacemodify}, \texttt{eval}).
%However, such attributes are still writable by \LibGr\indexmain{libGr} and \GrShell\indexmain{GrShell} directly. This property applies to attributes defined in the current class, only.
%It does not apply to inherited attributes.
%The \texttt{const} property will not be inherited by subclasses, either.
%If you want a subclass to have the \texttt{const} property, you have to set the \texttt{const} modifier explicitly.

\begin{example}
\begin{grgen}
abstract transient class Baz;
transient class Qux extends Baz {
  i:int;
  foo:Foo;
}
\end{grgen}
\end{example}


\subsection{Object Creation}

\subsubsection{new Operator}\label{subsec:copynclonefunctions}

The \texttt{new} operator allows to instantiate \emph{ObjectType}s as well as \emph{TransientObjectType}s.
It exists in two versions, a plain one just instantiating the (transient) object with default values for its attributes, and a version with an initializer list following an at character, which allows to explicitly initialize attributes.

\begin{rail}
  NewOperator: 'new' (ObjectType|TransientObjectType) ('(' ')'|ObjectAttributeInitializationList);
\end{rail}\ixnterm{NewOperator}\ixkeyw{new}


\indexmain{object attribute initialization}At a new operator application to a transient or non-transient object class (causing creation of the object), you can give an object attribute initialization list (similar to the attribute initialization list that can be applied to graph elements, cf. \ref{sec:attribinitrule}.

\begin{rail}
ObjectAttributeInitializationList : railat '(' ((ObjectAttributeInitialization)+(',')) ')';
ObjectAttributeInitialization : AttributeIdent '=' Expression;
\end{rail}\ixnterm{ObjectAttributeInitializationList}\ixnterm{ObjectAttributeInitialization}

The object initialization list is appended to the declaration with an at-Symbol, the attributes of the type are simply given by their name (i.e. \emph{Ident}ifier).
The expression must be of the type of the attribute.  
%Please take into account that the names must be unique if you intend to set them from the rules. -- maybe todo: percent sign for unique-id / initialization like the name of graph elements with the dollar

Note that (transient) objects are automatically garbage collected when no reference to them exists anymore.

\begin{example}
The following example creates a new object of type \texttt{FooBar}, initializing the attribute \texttt{i} to \texttt{42} and the attribute \texttt{s} to \texttt{"Hallo Welt"}.
\begin{grgen}
new FooBar@(i=42, s="Hallo Welt");
\end{grgen}
\end{example}

The new operator can be also used as a prefix to the container constructors, to have a syntax that is closer to the one of the common programming languages (a container is created and a reference returned).

\begin{example}
The following example creates a new container and initializes it with the string \texttt{"Furchtbar"}.
\begin{grgen}
function createArray : array<string>
{
  return(new array<string>["Furchtbar"]);
}
\end{grgen}
\end{example}

%TODO: object attribute initialization in shell. There with percent sign for unique-id assignment.


\subsubsection{Structure examples}

Let us take a look at more meaningful sample code than the synthetic examples from the previous sections just introducing the new constructs.
For one on an invasive linked list -- it shows how to build linked object structures with recursively contained objects.

\begin{example}
\begin{grgen}
class List {
  value:int;
  next:List;
}
function createList(var i:int, var j:int, var k:int) : List
{
  return(new List@(value = i, next = new List@(value = j, next = new List@(value = k, next = null))));
}
function sumList(ref list:List) : int
{
  if(list.next != null) {
    return(list.value + sumList(list.next));
  } else {
    return(list.value);
  }
}
\end{grgen}
\end{example}

And for the other on a tree -- it shows how to build linked object structures with objects recursively contained within a container.

\begin{example}
\begin{grgen}
transient class Tree {
  value:string;
  children:array<Tree>;
}
function createTree() : Tree
{
  return(new Tree@(value = "FooBar", children = new array<Tree>[new Tree@(value = "Furchtbar", children = new array<Tree>[])]));
}
function serializePreorder(ref tree:Tree) : string
{
  def var res:string = tree.value;
  res = res + "(";
  def ref children:array<Tree> = tree.children;
  for(child:Tree in children)
  {
    res = res + serializePreorder(child);
  }
  res = res + ")";
  return(res);
}
\end{grgen}
\end{example}

You could introduce shortcuts or cycles by inserting the same object multiple times into the \texttt{Tree}, yielding a graph (without the pattern matching abilities offered by \GrG).
Then you'd have to introduce a set storing already visited objects so that you don't run into an endless recursion upon visiting an already visited object again (meaning there is path from the object to itself) in case you intend to process such an object structure.
Or even a map of old, already visited objects to new ones, in case you are in need of a copy algorithm that replicates such an object structure.
But before you tackle the task of implementing it: such an algorithm is already offered natively and generically in the form of a pre-implemented copy function.


\subsubsection{Copy and Clone functions}\label{subsec:copynclonefunctions}

\indexmain{copy}\indexmain{clone}The copy and clone functions allow to create objects as deep copies or shallow clones of other objects.
Both create a new object, but the copy function also creates copies of contained objects, i.e. of attributes of object class type, in contrast to the clone function which only assigns their references.
So the copy function allows to copy transitively.
Note that each copy has a different unique id.
For the same functionality being applied to graph elements, see \ref{sec:copy}.

\begin{description}
\item[\texttt{clone(Object):Object}] returns a shallow clone of the original internal class object given as argument.
\item[\texttt{copy(Object):Object}] returns a deep copy of the original internal class object given as argument.
\end{description}

The copy and clone functions are also available for objects of transient classes.
They differ from the functions available for the non-transient classes in their handling of attributes of container types.
For transient objects, the container reference is taken over, while for non-transient objects (like for graph elements), a clone of the container is created (and in case of the copy function, the contained objects of transient or non-transient classes are copied).

\begin{description}
\item[\texttt{clone(TransientObject):TransientObject}] returns a shallow clone of the original internal transient class object given as argument.
\item[\texttt{copy(TransientObject):TransientObject}] returns a deep copy of the original internal transient class object given as argument.
\end{description}

\begin{example}
The example shows a simplified form of the clone and copy functions, manually implemented on a List class.
It highlights the differences in between the \texttt{copy} and the \texttt{clone} operator.
\begin{grgen}
class List {
  value:int;
  next:List;
}
procedure cloneList(ref list:List) : (List)
{
  def ref listClone:List = new List(); // create new list...
  listClone.value = list.value; // ...and assign member attributes
  listClone.next = list.next; // assignment not possible in function to ensure graph is not changed (would be ok for transient object)
  return(listClone);
}
procedure copyList(ref list:List) : (List)
{
  (def ref listCopy:List) = cloneList(list); // clone list...
  if(list.next != null) {
    (listCopy.next) = copyList(list.next); // ...then copy object attributes deeply
  } 
  return(listCopy);
}
\end{grgen}
Instead of implementing these procedures manually, you can simple write (and use in function context)
\begin{grgen}
clone(list) // == cloneList(list);
copy(list) // == copyList(list);
\end{grgen}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Methods}\label{sec:objectoriented}

Classes do not only allow to structure data, but also to attach functionality.
This occurs by means of method definitions.

Methods allow to factor out computations that are occurring frequently on attributes of node classes or edge classes or object classes or transient object classes and to reuse them. 
Such compound computations can be built and abstracted into reusable entities in two different forms, \emph{function methods} usable(/callable) from expression context, and \emph{procedure methods} usable(/callable) from statement context.

Besides, you could hide the exact data members behind an interface defined by the methods, giving a means of data abstraction.

Furthermore, some built-in function methods and procedure methods on container types are available in rule language computations and sequence computations, cf. \ref{cha:container};
in addition to the methods defined in \ref{cha:typeexpr} that are only available in the rule language.
%(Furthermore, external functions methods and computation methods may be declared, callable with the same syntax, too.)

%-----------------------------------------------------------------------------------------------
\subsection{Function Method Definition and Call}\label{sub:functionmethods}\label{sec:funcmethcall} 

Function methods are defined in exactly the same way as a function is defined, just inside the hosting class.
They have the same requirements, 
i.e. exactly one output value must be returned, 
and they must be side-effect free, which especially means that they are not allowed to change the attributes of their hosting type.

\begin{rail} 
  FunctionMethodDefinition: FunctionDefinition;
\end{rail}\ixnterm{FunctionMethodDefinition}

\begin{rail}
  FunctionMethodCall: MethodTarget '.' FunctionIdent '(' (Expression * ',') ')' ;
\end{rail}\ixnterm{FunctionMethodCall}

A such defined function method may then be called as an expression atom from anywhere in the rule language file where an expression is required; or even from the sequence computations where an expression is required.
In contrast to a regular function call with a method target prefix separated by a dot (defining the \texttt{this} value, obtained from a variable or an attribute, or in case of the function methods also a full expression).
The built-in function methods listed in \ref{funcmethstab} are called with the same syntax.

Inside the function methods, the special entity \texttt{this} is available.
It allows to access the attributes and methods of the type the method is contained in.
In contrast to Java, C++, or C\# where \texttt{this} may be used optionally to denote member or method access,
the usage of \texttt{this} is mandatory in \GrG~in order to access the attributes of the type or in order to call the methods of the type.

\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{string.length():int}\\
\texttt{string.startsWith():boolean}\\
\texttt{string.endsWith():boolean}\\
\texttt{string.indexOf(string[,int]):int}\\
\texttt{string.lastIndexOf(string[,int]):int}\\
\texttt{string.substring(int[,int]):string}\\
\texttt{string.replace(int, int, string):string}\\
\texttt{string.toLower():string}\\
\texttt{string.toUpper():string}\\
\texttt{string.asArray(string):array<string>}\\
\hline
\texttt{set<T>.size():int}\\
\texttt{set<T>.empty():boolean}\\
\texttt{set<T>.peek(int):T}\\
\texttt{set<T>.asArray():array<T>}\\
\hline
\texttt{map<S,T>.size():int}\\
\texttt{map<S,T>.empty():boolean}\\
\texttt{map<S,T>.peek(int):S}\\
\texttt{map<S,T>.domain():set<S>}\\
\texttt{map<S,T>.range():set<T>}\\
\texttt{map<int,T>.asArray():array<T>}\\
\hline
\texttt{deque<T>.size():int}\\
\texttt{deque<T>.empty():boolean}\\
\texttt{deque<T>.peek([int]):T}\\
\texttt{deque<T>.indexOf(T[,int]):int}\\
\texttt{deque<T>.lastIndexOf(T):int}\\
\texttt{deque<T>.subdeque(int, int):deque<T>}\\
\texttt{deque<T>.asArray():array<T>}\\
\texttt{deque<T>.asSet():set<T>}\\
\hline
\end{tabular}
\caption{Non-array function methods at a glance}
\label{funcmethstab}
\end{table}

\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{array<T>.size():int}\\
\texttt{array<T>.empty():boolean}\\
\texttt{array<T>.peek([int]):T}\\
\texttt{array<T>.indexOf(T[,int]):int}\\
\texttt{array<T>.lastIndexOf(T[,int]):int}\\
\texttt{array<T>.indexOfOrdered(T):int}\\
\texttt{array<T>.orderAscending():array<T>}\\
\texttt{array<T>.orderDescending():array<T>}\\
\texttt{array<T>.keepOneForEach():array<T>}\\
\texttt{array<T>.reverse():array<T>}\\
\texttt{array<T>.shuffle():array<T>}\\
\texttt{array<T>.subarray(int, int):array<T>}\\
\texttt{array<T>.asDeque():deque<T>}\\
\texttt{array<T>.asSet():set<T>}\\
\texttt{array<T>.asMap():map<int,T>}\\
\texttt{array<string>.asString(string):string}\\
\hline
\texttt{array<T>.sum():T}\\
\texttt{array<T>.prod():T}\\
\texttt{array<T>.min():T}\\
\texttt{array<T>.max():T}\\
\texttt{array<T>.avg():double}\\
\texttt{array<T>.med():double}\\
\texttt{array<T>.medUnordered():double}\\
\texttt{array<T>.var():double}\\
\texttt{array<T>.dev():double}\\
\texttt{array<boolean>.and():boolean}\\
\texttt{array<boolean>.or():boolean}\\
\hline
\texttt{array<T>.extract<attr>():array<typeof(attr)>}\\
\texttt{array<T>.orderAscendingBy<attr>():array<T>}\\
\texttt{array<T>.orderDescendingBy<attr>():array<T>}\\
\texttt{array<T>.keepOneForEach<attr>():array<T>}\\
\texttt{array<T>.groupBy<attr>():array<T>}\\
\texttt{array<T>.indexOfBy<attr>(typeof(attr)[,int]):int}\\
\texttt{array<T>.lastIndexOfBy<attr>(typeof(attr)[,int]):int}\\
\texttt{array<T>.indexOfOrderedBy<attr>(typeof(attr)):int}\\
\hline
\verb#array<T>.map<entity>{[this_:array<T>;][index:int->]elem:T->lambda-expr}#\\
\verb#array<T>.removeIf{[this_:array<T>;][index:int->]elem:T->lambda-expr}#\\
\verb#array<T>.map<entity>StartWith{[this_:array<T>;]init-expr}AccumulateBy#\\
\verb#{[this_:array<T>;]accumulation-var:T,[index:int->]elem:T->lambda-expr}#\\
\hline
\end{tabular}
\caption{Array function methods at a glance}
%\label{funcmethstab}
\end{table}

%-----------------------------------------------------------------------------------------------
\subsection{Procedure Method Definition And Call}\label{sub:proceduremethods}\label{sec:procmethcall} 

Procedure methods are defined in exactly the same way as a procedure is defined, just inside the hosting class.
They may return an arbitrary number of return values, and are thus only callable as a statement.
They are allowed to manipulate the graph and esp. the element they are contained in as needed, while being executed;
so you are free to call other procedures -- but in contrast to global procedures, you cannot include exec statements.

\begin{rail} 
  ProcedureMethodDefinition: ProcedureDefinition;
\end{rail}\ixnterm{ProcedureMethodDefinition}

\begin{rail}
  ProcedureMethodCall: (OutputAssignment)? MethodTarget \\
        '.' ProcedureIdent '(' (Expression * ',') ')' ;
  MethodTarget: (Variable | Variable '.' Attribute) ;
\end{rail}\ixnterm{ProcedureMethodCall}\ixnterm{MethodTarget}

A such defined procedure may then be called as a statement atom from anywhere in the rule language file where an attribute evaluation (/computation) is required; or even from the sequence computations where a statement is required.
In contrast to a regular procedure call with a method target prefix separated by a dot (defining the \texttt{this} value, obtained from a variable or an attribute).
The built-in procedure methods listed in \ref{procmethstab} are called with the same syntax.

Inside the procedure method, the special entity \texttt{this} is available.
It allows to access the attributes and methods of the type the method is contained in.
In contrast to Java, C++, or C\# where \texttt{this} may be used optionally to denote member or method access,
the usage of \texttt{this} is mandatory in \GrG~in order to access the attributes of the type or in order to call the methods of the type.


%\makeatletter
\begin{table}[htbp]
\centering
\begin{tabular}{|l|}
\hline
\texttt{set<T>.add(T)}\\
\texttt{set<T>.rem(T)}\\
\texttt{set<T>.clear()}\\
\hline
\texttt{map<S,T>.add(S,T)}\\
\texttt{map<S,T>.rem(S)}\\
\texttt{map<S,T>.clear()}\\
\hline
\texttt{array<T>.add(T[,int])}\\
\texttt{array<T>.rem([int])}\\
\texttt{array<T>.clear()}\\
\hline
\texttt{deque<T>.add(T[,int])}\\
\texttt{deque<T>.rem([int])}\\
\texttt{deque<T>.clear()}\\
\hline
\end{tabular}
\caption{Procedure methods at a glance}
\label{procmethstab}
\end{table}


\begin{example}
In the following listing, we declare function and a procedure methods inside a node class, and use them from a rule.
Please note the mandatory \texttt{this} in the methods to denote members and call other methods.
	\begin{grgen}
node class N
{
	i:int;
	
	function get_i():int
	{
		return(this.i);
	}
	procedure set_i(var val:int)
	{
		this.i = val;
		return;
	}
	procedure inc_i(var val:int) : (int)
	{
		this.set_i( this.get_i() + val );
		return(this.i);
	}
}

rule foo : (int)
{
	n:N;
	modify {
	---
		def var i:int;
		eval {
			n.set_i(41);
			n.inc_i(1);
			yield i = n.get_i();
		}
		return(i); // exeuting foo will return 42
	}
}
	\end{grgen}
\end{example}


\begin{example}
The following listing highlights the effect of dynamic dispatch (the heart and soul of object-oriented programming): 
the method finally called depends not simply on the static type we know for sure the object is an instance of,
but on the real dynamic type of the object, that it was created with.
Please note that in reality you use this language device to achieve the \emph{same behaviour} at the outside for objects of different types, but implemented \emph{internally consistent} regarding the exact type, taking all of its members into account (including the ones unknown to parent types).
	\begin{grgen}
node class N
{	
	function get():int
	{
		return(0);
	}
}

node class NN extends N
{	
	function get():int
	{
		return(1);
	}
}

rule foo : (int)
{
	n:N; // statically declared N, may match dynamically to node of type NN
	modify {
	---
		def var i:int;
		eval {
			yield i = n.get();
		}
		return(i); // exeuting foo will return 0 iff n was bound to node of type N, but 1 iff n was bound to node of type NN
	}
}
	\end{grgen}
\end{example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Packages}\label{sec:packages}

Packages allow you to separate a project into namespaces that shield their content from name clashes when getting used (for models) or included (for actions) together.
They incur some non-negligible notational overhead as every usage of a name from a package outside of that package \emph{must} be prefixed with the package name (in the form \verb#packagename::name#), so we recommend to use them only when needed.
This holds esp. as we expect that a typical project will be limited to an algorithmic kernel written by a single programmer who has everything under control and can thus easily prevent name clashes.

%-----------------------------------------------------------------------------------------------
\subsection{Package Definition in the Model}\label{sub:packagemodel} 

\begin{rail}
  PackageDefinitionModel: 'package' IdentDecl lbrace
	                   ((ClassDeclaration
  									 | EnumDeclaration)+)
										rbrace;
\end{rail}\ixnterm{PackageDefinitionModel}

A \indexed{package definition} in the model is similar to a model definition as such, just reduced in its content.
It consists of \emph{ClassDeclaration}s, defining node or edge types, or \emph{EnumDeclaration}s defining enum types.
The \emph{AdvancedModelDeclarations} allowed in the root model are \emph{not} available inside a package, \emph{neither} can other models be included inside a package with \texttt{using}.
Package definitions \emph{cannot} be nested.

\begin{rail}
  PackageUsageModel: Ident '::' Ident;
\end{rail}\ixnterm{PackageUsageModel}

In every context where a node, edge, or enum type can be referenced,
by noting down its declared \emph{Ident}ifier, 
also a type from a package can be referenced,
by noting down its package as a prefix.
The package prefix may be omitted inside the package for other entities from the same package.
But only for them, outside of that package you must always use the package prefixed form for referencing identifiers from the package.

\begin{example}
Types from a model defined like this:
	\begin{grgen}
package Foo {
	node class N {
		attr : Lol;
	}
	enum Lol {
		Bla,
		Blub
	}
}

package Bar {
	node class N {
		attr : Foo::Lol;
	}	
}
	\end{grgen}
Can be used like this:
	\begin{grgen}
rule r(var inp : Foo::Lol) {
	x : Foo::N --> y : Bar::N;
	if{ x.attr==Foo::Lol::Bla; }

	modify {
	---
		eval{ add(Foo::N); }
		eval{ y.attr = Foo::Lol::Blub; }
	}
}	
	\end{grgen}
\end{example}
	
%-----------------------------------------------------------------------------------------------
\subsection{Package Definition in the Actions}\label{sub:packageaction} 

\begin{rail}
  PackageDefinitionAction: 'package' IdentDecl lbrace ((ActionDeclaration | SubpatternDeclaration | RewriteSequenceDefinition | FunctionDefinition | ProcedureDefinition | FilterFunctionDefinition)+) rbrace;
\end{rail}\ixnterm{PackageDefinitionAction}

A \indexed{package definition} in the actions is similar to a rule set definition as such, just reduced in its content.
It consists of \emph{ActionDeclaration}s, defining rules and tests, or \emph{SubpatternDeclaration}s to be used from the actions, or \emph{FilterFunctionDefinition}s, for filtering the matches of the actions.
It furthermore consists of \emph{FunctionDefinition}s and \emph{ProcedureDefinition}s, or \emph{RewriteSequenceDefinition}s. 
The file header constructs for using models, including other actions, or declaring global variables are \emph{not} available inside a package.
\emph{Neither} can package definitions be nested.

The packages \texttt{Math}, \texttt{File}, \texttt{Time}, \texttt{Transaction}, and \texttt{Debug} are built-in, their functions and procedures can be used directly (see \ref{sec:primexpr}, \ref{sec:subgraphop}, \ref{sub:transaction} and \ref{secdebuggersubrule} for their content).

\begin{rail}
  PackageUsageActions: Ident '::' Ident;
\end{rail}\ixnterm{PackageUsageActions}

In every context where a rule, a test, a subpattern type, a filter function, a function, a procedure, or a sequence can be referenced, by noting down its declared \emph{Ident}ifier, 
also an entity from a package can be referenced,
by noting down its package as a prefix.
The package prefix may be omitted inside the package for other entities from the same package -- package content comes before global content.
But only for them, outside that package you must always use the package prefixed form for referencing identifiers from the package.
Inside a package you may use the \texttt{global} "package" in the form of \texttt{global::name} - it allows to access a global name from inside a package even if an entity with the same name is available locally.

Altogether, the name resolving rules are:
\begin{enumerate}
	\item content from the package specified with the prefix, if that is "global" then global content
	\item content from package context (which thus overrides global content)
	\item global content 
\end{enumerate}
And as a refinement regarding point 2: there is no package context available for interpreted sequences (they only appear in the Shell/API outside of any packages of the rule language), so only rules 1 and 3 apply there.

The packages in the actions are declared with the same syntax as the packages in the model, but are otherwise separate. 
You cannot extend a model package with an actions package, or vice versa.
A package with a given name can only be tied once, either in the model or the actions.

\begin{example}
The example highlights how action packages can be used.
	\begin{grgen}
package Foo {
	pattern P {
		x:Node -e:Edge-> x;

		modify {
			delete(e);
		}
	}
	rule r {
		p:P();

		modify {
			p();
		---
			eval { Bar::proc(true); }
		}
	}
	filter f<r> {
		return;
	}
}

package Bar {
	rule r {
		x:Node -e:Edge-> x;
		if{ func(); }

		modify {
			delete(e);
		---
			exec(Foo::r\Foo::f);
		}
	} \ auto
	function func : boolean {
		return(true);
	}
	procedure proc(var b:boolean) {
		return;
	}	
}

rule r2 {
	if{ Bar::func(); }
	p:Foo::P();
	
	modify {
		p();
	}
}

sequence s2 {
	Foo::r()\Foo::f ;> Bar::r\auto ;> { Bar::proc(Bar::func()); }
}
	\end{grgen}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph Nesting}\label{sec:graphnesting}

You can nest graphs by defining attributes of graph type (cf. \ref{cha:graph}) inside node or edge classes (cf. \ref{chapmodellang}) at modelling time, 
filling them at runtime with assignments of values of graph type, created with the operations introduced in \ref{sec:subgraphop}.
Thus, in contrast to certain modellings identifying nested graphs with nodes, a host graph contains further graphs in the \emph{attributes} of its nodes or edges.

Values of graph type are opaque and inaccessible to the computations that are available in -- and automatically apply to -- the host graph; 
from the outside, they can only be compared, i.e. isomorphy checked against other graphs
(a feature needed for state space enumeration (cf. \ref{sec:statespaceenum}), in this case only immutable subgraphs are stored).

\begin{rail} 
  ExtendedControl: 
    'in' (GraphVariable | NodeOrEdge '.' Attribute) lbrace RewriteSequence rbrace;
\end{rail}\ixkeyw{in}

But they can be opened up by switching the location of processing with the \verb#in g { seq }# sequence.
Inside the braces, the host graph is switched to \texttt{g}, the sequence \texttt{seq} is executed in that new host graph, all queries and updates are carried out on it. 
After executing the construct, the old graph that was previously used is made the current host graph again.

Switching the location of processing is a feature only available in the sequences, (re)defining the execution context for the rules; it is not available on lower levels, it is esp. not possible to access multiple graphs from within a single rule (a rule application is always carried out on a single by-then current host graph).

\begin{rail}
  Rule: GraphVariable '.' RuleIdent (() | '(' (Variable+',') ')');
\end{rail}\ixnterm{Rule}

A simplified and more lightweight version of the full switch just introduced is available for single rule calls with syntax \verb#g.r#; so a method call in the plain sequences (above the sequence computations) denotes in fact a temporary subgraph switch.
This is syntactic sugar for the dedicated switch containing only a single rule application as sequence.
The syntax of rule application is extended by the grammar rule above to allow for this is.

The \emph{information hiding} shown by the graph attributes is comparable to the information hiding shown by the objects in \emph{object-oriented programming}, there the attributes but especially the neighbouring elements are only known to the containing object and accessible to the methods of the object.
In \emph{graph-oriented programming} are the attributes but especially the neighboring elements known to the containing graph, the connecting topology is open for \emph{pattern matching}.
This crucial difference also defines the main benefit compared to OO, removing it would mean to revert back to OO.
But this openness might not be needed always for all parts.
When building a \emph{large system}, you typically only need a certain \emph{layer} to be accessible at a time.
You may use graph attributes and nested graph in this case,
utilizing open graph-oriented programming for the parts you need to work globally with pattern matching at a time,
and closed object-oriented programming for parts you only need to access locally,
decoupled by explicit move-to-subgraph and return-to-subgraph steps.

You may model containment with edges denoting a containment type pointing to the contained parts instead of attributes of subgraph type
when the pattern matcher needs overall access to the graph, but there are still some containment or nesting relationships in place.
You can then still benefit from a hierarchical structure in debugging, utilizing the built-in nesting for visualization capabilities of \GrG (cf. \ref{sub:visual}, the graphs nested in attributes are truly opaque and invisible, only when processing switches to them are they displayed instead of their containing host graph).

