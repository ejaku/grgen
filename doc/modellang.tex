\chapter{Graph Model Language}\indexmain{graph model language}
\label{chapmodellang}
The key features of \GrG\ \emph{graph models}\indexmain{graph model} as described by Geiß et al.~\cite{GBGHS:06,KG:07} are given below:

\begin{description}
\item[Types] Nodes and edges are typed. 
  This is similar to classes in common programming languages, except for the concept of methods that \GrG\ nodes and edges don't support. \GrG\ edge types can be directed and undirected.
\item[Attributes] Nodes and edges may possess attributes. The set of attributes assigned to a node or edge is determined by its type. The attributes themselves are typed, too.
\item[Inheritance] Node and edge types (classes) can be composed by multiple \indexed{inheritance}. \texttt{Node} and \texttt{Edge} are built-in root types of node and edge types, respectively. Inheritance eases the specification of attributes because subtypes inherit the attributes of their super types. Note that \GrG\ lacks a concept of overwriting. On a path in the \indexed{type hierarchy} graph from a type up to the built-in root type there must be exactly one declaration for each attribute identifier. Furthermore, if multiple paths from a type up to the built-in root type exist, the declaring types for an attribute identifier must be the same on all such paths.
\item[Connection Assertions] To specify that certain edge types should only connect specific node types a given number of times, we include connection assertions.
\end{description}

\begin{figure}[htbf]
\begin{example}\label{ex:model:map}
The following toy example of a model of road maps gives a rough picture of the language:
\begin{grgen}
enum Resident {VILLAGE = 500, TOWN = 5000, CITY = 50000}

node class Sight;

node class City {
	Size:Resident;
}

const node class Metropolis extends City {
  River:String;
}  

abstract node class AbandonedCity extends City;
node class GhostTown extends AbandonedCity;

edge class Street;
edge class Trail extends Street;
edge class Highway extends Street
    connect Metropolis[+] -> Metropolis[+]
{
    Jam:boolean = false;
}
\end{grgen}
\end{example}
\end{figure}
In this chapter as well as in Chapter~\ref{chapgrshell} (\GrShell) we use excerpts of Example~\ref{ex:model:map} (the \texttt{Map} model) for illustration purposes.

\section{Building Blocks}
\label{modelbb}

\begin{note}
The following syntax specifications make heavy use of \newtermsee{syntax diagram}{rail diagram}s (also known as \indexed{rail diagram}s). Syntax diagrams provide a visualization of EBNF\footnote{Extended Backus–Naur Form.} grammars. Follow a path along the arrows through a diagram to get a valid sentence (or subsentence) of the language. Ellipses represent terminals whereas rectangles represent non-terminals. For further information on syntax diagrams see~\cite{MMJW:91}.
\end{note}
Basic elements of the \GrG\ graph model language are identifiers to denominate nodes, edges, and attributes.
The model's name itself is given by its file name.
The \GrG\ graph model language is \indexed{case sensitive}.\\
\\
\emph{Ident}, \emph{IdentDecl}\\ \indexmain{identifier}\nopagebreak
A non-empty character sequence of arbitrary length consisting of letters, digits, or underscores.
The first character must not be a digit. \emph{Ident} and \emph{IdentDecl} differ in their role:
While \emph{IdentDecl} is a \emph{defining} occurrence of an identifier, \emph{Ident} is a \emph{using} occurrence.
An \emph{IdentDecl} non-terminal may be annotated\indexmain{annotation}. See Section~\ref{annotations} for annotations of declarations.
\begin{note}
\label{note:modeldecl}
  The \GrG\ model language does not distinguish between \indexed{declaration}s and \indexed{definition}s. More precisely, every declaration is also a definition. For instance, the following C-like pseudo \GrG\ model language code is illegal:
\begin{grgen}
node class t_node;
node class t_node {
  ...
}
\end{grgen}
Using an identifier before defining it is allowed. Every used identifier has to be defined exactly once.
\end{note}
\pagebreak
\emph{NodeType}, \emph{EdgeType}, \emph{EnumType}\\ \nopagebreak
These are (semantic) specializations of \emph{Ident} to restrict an identifier to denote a node type, an edge type, or an enum type, respectively.

\subsection{Base Types}
\label{sct:basetypes}
The \GrG\ model language has built-in types for nodes and edges.
All nodes have the attribute-less, built-in type \texttt{Node} as their ancestor.
All edges have the abstract (see Section~\ref{typedecl}), attribute-less, built-in type \texttt{\indexed{AEdge}} as their ancestor.
The \texttt{AEdge} has two non-abstract built-in children: \texttt{\indexed{UEdge}} as base type for undirected edges and \texttt{\indexed{Edge}} as base type for directed edges.
The direction for \texttt{AEdge} and its anchestors that do not inherit from \texttt{Edge} or \texttt{UEdge} is undefined or \newterm{arbitrary}.
Because there is the ``magic of direction'' linked to the edge base types, its recommended to use the keywords \texttt{directed}, \texttt{undirected}, and \texttt{arbitrary} in order to specify inheritance (see Section~\ref{typedecl}).
As soon as you decided for directed or undirected edge classes within your type hierarchie, you are not able to let anchestor classes inherited from a contradicting base type, of course.
That is, no edge may be directed \emph{and} undirected.
This is an exception of the concept multi-inheritance.
Figure~\ref{fig:basetypes} shows the edge \indexed{type hierarchy}.
\begin{figure}[htbp]
	\centering
	\input{fig/basetypes}
	\caption{Type Hierarchy of \GrG\ Edges}
	\label{fig:basetypes}
\end{figure}

\section{Type Declarations}
\label{typedecl}

\begin{rail}
  GraphModel: () + (ClassDeclaration | EnumDeclaration);
\end{rail}\ixnterm{GraphModel}
The \indexed{graph model} consists of zero or multiple type declarations. 
Whereas \emph{ClassDeclaration} defines a node type or an edge type, \emph{EnumDeclaration} defines an enum type to be used as a type for a attributes of nodes or edges.
Like all identifier definitions, types do not need to be declared\indexmain{declaration} before they are used.

\begin{rail}
  EnumDeclaration: 'enum' IdentDecl lbrace ((IdentDecl (() | '=' IntExpr)) + ',') rbrace ;
\end{rail}\ixkeyw{enum}\ixnterm{EnumDeclaration}
Defines an \indexed{enum type}.
An enum type is a collection of so called \emph{\indexed{enum item}s} that are associated with integral numbers, each.
Accordingly, a \GrG\ enum is internally represented as \texttt{int} (see Section~\ref{sec:builtintypes}).
\begin{note}
	An enum type and an {\tt int} are different things, but in expressions enum values are implicitly casted to {\tt int} values 	(see Section~\ref{sec:builtintypes}).
\end{note}
\begin{note}
	Normally, assignments of {\tt int} values to something that has an enum type are forbidden (see Section~\ref{sec:builtintypes}).
	Only inside a declaration of an enum type an int value may be assigned to the enum item that is currently declared.
	This also includes the usage of items taken from other enum types (because they are implicitly casted to {\tt int}).
	However, items from other enum types must be written fully qualified in this case (which, e.g., looks like {\tt MyEnum::a}, where {\tt MyEnum} is the name of the other enum type).
\end{note}

\begin{example}
\begin{grgen}
enum Color {RED, GREEN, BLUE}
enum Resident {VILLAGE = 500, TOWN = 5000, CITY = 50000}
enum AsInC {A = 2, B, C = 1, D, e = (int)Resident::VILLAGE + C}
\end{grgen}
Consider, e.g., the declaration of the enum item {\tt e}:
By implicit casts of   {\tt Resident::VILLAGE } and {\tt C} to {\tt int} we get the {\tt int} value 501, which is assigned to {\tt E}.
Moreover, the semantics is as in C~\cite{Sch:1990:ANSIC}. So, the following holds: $\texttt{RED} = 0$, $\texttt{GREEN} = 1$, $\texttt{BLUE} = 2$, $\texttt{A}=2$, $\texttt{B}=3$, $\texttt{C}=1$, $\texttt{D}=2$, and $\texttt{E}=501$.
\end{example}
\begin{note}
	The C-like semantics of enum item declarations implies, that multiple items of one enum type can be associated with the same same {\tt int} value.
	Moreover, it implies, that an enum item must not be used \emph{before} its definition.
	This also holds for items of other enum types, meaning that the items of another enum type can only be used in the definition of an enum item, when the other enum type is defined \emph{before} the enum type currently defined.
\end{note}

\begin{rail}  
  ClassDeclaration: (() | 'abstract') (() | 'const') \\
    (NodeClass | (() | ('arbitrary' | 'directed' | 'undirected')) EdgeClass);
\end{rail}\ixkeyw{abstract}\ixkeyw{const}\ixnterm{ClassDeclaration}\ixkeyw{arbitrary}\ixkeyw{directed}\ixkeyw{undirected}
Defines a new node type or edge type.
The keyword \texttt{abstract} indicates that you cannot instantiate graph elements of this type.
Instead you have to derive non-abstract types to create graph elements.
The abstract-property will not be inherited by subclasses, of course.

\begin{example}
We adjust our map model and make \texttt{city} abstract:
\begin{grgen}
abstract node class City {
	Size:int;
}
abstract node class AbandonedCity extends City;
node class GhostTown extends AbandonedCity;
\end{grgen}
You will be able to create nodes of type \texttt{GhostTown}, but not of type \texttt{City} or \texttt{AbandonedCity}. However, nodes of type \texttt{GhostTown} are also of type \texttt{AbandonedCity} as well as of type \texttt{City} and they have the attribute \texttt{Size}, hence.
\end{example}
The keyword \texttt{const} indicates that rules may not write to attributes (see also Section~\ref{sec:replacemodify}, \texttt{eval}). However, such attributes are still writable by \LibGr\indexmain{libGr} and \GrShell\indexmain{GrShell} directly. This property applies to attributes defined in the current class, only. It does not apply to inherited attributes. The \texttt{const} property will not be inherited by subclasses, either. If you want a subclass to have the \texttt{const} property, you have to set the \texttt{const} modifier explicitly.

The keywords \texttt{arbitrary}, \texttt{directed}, and \texttt{undirected} specify the direction ``attribute'' of an edge class and thus its inheritance.
An \texttt{arbitrary} edge inherits from \texttt{AEdge}, it is always abstract and neither directed nor undirected.
A \texttt{directed} edge inherits from \texttt{Edge}.
An \texttt{undirected} edge inherits from \texttt{UEdge}.
If you do not specify any of those keywords, a \texttt{directed} edge is choosen by default.
See also Section~\ref{sct:basetypes}

\begin{rail}  
  NodeClass: 'node' 'class' IdentDecl (() | 'extends' (NodeType+',')) \\ 
    (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{node}\ixkeyw{class}\ixkeyw{extends}\ixnterm{NodeClass}
Defines a new \indexed{node type}. Node types can inherit\indexmain{inheritance} from other node types defined within the same file. If the \texttt{extends} clause is omitted, \emph{NodeType} will inherit from the built-in type \texttt{\indexed{Node}}. Optionally nodes can possess attributes.

\begin{rail}    
  EdgeClass: 'edge' 'class' IdentDecl (() | 'extends' (EdgeType+',')) \\
    (() + ConnectAssertions) (';' | lbrace AttributeDeclarations rbrace);
\end{rail}\ixkeyw{edge}\ixkeyw{class}\ixkeyw{extends}\ixnterm{EdgeClass}
Defines a new \indexed{edge type}.
Edge types can inherit\indexmain{inheritance} from other edge types defined within the same file.
If the \texttt{extends} clause is omitted, \emph{EdgeType} will inherit from the built-in type \texttt{\indexed{Edge}}.
Optionally edges can possess attributes.
A \newterm{connection assertion} specifies that certain edge types should only connect specific nodes a given number of times.
(see Section~\ref{sct:basetypes})

\begin{note}
It is not forbidden to create graphs that are invalid according to \indexed{connection assertion}s.
\GrG\ just enables you to check, whether a graph is valid or not.
See also Section~\ref{graphcommands}, \texttt{validate}.
\end{note}

\begin{rail}  
  ConnectAssertions: 'connect' ((NodeConstraint ('-->' | '<--' | '--' | '?--?') NodeConstraint | 'copy' 'extends') + ',');
  NodeConstraint: NodeType (() | '[' ('*' | '+' | Number | RangeConstraint) ']') ;
  RangeConstraint: Number ':' ('*' | Number) ;
\end{rail}\ixkeyw{connect}\ixkeyw{copy}\ixkeyw{extends}\ixnterm{ConnectAssertions}\ixnterm{NodeConstraint}\ixnterm{RangeConstraint}
A \emph{\indexed{connection assertion}} is denoted as a pair of node types in conjunction with their multiplicities\indexmainsee{multiplicity}{connection assertion}. 
It is best understood as a simple pattern of the form(cf. ~\ref{sct:graphlets}) \texttt{:SourceNodeType -:EdgeType-> :TargetNodeType}, of which every occurrence in the graph is searched.
In contrast to a real such pattern and the node types only edges of exactly the given edge type are taken into account.
Per node of \texttt{SourceNodeType} (or a subtype) it is counted how often it was covered by a match of the pattern starting at it,
and per node of \texttt{TargetNodeType} (or a subtype) it is counted how often it was covered by a match of the pattern ending at it.
The numbers must be in the range specified at the \texttt{SourceNodeType} and the \texttt{TargetNodeType} for the connection assertion to be fulfilled.
Don't get surprised by matches of non-disjunct source/target types/subtypes in the case of undirected and especially arbitrary edges.
Multiple connection assertions are applied by conjunction, i.\,e.\ all of them must be fulfilled. 
It might happen that none of the connection assertion of an \texttt{EdgeType} are matching an edge of this type in the graph.
This is accepted in the case of normal validation; but as you normally want to see \emph{only} the specified connections occuring in the graph,
there is the additional mode of strict validation: if an edge is not covered by a single matching connection, validation fails.
See Section~\ref{graphcommands}, \texttt{validate}\ixkeyw{validate}, for an example.
 
The arrow syntax is based on the \GrG\ graphlet specification (see Section~\ref{sct:graphlets}).
The different kinds of arrows distinguish between directed, undirected, and arbitrary edges.
The \texttt{-->} arrow means a directed edge aiming towards a node of the target node type (or one of its subtypes).
The \texttt{A<--B} connection assertion is equivalent to the \texttt{B-->A} connection assertion.
The \texttt{--} arrow is used for undirected edges.
The \texttt{?--?} arrow means an arbitrary edge, i.e. directed as well as undirected possible (fixed by the concrete type inheriting from it); in case of an directed edge the connection pattern gets matched in both directions.
\emph{Number} is an \texttt{int} constant as defined in Chapter~\ref{cha:typeexpr}. 
Table~\ref{multiplicities} describes the multiplicity definitions. 

\begin{table}[htbp]
\begin{tabularx}{\linewidth}{|l|X|}\hline
	\texttt{[$n$:*]} & The number of edges incident to a node of that type is unbounded. At least $n$ edges must be incident to nodes of that type.\\ 
	\texttt{[$n$:$m$]} & At least $n$ edges must be incident to nodes of that type, but at most $m$ edges may be incident to nodes of that type ($m \geq n \geq 0$ must hold).\\
	\texttt{[*]} & Abbreviation for \texttt{[0:*]}.\\
	\texttt{[+]} & Abbreviation for \texttt{[1:*]}.\\
	\texttt{[$n$]} & Abbreviation for \texttt{[$n$:$n$]}.\\
	               & Abbreviation for \texttt{[$1$]}. \\ \hline
\end{tabularx}
\caption{\GrG\ node constraint multiplicities}
\label{multiplicities}
\end{table}

In order to apply the connection assertions of the supertypes to an \texttt{EdgeType}, you may use the keywords \texttt{copy extends}.
The \texttt{copy extends} assertion ``imports'' the connection assertions of the \emph{direct} ancestors of the declaring edge.
This is a purely syntactical simplification, i.\,e.\ the effect of using \texttt{copy extends} is the same as copying the connection assertions from the direct ancestors by hand.
%\begin{note}
%	Connection assertions must be consistent according to the type hierarchy.
%	That means---roughly spoken---the assertions for subtypes must get monotonously more restrictive or monotonously less restrictive.
%	For instance, the following connection assertions are illegal for node types \texttt{A}, \texttt{B}, \texttt{C}, \texttt{D} with \texttt{A} inherits from \texttt{B} and \texttt{C} inherits from \texttt{B}:
%	\begin{grgen}
%connect A[*] -> D, B[0:5] -> D, C[*] -> D
%	\end{grgen}
%	The \GrG\ compiler will warn you, if you're using inconsistent connection assertions.
%\end{note}

\subsection{Attribute Types}
\label{sct:attrtypes}

\begin{rail}    
  AttributeDeclaration: 'const'? IdentDecl ':' AttributeType (() | '=' Expression) ';' | AttributeOverwrite ;
  AttributeType: PrimitiveType | EnumType | GenericType; 
  AttributeOverwrite: Ident '=' Expression
\end{rail}\ixnterm{AttributeDeclarations}\ixnterm{AttributeType}\ixnterm{AttributeOverwrite}
Defines a node or edge \indexed{attribute}. Possible types are enumeration types (\texttt{enum}) and primitive types or generic types.
See Section~\ref{sec:builtintypes} for a list of built-in primitive and generic types.
Optionally attributes may be initialized with a \emph{constant} expression.
The expression has to be of a compatible type of the declared attribute.
See Chapter~\ref{cha:typeexpr} for the \GrG\ types and expressions reference.
The \emph{AttributeOverwrite} clause lets you overwrite initialization values for attributes of super classes.
The initialization values are evaluated in the order as they appear in the rule set file.
\begin{noze}
	The following attribute declarations are \emph{illegal} because of the order of evaluation of initialization values:
	\begin{grgen}
x:int = y;
y:int = 42;	
	\end{grgen}
\end{note}
