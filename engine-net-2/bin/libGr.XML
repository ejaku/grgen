<?xml version="1.0"?>
<doc>
    <assembly>
        <name>libGr</name>
    </assembly>
    <members>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceVariable">
            <summary>
            A variable declared/used within a sequence, 
            might be a sequence-local variable or a reference to a graph-global variable.
            It is first stored within the symbol table belonging to the sequence on sequence parsing,
            after parsing only on the heap, with references from the sequence AST pointing to it.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceType">
            <summary>
            Specifies the actual subtype used for a Sequence.
            A new sequence type -> you must adapt lgspSequenceChecker and lgspSequenceGenerator, 
            SequenceChecker and Sequence (add the corresponding class down below), the Debugger
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment">
            <summary>
            Environment for sequence exection giving access to graph element names and user interface 
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment.GetNamedGraph">
            <summary>
            returns the named graph on which the sequence is to be executed, containing the names
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment.ChooseDirection(System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered direction of execution for the sequence given
            the randomly chosen directions is supplied; 0: execute left operand first, 1: execute right operand first
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment.ChooseSequence(System.Int32,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.Sequence},de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered sequence to execute next for the sequence given
            the randomly chosen sequence is supplied; the object with all available sequences is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment.ChooseMatch(System.Int32,de.unika.ipd.grGen.libGr.IMatches,System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered match to apply next for the sequence given
            the randomly chosen match is supplied; the object with all available matches is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment.ChooseRandomNumber(System.Int32,System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered random number in the range 0 - upperBound exclusive for the sequence given
            the random number chosen is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment.ChooseValue(System.String,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns a user chosen/input value of the given type
            no random input value is supplied, the user must give a value
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Sequence">
            <summary>
            A sequence object with references to child sequences.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Sequence.randomGenerator">
            <summary>
            A common random number generator for all sequence objects.
            It uses a time-dependent seed.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Sequence.SequenceType">
            <summary>
            The type of the sequence (e.g. LazyOr or Transaction)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.#ctor(de.unika.ipd.grGen.libGr.SequenceType)">
            <summary>
            Initializes a new Sequence object with the given sequence type.
            </summary>
            <param name="seqType">The sequence type.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.Apply(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Applies this sequence.
            </summary>
            <param name="graph">The graph on which this sequence is to be applied.
                The rules will only be chosen during the Sequence object instantiation, so
                exchanging rules will have no effect for already existing Sequence objects.</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeded</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.ApplyImpl(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Applies this sequence. This function represents the actual implementation of the sequence.
            </summary>
            <param name="graph">The graph on which this sequence is to be applied.</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeded</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Sequence.id">
            <summary>
            stores the sequence unique id
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Sequence.idSource">
            <summary>
            the static member used to assign the unique ids to the sequence instances
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.Sequence.Children">
            <summary>
            Enumerates all child sequence objects
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.Sequence.Precedence">
            <summary>
            The precedence of this operator. Zero is the highest priority, int.MaxValue the lowest.
            Used to add needed parentheses for printing sequences
            TODO: WTF? das ist im Parser genau umgekehrt implementiert!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.Sequence.Symbol">
            <summary>
            A string symbol representing this sequence type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.Sequence.Id">
            <summary>
            returns the sequence id - every sequence is assigned a unique id used in xgrs code generation
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceSpecial">
            <summary>
            A Sequence with a Special flag
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceSpecial.Special">
            <summary>
            The "Special" flag. Usage is implementation specific.
            GrShell uses this flag to indicate breakpoints when in debug mode and
            to dump matches when in normal mode.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceSpecial.#ctor(System.Boolean,de.unika.ipd.grGen.libGr.SequenceType)">
            <summary>
            Initializes a new instance of the SequenceSpecial class.
            </summary>
            <param name="special">The initial value for the "Special" flag.</param>
            <param name="seqType">The sequence type.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceRandomChoice">
            <summary>
            A Sequence with a random decision which might be interactively overriden by a user choice.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceRandomChoice.Random">
            <summary>
            The "Random" flag "$" telling whether the sequence operates in random mode.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceRandomChoice.Choice">
            <summary>
            The "Choice" flag "%".
            Only applicable to a random decision sequence.
            GrShell uses this flag to indicate choicepoints when in debug mode.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceUnary">
            <summary>
            A sequence consisting of a unary operator and another sequence.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceBinary">
            <summary>
            A sequence consisting of a binary operator and two sequences.
            Decision on order of execution by random, by user choice possible.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceNAry">
            <summary>
            A sequence consisting of a list of subsequences. Breakpointable.
            Decision on order of execution by random, by user choice possible.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser">
            <summary>
            A parser class for xgrs strings.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.actions">
            <summary>
            The rules used in the specification, set if parsing an xgrs to be interpreted
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ruleNames">
            <summary>
            The names of the rules used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.model">
            <summary>
            The model used in the specification
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.varDecls">
            <summary>
            Symbol table of the sequence variables, maps from name to the prefixed(by block nesting) name and the type;
            a graph-global variable maps to type "", a sequence-local to its type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ParseSequence(System.String,de.unika.ipd.grGen.libGr.BaseActions)">
            <summary>
            Parses a given string in xgrs syntax and builds a Sequence object. Used for the interpreted xgrs.
            </summary>
            <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
            <param name="actions">The BaseActions object containing the rules used in the string.</param>
            <returns>The sequence object according to sequenceStr.</returns>
            <exception cref="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">Thrown when a syntax error was found in the string.</exception>
            <exception cref="T:de.unika.ipd.grGen.libGr.SequenceParserException">Thrown when a rule is used with the wrong number of arguments
            or return parameters.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ParseSequence(System.String,System.String[],System.Collections.Generic.Dictionary{System.String,System.String},de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Parses a given string in xgrs syntax and builds a Sequence object. Used for the compiled xgrs.
            </summary>
            <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
            <param name="ruleNames">An array containing the names of the rules used in the specification.</param>
            <param name="predefinedVariables">A map from variables to types giving the parameters to the sequence, i.e. predefined variables.</param>
            <param name="model">The model used in the specification.</param>
            <returns>The sequence object according to sequenceStr.</returns>
            <exception cref="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">Thrown when a syntax error was found in the string.</exception>
            <exception cref="T:de.unika.ipd.grGen.libGr.SequenceParserException">Thrown when a rule is used with the wrong number of arguments
            or return parameters.</exception>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ScopeType">
            <summary>
            The possible scope opening types
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SymbolTable">
            <summary>
            class of symbol table containing the variables declared in the sequence 
            variables might be implicitely(graph-global) or explicitely(sequence-local) declared
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.TokenMgrError.LexicalError">
            Lexical error occured.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.TokenMgrError.StaticLexerError">
            An attempt wass made to create a second instance of a static token manager.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.TokenMgrError.InvalidLexicalState">
            Tried to change to an invalid lexical state.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.TokenMgrError.LoopDetected">
            Detected (and bailed out of) an infinite loop in the token manager.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.TokenMgrError.errorCode">
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.TokenMgrError.AddEscapes(System.String)">
            Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.TokenMgrError.GetLexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            Returns a detailed message for the Exception when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
               EOFSeen     : indicates if EOF caused the lexicl error
               curLexState : lexical state in which this error occured
               errorLine   : line number when the error occured
               errorColumn : column number when the error occured
               errorAfter  : prefix that was seen before this error occured
               curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.porter.TokenMgrError.Message">
             You can also modify the body of this method to customize your error messages.
             For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
             of end-users concern, so you can return something like : 
            
                 "Internal Error : Please file a bug report .... "
            
             from this method for such cases in the release version of your parser.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly">
            <summary>
            Environment for sequence exection giving access to graph element names, with null user interface
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly.GetNamedGraph">
            <summary>
            returns the named graph on which the sequence is to be executed, containing the names
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly.ChooseDirection(System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered direction of execution for the sequence given
            the randomly chosen direction is supplied; 0: execute left operand first, 1: execute right operand first
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly.ChooseSequence(System.Int32,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.Sequence},de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered sequence to execute next for the sequence given
            the randomly chosen sequence is supplied; the object with all available sequences is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly.ChooseMatch(System.Int32,de.unika.ipd.grGen.libGr.IMatches,System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered match to apply next for the sequence given
            the randomly chosen match is supplied; the object with all available matches is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly.ChooseRandomNumber(System.Int32,System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered random number in the range 0 - upperBound exclusive for the sequence given
            the random number chosen is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExecutionEnvironmentNamedGraphOnly.ChooseValue(System.String,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns a user chosen/input value of the given type
            no random input value is supplied, the user must give a value
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.NamedGraph">
            <summary>
            An attributed, typed and directed multigraph with multiple inheritance on node and edge types
            and uniquely named elements. This class is a wrapper for an unnamed graph adding names.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraph">
            <summary>
            An attributed, typed and directed multigraph with multiple inheritance on node and edge types.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.DestroyGraph">
            <summary>
            For persistent backends permanently destroys the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.LoadActions(System.String)">
            <summary>
            Loads a BaseActions instance from the given file.
            If the file is a ".cs" file it will be compiled first.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddNode(de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds an existing INode object to the graph and assigns it to the given variable.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds an existing INode object to the graph.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String)">
            <summary>
            Adds a new node to the graph and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String)">
            <summary>
            Adds an existing IEdge object to the graph and assigns it to the given variable.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Adds an existing IEdge object to the graph.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds a new edge to the graph and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds a new edge to the graph.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Remove(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes the given node from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Remove(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Removes the given edge from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.RemoveEdges(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes all edges from the given node.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Clear">
            <summary>
            Removes all nodes and edges (including any variables pointing to them) from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Retype(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Retypes a node by creating a new node of the given type.
            All adjacent edges as well as all attributes from common super classes are kept.
            </summary>
            <param name="node">The node to be retyped.</param>
            <param name="newNodeType">The new type for the node.</param>
            <returns>The new node object representing the retyped node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Retype(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Retypes an edge by creating a new edge of the given type.
            Source and target node as well as all attributes from common super classes are kept.
            </summary>
            <param name="edge">The edge to be retyped.</param>
            <param name="newEdgeType">The new type for the edge.</param>
            <returns>The new edge object representing the retyped edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Mature">
            <summary>
            Mature a graph.
            This method should be invoked after adding all nodes and edges to the graph.
            The backend may implement analyses on the graph to speed up matching etc.
            The graph may not be modified by this function.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Custom(System.Object[])">
            <summary>
            Does graph-backend dependent stuff.
            </summary>
            <param name="args">Any kind of paramteres for the stuff to do</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Clone(System.String)">
            <summary>
            Duplicates a graph.
            The new graph will use the same model and backend as the other.
            The open transactions will NOT be cloned.
            </summary>
            <param name="newName">Name of the new graph.</param>
            <returns>A new graph with the same structure as this graph.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AllocateVisitedFlag">
            <summary>
            Allocates a clean visited flag on the graph elements.
            If needed the flag is cleared on all graph elements, so this is an O(n) operation.
            </summary>
            <returns>A visitor ID to be used in
            visited conditions in patterns ("if { !visited(elem, id); }"),
            visited expressions in evals ("visited(elem, id) = true; b.flag = visited(elem, id) || c.flag; "}
            and calls to other visitor functions.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.FreeVisitedFlag(System.Int32)">
            <summary>
            Frees a visited flag.
            This is an O(1) operation.
            </summary>
            <param name="visitorID">The ID of the visited flag to be freed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ResetVisitedFlag(System.Int32)">
            <summary>
            Resets the visited flag with the given ID on all graph elements, if necessary.
            </summary>
            <param name="visitorID">The ID of the visited flag.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.SetVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32,System.Boolean)">
            <summary>
            Sets the visited flag of the given graph element.
            </summary>
            <param name="elem">The graph element whose flag is to be set.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <param name="visited">True for visited, false for not visited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.IsVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32)">
            <summary>
            Returns whether the given graph element has been visited.
            </summary>
            <param name="elem">The graph element to be examined.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <returns>True for visited, false for not visited.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetElementName(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns the name for the given element,
            i.e. the name defined by the named graph if a named graph is available,
            or a hash value string if only a lgpsGraph is available.
            </summary>
            <param name="elem">Element of which the name is to be found</param>
            <returns>The name of the given element</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetElementVariables(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns a linked list of variables mapping to the given graph element
            or null, if no variable points to this element
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetVariableValue(System.String)">
            <summary>
            Retrieves the object for a variable name or null, if the variable isn't set yet or anymore
            </summary>
            <param name="varName">The variable name to lookup</param>
            <returns>The according object or null</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNodeVarValue(System.String)">
            <summary>
            Retrieves the INode for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an INode object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetEdgeVarValue(System.String)">
            <summary>
            Retrieves the IEdge for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an IEdge object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.SetVariableValue(System.String,System.Object)">
            <summary>
            Sets the value of the given variable to the given value.
            If the variable name is null, this function does nothing.
            If elem is null, the variable is unset.
            </summary>
            <param name="varName">The name of the variable</param>
            <param name="val">The new value of the variable</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Retrieves the newest version of an IAction object currently available for this graph.
            This may be the given object.
            </summary>
            <param name="action">The IAction object.</param>
            <returns>The newest version of the given action.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.SetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction,de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Sets the newest action version for a static action.
            </summary>
            <param name="staticAction">The original action generated by GrGen.exe.</param>
            <param name="newAction">A new action instance.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Replace(de.unika.ipd.grGen.libGr.IMatches,System.Int32)">
            <summary>
            Executes the modifications of the according rule to the given match/matches.
            Fires OnRewritingNextMatch events before each rewrite except for the first one.
            </summary>
            <param name="matches">The matches object returned by a previous matcher call.</param>
            <param name="which">The index of the match in the matches object to be applied,
            or -1, if all matches are to be applied.</param>
            <returns>A possibly empty array of objects returned by the last applied rewrite.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ApplyRewrite(de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Apply a rewrite rule.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule invocation</param>
            <param name="which">The index of the match to be rewritten or -1 to rewrite all matches</param>
            <param name="localMaxMatches">Specifies the maximum number of matches to be found (if less or equal 0 the number of matches
            depends on MaxMatches)</param>
            <param name="special">Specifies whether the %-modifier has been used for this rule, which may have a special meaning for
            the application</param>
            <param name="test">If true, no rewrite step is performed.</param>
            <returns>The number of matches found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Apply a graph rewrite sequence.
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Apply a graph rewrite sequence.
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ChangingNodeAttribute(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingNodeAttribute event.
            To be called before changing an attribute of a node,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="node">The node whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ChangingEdgeAttribute(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingEdgeAttribute event.
            To be called before changing an attribute of an edge,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="edge">The edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Matched(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnMatched event.
            </summary>
            <param name="matches">The IMatches object returned by the matcher.</param>
            <param name="special">Whether this is a 'special' match (user defined).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Finishing(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinishing event.
            </summary>
            <param name="matches">The IMatches object returned by the matcher.</param>
            <param name="special">Whether this is a 'special' match (user defined).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.RewritingNextMatch">
            <summary>
            Fires an OnRewritingNextMatch event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Finished(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinished event.
            </summary>
            <param name="matches">The IMatches object returned by the matcher. The elements may be invalid.</param>
            <param name="special">Whether this is a 'special' match (user defined).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.EnteringSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnEnteringSequence event.
            </summary>
            <param name="seq">The sequence to be entered.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ExitingSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnExitingSequence event.
            </summary>
            <param name="seq">The sequence to be exited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Validate(System.Boolean,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.ConnectionAssertionError}@)">
            <summary>
            Checks whether a graph meets the connection assertions.
            In strict mode all occuring connections must be specified
            by a connection assertion.
            </summary>
            <param name="strict">If false, only check for specified assertions,
            otherwise it isn an error, if an edge connects nodes without a
            specified connection assertion.</param>
            <param name="errors">If the graph is not valid, this refers to a List of ConnectionAssertionError objects, otherwise it is null.</param>
            <returns>True, if the graph is valid.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.DumpMatch(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.DumpMatchSpecial)">
            <summary>
            Dumps one or more matches with a given graph dumper.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
            <param name="matches">An IMatches object containing the matches.</param>
            <param name="which">Which match to dump, or AllMatches for dumping all matches
            adding connections between them, or OnlyMatches to dump the matches only</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Dump(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo)">
            <summary>
            Dumps the graph with a given graph dumper.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Dump(de.unika.ipd.grGen.libGr.IDumper)">
            <summary>
            Dumps the graph with a given graph dumper and default dump style.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Name">
            <summary>
            A name associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Model">
            <summary>
            The model associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Actions">
            <summary>
            A currently associated actions object.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.TransactionManager">
            <summary>
            Returns the graph's transaction manager.
            For attribute changes using the transaction manager is the only way to include such changes in the transaction history!
            Don't forget to call Commit after a transaction is finished!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.PerformanceInfo">
            <summary>
            If PerformanceInfo is non-null, this object is used to accumulate information about time, found matches and applied rewrites.
            By default it should be null.
            The user is responsible for resetting the PerformanceInfo object.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.EmitWriter">
            <summary>
            The writer used by emit statements. By default this is Console.Out.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.MaxMatches">
            <summary>
            The maximum number of matches to be returned for a RuleAll sequence element.
            If it is zero or less, the number of matches is unlimited.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.ReuseOptimization">
            <summary>
            If true (the default case), elements deleted during a rewrite
            may be reused in the same rewrite.
            As a result new elements may not be discriminable anymore from
            already deleted elements using object equality, hash maps, etc.
            In cases where this is needed this optimization should be disabled.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.NumNodes">
            <summary>
            The total number of nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.NumEdges">
            <summary>
            The total number of edges in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Nodes">
            <summary>
            Enumerates all nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Edges">
            <summary>
            Enumerates all edges in the graph.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnNodeAdded">
            <summary>
            Fired after a node has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnEdgeAdded">
            <summary>
            Fired after an edge has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRemovingNode">
            <summary>
            Fired before a node is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRemovingEdge">
            <summary>
            Fired before an edge is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRemovingEdges">
            <summary>
            Fired before all edges of a node are deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnClearingGraph">
            <summary>
            Fired before the whole graph is cleared
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnChangingNodeAttribute">
            <summary>
            Fired before an attribute of a node is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function 
            and want the event to be fired, you have to fire it yourself
            using ChangingNodeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnChangingEdgeAttribute">
            <summary>
            Fired before an attribute of an edge is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function 
            and want the event to be fired, you have to fire it yourself
            using ChangingEdgeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRetypingNode">
            <summary>
            Fired before the type of a node is changed.
            Old and new type and attributes are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRetypingEdge">
            <summary>
            Fired before the type of an edge is changed.
            Old and new type and attributes are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnSettingAddedNodeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the nodes added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnSettingAddedEdgeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the edges added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnMatched">
            <summary>
            Fired after all requested matches of a rule have been matched.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnFinishing">
            <summary>
            Fired before the rewrite step of a rule, when at least one match has been found.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRewritingNextMatch">
            <summary>
            Fired before the next match is rewritten. It is not fired before rewriting the first match.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnFinished">
            <summary>
            Fired after the rewrite step of a rule.
            Note, that the given matches object may contain invalid entries,
            as parts of the match may have been deleted!
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnEntereringSequence">
            <summary>
            Fired when a sequence is entered.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnExitingSequence">
            <summary>
            Fired when a sequence is left.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.#ctor(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Initializes the name maps with anonymous names in the form "$" + GetNextName()
            </summary>
            <param name="somegraph">The graph to be used named</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.#ctor(de.unika.ipd.grGen.libGr.IGraph,System.String)">
            <summary>
            Initializes the name maps with the names provided in a given attribute each graph element must have
            </summary>
            <param name="somegraph">The graph to be used named</param>
            <param name="nameAttributeName">The name of the attribute</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.SetElementName(de.unika.ipd.grGen.libGr.IGraphElement,System.String)">
            <summary>
            Sets the name for a graph element. Any previous name will be overwritten.
            </summary>
            <param name="elem">The graph element to be named.</param>
            <param name="name">The new name for the graph element.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.SetElementPrefixName(de.unika.ipd.grGen.libGr.IGraphElement,System.String)">
            <summary>
            Sets a name of the form prefix + number for the graph element,
            with number being the first number from 0 on yielding an element name not already available in the graph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.DifferentElementWithName(de.unika.ipd.grGen.libGr.IGraphElement,System.String)">
            <summary>
            returns whether another element than the one given already bears the name
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetElementName(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns the name for the given element,
            i.e. the name defined by the named graph if a named graph is available,
            or a hash value string if only a lgpsGraph is available.
            </summary>
            <param name="elem">Element of which the name is to be found</param>
            <returns>The name of the given element</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetGraphElement(System.String)">
            <summary>
            Gets the graph element for a given name.
            </summary>
            <param name="name">The name of a graph element.</param>
            <returns>The graph element for the given name or null, if there is no graph element with this name.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddElemName(de.unika.ipd.grGen.libGr.IGraphElement,System.String)">
            <summary>
            Tries to set the name of an element.
            If the name is already used by another element, the element is removed from the graph and
            an ArgumentException is thrown.
            </summary>
            <param name="elem"></param>
            <param name="name"></param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddNode(de.unika.ipd.grGen.libGr.INode,System.String,System.String)">
            <summary>
            Adds an existing node to the graph, names it, and assigns it to the given variable.
            </summary>
            <param name="node">The existing node.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the new node or null if it is to be auto-generated.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String,System.String)">
            <summary>
            Adds a new named node to the graph and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the new node or null if it is to be auto-generated.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddNode(de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds an existing INode object to the graph and assigns it to the given variable.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds an existing INode object to the graph.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String)">
            <summary>
            Adds a new node to the graph and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String,System.String)">
            <summary>
            Adds an existing edge to the graph, names it, and assigns it to the given variable.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the edge or null if it is to be auto-generated.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.String)">
            <summary>
            Adds a new named edge to the graph and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the edge or null if it is to be auto-generated.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String)">
            <summary>
            Adds an existing IEdge object to the graph and assigns it to the given variable.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Adds an existing IEdge object to the graph.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds a new edge to the graph and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds a new edge to the graph.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Remove(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes the given node from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Remove(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Removes the given edge from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.RemoveEdges(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes all edges from the given node.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Clear">
            <summary>
            Removes all nodes and edges (including any variables pointing to them) from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.DestroyGraph">
            <summary>
            For persistent backends permanently destroys the graph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.LoadActions(System.String)">
            <summary>
            Loads a BaseActions instance from the given file.
            If the file is a ".cs" file it will be compiled first.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetNumExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetNumExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetNumCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetNumCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Retype(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Retypes a node by creating a new node of the given type.
            All adjacent edges as well as all attributes from common super classes are kept.
            </summary>
            <param name="node">The node to be retyped.</param>
            <param name="newNodeType">The new type for the node.</param>
            <returns>The new node object representing the retyped node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Retype(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Retypes an edge by creating a new edge of the given type.
            Source and target node as well as all attributes from common super classes are kept.
            </summary>
            <param name="edge">The edge to be retyped.</param>
            <param name="newEdgeType">The new type for the edge.</param>
            <returns>The new edge object representing the retyped edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Mature">
            <summary>
            Mature a graph.
            This method should be invoked after adding all nodes and edges to the graph.
            The backend may implement analyses on the graph to speed up matching etc.
            The graph may not be modified by this function.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Custom(System.Object[])">
            <summary>
            Does graph-backend dependent stuff.
            </summary>
            <param name="args">Any kind of paramteres for the stuff to do</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Clone(System.String)">
            <summary>
            Duplicates a graph.
            The new graph will use the same model and backend as the other.
            The open transactions will NOT be cloned.
            </summary>
            <param name="newName">Name of the new graph.</param>
            <returns>A new graph with the same structure as this graph.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.AllocateVisitedFlag">
            <summary>
            Allocates a clean visited flag on the graph elements.
            If needed the flag is cleared on all graph elements, so this is an O(n) operation.
            </summary>
            <returns>A visitor ID to be used in
            visited conditions in patterns ("if { !visited(elem, id); }"),
            visited expressions in evals ("visited(elem, id) = true; b.flag = visited(elem, id) || c.flag; "}
            and calls to other visitor functions.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.FreeVisitedFlag(System.Int32)">
            <summary>
            Frees a visited flag.
            This is an O(1) operation.
            </summary>
            <param name="visitorID">The ID of the visited flag to be freed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ResetVisitedFlag(System.Int32)">
            <summary>
            Resets the visited flag with the given ID on all graph elements, if necessary.
            </summary>
            <param name="visitorID">The ID of the visited flag.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.SetVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32,System.Boolean)">
            <summary>
            Sets the visited flag of the given graph element.
            </summary>
            <param name="elem">The graph element whose flag is to be set.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <param name="visited">True for visited, false for not visited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.IsVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32)">
            <summary>
            Returns whether the given graph element has been visited.
            </summary>
            <param name="elem">The graph element to be examined.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <returns>True for visited, false for not visited.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetElementVariables(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns a linked list of variables mapped to the given graph element
            or null, if no variable points to this element
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetVariableValue(System.String)">
            <summary>
            Retrieves the object for a variable name or null, if the variable isn't set yet or anymore
            </summary>
            <param name="varName">The variable name to lookup</param>
            <returns>The according object or null</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetNodeVarValue(System.String)">
            <summary>
            Retrieves the INode for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an INode object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetEdgeVarValue(System.String)">
            <summary>
            Retrieves the IEdge for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an IEdge object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.SetVariableValue(System.String,System.Object)">
            <summary>
            Sets the value of the given variable to the given object.
            If the variable name is null, this function does nothing
            If elem is null, the variable is unset
            </summary>
            <param name="varName">The name of the variable</param>
            <param name="val">The new value of the variable</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Replace(de.unika.ipd.grGen.libGr.IMatches,System.Int32)">
            <summary>
            Executes the modifications of the according rule to the given match/matches.
            Fires OnRewritingNextMatch events before each rewrite except for the first one.
            </summary>
            <param name="matches">The matches object returned by a previous matcher call.</param>
            <param name="which">The index of the match in the matches object to be applied,
            or -1, if all matches are to be applied.</param>
            <returns>A possibly empty array of objects returned by the last applied rewrite.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ApplyRewrite(de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Apply a rewrite rule.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule invocation</param>
            <param name="which">The index of the match to be rewritten or -1 to rewrite all matches</param>
            <param name="localMaxMatches">Specifies the maximum number of matches to be found (if less or equal 0 the number of matches
            depends on MaxMatches)</param>
            <param name="special">Specifies whether the %-modifier has been used for this rule, which may have a special meaning for
            the application</param>
            <param name="test">If true, no rewrite step is performed.</param>
            <returns>The number of matches found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Apply a graph rewrite sequence.
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Apply a graph rewrite sequence.
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <param name="env">The execution environment giving access to the names and user interface</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <param name="env">The execution environment giving access to the names and user interface</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.GetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Retrieves the newest version of an IAction object currently available for this graph.
            This may be the given object.
            </summary>
            <param name="action">The IAction object.</param>
            <returns>The newest version of the given action.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.SetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction,de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Sets the newest action version for a static action.
            </summary>
            <param name="staticAction">The original action generated by GrGen.exe.</param>
            <param name="newAction">A new action instance.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ChangingNodeAttribute(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingNodeAttribute event.
            To be called before changing an attribute of a node,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="node">The node whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ChangingEdgeAttribute(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingEdgeAttribute event.
            To be called before changing an attribute of an edge,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="edge">The edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Matched(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnMatched event.
            </summary>
            <param name="matches">The match result.</param>
            <param name="special">The "special" flag of this rule application.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Finishing(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinishing event.
            </summary>
            <param name="matches">The match result.</param>
            <param name="special">The "special" flag of this rule application.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.RewritingNextMatch">
            <summary>
            Fires an OnRewritingNextMatch event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Finished(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinished event.
            </summary>
            <param name="matches">The match result.</param>
            <param name="special">The "special" flag of this rule application.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.EnteringSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnEnteringSequence event.
            </summary>
            <param name="seq">The sequence which is entered.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.ExitingSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnExitingSequence event.
            </summary>
            <param name="seq">The sequence which is exited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Validate(System.Boolean,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.ConnectionAssertionError}@)">
            <summary>
            Checks whether a graph meets the connection assertions.
            In strict mode all occuring connections must be specified
            by a connection assertion.
            </summary>
            <param name="strict">If false, only check for specified assertions,
            otherwise it isn an error, if an edge connects nodes without a
            specified connection assertion.</param>
            <param name="errors">If the graph is not valid, this refers to a List of ConnectionAssertionError objects, otherwise it is null.</param>
            <returns>True, if the graph is valid.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.DumpMatch(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.DumpMatchSpecial)">
            <summary>
            Dumps one or more matches with a given graph dumper.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
            <param name="matches">An IMatches object containing the matches.</param>
            <param name="which">Which match to dump, or AllMatches for dumping all matches
            adding connections between them, or OnlyMatches to dump the matches only</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Dump(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo)">
            <summary>
            Dumps the graph with a given graph dumper.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NamedGraph.Dump(de.unika.ipd.grGen.libGr.IDumper)">
            <summary>
            Dumps the graph with a given graph dumper and default dump style.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.WrappedGraph">
            <summary>
            returns the (lgsp) graph this named graph is wrapping
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnNodeAdded">
            <summary>
            Fired after a node has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnEdgeAdded">
            <summary>
            Fired after an edge has been added
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.Name">
            <summary>
            A name associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.Model">
            <summary>
            The model associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.Actions">
            <summary>
            A currently associated actions object.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.TransactionManager">
            <summary>
            Returns the graph's transaction manager.
            For attribute changes using the transaction manager is the only way to include such changes in the transaction history!
            Don't forget to call Commit after a transaction is finished!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.PerformanceInfo">
            <summary>
            If PerformanceInfo is non-null, this object is used to accumulate information about time, found matches and applied rewrites.
            The user is responsible for resetting the PerformanceInfo object.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.EmitWriter">
            <summary>
            The writer used by emit statements. By default this is Console.Out.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.MaxMatches">
            <summary>
            The maximum number of matches to be returned for a RuleAll sequence element.
            If it is zero or less, the number of matches is unlimited.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.ReuseOptimization">
            <summary>
            If true (the default case), elements deleted during a rewrite
            may be reused in the same rewrite.
            As a result new elements may not be discriminable anymore from
            already deleted elements using object equality, hash maps, etc.
            In cases where this is needed this optimization should be disabled.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.NumNodes">
            <summary>
            The total number of nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.NumEdges">
            <summary>
            The total number of edges in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.Nodes">
            <summary>
            Enumerates all nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NamedGraph.Edges">
            <summary>
            Enumerates all edges in the graph.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnRemovingNode">
            <summary>
            Fired before a node is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnRemovingEdge">
            <summary>
            Fired before an edge is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnRemovingEdges">
            <summary>
            Fired before all edges of a node are deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnClearingGraph">
            <summary>
            Fired before the whole graph is cleared
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnChangingNodeAttribute">
            <summary>
            Fired before an attribute of a node is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function 
            and want the event to be fired, you have to fire it yourself
            using ChangingNodeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnChangingEdgeAttribute">
            <summary>
            Fired before an attribute of an edge is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function 
            and want the event to be fired, you have to fire it yourself
            using ChangingEdgeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnRetypingNode">
            <summary>
            Fired before the type of a node is changed.
            Old and new type and attributes are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnRetypingEdge">
            <summary>
            Fired before the type of an edge is changed.
            Old and new type and attributes are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnSettingAddedNodeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the nodes added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnSettingAddedEdgeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the edges added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnMatched">
            <summary>
            Fired after all requested matches of a rule have been matched.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnFinishing">
            <summary>
            Fired before the rewrite step of a rule, when at least one match has been found.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnRewritingNextMatch">
            <summary>
            Fired before the next match is rewritten. It is not fired before rewriting the first match.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnFinished">
            <summary>
            Fired after the rewrite step of a rule.
            Note, that the given matches object may contain invalid entries,
            as parts of the match may have been deleted!
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnEntereringSequence">
            <summary>
            Fired when a sequence is entered.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.NamedGraph.OnExitingSequence">
            <summary>
            Fired when a sequence is left.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GXLExport">
            <summary>
            Exports graphs to the GXL format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.String)">
            <summary>
            Exports the given graph to a GXL file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="exportFilename">The filename for the exported file.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.IO.TextWriter)">
            <summary>
            Exports the given graph in GXL format to the given text writer output stream.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="streamWriter">The stream writer to export to.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLExport.GetDomainID(de.unika.ipd.grGen.libGr.AttributeKind,de.unika.ipd.grGen.libGr.EnumAttributeType)">
            <summary>
            Returns the domain ID for the given attribute type.
            </summary>
            <param name="kind">The attribute kind</param>
            <param name="enumAttrType">For enums, enumAttrType must be valid. Otherwise it may be null.</param>
            <returns></returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ECoreImport">
            <summary>
            Imports a graph model from the ECore format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ECoreImport.Import(de.unika.ipd.grGen.libGr.IBackend,System.Collections.Generic.List{System.String},System.String,System.String,System.Boolean)">
            <summary>
            Creates a new graph from the given ECore metamodels.
            If a grg file is given, the graph will use the graph model declared in it and the according
            actions object will be associated to the graph.
            If a xmi file is given, the model instance will be imported into the graph.
            Any errors will be reported by exception.
            </summary>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="ecoreFilenames">A list of ECore model specification files. It must at least contain one element.</param>
            <param name="grgFilename">A grg file to be used to create the graph, or null.</param>
            <param name="xmiFilename">The filename of the model instance to be imported, or null.</param>
            <param name="noPackageNamePrefix">Prefix the types with the name of the package? Can only be used if names from the packages are disjoint.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IDumper">
            <summary>
            A dumper for output of graphs.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.DumpNode(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Dump a node.
            </summary>
            <param name="node">The node to be dumped</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="nodeColor">The color of the node</param>
            <param name="borderColor">The color of the node border</param>
            <param name="nodeShape">The shape of the node</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.DumpEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrLineStyle)">
            <summary>
            Dump an edge
            </summary>
            <param name="srcNode">The source node of the edge</param>
            <param name="tgtNode">The target node of the edge</param>
            <param name="label">The label of the edge, may be null</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="edgeColor">The color of the edge</param>
            <param name="lineStyle">The linestyle of the edge</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.StartSubgraph(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Creates a new sub-graph
            </summary>
            <param name="node">The node starting the new sub-graph</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="subgraphColor">The color of the subgraph node</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.FinishSubgraph">
            <summary>
            Finishes a subgraph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.FinishDump">
            <summary>
            Finishes the dump and closes the file
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GroupMode">
            <summary>
            The supported group modes.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.None">
            <summary>
            Do not group any nodes.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.GroupIncomingNodes">
            <summary>
            Group only source nodes of incoming edges of the group node.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.GroupOutgoingNodes">
            <summary>
            Group only target nodes of outgoing edges of the group node.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.GroupAllNodes">
            <summary>
            Group all nodes connected to the group node.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.Hidden">
            <summary>
            Hide the grouping edges in visualizations of the graph.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GroupNodeType">
            <summary>
            Specifies which nodes are grouped by this group node type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupNodeType.NodeType">
            <summary>
            The node type of this group node type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupNodeType.Priority">
            <summary>
            Groups with lower priorities can be grouped inside groups with higher priorities.
            For same priorities the behaviour is undefined.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.#ctor(de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Initializes a GroupNodeType.
            </summary>
            <param name="nodeType">The node type of this group node type.</param>
            <param name="priority">The priority to be used, when two group node types apply to one edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.GetEdgeGroupMode(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Gets the group mode for this group node with an edge of type edgeType connected to a node of type adjNodeType.
            </summary>
            <param name="edgeType">The type of an edge connected to the group node.</param>
            <param name="adjNodeType">The type of a node connected to the group node.</param>
            <returns>The group mode for this case. Default is GroupMode.None.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.SetEdgeGroupMode(de.unika.ipd.grGen.libGr.EdgeType,System.Boolean,de.unika.ipd.grGen.libGr.NodeType,System.Boolean,de.unika.ipd.grGen.libGr.GroupMode)">
            <summary>
            Sets the group mode for the given case. Inheritance is handled as specified by the parameters.
            </summary>
            <param name="edgeType">The type of an edge connected to the group node.</param>
            <param name="exactEdgeType">Specifies, whether only the exact given edge type is meant.</param>
            <param name="adjNodeType">The type of a node connected to the group node.</param>
            <param name="exactAdjNodeType">Specifies, whether only the exact given node type is meant.</param>
            <param name="groupMode">The group mode to be applied.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.CompareTo(de.unika.ipd.grGen.libGr.GroupNodeType)">
            <summary>
            Compares this group node type to another given one.
            </summary>
            <param name="other">The other group node type.</param>
            <returns>Priority - other.Priority</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupNodeType.groupEdges">
            <summary>
            A map from EdgeTypes to NodeTypes to a GroupMode, specifying which connected nodes are grouped into this node.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GroupNodeType.GroupEdges">
            <summary>
            Enumerates all definitions related to this group node type.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.InfoTag">
            <summary>
            Represents an info tag.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InfoTag.AttributeType">
            <summary>
            The attribute to be shown.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InfoTag.ShortInfoTag">
            <summary>
            Whether this is a short info tag (no attribute name is shown).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.InfoTag.#ctor(de.unika.ipd.grGen.libGr.AttributeType,System.Boolean)">
            <summary>
            Initializes an info tag.
            </summary>
            <param name="attrType">The attribute to be shown.</param>
            <param name="shortInfoTag">Whether this is a short info tag (no attribute name is shown).</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DumpInfo">
            <summary>
            A description of how to dump a graph.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DumpInfo.nextGroupID">
            <summary>
            Used as priorities for GroupNodeType objects.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.SetElemTypeLabel(de.unika.ipd.grGen.libGr.GrGenType,System.String)">
            <summary>
            Sets the labels of the given element type.
            null is the default case, which is "&lt;elemname&gt;:&lt;type&gt;".
            </summary>
            <param name="type">The element type.</param>
            <param name="label">The label or null for the default case.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetElemTypeLabel(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Returns the label of the given element type or null for the default case.
            </summary>
            <param name="type">The element type.</param>
            <returns>The label or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.AddOrExtendGroupNodeType(de.unika.ipd.grGen.libGr.NodeType,System.Boolean,de.unika.ipd.grGen.libGr.EdgeType,System.Boolean,de.unika.ipd.grGen.libGr.NodeType,System.Boolean,de.unika.ipd.grGen.libGr.GroupMode)">
            <summary>
            Adds or extends a GroupNodeType.
            All nodes connected via the given edge type and fulfilling the GroupType condition are placed inside a group
            corresponding to the according group node. The edges which lead to the grouping are not displayed.
            The group node types are ordered by the time of creation. Groups of group node types created later
            will be moved into groups of group node types created earlier.
            </summary>
            <param name="nodeType">The node type of the group node.</param>
            <param name="exactNodeType">True, if the node type must be exact, false, if also subtypes are allowed.</param>
            <param name="edgeType">An edge type along which nodes are grouped.</param>
            <param name="exactEdgeType">True, if the edge type must be exact, false, if also subtypes are allowed.</param>
            <param name="adjNodeType">The adjacent node type according to the edge.</param>
            <param name="exactAdjNodeType">True, if the adjacent node type must be exact, false, if also subtypes are allowed.</param>
            <param name="groupMode">Specifies how the edge is used for grouping.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetGroupNodeType(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Gets the GroupNodeType for a given node type.
            </summary>
            <param name="nodeType">The given node type.</param>
            <returns>The GroupNodeType of the given node type or null, if it is not a group node type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetTypeInfoTags(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Returns a list of InfoTag objects for the given GrGenType or null.
            </summary>
            <param name="type">The GrGenType to be examined.</param>
            <returns>A list of associated InfoTag objects or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.AddTypeInfoTag(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.InfoTag)">
            <summary>
            Associates an InfoTag to a GrGenType.
            </summary>
            <param name="type">The GrGenType to given an InfoTag</param>
            <param name="infotag">The InfoTag</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetTypeInfoTag(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Returns an info tag with the given AttributeType registered for the given element type or null.
            </summary>
            <param name="type">The element type.</param>
            <param name="attrType">The attribute type.</param>
            <returns>The info tag or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetElementName(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Gets the element name of the given graph element according
            to the element name getter given to the constructor of DumpInfo.
            </summary>
            <param name="elem">The element.</param>
            <returns>The name of the element.</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.LexicalError">
            Lexical error occured.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.StaticLexerError">
            An attempt wass made to create a second instance of a static token manager.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.InvalidLexicalState">
            Tried to change to an invalid lexical state.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.LoopDetected">
            Detected (and bailed out of) an infinite loop in the token manager.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.errorCode">
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.AddEscapes(System.String)">
            Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.GetLexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            Returns a detailed message for the Exception when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
               EOFSeen     : indicates if EOF caused the lexicl error
               curLexState : lexical state in which this error occured
               errorLine   : line number when the error occured
               errorColumn : column number when the error occured
               errorAfter  : prefix that was seen before this error occured
               curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.Message">
             You can also modify the body of this method to customize your error messages.
             For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
             of end-users concern, so you can return something like : 
            
                 "Internal Error : Please file a bug report .... "
            
             from this method for such cases in the release version of your parser.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.porter.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.porter.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            </summary>
            <remarks>
            You can explicitly create objects of this exception type by
            calling the method GenerateParseException in the generated
            parser.
            <para>
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </para>
            </remarks>
        </member>
        <!-- Ungltiger XML-Kommentar wurde fr den Member "M:de.unika.ipd.grGen.libGr.porter.ParseException.#ctor(de.unika.ipd.grGen.libGr.porter.Token,System.Int32[][],System.String[])" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.porter.ParseException.#ctor">
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.ParseException.specialConstructor">
            This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.ParseException.currentToken">
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.ParseException.expectedTokenSequences">
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.ParseException.tokenImage">
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.ParseException.eol">
            The end of line string for this machine.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.ParseException.AddEscapes(System.String)">
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.porter.ParseException.Message">
            This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Variable">
            <summary>
            A named graph-global variable.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Variable.Name">
            <summary>
            The name of the variable.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Variable.Value">
            <summary>
            The value pointed to by the variable.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Variable.#ctor(System.String,System.Object)">
            <summary>
            Initializes a Variable instance.
            </summary>
            <param name="name">The name of the variable.</param>
            <param name="value">The value pointed to by the variable.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeChangeType">
            <summary>
            The changes which might occur to graph element attributes.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.Assign">
            <summary>
            Assignment of a value to some attribute.
            Value semantics, even if assigned attribute is a set or a map, not a primitive type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.PutElement">
            <summary>
            Inserting a value into some set or a key value pair into some map.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.RemoveElement">
            <summary>
            Removing a value from some set or a key value pair from some map.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ITransactionManager">
            <summary>
            An interface for managing graph transactions.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.StartTransaction">
            <summary>
            Starts a transaction
            </summary>
            <returns>A transaction ID to be used with Commit or Rollback</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Commit(System.Int32)">
            <summary>
            Removes the rollback data and stops this transaction
            </summary>
            <param name="transactionID">Transaction ID returned by a StartTransaction call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Rollback(System.Int32)">
            <summary>
            Undoes all changes during a transaction
            </summary>
            <param name="transactionID">The ID of the transaction to be rollbacked</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.ElementAdded(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Event handler for IGraph.OnNodeAdded and IGraph.OnEdgeAdded.
            </summary>
            <param name="elem">The added element.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.RemovingElement(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Event handler for IGraph.OnRemovingNode and IGraph.OnRemovingEdge.
            </summary>
            <param name="elem">The element to be deleted.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.ChangingElementAttribute(de.unika.ipd.grGen.libGr.IGraphElement,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Event handler for IGraph.OnChangingNodeAttribute and IGraph.OnChangingEdgeAttribute.
            </summary>
            <param name="elem">The element whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.RetypingElement(de.unika.ipd.grGen.libGr.IGraphElement,de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Event handler for IGraph.OnRetypingNode and IGraph.OnRetypingEdge.
            </summary>
            <param name="oldElem">The element to be retyped.</param>
            <param name="newElem">The new element with the common attributes, but without the correct connections, yet.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITransactionManager.TransactionActive">
            <summary>
            Indicates, whether a transaction is currently active.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.NodeAddedHandler">
            <summary>
            Represents a method called, when a node has been added.
            </summary>
            <param name="node">The added node.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EdgeAddedHandler">
            <summary>
            Represents a method called, when an edge has been added.
            </summary>
            <param name="edge">The added edge.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RemovingNodeHandler">
            <summary>
            Represents a method called before a node is removed.
            </summary>
            <param name="node">The node to be removed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RemovingEdgeHandler">
            <summary>
            Represents a method called before a edge is removed.
            </summary>
            <param name="edge">The edge to be removed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RemovingEdgesHandler">
            <summary>
            Represents a method called before all edges of a node are removed.
            </summary>
            <param name="node">The node whose edges are to be removed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ClearingGraphHandler">
            <summary>
            Represents a method called before a graph is cleared.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ChangingNodeAttributeHandler">
            <summary>
            Represents a method called just before a node attribute is changed,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="node">The node whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ChangingEdgeAttributeHandler">
            <summary>
            Represents a method called just before an edge attribute is changed,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="edge">The edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RetypingNodeHandler">
            <summary>
            Represents a method called before a node is retyped.
            </summary>
            <param name="oldNode">The node to be retyped.</param>
            <param name="newNode">The new node with the common attributes, but without any adjacent edges assigned, yet.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RetypingEdgeHandler">
            <summary>
            Represents a method called before a edge is retyped.
            </summary>
            <param name="oldEdge">The edge to be retyped.</param>
            <param name="newEdge">The new edge with the common attributes, but not fully connected with the adjacent nodes, yet.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SettingAddedElementNamesHandler">
            <summary>
            Delegate-type called shortly before elements are added to the graph, with the names of the elements added.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AfterMatchHandler">
            <summary>
            Represents a method called after all requested matches of an action have been matched.
            </summary>
            <param name="matches">The matches found.</param>
            <param name="special">Specifies whether the "special" flag has been used.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BeforeFinishHandler">
            <summary>
            Represents a method called before the rewrite step of an action, when at least one match has been found.
            </summary>
            <param name="matches">The matches found.</param>
            <param name="special">Specifies whether the "special" flag has been used.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RewriteNextMatchHandler">
            <summary>
            Represents a method called during rewriting a set of matches before the next match is rewritten.
            It is not fired before rewriting the first match.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AfterFinishHandler">
            <summary>
            Represents a method called after the rewrite step of a rule.
            </summary>
            <param name="matches">The matches found.
            This may contain invalid entries, because parts of the matches may have been deleted.</param>
            <param name="special">Specifies whether the "special" flag has been used.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EnterSequenceHandler">
            <summary>
            Represents a method called directly after a sequence has been entered.
            </summary>
            <param name="seq">The current sequence object.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ExitSequenceHandler">
            <summary>
            Represents a method called before a sequence is left.
            </summary>
            <param name="seq">The current sequence object.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.kind">
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.cs.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.beginLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.beginColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.endLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.endColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.image">
            The string image of the token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.next">
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.specialToken">
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.Token.ToString">
            Returns the image.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.Token.NewToken(System.Int32)">
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simlpy add something like :
            
                case MyParserConstants.ID : return new IDToken();
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use it in your lexical actions.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GXLImport">
            <summary>
            Imports graphs from the GXL format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.String,System.String,de.unika.ipd.grGen.libGr.IBackend)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from a GXL file
            with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="modelOverride">If not null, overrides the filename of the graph model to be used.</param>
            <param name="backend">The backend to use to create the graph.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.IO.TextReader,System.String,de.unika.ipd.grGen.libGr.IBackend)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="inStream">The text reader input stream import source.</param>
            <param name="modelOverride">If not null, overrides the filename of the graph model to be used.</param>
            <param name="backend">The backend to use to create the graph.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from a GXL file
            with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported,
                the model specification part will be ignored.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.IO.TextReader,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="inStream">The text reader input stream import source.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ProcessSpecFlags">
            <summary>
            Flags which determine, how the specification file should be processed.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseNoExistingFiles">
            <summary>
            Do not use existing files.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseJavaGeneratedFiles">
            <summary>
            Only use existing C# files generated by the Java frontend.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseAllGeneratedFiles">
            <summary>
            Use all existing C# files.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseExistingMask">
            <summary>
            Mask for flags specifying whether and how already existing C# files shall be used while processing a specification.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.KeepGeneratedFiles">
            <summary>
            Do not delete generated C# files.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.CompileWithDebug">
            <summary>
            Include debug information in the generated assemblies.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoProcessActions">
            <summary>
            Do not process intermediate actions file (stops after model has been processed).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoCreateActionsAssembly">
            <summary>
            Do not compile the generated final actions file.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoEvents">
            <summary>
            Do not fire any events in the generated code. Used for optimization.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoPerformanceInfoUpdates">
            <summary>
            Do not try to update the performance info object. Used for optimization.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IBackend">
            <summary>
            A helper class for backend independent graph and rule handling.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateGraph(de.unika.ipd.grGen.libGr.IGraphModel,System.String,System.String[])">
            <summary>
            Creates a new IGraph backend instance with the given graph model and name.
            </summary>
            <param name="graphModel">An IGraphModel instance.</param>
            <param name="graphName">Name of the graph.</param>
            <param name="parameters">Backend specific parameters.</param>
            <returns>The new IGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateGraph(System.String,System.String,System.String[])">
            <summary>
            Creates a new IGraph backend instance with the graph model provided by the graph model file and a name.
            </summary>
            <param name="modelFilename">Filename of a graph model file.</param>
            <param name="graphName">Name of the graph.</param>
            <param name="parameters">Backend specific parameters.</param>
            <returns>The new IGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateFromSpec(System.String,System.String,de.unika.ipd.grGen.libGr.IGraph@,de.unika.ipd.grGen.libGr.BaseActions@)">
            <summary>
            Creates a new IGraph and BaseActions backend instance from the specified specification file.
            If neccessary, any processing steps are performed automatically.
            </summary>
            <param name="grgFilename">Filename of the rule specification file (.grg).</param>
            <param name="graphName">Name of the new graph.</param>
            <param name="newGraph">Returns the new graph.</param>
            <param name="newActions">Returns the new BaseActions object.</param>
            <exception cref="T:System.Exception">Thrown when something goes wrong.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateFromSpec(System.String,System.String)">
            <summary>
            Creates a new IGraph instance from the specified specification file.
            If the according dll does not exist or is out of date, the needed processing steps are performed automatically.
            </summary>
            <param name="gmFilename">Filename of the model specification file (.gm).</param>
            <param name="graphName">Name of the new graph.</param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown, when a needed specification file does not exist.</exception>
            <exception cref="T:System.Exception">Thrown, when something goes wrong.</exception>
            <returns>The new IGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.OpenGraph(System.String,System.String,System.String[])">
            <summary>
            Opens an existing graph identified by graphName using the specified IGraphModel.
            This may not be supported by the backend, if the data is not persistent.
            </summary>
            <param name="modelFilename">Filename of a graph model file</param>
            <param name="graphName">Name of an existing graph</param>
            <param name="parameters">Backend specific parameters</param>
            <returns>The IGraph backend instance</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.ProcessSpecification(System.String,System.String,System.String,de.unika.ipd.grGen.libGr.ProcessSpecFlags)">
            <summary>
            Processes the given rule specification file and generates a model and actions library.
            </summary>
            <param name="specPath">The path to the rule specification file (.grg).</param>
            <param name="destDir">The directory, where the generated libraries are to be placed.</param>
            <param name="intermediateDir">A directory, where intermediate files can be placed.</param>
            <param name="flags">Specifies how the specification is to be processed.</param>
            <exception cref="T:System.Exception">Thrown, when an error occurred.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.ProcessSpecification(System.String)">
            <summary>
            Processes the given rule specification file and generates a model and actions library in the same directory as the specification file.
            </summary>
            <param name="specPath">The path to the rule specification file (.grg).</param>
            <exception cref="T:System.Exception">Thrown, when an error occurred.</exception>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IBackend.Name">
            <summary>
            The name of the backend.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IBackend.ArgumentNames">
            <summary>
            Enumerates the names of the arguments which can be optionally passed to the create/open functions.
            Not currently used...
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IBackend.ExistingGraphs">
            <summary>
            An enumerable of KeyValuePairs, where the keys are names of existing graphs and the
            values are the names of the appropriate models (not filenames).
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.porter.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.kind">
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.cs.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.beginLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.beginColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.endLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.endColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.image">
            The string image of the token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.next">
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.porter.Token.specialToken">
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.Token.ToString">
            Returns the image.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.Token.NewToken(System.Int32)">
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simlpy add something like :
            
                case MyParserConstants.ID : return new IDToken();
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use it in your lexical actions.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Porter">
            <summary>
            Import and export support for graphs.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.Export(de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{System.String})">
            <summary>
            Exports the given graph to a file with the given filename.
            The format is determined by the file extension. 
            Currently available are: .grs/.grsi or .gxl.
            Optionally suffixed by .gz; in this case they are saved gzipped.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. The .grs/.grsi exporter is capable of exporting a NamedGraph, i.e. including names.</param>
            <param name="filenameParameters">The names of the files to be exported.
            The first must be a filename, the following may be used for giving export parameters
            (in fact currently no exporter supports multiple files).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.Import(de.unika.ipd.grGen.libGr.IBackend,System.Collections.Generic.List{System.String})">
            <summary>
            Imports a graph from the given files.
            If the filenames only specify a model, the graph is empty.
            The format is determined by the file extensions.
            Currently available are: .grs/.grsi or .gxl or .ecore(/.xmi).
            Optionally suffixed by .gz; in this case they are expected to be gzipped.
            Any error will be reported by exception.
            </summary>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="filenameParameters">The names of the files to be imported.</param>
            <returns>The imported graph. 
            The .grs/.grsi importer returns a NamedGraph. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Imports a graph from the given file.
            The format is determined by the file extension.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported, 
                the model specification part will be ignored.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <returns>The imported graph. 
            The .grs/.grsi importer returns a NamedGraph. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.ListGet(System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            Returns the string at the given index, or null if the index is out of bounds.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ITypeModel">
            <summary>
            A type model for node or edge elements.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITypeModel.GetType(System.String)">
            <summary>
            Returns the element type with the given type name or null, if no type with this name exists.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.IsNodeModel">
            <summary>
            Specifies whether this type model is model for nodes (= true) or for edges (= false).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.RootType">
            <summary>
            The root type of this type model. All other types of this model inherit from the root type (in the GrGen model, not in C#).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.Types">
            <summary>
            An array of all types in this type model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.TypeTypes">
            <summary>
            An array of C# types of model types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.AttributeTypes">
            <summary>
            Enumerates all attribute types of this model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.INodeModel">
            <summary>
            A type model for nodes.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INodeModel.GetType(System.String)">
            <summary>
            Returns the element type with the given type name or null, if no type with this name exists.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INodeModel.RootType">
            <summary>
            The root type of this type model. All other types of this model inherit from the root type (in the GrGen model, not in C#).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INodeModel.Types">
            <summary>
            An array of all types in this type model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IEdgeModel">
            <summary>
            A type model for edges.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IEdgeModel.GetType(System.String)">
            <summary>
            Returns the element type with the given type name or null, if no type with this name exists.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdgeModel.RootType">
            <summary>
            The root type of this type model. All other types of this model inherit from the root type (in the GrGen model, not in C#).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdgeModel.Types">
            <summary>
            An array of all types in this type model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ValidateInfo">
            <summary>
            A representation of a GrGen connection assertion.
            Used by BaseGraph.Validate().
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.EdgeType">
            <summary>
            The edge type to which this constraint applies.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.SourceType">
            <summary>
            The node type to which applicable source nodes must be compatible.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.TargetType">
            <summary>
            The node type to which applicable target nodes must be compatible.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.SourceLower">
            <summary>
            The lower bound on the out-degree of the source node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.SourceUpper">
            <summary>
            The upper bound on the out-degree of the source node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.TargetLower">
            <summary>
            The lower bound on the in-degree of the target node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.TargetUpper">
            <summary>
            The upper bound on the in-degree of the target node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.BothDirections">
            <summary>
            Check the connection assertion in both directions (i.e. for reverse source and target, too)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ValidateInfo.#ctor(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.NodeType,System.Int64,System.Int64,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Constructs a ValidateInfo instance.
            </summary>
            <param name="edgeType">The edge type to which this constraint applies.</param>
            <param name="sourceType">The node type to which applicable source nodes must be compatible.</param>
            <param name="targetType">The node type to which applicable target nodes must be compatible.</param>
            <param name="sourceLower">The lower bound on the out-degree of the source node according to edges compatible to EdgeType.</param>
            <param name="sourceUpper">The upper bound on the out-degree of the source node according to edges compatible to EdgeType.</param>
            <param name="targetLower">The lower bound on the in-degree of the target node according to edges compatible to EdgeType.</param>
            <param name="targetUpper">The upper bound on the in-degree of the target node according to edges compatible to EdgeType.</param>
            <param name="bothDirections">Both directions are to be checked (undirected edge or arbitrary direction)</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.CAEType">
            <summary>
            Specifies the type of a connection assertion error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.EdgeNotSpecified">
            <summary>
            An edge was not specified.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooFewSources">
            <summary>
            A node has too few outgoing edges of some type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooManySources">
            <summary>
            A node has too many outgoing edges of some type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooFewTargets">
            <summary>
            A node has too few incoming edges of some type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooManyTargets">
            <summary>
            A node has too many incoming edges of some type.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ConnectionAssertionError">
            <summary>
            A description of an error, found during the validation process.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.CAEType">
            <summary>
            The type of error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.Elem">
            <summary>
            Specifies the graph element, where the error was found.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.FoundEdges">
            <summary>
            The number of edges found in the graph, if CAEType != CAEType.EdgeNotSpecified.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.ValidateInfo">
            <summary>
            The corresponding ValidatedInfo object, if CAEType != CAEType.EdgeNotSpecified.
            Otherwise it is null.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ConnectionAssertionError.#ctor(de.unika.ipd.grGen.libGr.CAEType,de.unika.ipd.grGen.libGr.IGraphElement,System.Int64,de.unika.ipd.grGen.libGr.ValidateInfo)">
            <summary>
            Initializes a ConnectionAssertionError instance.
            </summary>
            <param name="caeType">The type of error.</param>
            <param name="elem">The graph element, where the error was found.</param>
            <param name="found">The number of edges found in the graph, if CAEType != CAEType.EdgeNotSpecified.</param>
            <param name="valInfo">The corresponding ValidatedInfo object, if CAEType != CAEType.EdgeNotSpecified, otherwise null.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraphModel">
            <summary>
            A model of a GrGen graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.ModelName">
            <summary>
            The name of this model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.NodeModel">
            <summary>
            The model of the nodes.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.EdgeModel">
            <summary>
            The model of the edges.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.EnumAttributeTypes">
            <summary>
            Enumerates all enum attribute types declared for this model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.ValidateInfo">
            <summary>
            Enumerates all ValidateInfo objects describing constraints on the graph structure.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.MD5Hash">
            <summary>
            An MD5 hash sum of the model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeKind">
            <summary>
            Specifies the kind of a GrGen attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.IntegerAttr">
            <summary>The attribute is an integer.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.BooleanAttr">
            <summary>The attribute is a boolean.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.StringAttr">
            <summary>The attribute is a string.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.EnumAttr">
            <summary>The attribute is an enum.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.FloatAttr">
            <summary>The attribute is a float.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.DoubleAttr">
            <summary>The attribute is a double.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.ObjectAttr">
            <summary>The attribute is an object.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.MapAttr">
            <summary>The attribute is a map.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.SetAttr">
            <summary>The attribute is a set.</summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeType">
            <summary>
            Describes a GrGen attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.Name">
            <summary>
            The name of the attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.OwnerType">
            <summary>
            The model type owning this attribute, i.e. the type which defined this attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.Kind">
            <summary>
            The kind of the attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.EnumType">
            <summary>
            The enum type description, if Kind == AttributeKind.EnumAttr. Otherwise it is null.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.ValueType">
            <summary>
            The attribute type of the value of the set, if Kind == AttributeKind.SetAttr.
            The attribute type of the value of the map, if Kind == AttributeKind.MapAttr.
            Undefined otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.KeyType">
            <summary>
            The attribute type of the key of the map, if Kind == AttributeKind.MapAttr.
            Undefined otherwise.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AttributeType.#ctor(System.String,de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.AttributeKind,de.unika.ipd.grGen.libGr.EnumAttributeType,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Initializes an AttributeType instance.
            </summary>
            <param name="name">The name for the attribute.</param>
            <param name="ownerType">The owner model type.</param>
            <param name="kind">The kind of the attribute.</param>
            <param name="enumType">The enum type description, if Kind == AttributeKind.EnumAttr, otherwise null.</param>
            <param name="valueType">The attribute type of the value of the set, if Kind == AttributeKind.SetAttr; the attribute type of the value of the map, if Kind == AttributeKind.MapAttr; otherwise null. </param>
            <param name="keyType">The attribute type of the key of the map, if Kind == AttributeKind.MapAttr; otherwise null.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AttributeType.GetKindName(de.unika.ipd.grGen.libGr.AttributeKind)">
            <summary>
            Returns the name of the given basic attribute kind (not enum,set,map)
            </summary>
            <param name="attrKind">The AttributeKind value</param>
            <returns>The name of the attribute kind</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AttributeType.GetKindName">
            <summary>
            Returns the name of the kind
            </summary>
            <returns>The name of the kind of the attribute</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EnumMember">
            <summary>
            A description of a GrGen enum member.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumMember.Value">
            <summary>
            The integer value of the enum member.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumMember.Name">
            <summary>
            The name of the enum member.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EnumMember.#ctor(System.Int32,System.String)">
            <summary>
            Initializes an EnumMember instance.
            </summary>
            <param name="value">The value of the enum member.</param>
            <param name="name">The name of the enum member.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EnumAttributeType">
            <summary>
            A description of a GrGen enum type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumAttributeType.Name">
            <summary>
            The name of the enum type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumAttributeType.EnumType">
            <summary>
            The .NET type for the enum type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EnumAttributeType.#ctor(System.String,System.Type,de.unika.ipd.grGen.libGr.EnumMember[])">
            <summary>
            Initializes an EnumAttributeType instance.
            </summary>
            <param name="name">The name of the enum type.</param>
            <param name="enumType">The .NET type for the enum type.</param>
            <param name="memberArray">An array of all enum members.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EnumAttributeType.Members">
            <summary>
            Enumerates all enum members.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SetValueType">
            <summary>
            A dummy type used as value type for dictionaries representing sets.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GrGenType">
            <summary>
            A representation of a GrGen graph element type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.#ctor(System.Int32)">
            <summary>
            Initializes a GrGenType object.
            </summary>
            <param name="typeID">The type id for this GrGen type.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.TypeID">
            <summary>
            An identification number of the type, unique among all other types of the same kind (node/edge) in the owning type model.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.subOrSameGrGenTypes">
            <summary>
            Array containing this type first and following all sub types.
            </summary>
            <remarks>
            Must be assigned the same array as SubOrSameTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.directSubGrGenTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
            <remarks>
            Must be assigned the same array as DirectSubTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.superOrSameGrGenTypes">
            <summary>
            Array containing this type first and following all super types.
            </summary>
            <remarks>
            Must be assigned the same array as SubOrSameTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.directSuperGrGenTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
            <remarks>
            Must be assigned the same array as DirectSuperTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.GetAttributeType(System.String)">
            <summary>
            Returns an AttributeType object for the given attribute name.
            If this type does not have an attribute with this name, null is returned.
            </summary>
            <param name="name">Name of the attribute</param>
            <returns>The AttributeType matching the name, or null if there is no such</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.IsA(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether this type is compatible to the given type, i.e. this type is the same type as the given type
            or it is a sub type of the given type.
            </summary>
            <param name="other">The type to be compared to.</param>
            <returns>True, if this type is compatible to the given type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_LessThanOrEqual(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a super type of the second type or the types are the same.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if otherType is compatible to type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_GreaterThanOrEqual(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a sub type of the second type or the types are the same.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if type is compatible to otherType.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_LessThan(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a super type of the second type.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if type is a super type of otherType.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_GreaterThan(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a sub type of the second type.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if type is a sub type of otherType.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.ToString">
            <summary>
            Returns the name of the type.
            </summary>
            <returns>The name of the type.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SubOrSameTypes">
            <summary>
            Array containing this type first and following all sub types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.DirectSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SuperOrSameTypes">
            <summary>
            Array containing this type first and following all super types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SubTypes">
            <summary>
            Enumerates over all real subtypes of this type
            Warning: You should not use this property, but SubOrSameTypes starting from index 1,
                     because Enumerators in .NET are quite slow!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SuperTypes">
            <summary>
            Enumerates over all real supertypes of this type
            Warning: You should not use this property, but SuperOrSameTypes starting from index 1,
                     because Enumerators in .NET are quite slow!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.HasSuperTypes">
            <summary>
            True, if this type has any super types, i.e. if it is not the node/edge root type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.HasSubTypes">
            <summary>
            True, if this type has any sub types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.IsNodeType">
            <summary>
            True, if this type is a node type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.IsAbstract">
            <summary>
            True, if this type is an abstract element type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.IsConst">
            <summary>
            True, if this type is a const element type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.NumAttributes">
            <summary>
            The number of attributes of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.AttributeTypes">
            <summary>
            Enumerates all attribute types of this type.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.NodeType">
            <summary>
            A representation of a GrGen node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.#ctor(System.Int32)">
            <summary>
            Constructs a NodeType instance with the given type ID.
            </summary>
            <param name="typeID">The unique type ID.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.CreateNode">
            <summary>
            Creates an INode object according to this type.
            </summary>
            <returns>The created INode object.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.CreateNodeWithCopyCommons(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Creates an INode object according to this type and copies all
            common attributes from the given node.
            </summary>
            <param name="oldNode">The old node.</param>
            <returns>The created INode object.</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.subOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.directSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.superOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.directSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.IsNodeType">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.NodeInterfaceName">
            <summary>
            This NodeType describes nodes whose real .NET interface type is named as returned (fully qualified).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.NodeClassName">
            <summary>
            This NodeType describes nodes whose real .NET class type is named as returned (fully qualified).
            It might be null in case this type IsAbstract.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.SubOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.DirectSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.SuperOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Directedness">
            <summary>
            Specifies the kind of directedness for an EdgeType
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Directedness.Arbitrary">
            <summary>Arbitrary directed. Only for abstract edge types.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Directedness.Directed">
            <summary>Directed.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Directedness.Undirected">
            <summary>Undirected.</summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EdgeType">
            <summary>
            A representation of a GrGen edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.#ctor(System.Int32)">
            <summary>
            Constructs an EdgeType instance with the given type ID.
            </summary>
            <param name="typeID">The unique type ID.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.CreateEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Creates an IEdge object according to this type.
            </summary>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <returns>The created IEdge object.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.CreateEdgeWithCopyCommons(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Creates an IEdge object according to this type and copies all
            common attributes from the given edge.
            </summary>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="oldEdge">The old edge.</param>
            <returns>The created IEdge object.</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.subOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.directSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.superOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.directSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.IsNodeType">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.EdgeInterfaceName">
            <summary>
            This EdgeType describes edges whose real .NET interface type is named as returned (fully qualified).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.EdgeClassName">
            <summary>
            This EdgeType describes edges whose real .NET class type is named as returned (fully qualified).
            It might be null in case this type IsAbstract.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.Directedness">
            <summary>
            Specifies the directedness of this edge type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.SubOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.DirectSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.SuperOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VarType">
            <summary>
            A representation of a GrGen variable type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VarType.varTypeMap">
            <summary>
            A map from .NET types to singleton VarTypes.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.GetVarType(System.Type)">
            <summary>
            Gets the singleton VarType object for a given .NET type.
            </summary>
            <param name="type">The .NET type.</param>
            <returns>The singleton VarType object.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.IsA(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether this type is compatible to the given type, i.e. this type is the same type as the given type
            or it is a sub type of the given type.
            </summary>
            <param name="other">The type to be compared to.</param>
            <returns>True, if this type is compatible to the given type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.Equals(System.Object)">
            <summary>
            Checks, whether the given type equals this type.
            </summary>
            <param name="other">The type to be compared to.</param>
            <returns>True, if the given type is the same as this type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.VarType.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.VarType.Type">
            <summary>
            The .NET type of the variable.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraphElement">
            <summary>
            A GrGen graph element
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.InstanceOf(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Returns true, if the graph element is compatible to the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.GetAttribute(System.String)">
            <summary>
            Returns the graph element attribute with the given attribute name.
            If the graph element type doesn't have an attribute with this name, a NullReferenceException is thrown.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.SetAttribute(System.String,System.Object)">
            <summary>
            Sets the graph element attribute with the given attribute name to the given value.
            If the graph element type doesn't have an attribute with this name, a NullReferenceException is thrown.
            </summary>
            <param name="attrName">The name of the attribute.</param>
            <param name="value">The new value for the attribute. It must have the correct type.
            Otherwise a TargetException is thrown.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.ResetAllAttributes">
            <summary>
            Resets all graph element attributes to their initial values.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphElement.Type">
            <summary>
            The GrGenType of the graph element
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphElement.Valid">
            <summary>
            This is true, if the element is a valid graph element, i.e. it is part of a graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphElement.ReplacedByElement">
            <summary>
            The element which replaced this element (Valid is false in this case)
            or null, if this element has not been replaced or is still a valid member of a graph.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.INode">
            <summary>
            A GrGen node
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetCompatibleOutgoing(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all outgoing edges with the same type or a subtype of the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetExactOutgoing(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all outgoing edges with exactly the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetCompatibleIncoming(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incoming edges with the same type or a subtype of the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetExactIncoming(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incoming edges with exactly the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetCompatibleAdjacent(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all adjacent edges with the same type or a subtype of the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetExactAdjacent(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all adjacent edges with exactly the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.Clone">
            <summary>
            Creates a copy of this node.
            All attributes will be transfered to the new node.
            The node will not be associated to a graph, yet.
            So it will not have any adjacent edges nor any assigned variables.
            </summary>
            <returns>A copy of this node.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Type">
            <summary>
            The NodeType of the node
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.ReplacedByNode">
            <summary>
            The node which replaced this node (Valid is false in this case)
            or null, if this node has not been replaced or is still a valid member of a graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Outgoing">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all outgoing edges
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Incoming">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incoming edges
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Adjacent">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all adjacent edges
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IEdge">
            <summary>
            A GrGen edge
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IEdge.GetOther(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Retrieves the other adjacent node of this edge.
            </summary>
            <remarks>If the given node is not the source, the source will be returned.</remarks>
            <param name="sourceOrTarget">One node of this edge.</param>
            <returns>The other node of this edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IEdge.Clone(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Creates a copy of this edge.
            All attributes will be transfered to the new edge.
            The edge will not be associated to a graph, yet.
            So it will not have any assigned variables.
            </summary>
            <param name="newSource">The new source node for the new edge.</param>
            <param name="newTarget">The new target node for the new edge.</param>
            <returns>A copy of this edge.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.Type">
            <summary>
            Returns the EdgeType of the edge
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.ReplacedByEdge">
            <summary>
            The edge which replaced this edge (Valid is false in this case)
            or null, if this edge has not been replaced or is still a valid member of a graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.Source">
            <summary>
            The source node of the edge.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.Target">
            <summary>
            The target node of the edge.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DumpMatchSpecial">
            <summary>
            Specifies how an IMatches object should be dumped.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DumpMatchSpecial.AllMatches">
            <summary>
            Insert virtual match nodes and connect the matches
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DumpMatchSpecial.OnlyMatches">
            <summary>
            Show only the matches
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BaseGraph">
            <summary>
            A partial implementation of the IGraph interface.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.DestroyGraph">
            <summary>
            For persistent backends permanently destroys the graph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.LoadActions(System.String)">
            <summary>
            Loads a BaseActions instance from the given file.
            If the file is a ".cs" file it will be compiled first.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNumExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNumExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNumCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNumCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddNode(de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds an existing INode object to the graph and assigns it to the given variable.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds an existing INode object to the graph.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddINode(de.unika.ipd.grGen.libGr.NodeType,System.String)">
            <summary>
            Adds a new node to the graph and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String)">
            <summary>
            Adds a new node to the graph and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddINode(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String)">
            <summary>
            Adds an existing IEdge object to the graph and assigns it to the given variable.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Adds an existing IEdge object to the graph.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds a new edge to the graph and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds a new edge to the graph.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Remove(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes the given node from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Remove(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Removes the given edge from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemoveEdges(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes all edges from the given node.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Clear">
            <summary>
            Removes all nodes and edges (including any variables pointing to them) from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Retype(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Retypes a node by creating a new node of the given type.
            All adjacent edges as well as all attributes from common super classes are kept.
            </summary>
            <param name="node">The node to be retyped.</param>
            <param name="newNodeType">The new type for the node.</param>
            <returns>The new node object representing the retyped node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Retype(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Retypes an edge by creating a new edge of the given type.
            Source and target node as well as all attributes from common super classes are kept.
            </summary>
            <param name="edge">The edge to be retyped.</param>
            <param name="newEdgeType">The new type for the edge.</param>
            <returns>The new edge object representing the retyped edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Mature">
            <summary>
            Mature a graph.
            This method should be invoked after adding all nodes and edges to the graph.
            The backend may implement analyses on the graph to speed up matching etc.
            The graph may not be modified by this function.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Custom(System.Object[])">
            <summary>
            Does graph-backend dependent stuff.
            </summary>
            <param name="args">Any kind of paramteres for the stuff to do</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Clone(System.String)">
            <summary>
            Duplicates a graph.
            The new graph will use the same model and backend as the other
            The open transactions will NOT be cloned.
            </summary>
            <param name="newName">Name of the new graph.</param>
            <returns>A new graph with the same structure as this graph.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.AllocateVisitedFlag">
            <summary>
            Allocates a clean visited flag on the graph elements.
            If needed the flag is cleared on all graph elements, so this is an O(n) operation.
            </summary>
            <returns>A visitor ID to be used in
            visited conditions in patterns ("if { !visited(elem, id); }"),
            visited expressions in evals ("visited(elem, id) = true; b.flag = visited(elem, id) || c.flag; "}
            and calls to other visitor functions.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.FreeVisitedFlag(System.Int32)">
            <summary>
            Frees a visited flag.
            This is an O(1) operation.
            </summary>
            <param name="visitorID">The ID of the visited flag to be freed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ResetVisitedFlag(System.Int32)">
            <summary>
            Resets the visited flag with the given ID on all graph elements, if necessary.
            </summary>
            <param name="visitorID">The ID of the visited flag.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.SetVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32,System.Boolean)">
            <summary>
            Sets the visited flag of the given graph element.
            </summary>
            <param name="elem">The graph element whose flag is to be set.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <param name="visited">True for visited, false for not visited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.IsVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32)">
            <summary>
            Returns whether the given graph element has been visited.
            </summary>
            <param name="elem">The graph element to be examined.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <returns>True for visited, false for not visited.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetElementName(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns the name for the given element,
            i.e. the name defined by the named graph if a named graph is available,
            or a hash value string if only a lgpsGraph is available.
            </summary>
            <param name="elem">Element of which the name is to be found</param>
            <returns>The name of the given element</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetElementVariables(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns a linked list of variables mapped to the given graph element
            or null, if no variable points to this element
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetVariableValue(System.String)">
            <summary>
            Retrieves the object for a variable name or null, if the variable isn't set yet or anymore
            </summary>
            <param name="varName">The variable name to lookup</param>
            <returns>The according object or null</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNodeVarValue(System.String)">
            <summary>
            Retrieves the INode for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an INode object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetEdgeVarValue(System.String)">
            <summary>
            Retrieves the IEdge for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an IEdge object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.SetVariableValue(System.String,System.Object)">
            <summary>
            Sets the value of the given variable to the given object.
            If the variable name is null, this function does nothing
            If elem is null, the variable is unset
            </summary>
            <param name="varName">The name of the variable</param>
            <param name="val">The new value of the variable</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.BaseGraph.NoElems">
            <summary>
            A singleton object array used when no elements are returned.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Retrieves the newest version of an IAction object currently available for this graph.
            This may be the given object.
            </summary>
            <param name="action">The IAction object.</param>
            <returns>The newest version of the given action.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.SetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction,de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Sets the newest action version for a static action.
            </summary>
            <param name="staticAction">The original action generated by GrGen.exe.</param>
            <param name="newAction">A new action instance.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Replace(de.unika.ipd.grGen.libGr.IMatches,System.Int32)">
            <summary>
            Executes the modifications of the according rule to the given match/matches.
            Fires OnRewritingNextMatch events before each rewrite except for the first one.
            </summary>
            <param name="matches">The matches object returned by a previous matcher call.</param>
            <param name="which">The index of the match in the matches object to be applied,
            or -1, if all matches are to be applied.</param>
            <returns>A possibly empty array of objects returned by the last applied rewrite.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ApplyRewrite(de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Apply a rewrite rule.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule invocation</param>
            <param name="which">The index of the match to be rewritten or -1 to rewrite all matches</param>
            <param name="localMaxMatches">Specifies the maximum number of matches to be found (if less or equal 0 the number of matches
            depends on MaxMatches)</param>
            <param name="special">Specifies whether the %-modifier has been used for this rule, which may have a special meaning for
            the application</param>
            <param name="test">If true, no rewrite step is performed.</param>
            <returns>The number of matches found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Apply a graph rewrite sequence.
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Apply a graph rewrite sequence.
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.NodeAdded(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnNodeAdded event.
            </summary>
            <param name="node">The added node.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.EdgeAdded(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnEdgeAdded event.
            </summary>
            <param name="edge">The added edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemovingNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnRemovingNode event.
            </summary>
            <param name="node">The node to be removed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemovingEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnRemovingEdge event.
            </summary>
            <param name="edge">The edge to be removed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemovingEdges(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnRemovingEdges event.
            </summary>
            <param name="node">The node whose edges are to be removed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ClearingGraph">
            <summary>
            Fires an OnClearingGraph event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.SettingAddedNodeNames(System.String[])">
            <summary>
            Fires an OnSettingAddedNodeNames event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.SettingAddedEdgeNames(System.String[])">
            <summary>
            Fires an OnSettingAddedEdgeNames event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ChangingNodeAttribute(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingNodeAttribute event.
            To be called before changing an attribute of a node,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="node">The node whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ChangingEdgeAttribute(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingEdgeAttribute event.
            To be called before changing an attribute of an edge,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="edge">The edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RetypingNode(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnRetypingNode event.
            </summary>
            <param name="oldNode">The node to be retyped.</param>
            <param name="newNode">The new node with the common attributes, but without any adjacent edges assigned, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RetypingEdge(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnRetypingEdge event.
            </summary>
            <param name="oldEdge">The edge to be retyped.</param>
            <param name="newEdge">The new edge with the common attributes, but not fully connected with the adjacent nodes, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Matched(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnMatched event.
            </summary>
            <param name="matches">The match result.</param>
            <param name="special">The "special" flag of this rule application.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Finishing(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinishing event.
            </summary>
            <param name="matches">The match result.</param>
            <param name="special">The "special" flag of this rule application.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RewritingNextMatch">
            <summary>
            Fires an OnRewritingNextMatch event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Finished(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinished event.
            </summary>
            <param name="matches">The match result.</param>
            <param name="special">The "special" flag of this rule application.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.EnteringSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnEnteringSequence event.
            </summary>
            <param name="seq">The sequence which is entered.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ExitingSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnExitingSequence event.
            </summary>
            <param name="seq">The sequence which is exited.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.BaseGraph.emitWriter">
            <summary>
            The writer used by emit statements. By default this is Console.Out.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNodeType(System.String)">
            <summary>
            Returns the node type with the given name.
            </summary>
            <param name="typeName">The name of a node type.</param>
            <returns>The node type with the given name or null, if it does not exist.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetEdgeType(System.String)">
            <summary>
            Returns the edge type with the given name.
            </summary>
            <param name="typeName">The name of a edge type.</param>
            <returns>The edge type with the given name or null, if it does not exist.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Validate(System.Boolean,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.ConnectionAssertionError}@)">
            <summary>
            Checks whether a graph meets the connection assertions.
            In strict mode all edges must be specified by a connection assertion.
            </summary>
            <param name="strict">If false, only check for specified assertions,
            otherwise it isn an error, if an edge connects nodes without a
            specified connection assertion.</param>
            <param name="errors">If the graph is not valid, this refers to a List of ConnectionAssertionError objects, otherwise it is null.</param>
            <returns>True, if the graph is valid.</returns>
            TODO: Shouldn't strict be fulfilled, if the dictionary sizes equal the number of nodes/edges?
                --> faster positive answer
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.DumpAttributes(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Dumps all attributes in the form "kind owner::name = value" into a String List
            </summary>
            <param name="elem">IGraphElement which attributes are to be dumped</param>
            <returns>A String List containing the dumped attributes </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.DumpMatchOnly(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.DumpMatchSpecial,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.INode}@,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.INode}@,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.IEdge}@,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.IEdge}@)">
            <summary>
            Dumps the given matches.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
            <param name="matches">An IMatches object containing the matches.</param>
            <param name="which">Which match to dump, or AllMatches for dumping all matches
            adding connections between them, or OnlyMatches to dump the matches only</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.DumpMatch(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.DumpMatchSpecial)">
            <summary>
            Dumps the current graph and highlights any given matches.
            If no match is given, the whole graph is dumped without any changes.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
            <param name="matches">An IMatches object containing the matches or null, if the graph is to be dumped normally.</param>
            <param name="which">Which match to dump, or AllMatches for dumping all matches
            adding connections between them, or OnlyMatches to dump the matches only</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Dump(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo)">
            <summary>
            Dumps the graph with a given graph dumper.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.Dump(de.unika.ipd.grGen.libGr.IDumper)">
            <summary>
            Dumps the graph with a given graph dumper and default dump style.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.Name">
            <summary>
            A name associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.Model">
            <summary>
            The model associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.Actions">
            <summary>
            A currently associated actions object.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.TransactionManager">
            <summary>
            Returns the graph's transaction manager.
            For attribute changes using the transaction manager is the only way to include such changes in the transaction history!
            Don't forget to call Commit after a transaction is finished!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.ReuseOptimization">
            <summary>
            If true (the default case), elements deleted during a rewrite
            may be reused in the same rewrite.
            As a result new elements may not be discriminable anymore from
            already deleted elements using object equality, hash maps, etc.
            In cases where this is needed this optimization should be disabled.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.PerformanceInfo">
            <summary>
            If PerformanceInfo is non-null, this object is used to accumulate information about time, found matches and applied rewrites.
            The user is responsible for resetting the PerformanceInfo object.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.MaxMatches">
            <summary>
            The maximum number of matches to be returned for a RuleAll sequence element.
            If it is zero or less, the number of matches is unlimited.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnNodeAdded">
            <summary>
            Fired after a node has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnEdgeAdded">
            <summary>
            Fired after an edge has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnRemovingNode">
            <summary>
            Fired before a node is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnRemovingEdge">
            <summary>
            Fired before an edge is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnRemovingEdges">
            <summary>
            Fired before all edges of a node are deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnClearingGraph">
            <summary>
            Fired before the whole graph is cleared
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnChangingNodeAttribute">
            <summary>
            Fired before an attribute of a node is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function 
            and want the event to be fired, you have to fire it yourself
            using ChangingNodeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnChangingEdgeAttribute">
            <summary>
            Fired before an attribute of an edge is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function 
            and want the event to be fired, you have to fire it yourself
            using ChangingEdgeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnRetypingNode">
            <summary>
            Fired before a node is retyped.
            Old and new node are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnRetypingEdge">
            <summary>
            Fired before an edge is retyped.
            Old and new edge are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnSettingAddedNodeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the nodes added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnSettingAddedEdgeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the edges added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnMatched">
            <summary>
            Fired after all requested matches of a rule have been matched.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnFinishing">
            <summary>
            Fired before the rewrite step of a rule, when at least one match has been found.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnRewritingNextMatch">
            <summary>
            Fired before the next match is rewritten. It is not fired before rewriting the first match.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnFinished">
            <summary>
            Fired after the rewrite step of a rule.
            Note, that the given matches object may contain invalid entries,
            as parts of the match may have been deleted!
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnEntereringSequence">
            <summary>
            Fired when a sequence is entered.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.BaseGraph.OnExitingSequence">
            <summary>
            Fired when a sequence is left.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.NumNodes">
            <summary>
            The total number of nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.NumEdges">
            <summary>
            The total number of edges in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.Nodes">
            <summary>
            Enumerates all nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.Edges">
            <summary>
            Enumerates all edges in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseGraph.EmitWriter">
            <summary>
            The writer used by emit statements. By default this is Console.Out.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BaseGraph.VirtualNodeType">
            <summary>
            Trivial IType implementation for virtual nodes
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BaseGraph.VirtualNode">
            <summary>
            Trivial INode implementation for virtual nodes
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SingleLinkedList`1">
            <summary>
            Deprecated...
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceChecker">
            <summary>
            Class for some basic checking of the sequence which is to be interpreted.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceChecker.Check(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Checks the given sequence for errors
            reports them by exception
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GRSExport">
            <summary>
            Exports graphs to the GRS format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.String,System.Boolean)">
            <summary>
            Exports the given graph to a GRS file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. If a NamedGraph is given, it will be exported including the names.</param>
            <param name="exportFilename">The filename for the exported file.</param>
            <param name="withVariables">Export the graph variables, too?</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.IO.StreamWriter,System.Boolean)">
            <summary>
            Exports the given graph to the file given by the stream writer in grs format.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. If a NamedGraph is given, it will be exported including the names.</param>
            <param name="writer">The stream writer to export to.</param>
            <param name="withVariables">Export the graph variables, too?</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.ExportYouMustCloseStreamWriter(de.unika.ipd.grGen.libGr.IGraph,System.IO.StreamWriter,System.Boolean)">
            <summary>
            Exports the given graph to the file given by the stream writer in grs format.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. If a NamedGraph is given, it will be exported including the names.</param>
            <param name="sw">The stream writer of the file to export into. The stream writer is not closed automatically.</param>
            <param name="withVariables">Export the graph variables, too?</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.EmitAttributes(de.unika.ipd.grGen.libGr.AttributeType,System.Object,System.IO.StreamWriter)">
            <summary>
            Emits the node/edge attribute initialization code in graph exporting
            for an attribute of the given type with the given value into the stream writer
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.GRSImporter.Import(System.String,System.String,de.unika.ipd.grGen.libGr.IBackend)">
            <summary>
            Imports the given graph from a file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <returns>The imported graph. 
            A NamedGraph is returned. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.GRSImporter.Import(System.IO.TextReader,System.String,de.unika.ipd.grGen.libGr.IBackend)">
            <summary>
            Imports the given graph from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="reader">The text reader input stream import source.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <returns>The imported graph. 
            A NamedGraph is returned. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.GRSImporter.Import(System.String,de.unika.ipd.grGen.libGr.IBackend)">
            <summary>
            Imports the given graph from a file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <returns>The imported graph. 
            A NamedGraph is returned. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>        
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.GRSImporter.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Imports the given graph from a file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used.</param>
            <returns>The imported graph. 
            A NamedGraph is returned. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.porter.GRSImporter.Import(System.IO.TextReader,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Imports the given graph from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="reader">The text reader input stream import source.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used.</param>
            <returns>The imported graph. 
            A NamedGraph is returned. If you don't need it: cast to it, get the contained (lgsp) graph, and throw the named graph away
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings">
            <summary>
            An object representing a rule invocation.
            It tells from where (which variables/constants) to get the input values 
            and where (which variables) to store the output values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.Action">
            <summary>
            The IAction instance to be used
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.RuleName">
            <summary>
            The name of the rule. Used for generation, where the IAction objects do not exist yet.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.ParamVars">
            <summary>
            An array of variables used for the parameters.
            It must have the same length as Parameters.
            If an entry is null, the according entry in parameters is used unchanged.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.ReturnVars">
            <summary>
            An array of variables used for the return values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.Parameters">
            <summary>
            Buffer to store parameters used by libGr to avoid unneccessary memory allocation.
            Also holds constant parameters at the positions where ParamVars has null entries.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.#ctor(de.unika.ipd.grGen.libGr.IAction,de.unika.ipd.grGen.libGr.SequenceVariable[],System.Object[],de.unika.ipd.grGen.libGr.SequenceVariable[])">
            <summary>
            Instantiates a new RuleInvocationParameterBindings object
            </summary>
            <param name="action">The IAction instance to be used</param>
            <param name="paramVars">An array of variable used for the parameters</param>
            <param name="paramConsts">An array of constants used for the parameters.</param>
            <param name="returnVars">An array of variables used for the return values</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IAction">
            <summary>
            An object representing an executable rule.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.Match(de.unika.ipd.grGen.libGr.IGraph,System.Int32,System.Object[])">
            <summary>
            Searches for a graph pattern as specified by RulePattern.
            </summary>
            <param name="graph">The host graph.</param>
            <param name="maxMatches">The maximum number of matches to be searched for, or zero for an unlimited search.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>An IMatches object containing the found matches.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.Modify(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IMatch)">
            <summary>
            Performs the rule specific modifications to the given graph with the given match.
            The graph and match object must have the correct type for the used backend (and this action).
            </summary>
            <returns>An array of objects returned by the rule.
            It is only valid until the next graph rewrite with this rule.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ModifyAll(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IMatches)">
            <summary>
            Performs the rule specific modifications to the given graph with all of the given matches.
            The graph and match object must have the correct type for the used backend.
            No OnRewritingNextMatch events are triggered by this function.
            </summary>
            <returns>An array of objects returned by the last applicance of the rule.
            It is only valid until the next graph rewrite with this rule.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.Apply(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Tries to apply this rule to the given graph once.
            The rule may not require any parameters.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <returns>A possibly empty array of objects returned by the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.Apply(de.unika.ipd.grGen.libGr.IGraph,System.Object[])">
            <summary>
            Tries to apply this rule to the given graph once.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>A possibly empty array of objects returned by the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyAll(System.Int32,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Tries to apply this rule to all occurrences in the given graph "at once".
            The rule may not require any parameters.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="maxMatches">The maximum number of matches to be rewritten.</param>
            <param name="graph">Host graph for this rule</param>
            <returns>A possibly empty array of objects returned by the last applicance of the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyAll(System.Int32,de.unika.ipd.grGen.libGr.IGraph,System.Object[])">
            <summary>
            Tries to apply this rule to all occurrences in the given graph "at once".
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="maxMatches">The maximum number of matches to be rewritten.</param>
            <param name="graph">Host graph for this rule</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>A possibly empty array of objects returned by the last applicance of the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyStar(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Applies this rule to the given graph as often as possible.
            The rule may not require any parameters.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyStar(de.unika.ipd.grGen.libGr.IGraph,System.Object[])">
            <summary>
            Applies this rule to the given graph as often as possible.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyPlus(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Applies this rule to the given graph as often as possible.
            The rule may not require any parameters.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <returns>True, if the rule was applied at least once.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyPlus(de.unika.ipd.grGen.libGr.IGraph,System.Object[])">
            <summary>
            Applies this rule to the given graph as often as possible.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>True, if the rule was applied at least once.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyMinMax(de.unika.ipd.grGen.libGr.IGraph,System.Int32,System.Int32)">
            <summary>
            Applies this rule to the given graph at most max times.
            The rule may not require any parameters.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <param name="min">The minimum number of applications to be "successful".</param>
            <param name="max">The maximum number of applications to be applied.</param>
            <returns>True, if the rule was applied at least min times.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyMinMax(de.unika.ipd.grGen.libGr.IGraph,System.Int32,System.Int32,System.Object[])">
            <summary>
            Applies this rule to the given graph at most max times.
            No Matched/Finished events are triggered by this function.
            </summary>
            <param name="graph">Host graph for this rule</param>
            <param name="min">The minimum number of applications to be "successful".</param>
            <param name="max">The maximum number of applications to be applied.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>True, if the rule was applied at least min times.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IAction.Name">
            <summary>
            The name of the action
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IAction.RulePattern">
            <summary>
            The RulePattern object from which this IAction object has been created.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatch">
            <summary>
            Base class of classes representing matches.
            One exact match class is generated per pattern.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getNodeAt(System.Int32)">
            <summary>
            Returns node at position index (most efficient access)
            </summary>
            <param name="index">The position of the node to return</param>
            <returns>The node at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getEdgeAt(System.Int32)">
            <summary>
            Returns edge at position index (most efficient access)
            </summary>
            <param name="index">The position of the edge to return</param>
            <returns>The edge at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getVariableAt(System.Int32)">
            <summary>
            Returns variable at position index (most efficient access)
            </summary>
            <param name="index">The position of the variable to return</param>
            <returns>The variable at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getEmbeddedGraphAt(System.Int32)">
            <summary>
            Returns submatch due to subpattern at position index (most efficient access)
            </summary>
            <param name="index">The position of the submatch due to subpattern to return</param>
            <returns>The submatch due to subpattern at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getAlternativeAt(System.Int32)">
            <summary>
            Returns submatch due to alternatives at position index (most efficient access)
            </summary>
            <param name="index">The position of the submatch due to alternatives to return</param>
            <returns>The submatch due to alternatives at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getIteratedAt(System.Int32)">
            <summary>
            Returns submatch due to iterateds at position index (most efficient access)
            The submatch is a list of all matches of the iterated pattern.
            </summary>
            <param name="index">The position of the submatch due to iterateds to return</param>
            <returns>The submatch due to iterateds at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getIndependentAt(System.Int32)">
            <summary>
            Returns submatch due to independents at position index (most efficient access)
            </summary>
            <param name="index">The position of the submatch due to independents to return</param>
            <returns>The submatch due to independents at the given index</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Pattern">
            <summary>
            The match object represents a match of the pattern given by this member.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.MatchOfEnclosingPattern">
            <summary>
            The match of the enclosing pattern if this is the pattern of 
            a subpattern, alternative, iterated or independent; otherwise null
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Nodes">
            <summary>
            Enumerable returning enumerator over matched nodes (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NodesEnumerator">
            <summary>
            Enumerator over matched nodes (efficiency in between getNodeAt and Nodes)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfNodes">
            <summary>
            Number of nodes in the match
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Edges">
            <summary>
            Enumerable returning enumerator over matched edges (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.EdgesEnumerator">
            <summary>
            Enumerator over matched edges (efficiency in between getEdgeAt and Edges)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfEdges">
            <summary>
            Number of edges in the match
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Variables">
            <summary>
            Enumerable returning enumerator over matched variables (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.VariablesEnumerator">
            <summary>
            Enumerator over matched variables (efficiency in between getVariableAt and Variables)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfVariables">
            <summary>
            Number of variables in the match
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.EmbeddedGraphs">
            <summary>
            Enumerable returning enumerator over submatches due to subpatterns (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.EmbeddedGraphsEnumerator">
            <summary>
            Enumerator over submatches due to subpatterns (efficiency in between getEmbeddedGraphAt and EmbeddedGraphs)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfEmbeddedGraphs">
            <summary>
            Number of submatches due to subpatterns in the match
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Alternatives">
            <summary>
            Enumerable returning enumerator over submatches due to alternatives (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.AlternativesEnumerator">
            <summary>
            Enumerator over submatches due to alternatives. (efficiency in between getAlternativeAt and Alternatives)
            You can find out which alternative case was matched by inspecting the Pattern member of the submatch.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfAlternatives">
            <summary>
            Number of submatches due to alternatives in the match
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Iterateds">
            <summary>
            Enumerable returning enumerator over submatches due to iterateds (most inefficient access)
            The submatch is a list of all matches of the iterated pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.IteratedsEnumerator">
            <summary>
            Enumerator over submatches due to iterateds. (efficiency in between getIteratedAt and Iterateds)
            The submatch is a list of all matches of the iterated pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfIterateds">
            <summary>
            Number of submatches due to iterateds in the match.
            Corresponding to the number of iterated patterns, not the number of matches of some iterated pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Independents">
            <summary>
            Enumerable returning enumerator over submatches due to independents (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.IndependentsEnumerator">
            <summary>
            Enumerator over submatches due to independents. (efficiency in between getIndependentAt and Independents)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfIndependents">
            <summary>
            Number of submatches due to independents in the match
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatches">
            <summary>
            An object representing a (possibly empty) set of matches in a graph before the rewrite has been applied.
            If it is a match of an action, it is returned by IAction.Match() and given to the OnMatched event.
            Otherwise it's the match of an iterated-pattern, and the producing action is null.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.GetMatch(System.Int32)">
            <summary>
            Returns the match with the given index. Invalid indices cause an exception.
            This may be slow. If you want to iterate over the elements the Matches IEnumerable should be used.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.RemoveMatch(System.Int32)">
            <summary>
            Removes the match at the given index and returns it.
            </summary>
            <param name="index">The index of the match to be removed.</param>
            <returns>The removed match.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatches.Producer">
            <summary>
            The action object used to generate this IMatches object
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatches.First">
            <summary>
            Returns the first match (null if no match exists).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatches.Count">
            <summary>
            The number of matches found by Producer
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatchesExact`1">
            <summary>
            An object representing a (possibly empty) set of matches in a graph before the rewrite has been applied,
            capable of handing out enumerators of exact match interface type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.GetEnumeratorExact">
            <summary>
            Returns enumerator over matches of exact type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.RemoveMatchExact(System.Int32)">
            <summary>
            Removes the match of exact type at the given index and returns it.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchesExact`1.FirstExact">
            <summary>
            Returns the first match of exact type (null if no match exists).
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.PerformanceInfo">
            <summary>
            An object accumulating information about needed time, number of found matches and number of performed rewrites.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.MatchesFound">
            <summary>
            Accumulated number of matches found by any rule applied via an BaseActions object.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.RewritesPerformed">
            <summary>
            Accumulated number of rewrites performed by any rule applied via an BaseActions object.
            This differs from <see cref="F:de.unika.ipd.grGen.libGr.PerformanceInfo.MatchesFound"/> for test rules, tested rules, and undone rules.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.LastMatchTime">
            <summary>
            The time needed for the last matching.
            </summary>
            <remarks>Only updated if either DEBUGACTIONS or MATCHREWRITEDETAIL has been defined.</remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.LastRewriteTime">
            <summary>
            The time needed for the last rewriting.
            </summary>
            <remarks>Only updated if either DEBUGACTIONS or MATCHREWRITEDETAIL has been defined.</remarks>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.Start">
            <summary>
            Starts time measurement.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.Stop">
            <summary>
            Stops time measurement and increases the TotalTimeMS by the elapsed time between this call
            and the last call to Start().
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.Reset">
            <summary>
            Resets all accumulated information.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.StartLocal">
            <summary>
            Starts a local time measurement to be used with either StopMatch() or StopRewrite().
            </summary>
            <remarks>Only usable if either DEBUGACTIONS or MATCHREWRITEDETAIL has been defined.</remarks>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.StopMatch">
            <summary>
            Stops a local time measurement, sets LastMatchTime to the elapsed time between this call
            and the last call to StartLocal() and increases the TotalMatchTime by this amount.
            </summary>
            <remarks>Only usable if either DEBUGACTIONS or MATCHREWRITEDETAIL has been defined.</remarks>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.StopRewrite">
            <summary>
            Stops a local time measurement, sets LastRewriteTime to the elapsed time between this call
            and the last call to StartLocal() and increases the TotalRewriteTime by this amount.
            </summary>
            <remarks>Only usable if either DEBUGACTIONS or MATCHREWRITEDETAIL has been defined.</remarks>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.PerformanceInfo.TotalMatchTimeMS">
            <summary>
            The total time needed for matching.
            Due to timer resolution, this should not be used, except for very difficult patterns.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.PerformanceInfo.TotalRewriteTimeMS">
            <summary>
            The total time needed for rewriting.
            Due to timer resolution, this should not be used, except for very big rewrites.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.PerformanceInfo.TotalTimeMS">
            <summary>
            The accumulated time of rule and sequence applications.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Range">
            <summary>
            Describes a range with a minimum and a maximum value.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Range.Infinite">
            <summary>
            Constant value representing positive infinity for a range.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Range.Min">
            <summary>
            The lower bound of the range.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Range.Max">
            <summary>
            The upper bound of the range.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Range object.
            </summary>
            <param name="min">The lower bound of the range.</param>
            <param name="max">The upper bound of the range.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            </summary>
            <remarks>
            You can explicitly create objects of this exception type by
            calling the method GenerateParseException in the generated
            parser.
            <para>
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </para>
            </remarks>
        </member>
        <!-- Ungltiger XML-Kommentar wurde fr den Member "M:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.#ctor(de.unika.ipd.grGen.libGr.sequenceParser.Token,System.Int32[][],System.String[])" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.#ctor">
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.specialConstructor">
            This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.currentToken">
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.expectedTokenSequences">
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.tokenImage">
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.eol">
            The end of line string for this machine.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.AddEscapes(System.String)">
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.Message">
            This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GetDictionaryTypes(System.Object,System.Type@,System.Type@)">
            <summary>
            If dict is dictionary, the dictionary is returned together with it's key and value type
            </summary>
            <param name="dict">The object which should be a dictionary</param>
            <param name="keyType">The key type of the dictionary</param>
            <param name="valueType">The value type of the dictionary</param>
            <returns>The casted input dictionary, or null if not a dictionary</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GetDictionaryTypes(System.Type,System.Type@,System.Type@)">
            <summary>
            The key and value types are returned of the dictionary
            </summary>
            <param name="dictType">The dictionary type</param>
            <param name="keyType">The key type of the dictionary</param>
            <param name="valueType">The value type of the dictionary</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GetTypeFromNameForDictionary(System.String,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns type object for type name string, to be used for dictionary
            </summary>
            <param name="typeName">Name of the type we want some type object for</param>
            <param name="graph">Graph to be search for enum,node,edge types / enum,node/edge type names</param>
            <returns>The type object corresponding to the given string, null if type was not found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GetTypeFromNameForDictionary(System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns type object for type name string, to be used for dictionary
            </summary>
            <param name="typeName">Name of the type we want some type object for</param>
            <param name="model">Graph model to be search for enum,node,edge types / enum,node/edge type names</param>
            <returns>The type object corresponding to the given string, null if type was not found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GetQualifiedTypeName(System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the qualified type name for the type name given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.NewDictionary(System.Type,System.Type)">
            <summary>
            Creates a new dictionary of the given key type and value type
            </summary>
            <param name="keyType">The key type of the dictionary to be created</param>
            <param name="valueType">The value type of the dictionary to be created</param>
            <returns>The newly created dictionary, null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.NewDictionary(System.Type,System.Type,System.Object)">
            <summary>
            Creates a new dictionary of the given key type and value type,
            initialized with the content of the old dictionary (clones the old dictionary)
            </summary>
            <param name="keyType">The key type of the dictionary to be created</param>
            <param name="valueType">The value type of the dictionary to be created</param>
            <param name="oldDictionary">The old dictionary to be cloned</param>
            <returns>The newly created dictionary, containing the content of the old dictionary,
            null if unsuccessfull</returns>
        </member>
        <!-- Ungltiger XML-Kommentar wurde fr den Member "M:de.unika.ipd.grGen.libGr.DictionaryHelper.Union``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.Intersect``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a new dictionary containing all key/value pairs from
            <paramref name="b"/> whose keys are also contained in <paramref name="a"/>.
            If both dictionaries contain one key, the value from <paramref name="b"/> takes precedence
            for consistency with Union.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>A new dictionary containing all elements from <paramref name="b"/>,
            which are also in <paramref name="a"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.Except``3(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``2})">
            <summary>
            Creates a new dictionary containing all key/value pairs from
            <paramref name="a"/> whose keys are not contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <returns>A new dictionary containing all elements from <paramref name="a"/>,
            which are not in <paramref name="b"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.Domain``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a new dictionary representing a set,
            containing all keys from the given dictionary representing a map <paramref name="map"/>.
            </summary>
            <param name="map">A dictionary representing a map.</param>
            <returns>A new set dictionary containing all keys from <paramref name="map"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.Range``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a new dictionary representing a set, 
            containing all values from the given dictionary representing a map <paramref name="map"/>.
            </summary>
            <param name="map">A dictionary representing a map.</param>
            <returns>A new set dictionary containing all values from <paramref name="map"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.Peek``2(System.Collections.Generic.Dictionary{``0,``1},System.Int32)">
            <summary>
            Returns the value from the dictionary at the nth position as defined by the iterator of the dictionary.
            </summary>
            <param name="dict">A dictionary.</param>
            <param name="num">The number of the element to get in the iteration sequence.</param>
            <returns>The element at the position to get.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.Equal``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> equals set/map <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.NotEqual``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is not equal to set/map <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GreaterThan``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a proper superset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.GreaterOrEqual``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a superset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.LessThan``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a proper subset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.LessOrEqual``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a subset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.ToString(System.Collections.IDictionary)">
            <summary>
            Returns a string representation of the given dictionary
            </summary>
            <param name="setmap">The dictionary of which to get the string representation</param>
            <returns>String representation of set/map.</returns>
        </member>
        <!-- Ungltiger XML-Kommentar wurde fr den Member "M:de.unika.ipd.grGen.libGr.DictionaryHelper.ToString(System.Collections.IDictionary,System.String@,System.String@)" ignoriert -->
        <!-- Ungltiger XML-Kommentar wurde fr den Member "M:de.unika.ipd.grGen.libGr.DictionaryHelper.ToString(System.Collections.IDictionary,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object,System.String@,System.String@)" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.DictionaryHelper.IfAttributeOfElementIsDictionaryThenCloneDictionaryValue(de.unika.ipd.grGen.libGr.IGraphElement,System.String,System.Object,de.unika.ipd.grGen.libGr.AttributeType@)">
            <summary>
            If the attribute of the given name of the given element is a set or map attribute
            then return a clone of the given dictionary value, otherwise just return the original value;
            additionally returns the AttributeType of the attribute of the element.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Set`1">
            <summary>
            Set class only used by the dumping code in BaseGraph.
            The value of this class is questionable...
            </summary>
            <typeparam name="T">The type of the contained elements.</typeparam>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceParserError">
            <summary>
            Specifies the kind of sequence parser error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownRule">
            <summary>
            The rule is unknown.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.BadNumberOfParametersOrReturnParameters">
            <summary>
            The number of parameters and/or return parameters does not match the action.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.BadParameter">
            <summary>
            The type of a parameter does not match the signature of the action.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.BadReturnParameter">
            <summary>
            The type of a return parameter does not match the signature of the action.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.RuleNameUsedByVariable">
            <summary>
            A variable has been declared with the name of an action.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.VariableUsedWithParametersOrReturnParameters">
            <summary>
            A variable has been used with parameters and/or return parameters.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownAttribute">
            <summary>
            The attribute is not known
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.TypeMismatch">
            <summary>
            Type check error
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceParserException">
            <summary>
            An exception thrown by SequenceParser,
            describing the error, e.g. which rule caused the problem and how it was used
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.Kind">
            <summary>
            The kind of error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.RuleName">
            <summary>
            The name of the rule.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.Action">
            <summary>
            The associated action instance. If it is null, there was no rule with the name specified in RuleName.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.NumGivenInputs">
            <summary>
            The number of inputs given to the rule.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.NumGivenOutputs">
            <summary>
            The number of outputs given to the rule.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.BadParamIndex">
            <summary>
            The index of a bad parameter or -1 if another error occurred.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.VariableOrFunctionName">
            <summary>
            The variable which caused the type error or the function which caused the type error
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.ExpectedType">
            <summary>
            The expected type or types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.GivenType">
            <summary>
            The given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,de.unika.ipd.grGen.libGr.IAction,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule with the
            given name does not exist or input or output parameters do not match.
            </summary>
            <param name="ruleName">The name of the rule.</param>
            <param name="action">The associated action instance.
            If it is null, there was no rule with the name specified in RuleName.</param>
            <param name="numGivenInputs">The number of inputs given to the rule.</param>
            <param name="numGivenOutputs">The number of outputs given to the rule.</param>
            <param name="badParamIndex">The index of a bad parameter or -1 if another error occurred.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,de.unika.ipd.grGen.libGr.SequenceParserError)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule with the
            given name does not exist or input or output parameters do not match.
            </summary>
            <param name="ruleName">Name of the rule or variable.</param>
            <param name="errorKind">The kind of error.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings,de.unika.ipd.grGen.libGr.SequenceParserError)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule with the
            given name does not exist or input or output parameters do not match.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule invocation.</param>
            <param name="errorKind">The kind of error.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings,de.unika.ipd.grGen.libGr.SequenceParserError,System.Int32)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule with the
            given name does not exist or input or output parameters do not match.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule invocation.</param>
            <param name="errorKind">The kind of error.</param>
            <param name="badParamIndex">The index of a bad parameter or -1 if another error occurred.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser,
            when the expected type does not match the given type of the variable of function.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceParserException.Message">
            <summary>
            The error message of the exception.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BaseActions">
            <summary>
            A container of rules.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.GetAction(System.String)">
            <summary>
            Gets the action with the given name.
            </summary>
            <param name="name">The name of the action.</param>
            <returns>The action with the given name, or null, if no such action exists.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.Custom(System.Object[])">
            <summary>
            Does action-backend dependent stuff.
            </summary>
            <param name="args">Any kind of parameters for the stuff to do</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.ApplyGraphRewriteSequence(System.String)">
            <summary>
            Apply a graph rewrite sequence to the currently associated graph.
            </summary>
            <param name="seqStr">The graph rewrite sequence in form of a string</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.ApplyGraphRewriteSequence(System.String,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Apply a graph rewrite sequence to the currently associated graph.
            </summary>
            <param name="seqStr">The graph rewrite sequence in form of a string</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.ValidateWithSequence(System.String)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seqStr">The sequence to be executed in form of a string</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.ValidateWithSequence(System.String,de.unika.ipd.grGen.libGr.SequenceExecutionEnvironment)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seqStr">The sequence to be executed in form of a string</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.ParseSequence(System.String)">
            <summary>
            Parses the given XGRS string and generates a Sequence object.
            Any actions in the string must refer to actions from this action container.
            </summary>
            <param name="seqStr">The sequence to be parsed in form of an XGRS string.</param>
            <returns>The sequence object according to the given string.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.Name">
            <summary>
            An associated name.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.ModelMD5Hash">
            <summary>
            An MD5 hash of the used IGraphModel.
            Probably useless...
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.Graph">
            <summary>
            The associated graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.Actions">
            <summary>
            Enumerates all actions managed by this BaseActions instance.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VCGFlags">
            <summary>
            Specifies flags how the graph should be displayed by a graph layouter.
            </summary>
            <remarks>YComp does not support all flags.</remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientTopToBottom">
            <summary>
            Orient layout from top to bottom.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientBottomToTop">
            <summary>
            Orient layout from bottom to top.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientLeftToRight">
            <summary>
            Orient layout from left to right.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientRightToLeft">
            <summary>
            Orient layout from right to left.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientMask">
            <summary>
            Mask of orientation bits.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.EdgeLabels">
            <summary>
            Show edge labels.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.PortSharing">
            <summary>
            Enable port sharing.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.Splines">
            <summary>
            Use splines for edge drawing.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.ManhattanEdges">
            <summary>
            Use manhattan edges.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.SManhattanEdges">
            <summary>
            Use smanhattan edges.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.SuppressEdges">
            <summary>
            Suppress edge drawing.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.SuppressNodes">
            <summary>
            Suppress node drawing
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VCGDumper">
            <summary>
            A VCG graph dumper.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.GetColor(de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Gets the VCG string representation of a GrColor object.
            </summary>
            <param name="color">The GrColor object.</param>
            <returns>The VCG string representation of <c>color</c>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.GetLineStyle(de.unika.ipd.grGen.libGr.GrLineStyle)">
            <summary>
            Gets the VCG string representation of a GrLineStyle object.
            </summary>
            <param name="style">The GrLineStyle object.</param>
            <returns>The VCG string representation of <c>style</c>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.GetNodeShape(de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Gets the VCG string representation of a GrNodeShape object.
            </summary>
            <param name="shape">The GrNodeShape object.</param>
            <returns>The VCG string representation of <c>shape</c>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.#ctor(System.String,de.unika.ipd.grGen.libGr.VCGFlags,System.String)">
            <summary>
            Initializes a new instance of VCGDump.
            </summary>
            <param name="filename">Destination file.</param>
            <param name="flags">Flags to control the dumper's behavior.</param>
            <param name="layouter">Specifies the yComp layouter to be used.</param>
            <exception cref="T:System.IO.IOException">Thrown when the destination cannot be created.</exception>
            <remarks>Currently (YComp 1.3.9) valid layouters are:
             - "Random"
             - "Hierarchic"
             - "Organic"
             - "Orthogonal"
             - "Circular"
             - "Tree"
             - "Diagonal"
             - "Incremental Hierarchic"
             - "Compilergraph"
            </remarks>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.#ctor(System.String)">
            <summary>
            Initializes a new instance of VCGDump with standard flags (VCGFlags.OrientBottomToTop) and the "Orthogonal" layouter.
            </summary>
            <param name="filename">Destination file.</param>
            <exception cref="T:System.IO.IOException">Thrown when the destination cannot be created.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.DumpNode(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Dump a node to the VCG graph.
            </summary>
            <param name="node">The node to be dumped.</param>
            <param name="label">The label to use for the node.</param>
            <param name="attributes">An enumerable of attribute strings.</param>
            <param name="textColor">The color of the text.</param>
            <param name="nodeColor">The color of the node border.</param>
            <param name="borderColor">The color of the node.</param>
            <param name="nodeShape">The shape of the node.</param>
            
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
            
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.DumpEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrLineStyle)">
            <summary>
            Dump an edge to the VCG graph
            </summary>
            <param name="srcNode">The source node of the edge</param>
            <param name="tgtNode">The target node of the edge</param>
            <param name="label">The label of the edge, may be null</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="edgeColor">The color of the edge</param>
            <param name="lineStyle">The linestyle of the edge</param>
            
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
            
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.StartSubgraph(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Creates a new sub-graph to the VCG graph
            </summary>
            <param name="node">The node starting the new sub-graph</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="subgraphColor">The color of the subgraph node</param>
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.FinishSubgraph">
            <summary>
            Finishes a subgraph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.FinishDump">
            <summary>
            Finishes the dump and closes the file
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.Dispose">
            <summary>
            Disposes this object. If <see cref="M:de.unika.ipd.grGen.libGr.VCGDumper.FinishDump"/> has not been called yet, it is called.
            This allows using "using" with the dumper object.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternElement">
            <summary>
            An element of a rule pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.Name">
            <summary>
            The name of the pattern element.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.UnprefixedName">
            <summary>
            The pure name of the pattern element as specified in the .grg without any prefixes.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternNode">
            <summary>
            A pattern node of a rule pattern.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternEdge">
            <summary>
            A pattern edge of a rule pattern.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternVariable">
            <summary>
            A pattern variable of a rule pattern.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternGraph">
            <summary>
            A pattern graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IPatternGraph.GetSource(de.unika.ipd.grGen.libGr.IPatternEdge)">
            <summary>
            Returns the source pattern node of the given edge, null if edge dangles to the left
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IPatternGraph.GetTarget(de.unika.ipd.grGen.libGr.IPatternEdge)">
            <summary>
            Returns the target pattern node of the given edge, null if edge dangles to the right
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Name">
            <summary>
            The name of the pattern graph
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Nodes">
            <summary>
            An array of all pattern nodes.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Edges">
            <summary>
            An array of all pattern edges.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Variables">
            <summary>
            An array of all pattern variables;
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicNodes">
            <summary>
            A two-dimensional array describing which pattern node may be matched non-isomorphic to which pattern node.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicEdges">
            <summary>
            A two-dimensional array describing which pattern edge may be matched non-isomorphic to which pattern edge.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicNodesGlobal">
            <summary>
            A two-dimensional array describing which pattern node may be matched non-isomorphic to which pattern node globally,
            i.e. the nodes are contained in different, but locally nested patterns (alternative cases, iterateds).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicEdgesGlobal">
            <summary>
            A two-dimensional array describing which pattern edge may be matched non-isomorphic to which pattern edge globally,
            i.e. the edges are contained in different, but locally nested patterns (alternative cases, iterateds).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.EmbeddedGraphs">
            <summary>
            An array with subpattern embeddings, i.e. subpatterns and the way they are connected to the pattern
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Alternatives">
            <summary>
            An array of alternatives, each alternative contains in its cases the subpatterns to choose out of.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Iterateds">
            <summary>
            An array of iterated patterns, each iterated is matched as often as possible.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.NegativePatternGraphs">
            <summary>
            An array of negative pattern graphs which make the search fail if they get matched
            (NACs - Negative Application Conditions).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.IndependentPatternGraphs">
            <summary>
            An array of independent pattern graphs which must get matched in addition to the main pattern
            (PACs - Positive Application Conditions).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.EmbeddingGraph">
            <summary>
            The pattern graph which contains this pattern graph, null if this is a top-level-graph
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding">
            <summary>
            Embedding of a subpattern into it's containing pattern
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding.Name">
            <summary>
            The name of the usage of the subpattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding.EmbeddedGraph">
            <summary>
            The embedded subpattern
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IAlternative">
            <summary>
            An alternative is a pattern graph element containing subpatterns
            of which one must get successfully matched so that the entire pattern gets matched successfully
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IAlternative.AlternativeCases">
            <summary>
            Array with the alternative cases
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatchingPattern">
            <summary>
            A description of a GrGen matching pattern, that's a subpattern/subrule or the base for some rule.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.PatternGraph">
            <summary>
            The main pattern graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.Inputs">
            <summary>
            An array of GrGen types corresponding to rule parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.InputNames">
            <summary>
            An array of the names corresponding to rule parameters;
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IRulePattern">
            <summary>
            A description of a GrGen rule.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IRulePattern.Outputs">
            <summary>
            An array of GrGen types corresponding to rule return values.
            </summary>
        </member>
    </members>
</doc>
