<?xml version="1.0"?>
<doc>
    <assembly>
        <name>libGr</name>
    </assembly>
    <members>
        <member name="T:de.unika.ipd.grGen.libGr.ProcessSpecFlags">
            <summary>
            Flags which determine, how the specification file should be processed.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseNoExistingFiles">
            <summary>
            Do not use existing files.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseJavaGeneratedFiles">
            <summary>
            Only use existing C# files generated by the Java frontend.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseAllGeneratedFiles">
            <summary>
            Use all existing C# files.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.UseExistingMask">
            <summary>
            Mask for flags specifying whether and how already existing C# files shall be used while processing a specification.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.KeepGeneratedFiles">
            <summary>
            Do not delete generated C# files.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.CompileWithDebug">
            <summary>
            Include debug information in the generated assemblies.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoProcessActions">
            <summary>
            Do not process intermediate actions file (stops after model has been processed).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoCreateActionsAssembly">
            <summary>
            Do not compile the generated final actions file.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoDebugEvents">
            <summary>
            Do not fire debug (mostly action) events in the generated code. Used for optimization.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.NoEvents">
            <summary>
            Do not fire (attribute change) events in the generated code. Used for optimization.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.LazyNIC">
            <summary>
            Execute the negatives, independents, and conditionals only at the end of matching.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.Noinline">
            <summary>
            Forbids inlining of subpatterns and independents (allows quick disabling in case of a bug of for comparison).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.Profile">
            <summary>
            Profiling information is collected, i.e. some statistics about search steps carried out
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcessSpecFlags.GenerateEvenIfSourcesDidNotChange">
            <summary>
            Generates anew even if the sources did not change (needed to get a new build e.g. after changing profiling or statistics)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IBackend">
            <summary>
            A helper class for backend independent graph and rule handling.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IBackend.Name">
            <summary>
            The name of the backend.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IBackend.ArgumentNames">
            <summary>
            Enumerates the names of the arguments which can be optionally passed to the create/open functions.
            Not currently used...
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateGraph(de.unika.ipd.grGen.libGr.IGraphModel,System.String,System.String[])">
            <summary>
            Creates a new IGraph backend instance with the given graph model and name.
            </summary>
            <param name="graphModel">An IGraphModel instance.</param>
            <param name="graphName">Name of the graph.</param>
            <param name="parameters">Backend specific parameters.</param>
            <returns>The new IGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateNamedGraph(de.unika.ipd.grGen.libGr.IGraphModel,System.String,System.String[])">
            <summary>
            Creates a new INamedGraph backend instance with the given graph model and name.
            </summary>
            <param name="graphModel">An IGraphModel instance.</param>
            <param name="graphName">Name of the graph.</param>
            <param name="parameters">Backend specific parameters.</param>
            <returns>The new INamedGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateGraph(System.String,System.String,System.String[])">
            <summary>
            Creates a new IGraph backend instance with the graph model provided by the graph model file and a name.
            </summary>
            <param name="modelFilename">Filename of a graph model file.</param>
            <param name="graphName">Name of the graph.</param>
            <param name="parameters">Backend specific parameters.</param>
            <returns>The new IGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateNamedGraph(System.String,System.String,System.String[])">
            <summary>
            Creates a new INamedGraph backend instance with the graph model provided by the graph model file and a name.
            </summary>
            <param name="modelFilename">Filename of a graph model file.</param>
            <param name="graphName">Name of the graph.</param>
            <param name="parameters">Backend specific parameters.</param>
            <returns>The new INamedGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateFromSpec(System.String,System.String,System.String,de.unika.ipd.grGen.libGr.ProcessSpecFlags,System.Collections.Generic.List{System.String},de.unika.ipd.grGen.libGr.IGraph@,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Creates a new IGraph and IActions backend instance from the specified specification file.
            If neccessary, any processing steps are performed automatically.
            </summary>
            <param name="grgFilename">Filename of the rule specification file (.grg).</param>
            <param name="graphName">Name of the new graph.</param>
            <param name="statisticsPath">Optional path to a file containing the graph statistics to be used for building the matchers.</param>
            <param name="flags">Specifies how the specification is to be processed; only KeepGeneratedFiles and CompileWithDebug are taken care of!</param>
            <param name="externalAssemblies">List of external assemblies to reference.</param>
            <param name="newGraph">Returns the new graph.</param>
            <param name="newActions">Returns the new IActions object.</param>
            <exception cref="T:System.Exception">Thrown when something goes wrong.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateNamedFromSpec(System.String,System.String,System.String,de.unika.ipd.grGen.libGr.ProcessSpecFlags,System.Collections.Generic.List{System.String},System.Int32,de.unika.ipd.grGen.libGr.INamedGraph@,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Creates a new INamedGraph and IActions backend instance from the specified specification file.
            If neccessary, any processing steps are performed automatically.
            </summary>
            <param name="grgFilename">Filename of the rule specification file (.grg).</param>
            <param name="graphName">Name of the new graph.</param>
            <param name="statisticsPath">Optional path to a file containing the graph statistics to be used for building the matchers.</param>
            <param name="flags">Specifies how the specification is to be processed; only KeepGeneratedFiles and CompileWithDebug are taken care of!</param>
            <param name="externalAssemblies">List of external assemblies to reference.</param>
            <param name="capacity">The initial capacity for the name maps (performance optimization, use 0 if unsure).</param>
            <param name="newGraph">Returns the new named graph.</param>
            <param name="newActions">Returns the new IActions object.</param>
            <exception cref="T:System.Exception">Thrown when something goes wrong.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateFromSpec(System.String,System.String,System.String,de.unika.ipd.grGen.libGr.ProcessSpecFlags,System.Collections.Generic.List{System.String})">
            <summary>
            Creates a new IGraph instance from the specified specification file.
            If the according dll does not exist or is out of date, the needed processing steps are performed automatically.
            </summary>
            <param name="gmFilename">Filename of the model specification file (.gm).</param>
            <param name="graphName">Name of the new graph.</param>
            <param name="statisticsPath">Optional path to a file containing the graph statistics to be used for building the matchers.</param>
            <param name="flags">Specifies how the specification is to be processed; only KeepGeneratedFiles and CompileWithDebug are taken care of!</param>
            <param name="externalAssemblies">List of external assemblies to reference.</param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown, when a needed specification file does not exist.</exception>
            <exception cref="T:System.Exception">Thrown, when something goes wrong.</exception>
            <returns>The new IGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.CreateNamedFromSpec(System.String,System.String,System.String,de.unika.ipd.grGen.libGr.ProcessSpecFlags,System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            Creates a new INamedGraph instance from the specified specification file.
            If the according dll does not exist or is out of date, the needed processing steps are performed automatically.
            </summary>
            <param name="gmFilename">Filename of the model specification file (.gm).</param>
            <param name="graphName">Name of the new graph.</param>
            <param name="statisticsPath">Optional path to a file containing the graph statistics to be used for building the matchers.</param>
            <param name="flags">Specifies how the specification is to be processed; only KeepGeneratedFiles and CompileWithDebug are taken care of!</param>
            <param name="externalAssemblies">List of external assemblies to reference.</param>
            <param name="capacity">The initial capacity for the name maps (performance optimization, use 0 if unsure).</param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown, when a needed specification file does not exist.</exception>
            <exception cref="T:System.Exception">Thrown, when something goes wrong.</exception>
            <returns>The new INamedGraph backend instance.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.ProcessSpecification(System.String,System.String,System.String,System.String,de.unika.ipd.grGen.libGr.ProcessSpecFlags,System.String[])">
            <summary>
            Processes the given rule specification file and generates a model and actions library.
            </summary>
            <param name="specPath">The path to the rule specification file (.grg).</param>
            <param name="destDir">The directory, where the generated libraries are to be placed.</param>
            <param name="intermediateDir">A directory, where intermediate files can be placed.</param>
            <param name="statisticsPath">Optional path to a file containing the graph statistics to be used for building the matchers.</param>
            <param name="flags">Specifies how the specification is to be processed.</param>
            <param name="externalAssemblies">External assemblies to reference</param>
            <exception cref="T:System.Exception">Thrown, when an error occurred.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IBackend.ProcessSpecification(System.String)">
            <summary>
            Processes the given rule specification file and generates a model and actions library in the same directory as the specification file.
            </summary>
            <param name="specPath">The path to the rule specification file (.grg).</param>
            <exception cref="T:System.Exception">Thrown, when an error occurred.</exception>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BaseActions">
            <summary>
            A partial implementation of the interface to the actions. 
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.Actions">
            <summary>
            Enumerates all actions managed by this BaseActions instance.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.GetAction(System.String)">
            <summary>
            Gets the action with the given name.
            </summary>
            <param name="name">The name of the action.</param>
            <returns>The action with the given name, or null, if no such action exists.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.RegisterGraphRewriteSequenceDefinition(de.unika.ipd.grGen.libGr.SequenceDefinition)">
            <summary>
            Register a graph rewrite sequence definition.
            An interpreted sequence can be overwritten by a new one of the same name and signature.
            A compiled sequence is fixed, an exception is thrown if you try to set a sequence of the same name.
            </summary>
            <param name="sequenceDef">The sequence definition</param>
            <returns>Returns true if an existing definition was overwritten.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.GetSequenceDefinition(System.String)">
            <summary>
            Retrieve a graph rewrite sequence definition.
            </summary>
            <param name="name">The name of the defined sequence to retrieve</param>
            <returns>The defined sequence or null if no such sequence exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.SequenceDefinitions">
            <summary>
            Enumerates all graph rewrite sequence definitions.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.GetFunctionDefinition(System.String)">
            <summary>
            Retrieve a function definition.
            </summary>
            <param name="name">The name of the function to retrieve</param>
            <returns>The function or null if no such function exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.FunctionDefinitions">
            <summary>
            Enumerates all function definitions.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.FunctionNames">
            <summary>
            returns a comma separated list of the names of the functions known 
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseActions.GetProcedureDefinition(System.String)">
            <summary>
            Retrieve a procedure definition.
            </summary>
            <param name="name">The name of the procedure to retrieve</param>
            <returns>The procedure or null if no such procedure exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.ProcedureDefinitions">
            <summary>
            Enumerates all procedure definitions.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.BaseActions.ProcedureNames">
            <summary>
            returns a comma separated list of the names of the procedures known 
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BaseGraph">
            <summary>
            A partial implementation of the IGraph interface.
            Adding some methods implemented over the IGraph interface (some convenience stuff).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.NodeAdded(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnNodeAdded event.
            </summary>
            <param name="node">The added node.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.EdgeAdded(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnEdgeAdded event.
            </summary>
            <param name="edge">The added edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemovingNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnRemovingNode event.
            </summary>
            <param name="node">The node to be removed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemovingEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnRemovingEdge event.
            </summary>
            <param name="edge">The edge to be removed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RemovingEdges(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnRemovingEdges event.
            </summary>
            <param name="node">The node whose edges are to be removed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.ClearingGraph">
            <summary>
            Fires an OnClearingGraph event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RetypingNode(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Fires an OnRetypingNode event.
            </summary>
            <param name="oldNode">The node to be retyped.</param>
            <param name="newNode">The new node with the common attributes, but without any incident edges assigned, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RetypingEdge(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnRetypingEdge event.
            </summary>
            <param name="oldEdge">The edge to be retyped.</param>
            <param name="newEdge">The new edge with the common attributes, but not fully connected with the incident nodes, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.RedirectingEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Fires an OnRedirectingEdge event.
            </summary>
            <param name="oldEdge">The edge to be retyped.</param>
            <param name="newEdge">The new edge with the common attributes, but not fully connected with the incident nodes, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.VisitedAlloc(System.Int32)">
            <summary>
            Fires an OnVisitedAlloc event.
            </summary>
            <param name="visitorID">The allocated visitorID.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.VisitedFree(System.Int32)">
            <summary>
            Fires an OnVisitedFree event.
            </summary>
            <param name="visitorID">The freed visitorID.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.SettingVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32,System.Boolean)">
            <summary>
            Fires an OnSettingVisited event.
            </summary>
            <param name="elem">The graph element of which the specified flag is to be set.</param>
            <param name="visitorID">The id of the visited flag to be set.</param>
            <param name="newValue">The new value.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetNodeType(System.String)">
            <summary>
            Returns the node type with the given name.
            </summary>
            <param name="typeName">The name of a node type.</param>
            <returns>The node type with the given name or null, if it does not exist.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.BaseGraph.GetEdgeType(System.String)">
            <summary>
            Returns the edge type with the given name.
            </summary>
            <param name="typeName">The name of a edge type.</param>
            <returns>The edge type with the given name or null, if it does not exist.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetDictionaryTypes(System.Object,System.Type@,System.Type@)">
            <summary>
            If dict is dictionary, the dictionary is returned together with its key and value type
            </summary>
            <param name="dict">The object which should be a dictionary</param>
            <param name="keyType">The key type of the dictionary</param>
            <param name="valueType">The value type of the dictionary</param>
            <returns>The casted input dictionary, or null if not a dictionary</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetListType(System.Object,System.Type@)">
            <summary>
            If array is List, the List is returned together with its value type
            </summary>
            <param name="array">The object which should be a List</param>
            <param name="valueType">The value type of the List</param>
            <returns>The casted input List, or null if not a List</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetDequeType(System.Object,System.Type@)">
            <summary>
            If deque is Deque, the Deque is returned together with its value type
            </summary>
            <param name="deque">The object which should be a Deque</param>
            <param name="valueType">The value type of the Deque</param>
            <returns>The casted input Deque, or null if not a Deque</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetDictionaryTypes(System.Type,System.Type@,System.Type@)">
            <summary>
            The key and value types are returned of the dictionary
            </summary>
            <param name="dictType">The dictionary type</param>
            <param name="keyType">The key type of the dictionary</param>
            <param name="valueType">The value type of the dictionary</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetListType(System.Type,System.Type@)">
            <summary>
            The value type of the List is returned
            </summary>
            <param name="arrayType">The List type</param>
            <param name="valueType">The value type of the List</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetDequeType(System.Type,System.Type@)">
            <summary>
            The value type of the Deque is returned
            </summary>
            <param name="dequeType">The Deque type</param>
            <param name="valueType">The value type of the Deque</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetTypeFromNameForContainer(System.String,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns type object for type name string, to be used for container class, i.e. Dictionary, List, Deque
            </summary>
            <param name="typeName">Name of the type we want some type object for</param>
            <param name="graph">Graph to be search for enum,node,edge types / enum,node/edge type names</param>
            <returns>The type object corresponding to the given string, null if type was not found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetTypeFromNameForContainer(System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns type object for type name string, to be used for container class, i.e. Dictionary, List, Deque
            </summary>
            <param name="typeName">Name of the type we want some type object for</param>
            <param name="model">Graph model to be search for enum,node,edge types / enum,node/edge type names</param>
            <returns>The type object corresponding to the given string, null if type was not found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GetQualifiedTypeName(System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the qualified type name for the type name given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NewDictionary(System.Type,System.Type)">
            <summary>
            Creates a new dictionary of the given key type and value type
            </summary>
            <param name="keyType">The key type of the dictionary to be created</param>
            <param name="valueType">The value type of the dictionary to be created</param>
            <returns>The newly created dictionary, null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NewList(System.Type)">
            <summary>
            Creates a new List of the given value type
            </summary>
            <param name="valueType">The value type of the List to be created</param>
            <returns>The newly created List, null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NewDeque(System.Type)">
            <summary>
            Creates a new Deque of the given value type
            </summary>
            <param name="valueType">The value type of the Deque to be created</param>
            <returns>The newly created Deque, null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NewDictionary(System.Type,System.Type,System.Object)">
            <summary>
            Creates a new dictionary of the given key type and value type,
            initialized with the content of the old dictionary (clones the old dictionary)
            </summary>
            <param name="keyType">The key type of the dictionary to be created</param>
            <param name="valueType">The value type of the dictionary to be created</param>
            <param name="oldDictionary">The old dictionary to be cloned</param>
            <returns>The newly created dictionary, containing the content of the old dictionary,
            null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NewList(System.Type,System.Object)">
            <summary>
            Creates a new List of the given value type,
            initialized with the content of the old List (clones the old List)
            </summary>
            <param name="valueType">The value type of the List to be created</param>
            <param name="oldList">The old List to be cloned</param>
            <returns>The newly created List, containing the content of the old List,
            null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NewDeque(System.Type,System.Object)">
            <summary>
            Creates a new Deque of the given value type,
            initialized with the content of the old Deque (clones the old Deque)
            </summary>
            <param name="valueType">The value type of the Deque to be created</param>
            <param name="oldDeque">The old Deque to be cloned</param>
            <returns>The newly created Deque, containing the content of the old Deque,
            null if unsuccessfull</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Clone(System.Object)">
            <summary>
            Creates a shallow clone of the given container.
            </summary>
            <param name="oldContainer">The container to clone.</param>
            <returns>A shallow clone of the container</returns>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.ContainerHelper.Union``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Intersect``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a new dictionary containing all key/value pairs from
            <paramref name="a"/> whose keys are also contained in <paramref name="b"/>.
            If both dictionaries contain one key, the value from <paramref name="a"/> takes precedence, in contrast to union.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>A new dictionary containing all elements from <paramref name="a"/>,
            which are also in <paramref name="b"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Except``3(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``2})">
            <summary>
            Creates a new dictionary containing all key/value pairs from
            <paramref name="a"/> whose keys are not contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <returns>A new dictionary containing all elements from <paramref name="a"/>,
            which are not in <paramref name="b"/>.</returns>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.ContainerHelper.UnionChanged``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IntersectChanged``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Removes all key/value pairs from set/map <paramref name="a"/> whose keys are not also contained in <paramref name="b"/>.
            If both dictionaries contain one key, the value from <paramref name="a"/> takes precedence, in contrast to union.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ExceptChanged``3(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``2})">
            <summary>
            Removes all key/value pairs from set/map <paramref name="a"/> whose keys are contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.ContainerHelper.UnionChanged``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.ContainerHelper.UnionChanged``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.UnionChanged``1(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Adds all key/value pairs from set <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.UnionChanged``1(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Adds all key/value pairs from set <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IntersectChanged``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from map <paramref name="a"/> whose keys are not also contained in <paramref name="b"/>.
            If both dictionaries contain one key, the value from <paramref name="a"/> takes precedence, in contrast to union.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IntersectChanged``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from map <paramref name="a"/> whose keys are not also contained in <paramref name="b"/>.
            If both dictionaries contain one key, the value from <paramref name="a"/> takes precedence, in contrast to union.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IntersectChanged``1(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from set <paramref name="a"/> whose keys are not also contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IntersectChanged``1(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from set <paramref name="a"/> whose keys are not also contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ExceptChanged``3(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``2},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from map <paramref name="a"/> whose keys are contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ExceptChanged``3(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``2},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from map <paramref name="a"/> whose keys are contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ExceptChanged``2(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{``0,``1},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from set <paramref name="a"/> whose keys are contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ExceptChanged``2(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{``0,``1},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Removes all key/value pairs from set <paramref name="a"/> whose keys are contained in <paramref name="b"/>.
            </summary>
            <param name="a">A dictionary to change.</param>
            <param name="b">Another dictionary of compatible key type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.SetAsArray``1(System.Collections.Generic.Dictionary{``0,de.unika.ipd.grGen.libGr.SetValueType})">
            <summary>
            Creates a new dictionary representing a set containing all values from the given list.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IndexOf``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Returns the first position of entry in the array a
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <param name="entry">The value to search for.</param>
            <returns>The first position of entry in the array a, -1 if entry not in a.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IndexOfOrdered``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Returns the first position of entry in the array a that must be ordered with a binary search
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <param name="entry">The value to search for.</param>
            <returns>The first position of entry in the array a, -1 if entry not in a.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LastIndexOf``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Returns the first position from the end inwards of entry in the array a
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <param name="entry">The value to search for.</param>
            <returns>The first position from the end inwards of entry in the array a, -1 if entry not in a.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Subarray``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new dynamic array with length values copied from a from index start on.
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <param name="start">A start position in the dynamic array.</param>
            <param name="length">The number of elements to copy from start on.</param>
            <returns>A new List, i.e. dynamic array, containing the length first values from start on.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ArrayOrderAscending``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a new array containing the content of the old array but sorted.
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <returns>A new List with the content of the old list sorted.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ArrayOrderAscending(System.Collections.Generic.List{System.String})">
            <summary>
            Creates a new array containing the content of the old array but sorted.
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <returns>A new List with the content of the old list sorted.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ArrayReverse``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a new array containing the content of the old array but reversed.
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <returns>A new List with the content of the old list reversed.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ArrayAsSet``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a new dictionary representing a set containing all values from the given list.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ArrayAsMap``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a new dictionary representing a map containing all values from the given list, mapped to by their index.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ArrayAsDeque``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a new deque containing all values from the given list.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Concatenate``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Creates a new dynamic array and appends all values first from
            <paramref name="a"/> and then from <paramref name="b"/>.
            </summary>
            <param name="a">A List, i.e. dynamic array.</param>
            <param name="b">Another List, i.e. dynamic array of compatible type to <paramref name="a"/>.</param>
            <returns>A new List, i.e. dynamic array, containing a concatenation of the parameter arrays.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ConcatenateChanged``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Appends all values from dynamic array <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A List, i.e. dynamic array to change.</param>
            <param name="b">Another List, i.e. dynamic array of compatible type to <paramref name="a"/>.</param>
            <returns>A truth value telling whether a was changed (i.e. b not empty)</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ConcatenateChanged``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Appends all values from dynamic array <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A List, i.e. dynamic array to change.</param>
            <param name="b">Another List, i.e. dynamic array of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether a was changed (i.e. b not empty)</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ConcatenateChanged``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Appends all values from dynamic array <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A List, i.e. dynamic array to change.</param>
            <param name="b">Another List, i.e. dynamic array of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IndexOf``1(de.unika.ipd.grGen.libGr.Deque{``0},``0)">
            <summary>
            Returns the first position of entry in the deque a
            </summary>
            <param name="a">A Deque, i.e. double ended queue.</param>
            <param name="entry">The value to search for.</param>
            <returns>The first position of entry in the deque a, -1 if entry not in a.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LastIndexOf``1(de.unika.ipd.grGen.libGr.Deque{``0},``0)">
            <summary>
            Returns the first position from the end inwards of entry in the deque a
            </summary>
            <param name="a">A Deque, i.e. double ended queue.</param>
            <param name="entry">The value to search for.</param>
            <returns>The first position from the end inwards of entry in the deque a, -1 if entry not in a.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Subdeque``1(de.unika.ipd.grGen.libGr.Deque{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new deque with length values copied from a from index start on.
            </summary>
            <param name="a">A Deque, i.e. double ended queue.</param>
            <param name="start">A start position in the deque.</param>
            <param name="length">The number of elements to copy from start on.</param>
            <returns>A new Deque, containing the length first values from start on.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.DequeAsSet``1(de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Creates a new dictionary representing a set containing all values from the given list.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.DequeAsArray``1(de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Creates a new list representing an array containing all values from the given deque.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Concatenate``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Creates a new deque and appends all values first from
            <paramref name="a"/> and then from <paramref name="b"/>.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>A new Deque containing a concatenation of the parameter deques.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ConcatenateChanged``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Appends all values from deque <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A Deque to change.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>A truth value telling whether a was changed (i.e. b not empty)</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ConcatenateChanged``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Appends all values from deque <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A Deque to change.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the node containing the attribute which gets changed.</param>
            <param name="owner">The node containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether a was changed (i.e. b not empty)</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.ConcatenateChanged``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Appends all values from deque <paramref name="b"/> to <paramref name="a"/>.
            </summary>
            <param name="a">A Deque to change.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <param name="graph">The graph containing the edge containing the attribute which gets changed.</param>
            <param name="owner">The edge containing the attribute which gets changed.</param>
            <param name="attrType">The attribute type of the attribute which gets changed.</param>
            <returns>A truth value telling whether at least one element was changed in a</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Domain``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a new dictionary representing a set,
            containing all keys from the given dictionary representing a map <paramref name="map"/>.
            </summary>
            <param name="map">A dictionary representing a map.</param>
            <returns>A new set dictionary containing all keys from <paramref name="map"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Range``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a new dictionary representing a set,
            containing all values from the given dictionary representing a map <paramref name="map"/>.
            </summary>
            <param name="map">A dictionary representing a map.</param>
            <returns>A new set dictionary containing all values from <paramref name="map"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.MapAsArray``1(System.Collections.Generic.Dictionary{System.Int32,``0})">
            <summary>
            Creates a new list representing an array,
            containing all values from the given dictionary representing a map <paramref name="map"/> from int to some values.
            </summary>
            <param name="map">A dictionary representing a map.</param>
            <returns>A new list containing all values from <paramref name="map"/>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Peek``2(System.Collections.Generic.Dictionary{``0,``1},System.Int32)">
            <summary>
            Returns the value from the dictionary at the nth position as defined by the iterator of the dictionary.
            </summary>
            <param name="dict">A dictionary.</param>
            <param name="num">The number of the element to get in the iteration sequence.</param>
            <returns>The element at the position to get.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Peek(System.Object,System.Int32)">
            <summary>
            Returns the value from the dictionary or list or deque at the nth position as defined by the iterator of the dictionary or the index of the list or the iterator of the deque.
            </summary>
            <param name="obj">A dictionary or a list or a deque.</param>
            <param name="num">The number of the element to get in the iteration sequence.</param>
            <returns>The element at the position to get.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Peek(System.Object)">
            <summary>
            Returns the value from the deque begin or array end.
            </summary>
            <param name="obj">A list or a deque.</param>
            <returns>The element at the list end or deque begin.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Equal``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> equals set/map <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.EqualIDictionary(System.Collections.IDictionary,System.Collections.IDictionary)">
            <summary>
            Checks if set/map <paramref name="a"/> equals set/map <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NotEqual``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is not equal to set/map <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GreaterThan``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a proper superset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GreaterOrEqual``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a superset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LessThan``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a proper subset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LessOrEqual``2(System.Collections.Generic.Dictionary{``0,``1},System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Checks if set/map <paramref name="a"/> is a subset/map of <paramref name="b"/>.
            For a map, key and value must be same to be equal.
            </summary>
            <param name="a">A dictionary.</param>
            <param name="b">Another dictionary of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of set/map comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Equal``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if List <paramref name="a"/> equals List <paramref name="b"/>.
            Requires same values at same index for being true.
            </summary>
            <param name="a">A List.</param>
            <param name="b">Another List of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of List comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NotEqual``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if List <paramref name="a"/> is not equal List <paramref name="b"/>.
            </summary>
            <param name="a">A List.</param>
            <param name="b">Another List of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of List comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GreaterThan``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if List <paramref name="a"/> is a proper superlist of <paramref name="b"/>.
            Requires a to contain more entries than b and same values at same index for being true.
            </summary>
            <param name="a">A List.</param>
            <param name="b">Another List of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of List comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GreaterOrEqual``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if List <paramref name="a"/> is a superlist of <paramref name="b"/>.
            Requires a to contain more or same number of entries than b and same values at same index for being true.
            </summary>
            <param name="a">A List.</param>
            <param name="b">Another List of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of List comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LessThan``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if List <paramref name="a"/> is a proper sublist of <paramref name="b"/>.
            Requires a to contain less entries than b and same values at same index for being true.
            </summary>
            <param name="a">A List.</param>
            <param name="b">Another List of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of List comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LessOrEqual``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Checks if List <paramref name="a"/> is a sublist of <paramref name="b"/>.
            Requires a to contain less or same number of entries than b and same values at same index for being true.
            </summary>
            <param name="a">A List.</param>
            <param name="b">Another List of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of List comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.Equal``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Checks if Deque <paramref name="a"/> equals Deque <paramref name="b"/>.
            Requires same values at same position for being true.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of Deque comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.NotEqual``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Checks if Deque <paramref name="a"/> is not equal Deque <paramref name="b"/>.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of Deque comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GreaterThan``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Checks if Deque <paramref name="a"/> is a proper superdeque of <paramref name="b"/>.
            Requires a to contain more entries than b and same values at same position for being true.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of Deque comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.GreaterOrEqual``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Checks if Deque <paramref name="a"/> is a superdeque of <paramref name="b"/>.
            Requires a to contain more or same number of entries than b and same values at same position for being true.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of Deque comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LessThan``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Checks if Deque <paramref name="a"/> is a proper subseque of <paramref name="b"/>.
            Requires a to contain less entries than b and same values at same position for being true.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of Deque comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.LessOrEqual``1(de.unika.ipd.grGen.libGr.Deque{``0},de.unika.ipd.grGen.libGr.Deque{``0})">
            <summary>
            Checks if Deque <paramref name="a"/> is a subdeque of <paramref name="b"/>.
            Requires a to contain less or same number of entries than b and same values at same positions for being true.
            </summary>
            <param name="a">A Deque.</param>
            <param name="b">Another Deque of compatible type to <paramref name="a"/>.</param>
            <returns>Boolean result of Deque comparison.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IfAttributeOfElementIsContainerThenCloneContainer(de.unika.ipd.grGen.libGr.IGraphElement,System.String,System.Object,de.unika.ipd.grGen.libGr.AttributeType@)">
            <summary>
            If the attribute of the given name of the given element is a container attribute
            then return a clone of the given container value, otherwise just return the original value;
            additionally returns the AttributeType of the attribute of the element.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ContainerHelper.IfAttributeOfElementIsContainerThenCloneContainer(de.unika.ipd.grGen.libGr.IGraphElement,System.String,System.Object)">
            <summary>
            If the attribute of the given name of the given element is a conatiner attribute
            then return a clone of the given container value, otherwise just return the original value
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IDeque">
            <summary>
            Interface of a Double Ended Queue. 
            (Why is there none in the .NET collection library?)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Deque`1">
            <summary>
            Class implementing a Double Ended Queue. 
            Items can be added and removed in O(1) at the beginning and at the end, and accessed at an arbitrary index in O(1).
            Implemented by a ring buffer that is doubled in size (and the old content copied) when necessary (so insert is only amortized O(1)).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Collections.IDictionary,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given dictionary
            </summary>
            <param name="setmap">The dictionary of which to get the string representation</param>
            <param name="graph">The graph with the model and the element names if available, otherwise null</param>
            <returns>string representation of dictionary</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Collections.IList,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given List
            </summary>
            <param name="array">The List of which to get the string representation</param>
            <param name="graph">The graph with the model and the element names if available, otherwise null</param>
            <returns>string representation of List</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(de.unika.ipd.grGen.libGr.IDeque,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given Deque
            </summary>
            <param name="deque">The Deque of which to get the string representation</param>
            <param name="graph">The graph with the model and the element names if available, otherwise null</param>
            <returns>string representation of Deque</returns>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Collections.IDictionary,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Collections.IList,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(de.unika.ipd.grGen.libGr.IDeque,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Collections.IDictionary,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Collections.IList,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)" ignoriert -->
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(de.unika.ipd.grGen.libGr.IDeque,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given scalar value
            </summary>
            <param name="value">The scalar value of which to get the string representation</param>
            <param name="graph">The graph with the model and the element names if available, otherwise null</param>
            <returns>string representation of scalar value</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToStringNonNull(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given value, which must be not null (for emit,record)
            </summary>
            <param name="value">The value of which to get the string representation</param>
            <param name="graph">The graph with the model and the element names if available, otherwise null</param>
            <returns>string representation of the value</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Object,System.String@,System.String@,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given scalar value
            </summary>
            <param name="value">The scalar value of which to get the string representation</param>
            <param name="type">The type as string, e.g int,string,Foo </param>
            <param name="content">The content as string, e.g. 42,"foo",bar } </param>
            <param name="attrType">The attribute type of the value (may be null)</param>
            <param name="graph">The graph with the model and the element names</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToString(System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given scalar value
            </summary>
            <param name="value">The scalar of which to get the string representation</param>
            <param name="attrType">The attribute type</param>
            <param name="graph">The graph with the model and the element names</param>
            <returns>String representation of the scalar.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToStringObject(System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given scalar value of attribute kind object,
            i.e. an externally defined type, maybe registered as external type to GrGen, maybe not, only defined as object
            </summary>
            <param name="value">The scalar of which to get the string representation</param>
            <param name="attrType">The attribute type</param>
            <param name="graph">The graph with the model and the element names</param>
            <returns>String representation of the scalar.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmitHelper.ToStringAutomatic(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns a string representation of the given value, might be a scalar, a dictionary, a list, or a deque
            </summary>
            <param name="value">The value of which to get the string representation</param>
            <param name="graph">The graph with the model and the element names if available, otherwise null</param>
            <returns>string representation of value</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.FilterCall">
            <summary>
            An object representing a filter call.
            It specifies the filter and potential arguments.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.Name">
            <summary>
            The name of the filter.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.Package">
            <summary>
            null if this is a call of a global filter, otherwise the package the call target is contained in.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.PackagePrefixedName">
            <summary>
            The name of the filter, prefixed by the package it is contained in (separated by a double colon), if it is contained in a package.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.PrePackage">
            <summary>
            null if this is a call of a global filter, otherwise the package the call target is contained in.
            May be even null for a call of a package target, if done from a context where the package is set.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.PrePackageContext">
            <summary>
            The package this invocation is contained in (the calling source, not the filter call target).
            Needed to resolve names from the local package accessed without package prefix.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.Entity">
            <summary>
            The entity the filter is based on, in case of a def-variable based auto-generated filter, otherwise null.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.IsAutoSupplied">
            <summary>
            True in case this is the call of an auto-supplied filter.
            In this case, there must be exactly one Argument or ArgumentExpression given.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.ArgumentExpressions">
            <summary>
            An array of expressions used to compute the input arguments for a filter function (or auto-supplied filter).
            It must have the same length as Arguments.
            If an entry is null, the according entry in Arguments is used unchanged.
            Otherwise the entry in Arguments is filled with the evaluation result of the expression.
            The sequence parser generates argument expressions for every entry;
            they may be omitted by a user assembling an invocation at API level.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FilterCall.Arguments">
            <summary>
            Buffer to store the argument values for the filter function call (or auto-supplied filter call);
            used by libGr to avoid unneccessary memory allocations.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.FilterCall.#ctor(System.String,System.String,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.SequenceExpression},System.String)">
            <summary>
            Instantiates a new FilterCall object for a filter function or auto
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.FilterCall.#ctor(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Instantiates a new FilterCall object for an auto-generated filter
            dummy is only existing so that FilterCall(null, "auto", null, null, true) can be resolved to this constructor
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.FilterCall.#ctor(System.String,System.String,de.unika.ipd.grGen.libGr.SequenceExpression,System.String)">
            <summary>
            Instantiates a new FilterCall object for an auto-supplied filter (with sequence expression parameter)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.FunctionInfo">
            <summary>
            A description of a GrGen (attribute evaluation) function.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.FunctionInfo.#ctor(System.String,System.String,System.String,System.Boolean,System.String[],de.unika.ipd.grGen.libGr.GrGenType[],de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Constructs a FunctionInfo object.
            </summary>
            <param name="name">The name the function was defined with.</param>
            <param name="package">null if this is a global pattern graph, otherwise the package the pattern graph is contained in.</param>
            <param name="packagePrefixedName">The name of the pattern graph in case of a global type,
            the name of the pattern graph is prefixed by the name of the package otherwise (package "::" name).</param>
            <param name="isExternal">Tells whether the function is an externally defined one or an internal one.</param>
            <param name="inputNames">The names of the input parameters.</param>
            <param name="inputs">The types of the input parameters.</param>
            <param name="output">The type of the output parameter.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.name">
            <summary>
            The name of the function.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.annotations">
            <summary>
            The annotations of the function
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.packagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.inputNames">
            <summary>
            Names of the function parameters.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.inputs">
            <summary>
            The GrGen types of the function parameters.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.output">
            <summary>
            The GrGen type of the function return value.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInfo.isExternal">
            <summary>
            Tells whether the function is an externally defined one or an internal one
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.FunctionInfo.Apply(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.FunctionInvocationParameterBindings)">
            <summary>
            Applies this function with the given action environment on the given graph.
            Takes the parameters from paramBindings as inputs.
            Returns the one output value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Nodes(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the nodes in the graph of the type given, as set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Edges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the edges in the graph of the type given, as set of IEdge
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.EdgesDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the directed edges in the graph of the type given, as set of IDEdge
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.EdgesUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the undirected edges in the graph of the type given, as set of IUEdge
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountNodes(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes in the graph of the type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the count of the edges in the graph of the type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Adjacent(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes adjacent to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AdjacentOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes adjacent to the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AdjacentIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes adjacent to the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountAdjacent(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes adjacent to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountAdjacentOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes adjacent to the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountAdjacentIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes adjacent to the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Incident(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncidentDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of directed edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncidentUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of undirected edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Outgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.OutgoingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of directed edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.OutgoingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of undirected edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Incoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncomingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of directed edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncomingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of undirected edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountIncident(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns count of the edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns count of the edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns count of the edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Reachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Reachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType})">
            <summary>
            Fills set of nodes reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType})">
            <summary>
            Fills set of nodes reachable from the start node via outgoing edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType})">
            <summary>
            Fills set of nodes reachable from the start node via incoming edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes reachable from the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes reachable from the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdges(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of directed edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of undirected edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of outgoing edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of outgoing directed edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of outgoing undirected edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of outgoing edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of outgoing directed edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of outgoing undirected edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of incoming edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of incoming edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of incoming edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of incoming edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of incoming directed edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of incoming undirected edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the outgoing edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the incoming edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachable(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachable(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Fills set of nodes reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Fills set of nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Fills set of nodes reachable from the start node within the given depth via incoming edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableWithRemainingDepth(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableWithRemainingDepthOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableWithRemainingDepthIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachable(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the nodes reachable from the start node within the given depth via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of directed edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of undirected edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdges(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesDirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of directed edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesUndirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of undirected edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of outgoing edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of outgoing directed edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of outgoing undirected edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of outgoing edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of outgoing directed edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of outgoing undirected edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of incoming edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of incoming directed edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns set of incoming undirected edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of incoming edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of incoming directed edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Fills set of incoming undirected edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the outgoing edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the count of the incoming edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsAdjacent(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is adajcent to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsAdjacentOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is adajcent to the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsAdjacentIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is adajcent to the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsIncident(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is incident to the start node as outgoing edge, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is incident to the start node as outgoing edge, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachable(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode})">
            <summary>
            Returns whether the end node is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode})">
            <summary>
            Returns whether the end node is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode})">
            <summary>
            Returns whether the end node is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdges(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode})">
            <summary>
            Returns whether the end edge is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode})">
            <summary>
            Returns whether the end edge is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode})">
            <summary>
            Returns whether the end edge is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachable(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdges(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32})">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InducedSubgraph(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the induced subgraph of the given node set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.DefinedSubgraph(System.Collections.IDictionary,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the edge induced/defined subgraph of the given edge set of unknown direction
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.DefinedSubgraph(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the edge induced/defined subgraph of the given edge set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.DefinedSubgraphDirected(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the edge induced/defined subgraph of the given directed edge set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.DefinedSubgraphUndirected(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the edge induced/defined subgraph of the given undirected edge set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InsertInduced(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts a copy of the induced subgraph of the given node set to the graph
            returns the copy of the dedicated root node
            the root node is processed as if it was in the given node set even if it isn't
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InsertDefined(System.Collections.IDictionary,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts a copy of the edge induced/defined subgraph of the given edge set to the graph
            returns the copy of the dedicated root edge
            the root edge is processed as if it was in the given edge set even if it isn't
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InsertDefined(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts a copy of the edge induced/defined subgraph of the given edge set to the graph
            returns the copy of the dedicated root edge
            the root edge is processed as if it was in the given edge set even if it isn't
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InsertDefinedDirected(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts a copy of the edge induced/defined subgraph of the given directed edge set to the graph
            returns the copy of the dedicated directed root edge
            the root edge is processed as if it was in the given edge set even if it isn't
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InsertDefinedUndirected(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts a copy of the edge induced/defined subgraph of the given undirected edge set to the graph
            returns the copy of the dedicated undirected root edge
            the root edge is processed as if it was in the given edge set even if it isn't
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Copy(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Copies the given graph, returns the copy
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.InsertCopy(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts a copy of the given subgraph to the graph (disjoint union).
            Returns the copy of the dedicated root node.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Insert(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Inserts the given subgraph to the graph, destroying the source (destructive disjoint union).
            The elements keep their identity (though not their name).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Nameof(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the name of the given entity (which might be a node, an edge, or a graph).
            If the entity is null, the name of the graph is returned.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Uniqueof(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns the unique if of the given entity (which might be a node, an edge, or a graph).
            If the entity is null, the unique id of the graph is returned.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Import(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Imports and returns the graph within the file specified by its path (model from given graph).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Export(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Exports the graph to the file specified by its path.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AddCopyOfNode(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            creates a node of given type and adds it to the graph, returns it
            type might be a string denoting a NodeType or a NodeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AddCopyOfEdge(System.Object,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            creates an edge of given type and adds it to the graph between from and to, returns it
            type might be a string denoting an EdgeType or an EdgeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AddNodeOfType(System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            creates a node of given type and adds it to the graph, returns it
            type might be a string denoting a NodeType or a NodeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AddEdgeOfType(System.Object,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            creates an edge of given type and adds it to the graph between from and to, returns it
            type might be a string denoting an EdgeType or an EdgeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.RetypeNode(de.unika.ipd.grGen.libGr.INode,System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            retypes a node to the given type, returns it
            type might be a string denoting a NodeType or a NodeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.RetypeEdge(de.unika.ipd.grGen.libGr.IEdge,System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            retypes an edge to the given type, returns it
            type might be a string denoting an EdgeType or an EdgeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.RetypeGraphElement(de.unika.ipd.grGen.libGr.IGraphElement,System.Object,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            retypes a graph element to the given type, returns it
            type might be a string denoting a NodeType or EdgeType, or a NodeType or EdgeType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.EqualsAny(de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.SetValueType},System.Boolean)">
            <summary>
            Returns whether the candidate (sub)graph equals any of the graphs in the given set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Nodes(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the nodes in the graph of the type given, as set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Edges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType,System.Int32)">
            <summary>
            Returns the edges in the graph of the type given, as set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.EdgesDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType,System.Int32)">
            <summary>
            Returns the directed edges in the graph of the type given, as set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.EdgesUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType,System.Int32)">
            <summary>
            Returns the undirected edges in the graph of the type given, as set
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountNodes(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes in the graph of the type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.EdgeType,System.Int32)">
            <summary>
            Returns the count of the edges in the graph of the type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Adjacent(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes adjacent to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AdjacentOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes adjacent to the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.AdjacentIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes adjacent to the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountAdjacent(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes adjacent to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountAdjacentOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes adjacent to the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountAdjacentIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes adjacent to the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Incident(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncidentDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of directed edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncidentUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of undirected edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Outgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.OutgoingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of directed edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.OutgoingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of undirected edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Incoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncomingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of directed edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IncomingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of undirected edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountIncident(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns count of the edges incident to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns count of the edges outgoing from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns count of the edges incoming to the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Reachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.Reachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of nodes reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes reachable from the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of nodes reachable from the start node via outgoing edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes reachable from the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of nodes reachable from the start node via incoming edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes reachable from the start node via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes reachable from the start node via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of directed edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of undirected edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdges(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of directed edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of undirectd edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of outgoing edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of outgoing directed edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of outgoing undirected edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of outgoing edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of outgoing directed edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of outgoing undirected edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of incoming edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of incoming directed edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of incoming undirected edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of incoming edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of incoming directed edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.ReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Fills set of incoming undirected edges reachable from the start node, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the outgoing edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the incoming edges reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachable(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachable(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of nodes reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of nodes reachable from the start node within the given depth via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of nodes reachable from the start node within the given depth via incoming edges, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableWithRemainingDepth(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns map of nodes to remaining depth reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableWithRemainingDepthOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns map of nodes to remaining depth reachable from the start node within the given depth via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableWithRemainingDepthIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns map of nodes to remaining depth reachable from the start node within the given depth via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachable(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes reachable from the start node within the given depth via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the nodes reachable from the start node within the given depth via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of directed edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of undirected edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdges(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesDirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of directed edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesUndirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of undirected edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of outgoing edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of outgoing directed edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of outgoing undirected edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of outgoing edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingDirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of outgoing directed edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesOutgoingUndirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of outgoing undirected edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of incoming edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of incoming directed edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns set of incoming undirected edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingDirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IDEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of incoming directed edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncomingUndirected(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IUEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of incoming undirected edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.BoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Fills set of incoming edges reachable from the start node within the given depth, under the type constraints given, in a depth-first walk
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the outgoing edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.CountBoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns the count of the incoming edges reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachable(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode},System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode},System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.INode},System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdges(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.IGraphElement},System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.IGraphElement},System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.IGraphElement},System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachable(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachable(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Returns whether the end node is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdges(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdges(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesOutgoing(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via outgoing edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphHelper.IsBoundedReachableEdgesIncoming(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge,System.Int32,de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.INode,System.Int32},de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32)">
            <summary>
            Returns whether the end edge is reachable from the start node within the given depth, via incoming edges, under the type constraints given
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IActions">
            <summary>
            The interface to the actions (the "generic" interface, using strings and objects).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.Name">
            <summary>
            The name of the actions.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.Graph">
            <summary>
            The associated graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.Packages">
            <summary>
            The packages defined in this IActions instance.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActions.GetAction(System.String)">
            <summary>
            Gets the action with the given name.
            </summary>
            <param name="name">The name of the action.</param>
            <returns>The action with the given name, or null, if no such action exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.Actions">
            <summary>
            Enumerates all actions managed by this IActions instance.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActions.GetSequenceDefinition(System.String)">
            <summary>
            Retrieve a graph rewrite sequence definition.
            </summary>
            <param name="name">The name of the defined sequence to retrieve</param>
            <returns>The defined sequence or null if no such sequence exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.SequenceDefinitions">
            <summary>
            Enumerates all graph rewrite sequence definitions.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActions.GetFunctionDefinition(System.String)">
            <summary>
            Retrieve a function definition.
            </summary>
            <param name="name">The name of the function to retrieve</param>
            <returns>The function or null if no such function exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.FunctionDefinitions">
            <summary>
            Enumerates all function definitions.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActions.GetProcedureDefinition(System.String)">
            <summary>
            Retrieve a procedure definition.
            </summary>
            <param name="name">The name of the procedure to retrieve</param>
            <returns>The procedure or null if no such procedure exists.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.ProcedureDefinitions">
            <summary>
            Enumerates all procedure definitions.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActions.ModelMD5Hash">
            <summary>
            An MD5 hash of the used IGraphModel.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActions.Custom(System.Object[])">
            <summary>
            Does action-backend dependent stuff.
            </summary>
            <param name="args">Any kind of parameters for the stuff to do</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IIndex">
            <summary>
            Base class for a single index, the different kinds of indices.
            (You must typecheck and cast to the concrete index type for more information).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IIndex.Description">
            <summary>
            The description of the index.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IAttributeIndex">
            <summary>
            A single attribute index.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElements(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is equal to the value given.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscending">
            <summary>
            Lookup all graph elements in the index in ascending order.
            Index lookup begins at the graph element with the minimum attribute value.
            Index lookup ends at the graph element with the maximum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingFromInclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher or equal than the from value specified,
            in ascending order.
            Index lookup ends at the graph element with the maximum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingFromExclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher than the from value specified,
            in ascending order.
            Index lookup ends at the graph element with the maximum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingToInclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower or equal than the to value specified,
            in ascending order.
            Index lookup begins at the graph element with the minimum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingToExclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower than the to value specified, 
            in ascending order.
            Index lookup begins at the graph element with the minimum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingFromInclusiveToInclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher or equal than the from value specified, and
            lower or equal than the to value specified, 
            in ascending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingFromInclusiveToExclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher or equal than the from value specified, and
            lower than the to value specified,
            in ascending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingFromExclusiveToInclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher than the from value specified, and
            lower or equal than the to value specified, 
            in ascending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsAscendingFromExclusiveToExclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher than the from value specified, and
            lower than the to value specified, 
            in ascending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescending">
            <summary>
            Lookup all graph elements in the index in descending order.
            Index lookup begins at the graph element with the maximum attribute value.
            Index lookup ends at the graph element with the minimum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingFromInclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower or equal than the from value specified, 
            in descending order.
            Index lookup ends at the graph element with the minimum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingFromExclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower than the from value specified, 
            in descending order.
            Index lookup ends at the graph element with the minimum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingToInclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher or equal than the to value specified, 
            in descending order.
            Index lookup begins at the graph element with the maximum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingToExclusive(System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            higher than the to value specified, 
            in descending order.
            Index lookup begins at the graph element with the maximum attribute value.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingFromInclusiveToInclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower or equal than the from value specified, and
            higher or equal than the to value specified, 
            in descending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingFromInclusiveToExclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower or equal than the from value specified, and
            higher than the to value specified, 
            in descending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingFromExclusiveToInclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower than the from value specified, and
            higher or equal than the to value specified, 
            in descending order.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAttributeIndex.LookupElementsDescendingFromExclusiveToExclusive(System.Object,System.Object)">
            <summary>
            Lookup all graph elements in the index whose indexed attribute value is:
            lower than the from value specified, and
            higher than the to value specified, 
            in descending order.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IIncidenceCountIndex">
            <summary>
            A single incidence count index.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IIncidenceCountIndex.GetIncidenceCount(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Lookup the incidence count of the graph element given.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IIndexSet">
            <summary>
            The index set applied on a graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IIndexSet.GetIndex(System.String)">
            <summary>
            Returns the index of the given name associated with the graph,
            or null in case no index of the given name is known.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.InvocationParameterBindings">
            <summary>
            An object representing a rule or sequence or procedure or function invocation.
            It stores the input arguments (values) and
            tells with which sequence expressions to compute them.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.Name">
            <summary>
            The name of the rule or sequence or procedure or function.
            Used for compilation, where the rule or sequence or procedure or function representation objects do not exist yet.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.Package">
            <summary>
            null if this is a call of a global rule/sequence/procedure/function, otherwise the package the call target is contained in.
            Used for compilation, where the rule or sequence or procedure or function representation objects do not exist yet.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.PackagePrefixedName">
            <summary>
            The name of the rule or sequence or procedure or function, prefixed by the package it is contained in (separated by a double colon), if it is contained in a package.
            Used for compilation, where the rule or sequence or procedure or function representation objects do not exist yet.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.PrePackage">
            <summary>
            null if this is a call of a global rule/sequence/procedure/function, otherwise the package the call target is contained in.
            May be even null for a call of a package target, if done from a context where the package is set.
            Used for compilation, where the rule or sequence or procedure or function representation objects do not exist yet.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.PrePackageContext">
            <summary>
            The package this invocation is contained in (the calling source, not the rule/sequence/procedure/function call target).
            Needed to resolve names from the local package accessed without package prefix.
            Used for compilation, where the rule or sequence or procedure or function representation objects do not exist yet.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.ArgumentExpressions">
            <summary>
            An array of expressions used to compute the input arguments.
            It must have the same length as Arguments.
            If an entry is null, the according entry in Arguments is used unchanged.
            Otherwise the entry in Arguments is filled with the evaluation result of the expression.
            The sequence parser generates argument expressions for every entry;
            they may be omitted by a user assembling an invocation at API level.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindings.Arguments">
            <summary>
            Buffer to store the argument values for the call;
            used by libGr to avoid unneccessary memory allocations.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.InvocationParameterBindings.#ctor(de.unika.ipd.grGen.libGr.SequenceExpression[],System.Object[])">
            <summary>
            Instantiates a new InvocationParameterBindings object
            </summary>
            <param name="argExprs">An array of expressions used to compute the arguments</param>
            <param name="arguments">An array of arguments.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.InvocationParameterBindingsWithReturns">
            <summary>
            An object representing a rule or sequence or procedure invocation.
            It stores the input arguments (values),
            tells with which sequence expressions to compute them,
            and where (which variables) to store the output values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InvocationParameterBindingsWithReturns.ReturnVars">
            <summary>
            An array of variables used for the return values.
            Might be empty if the rule/sequence/procedure caller is not interested in available returns values.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.InvocationParameterBindingsWithReturns.#ctor(de.unika.ipd.grGen.libGr.SequenceExpression[],System.Object[],de.unika.ipd.grGen.libGr.SequenceVariable[])">
            <summary>
            Instantiates a new InvocationParameterBindingsWithReturns object
            </summary>
            <param name="argExprs">An array of expressions used to compute the arguments</param>
            <param name="arguments">An array of arguments.</param>
            <param name="returnVars">An array of variables used for the return values</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings">
            <summary>
            An object representing a rule invocation.
            It stores the input arguments (values),
            tells with which sequence expressions to compute them,
            and where (which variables) to store the output values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.Action">
            <summary>
            The IAction instance to be used
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.Subgraph">
            <summary>
            The subgraph to be switched to for rule execution
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings.#ctor(de.unika.ipd.grGen.libGr.IAction,de.unika.ipd.grGen.libGr.SequenceExpression[],System.Object[],de.unika.ipd.grGen.libGr.SequenceVariable[],de.unika.ipd.grGen.libGr.SequenceVariable)">
            <summary>
            Instantiates a new RuleInvocationParameterBindings object
            </summary>
            <param name="action">The IAction instance to be used</param>
            <param name="argExprs">An array of expressions used to compute the arguments</param>
            <param name="arguments">An array of arguments.</param>
            <param name="returnVars">An array of variables used for the return values</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceInvocationParameterBindings">
            <summary>
            An object representing a sequence invocation.
            It stores the input arguments (values),
            tells with which sequence expressions to compute them,
            and where (which variables) to store the output values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceInvocationParameterBindings.SequenceDef">
            <summary>
            The defined sequence to be used
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceInvocationParameterBindings.Subgraph">
            <summary>
            The subgraph to be switched to for sequence execution
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceInvocationParameterBindings.#ctor(de.unika.ipd.grGen.libGr.ISequenceDefinition,de.unika.ipd.grGen.libGr.SequenceExpression[],System.Object[],de.unika.ipd.grGen.libGr.SequenceVariable[],de.unika.ipd.grGen.libGr.SequenceVariable)">
            <summary>
            Instantiates a new SequenceInvocationParameterBindings object
            </summary>
            <param name="sequenceDef">The defined sequence to be used</param>
            <param name="argExprs">An array of expressions used to compute the arguments</param>
            <param name="arguments">An array of arguments.</param>
            <param name="returnVars">An array of variables used for the return values</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ProcedureInvocationParameterBindings">
            <summary>
            An object representing a procedure.
            It stores the input arguments (values),
            tells with which sequence expressions to compute them,
            and where (which variables) to store the output values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInvocationParameterBindings.ProcedureDef">
            <summary>
            The procedure to be used
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ProcedureInvocationParameterBindings.#ctor(de.unika.ipd.grGen.libGr.IProcedureDefinition,de.unika.ipd.grGen.libGr.SequenceExpression[],System.Object[],de.unika.ipd.grGen.libGr.SequenceVariable[])">
            <summary>
            Instantiates a new ProcedureInvocationParameterBindings object
            </summary>
            <param name="procedureDef">The defined procedure to be used</param>
            <param name="argExprs">An array of expressions used to compute the arguments</param>
            <param name="arguments">An array of arguments.</param>
            <param name="returnVars">An array of variables used for the return values</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.FunctionInvocationParameterBindings">
            <summary>
            An object representing a function invocation.
            It stores the input arguments (values) and
            tells with which function to compute them.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInvocationParameterBindings.FunctionDef">
            <summary>
            The function to be used
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.FunctionInvocationParameterBindings.ReturnType">
            <summary>
            The type returned
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.FunctionInvocationParameterBindings.#ctor(de.unika.ipd.grGen.libGr.IFunctionDefinition,de.unika.ipd.grGen.libGr.SequenceExpression[],System.Object[])">
            <summary>
            Instantiates a new FunctionInvocationParameterBindings object
            </summary>
            <param name="functionDef">The defined function to be used</param>
            <param name="argExprs">An array of expressions used to compute the arguments</param>
            <param name="arguments">An array of arguments.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DOTDumper">
            <summary>
            A VCG graph dumper.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.GetColor(de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Gets the DOT string representation of a GrColor object.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.GetLineStyle(de.unika.ipd.grGen.libGr.GrLineStyle)">
            <summary>
            Gets the DOT string representation of a GrLineStyle object.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.GetNodeShape(de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Gets the DOT string representation of a GrNodeShape object.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.#ctor(System.String,System.String,de.unika.ipd.grGen.libGr.VCGFlags)">
            <summary>
            Initializes a new instance of the DOTDumper.
            </summary>
            <param name="filename">Destination file.</param>
            <param name="graphname">Name of the host graph.</param>
            <param name="flags">Flags to control the dumper's behavior.</param>
            <exception cref="T:System.IO.IOException">Thrown when the destination cannot be created.</exception>
            TODO: replace VCGFlags by generic GrFlags (to be introduced and mapped to VCG and DOT)
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the DOTDumper with standard flags (VCGFlags.OrientBottomToTop).
            </summary>
            <param name="filename">Destination file.</param>
            <param name="graphname">Name of the host graph.</param>
            <exception cref="T:System.IO.IOException">Thrown when the destination cannot be created.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.DumpNode(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Dump a node to the DOT language graph.
            </summary>
            <param name="node">The node to be dumped.</param>
            <param name="label">The label to use for the node.</param>
            <param name="attributes">An enumerable of attribute strings.</param>
            <param name="textColor">The color of the text.</param>
            <param name="nodeColor">The color of the node.</param>
            <param name="borderColor">The color of the node border.</param>
            <param name="nodeShape">The shape of the node.</param>
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.DumpEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrLineStyle,System.Int32)">
            <summary>
            Dump an edge to the DOT language graph
            </summary>
            <param name="srcNode">The source node of the edge</param>
            <param name="tgtNode">The target node of the edge</param>
            <param name="label">The label of the edge, may be null</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="edgeColor">The color of the edge</param>
            <param name="lineStyle">The linestyle of the edge</param>
            <param name="thickness">The thickness of the edge (1-5)</param>
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.StartSubgraph(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Creates a new sub-graph to the DOT graph
            </summary>
            <param name="node">The node starting the new sub-graph</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="subgraphColor">The color of the subgraph node</param>
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.FinishSubgraph">
            <summary>
            Finishes a subgraph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.FinishDump">
            <summary>
            Finishes the dump and closes the file
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DOTDumper.Dispose">
            <summary>
            Disposes this object. If <see cref="M:de.unika.ipd.grGen.libGr.DOTDumper.FinishDump"/> has not been called yet, it is called.
            This allows using "using" with the dumper object.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IDumper">
            <summary>
            A dumper for output of graphs.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.DumpNode(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Dump a node.
            </summary>
            <param name="node">The node to be dumped</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="nodeColor">The color of the node</param>
            <param name="borderColor">The color of the node border</param>
            <param name="nodeShape">The shape of the node</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.DumpEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrLineStyle,System.Int32)">
            <summary>
            Dump an edge
            </summary>
            <param name="srcNode">The source node of the edge</param>
            <param name="tgtNode">The target node of the edge</param>
            <param name="label">The label of the edge, may be null</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="edgeColor">The color of the edge</param>
            <param name="lineStyle">The linestyle of the edge</param>
            <param name="thickness">The thickness of the edge</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.StartSubgraph(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Creates a new sub-graph
            </summary>
            <param name="node">The node starting the new sub-graph</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="subgraphColor">The color of the subgraph node</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.FinishSubgraph">
            <summary>
            Finishes a subgraph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IDumper.FinishDump">
            <summary>
            Finishes the dump and closes the file
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GroupMode">
            <summary>
            The supported group modes.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.None">
            <summary>
            Do not group any nodes.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.GroupIncomingNodes">
            <summary>
            Group only source nodes of incoming edges of the group node.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.GroupOutgoingNodes">
            <summary>
            Group only target nodes of outgoing edges of the group node.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.GroupAllNodes">
            <summary>
            Group all nodes connected to the group node.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupMode.Hidden">
            <summary>
            Hide the grouping edges in visualizations of the graph.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GroupNodeType">
            <summary>
            Specifies which nodes are grouped by this group node type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupNodeType.NodeType">
            <summary>
            The node type of this group node type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupNodeType.Priority">
            <summary>
            Groups with lower priorities can be grouped inside groups with higher priorities.
            For same priorities the behaviour is undefined.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.#ctor(de.unika.ipd.grGen.libGr.NodeType,System.Int32)">
            <summary>
            Initializes a GroupNodeType.
            </summary>
            <param name="nodeType">The node type of this group node type.</param>
            <param name="priority">The priority to be used, when two group node types apply to one edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.GetEdgeGroupMode(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Gets the group mode for this group node with an edge of type edgeType connected to a node of type adjNodeType.
            </summary>
            <param name="edgeType">The type of an edge connected to the group node.</param>
            <param name="adjNodeType">The type of a node connected to the group node.</param>
            <returns>The group mode for this case. Default is GroupMode.None.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.SetEdgeGroupMode(de.unika.ipd.grGen.libGr.EdgeType,System.Boolean,de.unika.ipd.grGen.libGr.NodeType,System.Boolean,de.unika.ipd.grGen.libGr.GroupMode)">
            <summary>
            Sets the group mode for the given case. Inheritance is handled as specified by the parameters.
            </summary>
            <param name="edgeType">The type of an edge connected to the group node.</param>
            <param name="exactEdgeType">Specifies, whether only the exact given edge type is meant.</param>
            <param name="adjNodeType">The type of a node connected to the group node.</param>
            <param name="exactAdjNodeType">Specifies, whether only the exact given node type is meant.</param>
            <param name="groupMode">The group mode to be applied.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GroupNodeType.GroupEdges">
            <summary>
            Enumerates all definitions related to this group node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GroupNodeType.CompareTo(de.unika.ipd.grGen.libGr.GroupNodeType)">
            <summary>
            Compares this group node type to another given one.
            </summary>
            <param name="other">The other group node type.</param>
            <returns>Priority - other.Priority</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GroupNodeType.groupEdges">
            <summary>
            A map from EdgeTypes to NodeTypes to a GroupMode, specifying which connected nodes are grouped into this node.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.InfoTag">
            <summary>
            Represents an info tag.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InfoTag.AttributeType">
            <summary>
            The attribute to be shown.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.InfoTag.ShortInfoTag">
            <summary>
            Whether this is a short info tag (no attribute name is shown).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.InfoTag.#ctor(de.unika.ipd.grGen.libGr.AttributeType,System.Boolean)">
            <summary>
            Initializes an info tag.
            </summary>
            <param name="attrType">The attribute to be shown.</param>
            <param name="shortInfoTag">Whether this is a short info tag (no attribute name is shown).</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DumpInfo">
            <summary>
            A description of how to dump a graph.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DumpInfo.nextGroupID">
            <summary>
            Used as priorities for GroupNodeType objects.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.SetElemTypeLabel(de.unika.ipd.grGen.libGr.GrGenType,System.String)">
            <summary>
            Sets the labels of the given element type.
            null is the default case, which is "&lt;elemname&gt;:&lt;type&gt;".
            </summary>
            <param name="type">The element type.</param>
            <param name="label">The label or null for the default case.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetElemTypeLabel(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Returns the label of the given element type or null for the default case.
            </summary>
            <param name="type">The element type.</param>
            <returns>The label or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.AddOrExtendGroupNodeType(de.unika.ipd.grGen.libGr.NodeType,System.Boolean,de.unika.ipd.grGen.libGr.EdgeType,System.Boolean,de.unika.ipd.grGen.libGr.NodeType,System.Boolean,de.unika.ipd.grGen.libGr.GroupMode)">
            <summary>
            Adds or extends a GroupNodeType.
            All nodes connected via the given edge type and fulfilling the GroupType condition are placed inside a group
            corresponding to the according group node. The edges which lead to the grouping are not displayed.
            The group node types are ordered by the time of creation. Groups of group node types created later
            will be moved into groups of group node types created earlier.
            </summary>
            <param name="nodeType">The node type of the group node.</param>
            <param name="exactNodeType">True, if the node type must be exact, false, if also subtypes are allowed.</param>
            <param name="edgeType">An edge type along which nodes are grouped.</param>
            <param name="exactEdgeType">True, if the edge type must be exact, false, if also subtypes are allowed.</param>
            <param name="incNodeType">The incident node type according to the edge.</param>
            <param name="exactIncNodeType">True, if the incident node type must be exact, false, if also subtypes are allowed.</param>
            <param name="groupMode">Specifies how the edge is used for grouping.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetGroupNodeType(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Gets the GroupNodeType for a given node type.
            </summary>
            <param name="nodeType">The given node type.</param>
            <returns>The GroupNodeType of the given node type or null, if it is not a group node type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetTypeInfoTags(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Returns a list of InfoTag objects for the given GrGenType or null.
            </summary>
            <param name="type">The GrGenType to be examined.</param>
            <returns>A list of associated InfoTag objects or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.AddTypeInfoTag(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.InfoTag)">
            <summary>
            Associates an InfoTag to a GrGenType.
            </summary>
            <param name="type">The GrGenType to given an InfoTag</param>
            <param name="infotag">The InfoTag</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetTypeInfoTag(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Returns an info tag with the given AttributeType registered for the given element type or null.
            </summary>
            <param name="type">The element type.</param>
            <param name="attrType">The attribute type.</param>
            <returns>The info tag or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DumpInfo.GetElementName(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Gets the element name of the given graph element according
            to the element name getter given to the constructor of DumpInfo.
            </summary>
            <param name="elem">The element.</param>
            <returns>The name of the element.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IActionCore">
            <summary>
            An object representing an executable rule.
            The core functions used by the sequences/GrGen itself, the IAction interface contains a lot more convenience helper functions for direct rule application that could be used from own code (and are a bit faster due to missing debug events).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionCore.Name">
            <summary>
            The name of the action
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionCore.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionCore.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionCore.RulePattern">
            <summary>
            The RulePattern object from which this IAction object has been created.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionCore.Match(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32,System.Object[])">
            <summary>
            Searches for a graph pattern as specified by RulePattern in the current graph of the graph processing environment.
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="maxMatches">The maximum number of matches to be searched for, or zero for an unlimited search.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>An IMatches object containing the found matches.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionCore.Modify(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IMatch)">
            <summary>
            Performs the rule specific modifications to the current graph of the graph processing environment with the given match.
            The graph and match object must have the correct type for the used backend (and this action).
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="match">The match of the rule to apply.</param>
            <returns>An array of objects returned by the rule.
            It is only valid until the next graph rewrite with this rule.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionCore.Filter(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.FilterCall)">
            <summary>
            Filters the matches found by this action 
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="matches">The matches to inspect and filter</param>
            <param name="filter">The filter to apply</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionCore.Reserve(System.Int32)">
            <summary>
            Returns a list of arrays with the given number of list elements;
            the array size is as needed for storing the return values.
            The list/its members are only valid until the next allocate or graph rewrite with this rule.
            Internal memory optimization.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IAction">
            <summary>
            An object representing an executable rule.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ModifyAll(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IMatches)">
            <summary>
            Performs the rule specific modifications to the current graph of the graph processing environment with all of the given matches.
            The graph and match object must have the correct type for the used backend.
            No OnRewritingNextMatch events are triggered by this function (needed for visual debugging), in contrast to the Replace function of the action execution environment.
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="matches">The matches of the rule to apply.</param>
            <returns>A list of arrays of objects returned by the applications of the rule.
            It is only valid until the next graph rewrite with this rule.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.Apply(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment)">
            <summary>
            Tries to apply this rule to the given graph processing environment/its current graph once.
            Only applicable for parameterless rules. Shows better performance than the normal Apply called without parameters.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <returns>A possibly empty array of objects returned by the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.Apply(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Object[])">
            <summary>
            Tries to apply this rule to the given processing environment/its current graph once.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            The null parameter check is omitted also.
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>A possibly empty array of objects returned by the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyAll(System.Int32,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment)">
            <summary>
            Tries to apply this rule to all occurrences in the current graph of the graph processing environment "at once".
            Only applicable for parameterless rules. Shows better performance than the normal ApplyAll called without parameters.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            </summary>
            <param name="maxMatches">The maximum number of matches to be rewritten.</param>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <returns>A list of arrays of objects (the arrays may be empty) returned by the last application of the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyAll(System.Int32,de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Object[])">
            <summary>
            Tries to apply this rule to all occurrences in the current graph of the graph processing environment "at once".
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            The null parameter check is omitted also.
            </summary>
            <param name="maxMatches">The maximum number of matches to be rewritten.</param>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>A list of arrays of objects (the arrays may be empty) returned by the last application of the rule,
            which is only valid until the next graph rewrite with this rule,
            or null, if no match was found.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyStar(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment)">
            <summary>
            Applies this rule to the given processing environment/its current graph as often as possible.
            Only applicable for parameterless rules. Shows better performance than the normal ApplyStar called without parameters.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyStar(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Object[])">
            <summary>
            Applies this rule to the given processing environment/its current graph as often as possible.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            The null parameter check is omitted also.
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyPlus(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment)">
            <summary>
            Applies this rule to the given processing environment/its current graph as often as possible.
            Only applicable for parameterless rules. Shows better performance than the normal ApplyPlus called without parameters.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <returns>True, if the rule was applied at least once.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyPlus(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Object[])">
            <summary>
            Applies this rule to the given processing environment/its current graph as often as possible.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            The null parameter check is omitted also.
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>True, if the rule was applied at least once.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyMinMax(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32,System.Int32)">
            <summary>
            Applies this rule to The action execution environment/its current graph at most max times.
            Only applicable for parameterless rules. Shows better performance than the normal ApplyMinMax called without parameters.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="min">The minimum number of applications to be "successful".</param>
            <param name="max">The maximum number of applications to be applied.</param>
            <returns>True, if the rule was applied at least min times.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IAction.ApplyMinMax(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,System.Int32,System.Int32,System.Object[])">
            <summary>
            Applies this rule to the given processing environment/its current graph at most max times.
            No Matched/Finished events are triggered by this function (needed for visual debugging).
            The null parameter check is omitted also.
            </summary>
            <param name="actionEnv">The action execution environment, esp. giving access to the host graph.</param>
            <param name="min">The minimum number of applications to be "successful".</param>
            <param name="max">The maximum number of applications to be applied.</param>
            <param name="parameters">An array of parameters (nodes, edges, values) of the types specified by RulePattern.Inputs.
            The array must contain at least RulePattern.Inputs.Length elements.</param>
            <returns>True, if the rule was applied at least min times.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ISequenceDefinition">
            <summary>
            An object representing an executable sequence.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ISequenceDefinition.Name">
            <summary>
            The name of the sequence
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ISequenceDefinition.Annotations">
            <summary>
            The annotations of the sequence
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISequenceDefinition.Apply(de.unika.ipd.grGen.libGr.SequenceInvocationParameterBindings,de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Applies this sequence.
            </summary>
            <param name="sequenceInvocation">Sequence invocation object for this sequence application,
                containing the input parameter sources and output parameter targets</param>
            <param name="procEnv">The graph processing environment on which this sequence is to be applied.
                Contains especially the graph on which this sequence is to be applied.
                The rules will only be chosen during the Sequence object instantiation, so
                exchanging rules will have no effect for already existing Sequence objects.</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeded</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IProcedureDefinition">
            <summary>
            An object representing an executable procedure.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.Name">
            <summary>
            The name of the procedure
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.Annotations">
            <summary>
            The annotations of the procedure
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.InputNames">
            <summary>
            Names of the procedure parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.Inputs">
            <summary>
            The GrGen types of the procedure parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IProcedureDefinition.Outputs">
            <summary>
            The GrGen types of the procedure return values.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "P:de.unika.ipd.grGen.libGr.IProcedureDefinition.IsExternal" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.IProcedureDefinition.Apply(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.ProcedureInvocationParameterBindings)">
            <summary>
            Applies this procedure with the given action environment on the given graph.
            Takes the parameters from paramBindings as inputs.
            Returns an array of output values.
            Attention: at the next call of Apply, the array returned from previous call is overwritten with the new return values.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IFunctionDefinition">
            <summary>
            An object representing an executable function.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.Name">
            <summary>
            The name of the function.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.Annotations">
            <summary>
            The annotations of the function
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.InputNames">
            <summary>
            Names of the function parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.Inputs">
            <summary>
            The GrGen types of the function parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFunctionDefinition.Output">
            <summary>
            The GrGen type of the function return value.
            </summary>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "P:de.unika.ipd.grGen.libGr.IFunctionDefinition.IsExternal" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.IFunctionDefinition.Apply(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.FunctionInvocationParameterBindings)">
            <summary>
            Applies this function with the given action environment on the given graph.
            Takes the parameters from paramBindings as inputs.
            Returns the one output value.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraphElement">
            <summary>
            A GrGen graph element
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphElement.Type">
            <summary>
            The GrGenType of the graph element
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphElement.Valid">
            <summary>
            This is true, if the element is a valid graph element, i.e. it is part of a graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphElement.ReplacedByElement">
            <summary>
            The element which replaced this element (Valid is false in this case)
            or null, if this element has not been replaced or is still a valid member of a graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.InstanceOf(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Returns true, if the graph element is compatible to the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.GetUniqueId">
            <summary>
            Gets the unique id of the graph element.
            Only available if unique ids for nodes and edges were declared in the model
            (or implicitely switched on by parallelization or the declaration of some index).
            </summary>
            <returns>The unique id of the graph element (an arbitrary number in case uniqueness was not requested).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.GetAttribute(System.String)">
            <summary>
            Returns the graph element attribute with the given attribute name.
            If the graph element type doesn't have an attribute with this name, a NullReferenceException is thrown.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.SetAttribute(System.String,System.Object)">
            <summary>
            Sets the graph element attribute with the given attribute name to the given value.
            If the graph element type doesn't have an attribute with this name, a NullReferenceException is thrown.
            </summary>
            <param name="attrName">The name of the attribute.</param>
            <param name="value">The new value for the attribute. It must have the correct type.
            Otherwise a TargetException is thrown.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.ResetAllAttributes">
            <summary>
            Resets all graph element attributes to their initial values.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.AreAttributesEqual(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns whether the attributes of this element and that are equal.
            If types are unequal the result is false, otherwise the conjunction of equality comparison of the attributes.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.ApplyFunctionMethod(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IGraph,System.String,System.Object[])">
            <summary>
            Executes the function method given by its name.
            Throws an exception if the method does not exists or the parameters are of wrong types.
            </summary>
            <param name="actionEnv">The current action execution environment.</param>
            <param name="graph">The current graph.</param>
            <param name="name">The name of the function method to apply.</param>
            <param name="arguments">An array with the arguments to the method.</param>
            <returns>The return value of function application.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphElement.ApplyProcedureMethod(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IGraph,System.String,System.Object[])">
            <summary>
            Executes the procedure method given by its name.
            Throws an exception if the method does not exists or the parameters are of wrong types.
            </summary>
            <param name="actionEnv">The current action execution environment.</param>
            <param name="graph">The current graph.</param>
            <param name="name">The name of the procedure method to apply.</param>
            <param name="arguments">An array with the arguments to the method.</param>
            <returns>An array with the return values of procedure application. Only valid until the next call of this method.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.INode">
            <summary>
            A GrGen node
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Type">
            <summary>
            The NodeType of the node
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.ReplacedByNode">
            <summary>
            The node which replaced this node (Valid is false in this case)
            or null, if this node has not been replaced or is still a valid member of a graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Outgoing">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all outgoing edges
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetCompatibleOutgoing(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all outgoing edges with the same type or a subtype of the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetExactOutgoing(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all outgoing edges with exactly the given type
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Incoming">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incoming edges
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetCompatibleIncoming(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incoming edges with the same type or a subtype of the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetExactIncoming(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incoming edges with exactly the given type
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INode.Incident">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incident edges
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetCompatibleIncident(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incident edges with the same type or a subtype of the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.GetExactIncident(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns an IEnumerable&lt;IEdge&gt; over all incident edges with exactly the given type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INode.Clone">
            <summary>
            Creates a copy of this node.
            All attributes will be transfered to the new node.
            The node will not be associated to a graph, yet.
            So it will not have any incident edges nor any assigned variables.
            </summary>
            <returns>A copy of this node.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IEdge">
            <summary>
            A GrGen edge (arbitrary direction)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.Type">
            <summary>
            Returns the EdgeType of the edge
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.ReplacedByEdge">
            <summary>
            The edge which replaced this edge (Valid is false in this case)
            or null, if this edge has not been replaced or is still a valid member of a graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.Source">
            <summary>
            The source node of the edge.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdge.Target">
            <summary>
            The target node of the edge.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IEdge.Opposite(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Retrieves the other incident node of this edge.
            </summary>
            <remarks>If the given node is not the source, the source will be returned.</remarks>
            <param name="sourceOrTarget">One node of this edge.</param>
            <returns>The other node of this edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IEdge.Clone(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Creates a copy of this edge.
            All attributes will be transfered to the new edge.
            The edge will not be associated to a graph, yet.
            So it will not have any assigned variables.
            </summary>
            <param name="newSource">The new source node for the new edge.</param>
            <param name="newTarget">The new target node for the new edge.</param>
            <returns>A copy of this edge.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IDEdge">
            <summary>
            A directed GrGen edge
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IUEdge">
            <summary>
            An undirected GrGen edge
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DumpMatchSpecial">
            <summary>
            Specifies how an IMatches object should be dumped.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DumpMatchSpecial.AllMatches">
            <summary>
            Insert virtual match nodes and connect the matches
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DumpMatchSpecial.OnlyMatches">
            <summary>
            Show only the matches
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VirtualNodeType">
            <summary>
            Trivial IType implementation for virtual nodes
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VirtualNode">
            <summary>
            Trivial INode implementation for virtual nodes
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphDumper.DumpAttributes(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Dumps all attributes in the form "kind owner::name = value" into a String List
            </summary>
            <param name="elem">IGraphElement which attributes are to be dumped</param>
            <returns>A String List containing the dumped attributes </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphDumper.DumpMatchOnly(de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.DumpMatchSpecial,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.INode}@,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.INode}@,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.IEdge}@,de.unika.ipd.grGen.libGr.Set{de.unika.ipd.grGen.libGr.IEdge}@)">
            <summary>
            Dumps the given matches.
            </summary>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
            <param name="matches">An IMatches object containing the matches.</param>
            <param name="which">Which match to dump, or AllMatches for dumping all matches
            adding connections between them, or OnlyMatches to dump the matches only</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphDumper.DumpMatch(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.DumpMatchSpecial)">
            <summary>
            Dumps one or more matches with a given graph dumper.
            </summary>
            <param name="graph">The graph to be dumped.</param>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
            <param name="matches">An IMatches object containing the matches.</param>
            <param name="which">Which match to dump, or AllMatches for dumping all matches
            adding connections between them, or OnlyMatches to dump the matches only</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphDumper.Dump(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IDumper,de.unika.ipd.grGen.libGr.DumpInfo)">
            <summary>
            Dumps the graph with a given graph dumper.
            </summary>
            <param name="graph">The graph to be dumped.</param>
            <param name="dumper">The graph dumper to be used.</param>
            <param name="dumpInfo">Specifies how the graph shall be dumped.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphDumper.Dump(de.unika.ipd.grGen.libGr.INamedGraph,de.unika.ipd.grGen.libGr.IDumper)">
            <summary>
            Dumps the named graph with a given graph dumper and default dump style.
            </summary>
            <param name="namedGraph">The named graph to be dumped.</param>
            <param name="dumper">The graph dumper to be used.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GraphValidator.Validate(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.ValidationMode,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.ConnectionAssertionError}@)">
            <summary>
            Checks whether a graph meets its connection assertions.
            </summary>
            <param name="graph">The graph to validate.</param>
            <param name="mode">The validation mode to apply.</param>
            <param name="errors">If the graph is not valid, this refers to a List of ConnectionAssertionError objects, otherwise it is null.</param>
            <returns>True, if the graph is valid.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AfterMatchHandler">
            <summary>
            Represents a method called after all requested matches of an action have been matched.
            </summary>
            <param name="matches">The matches found.</param>
            <param name="match">If not null, specifies the one current match from the matches 
            (to highlight the currently processed match during backtracking and the for matches loop).</param>
            <param name="special">Specifies whether the "special" flag has been used.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.BeforeFinishHandler">
            <summary>
            Represents a method called before the rewrite step of an action, when at least one match has been found.
            </summary>
            <param name="matches">The matches found.</param>
            <param name="special">Specifies whether the "special" flag has been used.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RewriteNextMatchHandler">
            <summary>
            Represents a method called during rewriting a set of matches before the next match is rewritten.
            It is not fired before rewriting the first match.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AfterFinishHandler">
            <summary>
            Represents a method called after the rewrite step of a rule.
            </summary>
            <param name="matches">The matches found.
            This may contain invalid entries, because parts of the matches may have been deleted.</param>
            <param name="special">Specifies whether the "special" flag has been used.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment">
            <summary>
            An environment for the execution of actions (without embedded sequences).
            Holds a reference to the current graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Graph">
            <summary>
            Returns the graph currently focused in processing / sequence execution.
            This may be the initial main graph, or a subgraph switched to, the current top element of the graph usage stack.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.NamedGraph">
            <summary>
            Returns the named graph currently focused in processing / sequence execution.
            Returns null if this graph is not a named but an unnamed graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Actions">
            <summary>
            The actions employed by this graph processing environment
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.PerformanceInfo">
            <summary>
            PerformanceInfo is used to accumulate information about needed time, found matches and applied rewrites.
            And additionally search steps carried out if profiling instrumentation code was generated.
            It must not be null.
            The user is responsible for resetting the PerformanceInfo object.
            This is typically done at the start of a rewrite sequence, to measure its performance.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.HighlightingUnderway">
            <summary>
            Tells whether execution is interrupted because a highlight statement was hit.
            Consequence: the timer that normally prints match statistics every second remains silent
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.MaxMatches">
            <summary>
            The maximum number of matches to be returned for a RuleAll sequence element.
            If it is zero or less, the number of matches is unlimited.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Custom(System.Object[])">
            <summary>
            Does action execution environment dependent stuff.
            </summary>
            <param name="args">Any kind of paramteres for the stuff to do</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.GetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Retrieves the newest version of an IAction object currently available for this graph.
            This may be the given object.
            </summary>
            <param name="action">The IAction object.</param>
            <returns>The newest version of the given action.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.SetNewestActionVersion(de.unika.ipd.grGen.libGr.IAction,de.unika.ipd.grGen.libGr.IAction)">
            <summary>
            Sets the newest action version for a static action.
            </summary>
            <param name="staticAction">The original action generated by GrGen.exe.</param>
            <param name="newAction">A new action instance.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Replace(de.unika.ipd.grGen.libGr.IMatches,System.Int32)">
            <summary>
            Executes the modifications of the according rule to the given match/matches.
            Fires OnRewritingNextMatch events before each rewrite except for the first one.
            </summary>
            <param name="matches">The matches object returned by a previous matcher call.</param>
            <param name="which">The index of the match in the matches object to be applied,
            or -1, if all matches are to be applied.</param>
            <returns>A list with the return values of each of the rewrites applied. 
            Each element is a possibly empty array of objects that were returned by their rewrite.</returns>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.OnMatched">
            <summary>
            Fired after all requested matches of a rule have been matched.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.OnFinishing">
            <summary>
            Fired before the rewrite step of a rule, when at least one match has been found.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.OnRewritingNextMatch">
            <summary>
            Fired before the next match is rewritten. It is not fired before rewriting the first match.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.OnFinished">
            <summary>
            Fired after the rewrite step of a rule.
            Note, that the given matches object may contain invalid entries,
            as parts of the match may have been deleted!
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Matched(de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.IMatch,System.Boolean)">
            <summary>
            Fires an OnMatched event.
            </summary>
            <param name="matches">The IMatches object returned by the matcher.</param>
            <param name="match">If not null, specifies the one current match from the matches 
            (to highlight the currently processed match during backtracking and the for matches loop).</param>
            <param name="special">Whether this is a 'special' match (user defined).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Finishing(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinishing event.
            </summary>
            <param name="matches">The IMatches object returned by the matcher.</param>
            <param name="special">Whether this is a 'special' match (user defined).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.RewritingNextMatch">
            <summary>
            Fires an OnRewritingNextMatch event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IActionExecutionEnvironment.Finished(de.unika.ipd.grGen.libGr.IMatches,System.Boolean)">
            <summary>
            Fires an OnFinished event.
            </summary>
            <param name="matches">The IMatches object returned by the matcher. The elements may be invalid.</param>
            <param name="special">Whether this is a 'special' match (user defined).</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.NodeAddedHandler">
            <summary>
            Represents a method called, when a node has been added.
            </summary>
            <param name="node">The added node.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EdgeAddedHandler">
            <summary>
            Represents a method called, when an edge has been added.
            </summary>
            <param name="edge">The added edge.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RemovingNodeHandler">
            <summary>
            Represents a method called before a node is removed.
            </summary>
            <param name="node">The node to be removed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RemovingEdgeHandler">
            <summary>
            Represents a method called before a edge is removed.
            </summary>
            <param name="edge">The edge to be removed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RemovingEdgesHandler">
            <summary>
            Represents a method called before all edges of a node are removed.
            </summary>
            <param name="node">The node whose edges are to be removed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ClearingGraphHandler">
            <summary>
            Represents a method called before a graph is cleared.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ChangingNodeAttributeHandler">
            <summary>
            Represents a method called just before a node attribute is changed,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="node">The node whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.
                                   Or the new value to be inserted/added if changeType==PutElement on array.
                                   Or the new value to be assigned to the given position if changeType==AssignElement on array.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.
                                   The array index to be removed/written to if changeType==RemoveElement/AssignElement on array.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ChangingEdgeAttributeHandler">
            <summary>
            Represents a method called just before an edge attribute is changed,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="edge">The edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.
                                   Or the new value to be inserted/added if changeType==PutElement on array.
                                   Or the new value to be assigned to the given position if changeType==AssignElement on array.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.
                                   The array index to be removed/written to if changeType==RemoveElement/AssignElement on array.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ChangedNodeAttributeHandler">
            <summary>
            Represents a method called after a node attribute was changed (for debugging, omitted in case nodebugevents).
            </summary>
            <param name="node">The node whose attribute was changed.</param>
            <param name="attrType">The type of the attribute changed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ChangedEdgeAttributeHandler">
            <summary>
            Represents a method called after an edge attribute was changed (for debugging, omitted in case of nodebugevents).
            </summary>
            <param name="edge">The edge whose attribute was changed.</param>
            <param name="attrType">The type of the attribute changed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RetypingNodeHandler">
            <summary>
            Represents a method called before a node is retyped.
            </summary>
            <param name="oldNode">The node to be retyped.</param>
            <param name="newNode">The new node with the common attributes, but without any incident edges assigned, yet.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RetypingEdgeHandler">
            <summary>
            Represents a method called before an edge is retyped.
            </summary>
            <param name="oldEdge">The edge to be retyped.</param>
            <param name="newEdge">The new edge with the common attributes, but not fully connected with the incident nodes, yet.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RedirectingEdgeHandler">
            <summary>
            Represents a method called before an edge is redirected (i.e. will be removed soon and added again immediately thereafter).
            </summary>
            <param name="oldEdge">The edge which will be redirectey.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SettingAddedElementNamesHandler">
            <summary>
            Delegate-type called shortly before elements are added to the graph, with the names of the elements added.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VisitedAllocHandler">
            <summary>
            Represents a method called, when a visited flag was allocated.
            </summary>
            <param name="visitorID">The id of the visited flag that was allocated.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VisitedFreeHandler">
            <summary>
            Represents a method called, when a visited flag was freed.
            </summary>
            <param name="visitorID">The id of the visited flag that was freed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SettingVisitedHandler">
            <summary>
            Represents a method called before a visited flag is set to a new value.
            </summary>
            <param name="elem">The graph element of which the specified flag is to be set.</param>
            <param name="visitorID">The id of the visited flag to be set.</param>
            <param name="newValue">The new value.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraph">
            <summary>
            An attributed, typed and directed multigraph with multiple inheritance on node and edge types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Name">
            <summary>
            A name associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.GraphId">
            <summary>
            A unique id associated with the graph
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Model">
            <summary>
            The model associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Indices">
            <summary>
            The indices associated with the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.ReuseOptimization">
            <summary>
            If true (the default case), elements deleted during a rewrite
            may be reused in the same rewrite.
            As a result new elements may not be discriminable anymore from
            already deleted elements using object equality, hash maps, etc.
            In cases where this is needed this optimization should be disabled.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.ChangesCounter">
            <summary>
            Returns a counter of the number of changes that occured since the graph was created.
            If it's different since last time you visited, the graph has changed (but it may be back again in the original state).
            Only graph structure changes are counted, attribute changes are not included.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.NumNodes">
            <summary>
            The total number of nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.NumEdges">
            <summary>
            The total number of edges in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Nodes">
            <summary>
            Enumerates all nodes in the graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Edges">
            <summary>
            Enumerates all edges in the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetExactNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes with the exact given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetExactEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges with the exact given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Returns the number of nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNumCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Returns the number of edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetCompatibleNodes(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Enumerates all nodes compatible to the given node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetCompatibleEdges(de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Enumerates all edges compatible to the given edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetGraphElement(System.Int32)">
            <summary>
            Gets the graph element for the given unique id.
            Only available if the unique index was declared in the model.
            </summary>
            <param name="unique">The unique id of a graph element.</param>
            <returns>The graph element for the given unique id or null, if there is no graph element with this unique id.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetNode(System.Int32)">
            <summary>
            Gets the node for the given unique id.
            Only available if the unique index was declared in the model.
            </summary>
            <param name="unique">The unique id of a node.</param>
            <returns>The node for the given unique id or null, if there is no node with this unique id.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetEdge(System.Int32)">
            <summary>
            Gets the edge for the given id.
            Only available if the unique index was declared in the model.
            </summary>
            <param name="unique">The unique id of a edge.</param>
            <returns>The edge for the given unique id or null, if there is no edge with this unique id.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds an existing INode object to the graph.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Adds a new node to the graph.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Adds an existing IEdge object to the graph.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Adds a new edge to the graph.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Remove(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes the given node from the graph.
            There must be no edges left incident to the node (you may use RemoveEdges to ensure this).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Remove(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Removes the given edge from the graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.RemoveEdges(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Removes all edges from the given node.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Clear">
            <summary>
            Removes all nodes and edges from the graph (so any variables pointing to them start dangling).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Retype(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.NodeType)">
            <summary>
            Retypes a node by creating a new node of the given type.
            All incident edges as well as all attributes from common super classes are kept.
            </summary>
            <param name="node">The node to be retyped.</param>
            <param name="newNodeType">The new type for the node.</param>
            <returns>The new node object representing the retyped node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Retype(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.EdgeType)">
            <summary>
            Retypes an edge by creating a new edge of the given type.
            Source and target node as well as all attributes from common super classes are kept.
            </summary>
            <param name="edge">The edge to be retyped.</param>
            <param name="newEdgeType">The new type for the edge.</param>
            <returns>The new edge object representing the retyped edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Merge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Merges the source node into the target node,
            i.e. all edges incident to the source node are redirected to the target node, then the source node is deleted.
            </summary>
            <param name="target">The node which remains after the merge.</param>
            <param name="source">The node to be merged.</param>
            <param name="sourceName">The name of the node to be merged (used for debug display of redirected edges).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.RedirectSource(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Changes the source node of the edge from the old source to the given new source.
            </summary>
            <param name="edge">The edge to redirect.</param>
            <param name="newSource">The new source node of the edge.</param>
            <param name="oldSourceName">The name of the old source node (used for debug display of the new edge).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.RedirectTarget(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Changes the target node of the edge from the old target to the given new target.
            </summary>
            <param name="edge">The edge to redirect.</param>
            <param name="newTarget">The new target node of the edge.</param>
            <param name="oldTargetName">The name of the old target node (used for debug display of the new edge).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.RedirectSourceAndTarget(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.String)">
            <summary>
            Changes the source of the edge from the old source to the given new source,
            and changes the target node of the edge from the old target to the given new target.
            </summary>
            <param name="edge">The edge to redirect.</param>
            <param name="newSource">The new source node of the edge.</param>
            <param name="newTarget">The new target node of the edge.</param>
            <param name="oldSourceName">The name of the old source node (used for debug display of the new edge).</param>
            <param name="oldTargetName">The name of the old target node (used for debug display of the new edge).</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Custom(System.Object[])">
            <summary>
            Does graph-backend dependent stuff.
            </summary>
            <param name="args">Any kind of paramteres for the stuff to do</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraph.Backend">
            <summary>
            The backend that created the graph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Clone(System.String)">
            <summary>
            Duplicates a graph.
            The new graph will use the same model and backend as the other.
            </summary>
            <param name="newName">Name of the new graph.</param>
            <returns>A new graph with the same structure as this graph.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.CloneAndAssignNames">
            <summary>
            Duplicates a graph, assigning names. (Don't use this on a named graph.)
            The new graph will use the same model and backend as the other.
            </summary>
            <returns>A new named graph with the same structure as this graph.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.CreateEmptyEquivalent(System.String)">
            <summary>
            Creates an empty graph using the same model and backend as the other.
            </summary>
            <param name="newName">Name of the new graph.</param>
            <returns>A new empty graph of the same model.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.IsIsomorph(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns whether this graph is isomorph to that graph (including the attribute values)
            If a graph changed only in attribute values since the last comparison, results will be wrong!
            (Do a fake node insert and removal to ensure the graph is recognized as having changed.)
            </summary>
            <param name="that">The other graph we check for isomorphy against</param>
            <returns>true if that is isomorph (structure and attributes) to this, false otherwise</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.IsIsomorph(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.SetValueType})">
            <summary>
            Returns whether this graph is isomorph to any of the set of graphs given (including the attribute values)
            If a graph changed only in attribute values since the last comparison, results will be wrong!
            (Do a fake node insert and removal to ensure the graph is recognized as having changed.)
            Don't call from a parallelized matcher!
            </summary>
            <param name="graphsToCheckAgainst">The other graph we check for isomorphy against</param>
            <returns>true if any of the graphs given is isomorph to this, false otherwise</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.HasSameStructure(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Returns whether this graph is isomorph to that graph, neglecting the attribute values, only structurally
            </summary>
            <param name="that">The other graph we check for isomorphy against, neglecting attribute values</param>
            <returns>true if that is isomorph (regarding structure) to this, false otherwise</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.HasSameStructure(System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.SetValueType})">
            <summary>
            Returns whether this graph is isomorph to any of the set of graphs given, neglecting the attribute values, only structurally
            Don't call from a parallelized matcher!
            </summary>
            <param name="graphsToCheckAgainst">The other graphs we check for isomorphy against, neglecting attribute values</param>
            <returns>true if any of the graphs given is isomorph (regarding structure) to this, false otherwise</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Canonize">
            <summary>
            Returns a canonical representation of the graph as a string
            </summary>
            <returns>a canonical representation of the graph as a string</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Validate(de.unika.ipd.grGen.libGr.ValidationMode,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.ConnectionAssertionError}@)">
            <summary>
            Checks whether a graph meets the connection assertions.
            </summary>
            <param name="mode">The validation mode to apply.</param>
            <param name="errors">If the graph is not valid, this refers to a List of ConnectionAssertionError objects, otherwise it is null.</param>
            <returns>True, if the graph is valid.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.Check">
            <summary>
            Checks whether the internal data structures are ok (will throw an exception if they are not).
            This is for debugging the underlying implementation from positions outside the implementation.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.AllocateVisitedFlag">
            <summary>
            Allocates a visited flag on the graph elements.
            </summary>
            <returns>A visitor ID to be used in
            visited conditions in patterns ("if { !elem.visited[id]; }"),
            visited expressions in evals ("elem.visited[id] = true; b.flag = elem.visited[id] || c.flag; "}
            and calls to other visitor functions.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.FreeVisitedFlag(System.Int32)">
            <summary>
            Frees a visited flag.
            This is a safe but O(n) operation, as it resets the visited flag in the graph.
            </summary>
            <param name="visitorID">The ID of the visited flag to be freed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.FreeVisitedFlagNonReset(System.Int32)">
            <summary>
            Frees a clean visited flag.
            This is an O(1) but potentially unsafe operation.
            Attention! A marked element stays marked, so a later allocation hands out a dirty visited flag! 
            Use only if you can ensure that all elements of that flag are unmarked before calling.
            </summary>
            <param name="visitorID">The ID of the visited flag to be freed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ResetVisitedFlag(System.Int32)">
            <summary>
            Resets the visited flag with the given ID on all graph elements, if necessary.
            </summary>
            <param name="visitorID">The ID of the visited flag.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.SetVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32,System.Boolean)">
            <summary>
            Sets the visited flag of the given graph element.
            </summary>
            <param name="elem">The graph element whose flag is to be set.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <param name="visited">True for visited, false for not visited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.IsVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32)">
            <summary>
            Returns whether the given graph element has been visited.
            </summary>
            <param name="elem">The graph element to be examined.</param>
            <param name="visitorID">The ID of the visited flag.</param>
            <returns>True for visited, false for not visited.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.GetAllocatedVisitedFlags">
            <summary>
            Returns the ids of the allocated visited flags.
            </summary>
            <returns>A dynamic array of the visitor ids allocated.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.SetInternallyVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Boolean)">
            <summary>
            Sets the internal-use visited flag of the given graph element.
            (Used for computing reachability.)
            </summary>
            <param name="elem">The graph element whose flag is to be set.</param>
            <param name="visited">True for visited, false for not visited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.IsInternallyVisited(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns whether the given graph element has been internally visited.
            (Used for computing reachability.)
            </summary>
            <param name="elem">The graph element whose flag is to be retrieved.</param>
            <returns>True for visited, false for not visited.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.SetInternallyVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Boolean,System.Int32)">
            <summary>
            Sets the internal-use visited flag of the given graph element.
            (Used for computing reachability when employed from a parallelized matcher executed by the thread pool.)
            </summary>
            <param name="elem">The graph element whose flag is to be set.</param>
            <param name="visited">True for visited, false for not visited.</param>
            <param name="threadId">The id of the thread which marks the graph element.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.IsInternallyVisited(de.unika.ipd.grGen.libGr.IGraphElement,System.Int32)">
            <summary>
            Returns whether the given graph element has been internally visited.
            (Used for computing reachability when employed from a parallelized matcher executed by the thread pool.)
            </summary>
            <param name="elem">The graph element whose flag is to be retrieved.</param>
            <param name="threadId">The id of the thread which queries the marking of the graph element.</param>
            <returns>True for visited, false for not visited.</returns>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnNodeAdded">
            <summary>
            Fired after a node has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnEdgeAdded">
            <summary>
            Fired after an edge has been added
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRemovingNode">
            <summary>
            Fired before a node is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRemovingEdge">
            <summary>
            Fired before an edge is deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRemovingEdges">
            <summary>
            Fired before all edges of a node are deleted
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnClearingGraph">
            <summary>
            Fired before the whole graph is cleared
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnChangingNodeAttribute">
            <summary>
            Fired before an attribute of a node is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function
            and want the event to be fired, you have to fire it yourself
            using ChangingNodeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnChangingEdgeAttribute">
            <summary>
            Fired before an attribute of an edge is changed.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function
            and want the event to be fired, you have to fire it yourself
            using ChangingEdgeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnChangedNodeAttribute">
            <summary>
            Fired after an attribute of a node is changed; for debugging purpose.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function
            and want the event to be fired, you have to fire it yourself
            using ChangedNodeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnChangedEdgeAttribute">
            <summary>
            Fired after an attribute of an edge is changed; for debugging purpose.
            Note for LGSPBackend:
            Because graph elements of the LGSPBackend don't know their graph a call to
            LGSPGraphElement.SetAttribute will not fire this event. If you use this function
            and want the event to be fired, you have to fire it yourself
            using ChangedEdgeAttributes.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRetypingNode">
            <summary>
            Fired before the type of a node is changed.
            Old and new nodes are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRetypingEdge">
            <summary>
            Fired before the type of an edge is changed.
            Old and new edges are provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnRedirectingEdge">
            <summary>
            Fired before an edge is redirected (causing removal then adding again).
            The edge to be redirected is provided to the handler.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnVisitedAlloc">
            <summary>
            Fired after a visited flag was allocated.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnVisitedFree">
            <summary>
            Fired after a visited flag was freed.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnSettingVisited">
            <summary>
            Fired before a visited flag is set.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnSettingAddedNodeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the nodes added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraph.OnSettingAddedEdgeNames">
            <summary>
            Fired before each rewrite step (also rewrite steps of subpatterns) to indicate the names
            of the edges added in this rewrite step in order of addition.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ChangingNodeAttribute(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingNodeAttribute event.
            To be called before changing an attribute of a node,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="node">The node whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.
                                   Or the new value to be inserted/added if changeType==PutElement on array/deque.
                                   Or the new value to be assigned to the given position if changeType==AssignElement on array/deque.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.
                                   The index to be removed/written to if changeType==RemoveElement/AssignElement on array/deque.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ChangingEdgeAttribute(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Fires an OnChangingEdgeAttribute event.
            To be called before changing an attribute of an edge,
            with exact information about the change to occur,
            to allow rollback of changes, in case a transaction is underway.
            </summary>
            <param name="edge">The edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.
                                   Or the new value to be inserted/added if changeType==PutElement on array/deque.
                                   Or the new value to be assigned to the given position if changeType==AssignElement on array/deque.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.
                                   The index to be removed/written to if changeType==RemoveElement/AssignElement on array/deque.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ChangedNodeAttribute(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Fires an OnChangedNodeAttribute event.
            For debugging, won't be automatically called in case of -nodebugevents, attribute change rollback is based on the pre-events.
            </summary>
            <param name="node">The node whose attribute was changed.</param>
            <param name="attrType">The type of the attribute changed.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraph.ChangedEdgeAttribute(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.AttributeType)">
            <summary>
            Fires an OnChangedEdgeAttribute event.
            For debugging, won't be automatically called in case of -nodebugevents, attribute change rollback is based on the pre-events.
            </summary>
            <param name="edge">The edge whose attribute was changed.</param>
            <param name="attrType">The type of the attribute changed.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Variable">
            <summary>
            A named graph-global variable.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Variable.Name">
            <summary>
            The name of the variable.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Variable.Value">
            <summary>
            The value pointed to by the variable.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Variable.#ctor(System.String,System.Object)">
            <summary>
            Initializes a Variable instance.
            </summary>
            <param name="name">The name of the variable.</param>
            <param name="value">The value pointed to by the variable.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeChangeType">
            <summary>
            The changes which might occur to graph element attributes.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.Assign">
            <summary>
            Assignment of a value to some attribute.
            Value semantics, even if assigned attribute is a set or a map, not a primitive type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.PutElement">
            <summary>
            Inserting a value into some set or a key value pair into some map or a value into some array.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.RemoveElement">
            <summary>
            Removing a value from some set or a key value pair from some map or a key/index from some array.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeChangeType.AssignElement">
            <summary>
            Assignment of a value to a key/index position in an array, overwriting old element at that position.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IUndoItem">
            <summary>
            An interface for undo items of the transaction manager.
            Allows to register own ones for external types, will be called on rollback.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUndoItem.DoUndo(de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Called on rollback by the transaction manager,
            in order to undo the effects of some change it was created for.
            </summary>
            <param name="procEnv">The current graph processing environment</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ITransactionManager">
            <summary>
            An interface for managing graph transactions.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Start">
            <summary>
            Starts a transaction
            </summary>
            <returns>A transaction ID to be used with Commit or Rollback</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Pause">
            <summary>
            Pauses the running transactions,
            i.e. changes done from now on until resume won't be undone in case of a rollback
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Resume">
            <summary>
            Resumes the running transactions after a pause,
            i.e. changes done from now on will be undone again in case of a rollback
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Commit(System.Int32)">
            <summary>
            Removes the rollback data and stops this transaction
            </summary>
            <param name="transactionID">Transaction ID returned by a Start call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.Rollback(System.Int32)">
            <summary>
            Undoes all changes during a transaction
            </summary>
            <param name="transactionID">The ID of the transaction to be rollbacked</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITransactionManager.IsActive">
            <summary>
            Indicates, whether a transaction is currently active.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITransactionManager.ExternalTypeChanged(de.unika.ipd.grGen.libGr.IUndoItem)">
            <summary>
            Registers an undo item to be called on rollback,
            for reverting the changes applied to some graph element attribute of external type.
            Only in case a transaction is underway and not paused (and not rolling back) is the undo item added to the undo log,
            so you may call this method simply on each change to an external type.
            </summary>
            <param name="item">An object that is capable of undoing the effects of some change it was created for in case of rollback</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IRecorder">
            <summary>
            An interface for recording changes (and their causes) applied to a graph into a file,
            so that they can get replayed.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.StartRecording(System.String)">
            <summary>
            Creates a file which initially gets filled with a .grs export of the graph.
            Afterwards the changes applied to the graph are recorded into the file,
            in the order they occur.
            You can start multiple recordings into differently named files.
            </summary>
            <param name="filename">The name of the file to record to</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.StopRecording(System.String)">
            <summary>
            Stops recording of the changes applied to the graph to the given file.
            </summary>
            <param name="filename">The name of the file to stop recording to</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.IsRecording(System.String)">
            <summary>
            Returns whether the graph changes get currently recorded into the given file.
            </summary>
            <param name="filename">The name of the file whose recording status gets queried</param>
            <returns>The recording status of the file queried</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.External(System.String)">
            <summary>
            Writes a line starting with "external ", ending with a new line, 
            containing the given string in between (which must not contain "\n" or "\r"),
            to the currently ongoing recordings.
            This is the format expected for fine-grain external attribute changes, 
            the string is passed to External of the graph model on replaying, 
            which is forwarding it to external user code for parsing and executing the changes.
            </summary>
            <param name="value">The string to write to the recordings</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.Write(System.String)">
            <summary>
            Writes the given string to the currently ongoing recordings
            </summary>
            <param name="value">The string to write to the recordings</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.WriteLine(System.String)">
            <summary>
            Writes the given string to the currently ongoing recordings followed by a new line
            </summary>
            <param name="value">The string to write to the recordings</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.Flush">
            <summary>
            Flushes the writer
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.TransactionStart(System.Int32)">
            <summary>
            Called by the transaction manager when a transaction is started
            </summary>
            <param name="transactionID">The id of the transaction</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.TransactionCommit(System.Int32)">
            <summary>
            Called by the transaction manager when a transaction is committed
            </summary>
            <param name="transactionID">The id of the transaction</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IRecorder.TransactionRollback(System.Int32,System.Boolean)">
            <summary>
            Called by the transaction manager when a transaction is rolled back
            </summary>
            <param name="transactionID">The id of the transaction</param>
            <param name="start">true when called at rollback start, false when called at rollback end</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ValidationMode">
            <summary>
            The different graph validation modes
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.PerformanceInfo">
            <summary>
            An object accumulating information about needed time, number of found matches and number of performed rewrites.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.ActionProfiles">
            <summary>
            Stores a profile per action (given by name, that gives the average for the loop and search steps needed to achieve the goal or finally fail)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.MatchesFound">
            <summary>
            Accumulated number of matches found by any rule since last Reset.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.RewritesPerformed">
            <summary>
            Accumulated number of rewrites performed by any rule since last Reset.
            This differs from <see cref="F:de.unika.ipd.grGen.libGr.PerformanceInfo.MatchesFound"/> for test rules, tested rules, and undone rules.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.SearchSteps">
            <summary>
            Accumulated number of search steps carried out since last Reset.
            (Number of bindings of a graph element to a pattern element, but bindings where only one choice is available don't count into this.)
            Only incremented if gathering of profiling information was requested ("-profile", "new set profile on").
            (The per-thread steps are added here after each action call when the threads completed.)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.SearchStepsPerThread">
            <summary>
            Number of search steps carried out for the current/last action call, per thread (in case a multithreaded matcher is/was used).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.PerformanceInfo.LoopStepsPerThread">
            <summary>
            Number of loop steps of the first loop executed for the current/last action call, per thread (in case a multithreaded matcher is/was used)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.PerformanceInfo.TimeNeeded">
            <summary>
            The accumulated time of rule and sequence applications in seconds since last Reset,
            as defined by the intervals between Start and Stop.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.Start">
            <summary>
            Starts time measurement.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.Stop">
            <summary>
            Stops time measurement and increases the TimeNeeded by the elapsed time 
            between this call and the last call to Start().
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.PerformanceInfo.Reset">
            <summary>
            Resets all accumulated information.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ActionProfile">
            <summary>
            A class for collecting an action profile, 
            accumulating per-action statistics, over all applications of the corresponding rule or test
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ProfileAverages">
            <summary>
            A class for collecting average information, for profiling,
            per thread that was used in matching
            (so in case of a normal single threaded action the values characterize the action)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Range">
            <summary>
            Describes a range with a minimum and a maximum value.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Range.Infinite">
            <summary>
            Constant value representing positive infinity for a range.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Range.Min">
            <summary>
            The lower bound of the range.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Range.Max">
            <summary>
            The upper bound of the range.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Range.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a Range object.
            </summary>
            <param name="min">The lower bound of the range.</param>
            <param name="max">The upper bound of the range.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EnterSequenceHandler">
            <summary>
            Represents a method called directly after a sequence has been entered.
            </summary>
            <param name="seq">The current sequence object.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ExitSequenceHandler">
            <summary>
            Represents a method called before a sequence is left.
            </summary>
            <param name="seq">The current sequence object.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EndOfIterationHandler">
            <summary>
            Represents a method called when a loop iteration is ended.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment">
            <summary>
            An environment for the advanced processing of graphs and the execution of sequences.
            With global variables, (sub)graph switching, and transaction management.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.TransactionManager">
            <summary>
            Returns the transaction manager of the processing environment.
            (Recording and undoing changes in the main graph and all processed subgraphs).
            Don't forget to call Commit after a transaction is finished!
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.CloneGraphVariables(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Duplicates the graph variables of an old just cloned graph, assigns them to the new cloned graph.
            </summary>
            <param name="old">The old graph.</param>
            <param name="clone">The new, cloned version of the graph.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ApplyRewrite(de.unika.ipd.grGen.libGr.RuleInvocationParameterBindings,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.FilterCall})">
            <summary>
            Apply a rewrite rule (first computing the parameters with sequence expressions, last assigning result variables).
            </summary>
            <param name="paramBindings">The parameter bindings of the rule invocation</param>
            <param name="which">The index of the match to be rewritten or -1 to rewrite all matches</param>
            <param name="localMaxMatches">Specifies the maximum number of matches to be found (if less or equal 0 the number of matches
            depends on MaxMatches)</param>
            <param name="special">Specifies whether the %-modifier has been used for this rule, which may have a special meaning for
            the application</param>
            <param name="test">If true, no rewrite step is performed.</param>
            <param name="filters">The name of the filters to apply to the matches before rewriting, in the order of filtering.</param>
            <returns>The number of matches found</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.GetElementVariables(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns a linked list of variables mapping to the given graph element
            or null, if no variable points to this element
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.GetVariableValue(System.String)">
            <summary>
            Retrieves the object for a variable name or null, if the variable isn't set yet or anymore
            </summary>
            <param name="varName">The variable name to lookup</param>
            <returns>The according object or null</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.GetNodeVarValue(System.String)">
            <summary>
            Retrieves the INode for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an INode object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.GetEdgeVarValue(System.String)">
            <summary>
            Retrieves the IEdge for a variable name or null, if the variable isn't set yet or anymore.
            A InvalidCastException is thrown, if the variable is set and does not point to an IEdge object.
            </summary>
            <param name="varName">The variable name to lookup.</param>
            <returns>The according INode or null.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.SetVariableValue(System.String,System.Object)">
            <summary>
            Sets the value of the given variable to the given value.
            If the variable name is null, this function does nothing.
            If elem is null, the variable is unset.
            </summary>
            <param name="varName">The name of the variable</param>
            <param name="val">The new value of the variable</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.Variables">
            <summary>
            Returns an iterator over all available (non-null) variables
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.Item(System.String)">
            <summary>
            Indexer for accessing the variables by name, via index notation on this object.
            </summary>
            <param name="name">The name of the variable to access</param>
            <returns>The value of the variable accessed (read on get, written on set)</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddNode(de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds an existing INode object to the current graph of this processing environment and assigns it to the given variable.
            The node must not be part of any graph, yet!
            The node may not be connected to any other elements!
            </summary>
            <param name="node">The node to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String)">
            <summary>
            Adds a new node to the current graph of this processing environment and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String)">
            <summary>
            Adds an existing IEdge object to the current graph of this processing environment and assigns it to the given variable.
            The edge must not be part of any graph, yet!
            Source and target of the edge must already be part of the graph.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="varName">The name of the variable.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds a new edge to the current graph of this processing environment and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="varName">The name of the variable.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddNode(de.unika.ipd.grGen.libGr.INode,System.String,System.String)">
            <summary>
            Adds an existing node to the graph, names it, and assigns it to the given variable.
            </summary>
            <param name="node">The existing node.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the new node or null if it is to be auto-generated.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String,System.String)">
            <summary>
            Adds a new named node to the graph and assigns it to the given variable.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the new node or null if it is to be auto-generated.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String,System.String)">
            <summary>
            Adds an existing edge to the graph, names it, and assigns it to the given variable.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the edge or null if it is to be auto-generated.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.String)">
            <summary>
            Adds a new named edge to the graph and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="varName">The name of the variable.</param>
            <param name="elemName">The name for the edge or null if it is to be auto-generated.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ApplyGraphRewriteSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Apply a graph rewrite sequence (to the currently associated graph).
            </summary>
            <param name="sequence">The graph rewrite sequence</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ApplyGraphRewriteSequence(System.String)">
            <summary>
            Apply a graph rewrite sequence (to the currently associated graph).
            </summary>
            <param name="seqStr">The graph rewrite sequence in form of a string</param>
            <returns>The result of the sequence.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ValidateWithSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seq">The sequence to be executed</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ValidateWithSequence(System.String)">
            <summary>
            Tests whether the given sequence succeeds on a clone of the associated graph.
            </summary>
            <param name="seqStr">The sequence to be executed in form of a string</param>
            <returns>True, iff the sequence succeeds on the cloned graph </returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ParseSequence(System.String)">
            <summary>
            Parses the given XGRS string and generates a Sequence object.
            Any actions in the string must refer to actions from the actions contained in this object.
            </summary>
            <param name="seqStr">The sequence to be parsed in form of an XGRS string.</param>
            <returns>The sequence object according to the given string.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.UserProxy">
            <summary>
            The user proxy queried for choices during sequence execution.
            By default the compliant user proxy, if debugging the debugger acting on behalf of/controlled by the user.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.CompliantUserProxy">
            <summary>
            Returns a non-interactive user proxy just echoing its inputs.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.OnEntereringSequence">
            <summary>
            Fired when a sequence is entered.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.OnExitingSequence">
            <summary>
            Fired when a sequence is left.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.OnEndOfIteration">
            <summary>
            Fired when a sequence iteration is ended.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.EnteringSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnEnteringSequence event.
            </summary>
            <param name="seq">The sequence to be entered.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.ExitingSequence(de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnExitingSequence event.
            </summary>
            <param name="seq">The sequence to be exited.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment.EndOfIteration(System.Boolean,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Fires an OnEndOfIteration event. 
            This informs the debugger about the end of a loop iteration, so it can display the state at the end of the iteration.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.CompliantUserProxyForSequenceExecution">
            <summary>
            A proxy simulating an always compliant user for choices during sequence execution,
            always returns the suggested choice. Used for sequence execution without debugger.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.INamedGraph">
            <summary>
            An named IGraph (which is an attributed, typed and directed multigraph with multiple inheritance on node and edge types),
            with a unique name assigned to each node and edge; allowing to access an element by name and a name by element.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.SetElementName(de.unika.ipd.grGen.libGr.IGraphElement,System.String)">
            <summary>
            Sets the name for a graph element. Any previous name will be overwritten.
            </summary>
            <param name="elem">The graph element to be named.</param>
            <param name="name">The new name for the graph element.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.SetElementPrefixName(de.unika.ipd.grGen.libGr.IGraphElement,System.String)">
            <summary>
            Sets a name of the form prefix + number for the graph element,
            with number being the first number from 0 on yielding an element name not already available in the graph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.GetElementName(de.unika.ipd.grGen.libGr.IGraphElement)">
            <summary>
            Returns the name for the given element.
            </summary>
            <param name="elem">Element of which the name is to be found</param>
            <returns>The name of the given element</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.GetGraphElement(System.String)">
            <summary>
            Gets the graph element for the given name.
            </summary>
            <param name="name">The name of a graph element.</param>
            <returns>The graph element for the given name or null, if there is no graph element with this name.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.GetNode(System.String)">
            <summary>
            Gets the node for the given name.
            </summary>
            <param name="name">The name of a node.</param>
            <returns>The node for the given name or null, if there is no node with this name.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.GetEdge(System.String)">
            <summary>
            Gets the graph element for the given name.
            </summary>
            <param name="name">The name of an edge.</param>
            <returns>The edge for the given name or null, if there is no edge with this name.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.AddNode(de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds an existing node to the graph and names it.
            </summary>
            <param name="node">The existing node.</param>
            <param name="elemName">The name for the new node or null if it is to be auto-generated.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.AddNode(de.unika.ipd.grGen.libGr.NodeType,System.String)">
            <summary>
            Adds a new named node to the graph.
            </summary>
            <param name="nodeType">The node type for the new node.</param>
            <param name="elemName">The name for the new node or null if it is to be auto-generated.</param>
            <returns>The newly created node.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.AddEdge(de.unika.ipd.grGen.libGr.IEdge,System.String)">
            <summary>
            Adds an existing edge to the graph, names it, and assigns it to the given variable.
            </summary>
            <param name="edge">The edge to be added.</param>
            <param name="elemName">The name for the edge or null if it is to be auto-generated.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.AddEdge(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String)">
            <summary>
            Adds a new named edge to the graph and assigns it to the given variable.
            </summary>
            <param name="edgeType">The edge type for the new edge.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="elemName">The name for the edge or null if it is to be auto-generated.</param>
            <returns>The newly created edge.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.CloneNamed(System.String)">
            <summary>
            Duplicates a named graph.
            The new graph will use the same model and backend as the other.
            </summary>
            <param name="newName">Name of the new graph.</param>
            <returns>A new graph with the same structure and names as this graph.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.Merge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Merges the source node into the target node,
            i.e. all edges incident to the source node are redirected to the target node, then the source node is deleted.
            </summary>
            <param name="target">The node which remains after the merge.</param>
            <param name="source">The node to be merged.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.RedirectSource(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Changes the source node of the edge from the old source to the given new source.
            </summary>
            <param name="edge">The edge to redirect.</param>
            <param name="newSource">The new source node of the edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.RedirectTarget(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Changes the target node of the edge from the old target to the given new target.
            </summary>
            <param name="edge">The edge to redirect.</param>
            <param name="newTarget">The new target node of the edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INamedGraph.RedirectSourceAndTarget(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Changes the source of the edge from the old source to the given new source,
            and changes the target node of the edge from the old target to the given new target.
            </summary>
            <param name="edge">The edge to redirect.</param>
            <param name="newSource">The new source node of the edge.</param>
            <param name="newTarget">The new target node of the edge.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ECoreImport">
            <summary>
            Imports a graph model from the ECore format.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ECoreImport.typeMap">
            <summary>
            map of package prefixed type name to graph node type
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ECoreImport.enumToLiteralToValue">
            <summary>
            enum type definitions
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ECoreImport.Import(de.unika.ipd.grGen.libGr.IBackend,System.Collections.Generic.List{System.String},System.String,System.String,System.Boolean,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Creates a new graph from the given ECore metamodels.
            If a grg file is given, the graph will use the graph model declared in it and the according
            actions object will be associated to the graph.
            If a xmi file is given, the model instance will be imported into the graph.
            Any errors will be reported by exception.
            </summary>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="ecoreFilenames">A list of ECore model specification files. It must at least contain one element.</param>
            <param name="grgFilename">A grg file to be used to create the graph, or null.</param>
            <param name="xmiFilename">The filename of the model instance to be imported, or null.</param>
            <param name="noPackageNamePrefix">Prefix the types with the name of the package? Can only be used if names from the packages are disjoint.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ECoreImport.root">
            <summary>
            root of the xml tree hierarchy
            needed to decode path references for documents not using xmi:id to reference elements
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ECoreImport.graph">
            <summary>
            the graph we build by importing
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ECoreImport.nodeMap">
            <summary>
            map of xmi:id to the graph node it denotes
            might be empty for documents which don't use ids to reference elements but paths
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GRGExport">
            <summary>
            Exports graphs in GRG format, i.e. as GrGen rules.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRGExport.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.String)">
            <summary>
            Exports the given graph to a GRG file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="exportFilename">The filename for the exported file.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRGExport.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter)">
            <summary>
            Exports the given graph to the file given by the stream writer in grg format, i.e. as GrGen rule.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="writer">The stream writer to export to.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRGExport.ExportYouMustCloseStreamWriter(de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter,System.String)">
            <summary>
            Exports the given graph to the file given by the stream writer in grg format, i.e. as GrGen rule.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a NamedGraph.</param>
            <param name="sw">The stream writer of the file to export into. The stream writer is not closed automatically.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRGExport.EmitAttributeInitialization(de.unika.ipd.grGen.libGr.IGraphElement,de.unika.ipd.grGen.libGr.AttributeType,System.Object,de.unika.ipd.grGen.libGr.INamedGraph,System.String,System.IO.StreamWriter)">
            <summary>
            Emits the node/edge attribute initialization code in graph exporting
            for an attribute of the given type with the given value into the stream writer
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRGExport.EmitAttribute(de.unika.ipd.grGen.libGr.AttributeType,System.Object,de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter)">
            <summary>
            Emits the attribute value as code
            for an attribute of the given type with the given value into the stream writer
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRGExport.ToString(System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.INamedGraph)">
            <summary>
            type needed for enum, otherwise null ok
            graph needed for node/edge in set/map, otherwise null ok
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GRSExport">
            <summary>
            Exports graphs to the GRS format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.String)">
            <summary>
            Exports the given graph to a GRS file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="exportFilename">The filename for the exported file.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.String}})">
            <summary>
            Exports the given graph to a GRS file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="exportFilename">The filename for the exported file.</param>
            <param name="nonewgraph">If true, the new graph command is not emitted.</param>
            <param name="typesToAttributesToSkip">Gives a dictionary with type names containing a dictionary with attribute names that are not to be emitted</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter)">
            <summary>
            Exports the given graph to the file given by the stream writer in grs format.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="writer">The stream writer to export to.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.String}})">
            <summary>
            Exports the given graph to the file given by the stream writer in grs format.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="writer">The stream writer to export to.</param>
            <param name="nonewgraph">If true, the new graph command is not emitted.</param>
            <param name="typesToAttributesToSkip">Gives a dictionary with type names containing a dictionary with attribute names that are not to be emitted</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.ExportYouMustCloseStreamWriter(de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter,System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.String}})">
            <summary>
            Exports the given graph to the file given by the stream writer in grs format.
            Any errors will be reported by exception.
            Returns the graph export context of the main graph.
            </summary>
            <param name="graph">The graph to export. Must be a named graph.</param>
            <param name="sw">The stream writer of the file to export into. The stream writer is not closed automatically.</param>
            <param name="modelPathPrefix">Path to the model.</param>
            <param name="nonewgraph">If true, the new graph command is not emitted.</param>
            <param name="typesToAttributesToSkip">Gives a dictionary with type names containing a dictionary with attribute names that are not to be emitted</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.EmitAttributeInitialization(de.unika.ipd.grGen.libGr.MainGraphExportContext,de.unika.ipd.grGen.libGr.AttributeType,System.Object,de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter)">
            <summary>
            Emits the node/edge attribute initialization code in graph exporting
            for an attribute of the given type with the given value into the stream writer.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.EmitAttribute(de.unika.ipd.grGen.libGr.MainGraphExportContext,de.unika.ipd.grGen.libGr.AttributeType,System.Object,de.unika.ipd.grGen.libGr.INamedGraph,System.IO.StreamWriter)">
            <summary>
            Emits the attribute value as code
            for an attribute of the given type with the given value into the stream writer
            Main graph context is needed to get access to the graph -> env dictionary.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSExport.ToString(de.unika.ipd.grGen.libGr.MainGraphExportContext,System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.INamedGraph)">
            <summary>
            Type needed for enum, otherwise null ok.
            Graph needed for node/edge, otherwise null ok.
            Main graph context needed to get access to the graph -> env dictionary for subgraph.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GRSImport">
            <summary>
            Imports graphs from files in GRS format.
            Implementation note: this is a boring hand written lexer and parser,
            needed because the lexer/parser generated by CSharpCC that was replaced by it
            fired a multitude of "LookaheadSuccess"-exceptions, wreaking havoc on performance.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSImport.Import(System.String,System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the given graph from a file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="modelOverride">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSImport.Import(System.IO.TextReader,System.Int64,System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the given graph from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="reader">The text reader input stream import source.</param>
            <param name="fileSize">The size of the input file.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="modelOverride">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSImport.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the given graph from a file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSImport.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the given graph from a file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GRSImport.Import(System.IO.TextReader,System.Int64,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the given graph from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="reader">The text reader input stream import source.</param>
            <param name="fileSize">The size of the input file.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GXLExport">
            <summary>
            Exports graphs to the GXL format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.String)">
            <summary>
            Exports the given graph to a GXL file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="exportFilename">The filename for the exported file.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.IO.TextWriter)">
            <summary>
            Exports the given graph in GXL format to the given text writer output stream.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="streamWriter">The stream writer to export to.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLExport.GetDomainID(de.unika.ipd.grGen.libGr.AttributeKind,de.unika.ipd.grGen.libGr.EnumAttributeType)">
            <summary>
            Returns the domain ID for the given attribute type.
            </summary>
            <param name="kind">The attribute kind</param>
            <param name="enumAttrType">For enums, enumAttrType must be valid. Otherwise it may be null.</param>
            <returns></returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GXLImport">
            <summary>
            Imports graphs from the GXL format.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.String,System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from a GXL file
            with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported.</param>
            <param name="modelOverride">If not null, overrides the filename of the graph model to be used.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.IO.TextReader,System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="inStream">The text reader input stream import source.</param>
            <param name="modelOverride">If not null, overrides the filename of the graph model to be used.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from a GXL file
            with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported,
                the model specification part will be ignored.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GXLImport.Import(System.IO.TextReader,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports the first graph not being of type "gxl-1.0" from the given text reader input stream.
            Any errors will be reported by exception.
            </summary>
            <param name="inStream">The text reader input stream import source.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.XMIExport">
            <summary>
            Exports graphs to the XMI format (assuming a matching ecore exists).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.XMIExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.String)">
            <summary>
            Exports the given graph to a XMI file with the given filename.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="exportFilename">The filename for the exported file.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.XMIExport.Export(de.unika.ipd.grGen.libGr.IGraph,System.IO.TextWriter)">
            <summary>
            Exports the given graph in XMI format to the given text writer output stream.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="streamWriter">The stream writer to export to.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SwitchToSubgraphHandler">
            <summary>
            Represents a method called directly before graph processing switches to a subgraph.
            (Graph processing means rule and sequence execution. Not called when the main graph is replaced.)
            </summary>
            <param name="graph">The new graph switched to.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ReturnFromSubgraphHandler">
            <summary>
            Represents a method called directly after graph processing returned back (from a previous switch).
            (To the main graph, or a subgraph previously switched to. Graph processing means rule and sequence execution.)
            </summary>
            <param name="graph">The old graph returned from.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DebugEnterHandler">
            <summary>
            Represents a method called directly after a computation has been entered (for tracing/debugging purpose).
            Applying user-defined computation borders, or e.g. auto-generated rule eval or procedure call borders;
            but not interpreted sequences, they receive dedicated treatement in the graph processing environment, are debugged directly.
            </summary>
            <param name="message">The message = name of the computation entered.</param>
            <param name="values">Some values specified at entering, typically input parameters of a computation call.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DebugExitHandler">
            <summary>
            Represents a method called directly before a computation is left (for tracing/debugging purpose).
            Applying user-defined computation borders, or e.g. auto-generated rule eval or procedure call borders;
            but not interpreted sequences, they receive dedicated treatement in the graph processing environment, are debugged directly.
            </summary>
            <param name="message">The message = name of the computation to be left. (Must be the same as message of the corresponding enter, stored on the debug traces stack.)</param>
            <param name="values">Some values specified at exiting, typically output parameters of a computation call.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DebugEmitHandler">
            <summary>
            Represents a method called by the user to emit debugging information, not halting execution.
            (Stored on the debug traces stack, removed when its directly nesting debug enter is exited.)
            </summary>
            <param name="message">The message emitted.</param>
            <param name="values">Some further values to be emitted with more detailed information.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DebugHaltHandler">
            <summary>
            Represents a method called by the user to halt execution, emitting some debugging information.
            </summary>
            <param name="message">The message emitted and attached to the halt.</param>
            <param name="values">Some further values to be emitted with more detailed information.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DebugHighlightHandler">
            <summary>
            Represents a method called by the user to highlight some elements in the graph, halting execution.
            </summary>
            <param name="message">The message attached to the highlight.</param>
            <param name="values">The values to highlight (graph elements, containers of graph elements, visited flag ids).</param>
            <param name="annotations">The annotation to highlight the elements with in the graph.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment">
            <summary>
            An environment extending basic action execution with subaction debugging, plus subgraph nesting, 
            and output -- for one textual emits, and for the other graph change recording.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.SwitchToSubgraph(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Switches the graph to the given (sub)graph.
            (One level added to the current graph stack.)
            </summary>
            <param name="newGraph">The new graph to use as current graph</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.ReturnFromSubgraph">
            <summary>
            Returns from the last switch to subgraph.
            (One level back on the current graph stack.)
            </summary>
            <returns>The lastly used (sub)graph, now not used any more</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.IsInSubgraph">
            <summary>
            Returns true when graph processings is currently occuring inside a subgraph,
            returns false when the main host graph is currently processed
            (i.e. only one entry on the current graph stack is existing).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.Recorder">
            <summary>
            The recorder of the main graph.
            Might be null (is set if a named graph is available, then the persistent names are taken from the named graph).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.EmitWriter">
            <summary>
            The writer used by emit statements. By default this is Console.Out.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.EmitWriterDebug">
            <summary>
            The writer used by emitdebug statements. This is Console.Out, and can't be redirected to a file in contrast to the EmitWriter.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnSwitchingToSubgraph">
            <summary>
            Fired when graph processing (rule and sequence execution) is switched to a (sub)graph.
            (Not fired when the main graph is replaced by another main graph, or initialized.)
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnReturnedFromSubgraph">
            <summary>
            Fired when graph processing is returning back after a switch.
            (To the main graph, or a subgraph previously switched to.)
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnDebugEnter">
            <summary>
            Fired when a debug entity is entered.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnDebugExit">
            <summary>
            Fired when a debug entity is left.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnDebugEmit">
            <summary>
            Fired when a debug emit is executed.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnDebugHalt">
            <summary>
            Fired when a debug halt is executed.
            </summary>
        </member>
        <member name="E:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.OnDebugHighlight">
            <summary>
            Fired when a debug highlight is executed.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.DebugEntering(System.String,System.Object[])">
            <summary>
            Fires an OnDebugEnter event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.DebugExiting(System.String,System.Object[])">
            <summary>
            Fires an OnDebugExit event.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.DebugEmitting(System.String,System.Object[])">
            <summary>
            Fires an OnDebugEmit event. 
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.DebugHalting(System.String,System.Object[])">
            <summary>
            Fires an OnDebugHalt event. 
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment.DebugHighlighting(System.String,System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.String})">
            <summary>
            Fires an OnDebugHighlight event. 
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatch">
            <summary>
            Base class of classes representing matches.
            One exact match class is generated per pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Pattern">
            <summary>
            The match object represents a match of the pattern given by this member.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.MatchOfEnclosingPattern">
            <summary>
            The match of the enclosing pattern if this is the pattern of
            a subpattern, alternative, iterated or independent; otherwise null
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.Clone">
            <summary>
            Clone the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.Mark(System.Boolean)">
            <summary>
            Writes a flag to the match, which is remembered; helper for symmetry checking
            </summary>
            <param name="flag">The boolean value to write</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.IsMarked">
            <summary>
            Reads a previously written flag (intially false); helper for symmetry checking
            </summary>
            <returns></returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.IterationNumber">
            <summary>
            Helper for parallelized matching, for building the matches list as if it was matched sequentially
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Nodes">
            <summary>
            Enumerable returning enumerator over matched nodes (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NodesEnumerator">
            <summary>
            Enumerator over matched nodes (efficiency in between getNodeAt and Nodes)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfNodes">
            <summary>
            Number of nodes in the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getNodeAt(System.Int32)">
            <summary>
            Returns node at position index (most efficient access)
            </summary>
            <param name="index">The position of the node to return</param>
            <returns>The node at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getNode(System.String)">
            <summary>
            Returns node bound to the pattern node of the given name or null if no such pattern node exists
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Edges">
            <summary>
            Enumerable returning enumerator over matched edges (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.EdgesEnumerator">
            <summary>
            Enumerator over matched edges (efficiency in between getEdgeAt and Edges)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfEdges">
            <summary>
            Number of edges in the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getEdgeAt(System.Int32)">
            <summary>
            Returns edge at position index (most efficient access)
            </summary>
            <param name="index">The position of the edge to return</param>
            <returns>The edge at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getEdge(System.String)">
            <summary>
            Returns edge bound to the pattern edge of the given name or null if no such pattern edge exists
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Variables">
            <summary>
            Enumerable returning enumerator over matched variables (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.VariablesEnumerator">
            <summary>
            Enumerator over matched variables (efficiency in between getVariableAt and Variables)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfVariables">
            <summary>
            Number of variables in the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getVariableAt(System.Int32)">
            <summary>
            Returns variable at position index (most efficient access)
            </summary>
            <param name="index">The position of the variable to return</param>
            <returns>The variable at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getVariable(System.String)">
            <summary>
            Returns value bound to the pattern variable of the given name or null if no such pattern variable exists
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.EmbeddedGraphs">
            <summary>
            Enumerable returning enumerator over submatches due to subpatterns (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.EmbeddedGraphsEnumerator">
            <summary>
            Enumerator over submatches due to subpatterns (efficiency in between getEmbeddedGraphAt and EmbeddedGraphs)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfEmbeddedGraphs">
            <summary>
            Number of submatches due to subpatterns in the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getEmbeddedGraphAt(System.Int32)">
            <summary>
            Returns submatch due to subpattern at position index (most efficient access)
            </summary>
            <param name="index">The position of the submatch due to subpattern to return</param>
            <returns>The submatch due to subpattern at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getEmbeddedGraph(System.String)">
            <summary>
            Returns submatch bound to the subpattern of the given name or null if no such subpattern exists
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Alternatives">
            <summary>
            Enumerable returning enumerator over submatches due to alternatives (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.AlternativesEnumerator">
            <summary>
            Enumerator over submatches due to alternatives. (efficiency in between getAlternativeAt and Alternatives)
            You can find out which alternative case was matched by inspecting the Pattern member of the submatch.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfAlternatives">
            <summary>
            Number of submatches due to alternatives in the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getAlternativeAt(System.Int32)">
            <summary>
            Returns submatch due to alternatives at position index (most efficient access)
            </summary>
            <param name="index">The position of the submatch due to alternatives to return</param>
            <returns>The submatch due to alternatives at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getAlternative(System.String)">
            <summary>
            Returns submatch bound to the pattern alternative of the given name or null if no such pattern alternative exists
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Iterateds">
            <summary>
            Enumerable returning enumerator over submatches due to iterateds (most inefficient access)
            The submatch is a list of all matches of the iterated pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.IteratedsEnumerator">
            <summary>
            Enumerator over submatches due to iterateds. (efficiency in between getIteratedAt and Iterateds)
            The submatch is a list of all matches of the iterated pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfIterateds">
            <summary>
            Number of submatches due to iterateds in the match.
            Corresponding to the number of iterated patterns, not the number of matches of some iterated pattern.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getIteratedAt(System.Int32)">
            <summary>
            Returns submatch due to iterateds at position index (most efficient access)
            The submatch is a list of all matches of the iterated pattern.
            </summary>
            <param name="index">The position of the submatch due to iterateds to return</param>
            <returns>The submatch due to iterateds at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getIterated(System.String)">
            <summary>
            Returns submatch bound to the iterated pattern of the given name or null if no such iterated pattern exists
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.Independents">
            <summary>
            Enumerable returning enumerator over submatches due to independents (most inefficient access)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.IndependentsEnumerator">
            <summary>
            Enumerator over submatches due to independents. (efficiency in between getIndependentAt and Independents)
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatch.NumberOfIndependents">
            <summary>
            Number of submatches due to independents in the match
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getIndependentAt(System.Int32)">
            <summary>
            Returns submatch due to independents at position index (most efficient access)
            </summary>
            <param name="index">The position of the submatch due to independents to return</param>
            <returns>The submatch due to independents at the given index</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatch.getIndependent(System.String)">
            <summary>
            Returns submatch bound to the independent pattern of the given name or null if no such independent pattern exists
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatches">
            <summary>
            An object representing a (possibly empty) set of matches in a graph before the rewrite has been applied.
            If it is a match of an action, it is returned by IAction.Match() and given to the OnMatched event.
            Otherwise it's the match of an iterated-pattern, and the producing action is null.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatches.Producer">
            <summary>
            The action object used to generate this IMatches object
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatches.First">
            <summary>
            Returns the first match (null if no match exists).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatches.Count">
            <summary>
            The number of matches found by Producer
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.GetMatch(System.Int32)">
            <summary>
            Returns the match with the given index. Invalid indices cause an exception.
            This may be slow. If you want to iterate over the elements the Matches IEnumerable should be used.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.RemoveMatch(System.Int32)">
            <summary>
            Removes the match at the given index and returns it.
            </summary>
            <param name="index">The index of the match to be removed.</param>
            <returns>The removed match.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.Clone">
            <summary>
            Clone the matches
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterKeepFirst(System.Int32)">
            <summary>
            For filtering with the auto-supplied filter keepFirst
            </summary>
            <param name="count">The number of matches to keep</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterKeepLast(System.Int32)">
            <summary>
            For filtering with the auto-supplied filter keepLast
            </summary>
            <param name="count">The number of matches to keep</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterRemoveFirst(System.Int32)">
            <summary>
            For filtering with the auto-supplied filter removeFirst
            </summary>
            <param name="count">The number of matches to remove</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterRemoveLast(System.Int32)">
            <summary>
            For filtering with the auto-supplied filter removeLast
            </summary>
            <param name="count">The number of matches to remove</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterKeepFirstFraction(System.Double)">
            <summary>
            For filtering with the auto-supplied filter keepFirstFraction
            </summary>
            <param name="fraction">The fraction of matches to keep</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterKeepLastFraction(System.Double)">
            <summary>
            For filtering with the auto-supplied filter keepLastFraction
            </summary>
            <param name="fraction">The fraction of matches to keep</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterRemoveFirstFraction(System.Double)">
            <summary>
            For filtering with the auto-supplied filter removeFirstFraction
            </summary>
            <param name="fraction">The fraction of matches to keep</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatches.FilterRemoveLastFraction(System.Double)">
            <summary>
            For filtering with the auto-supplied filter removeLastFraction
            </summary>
            <param name="fraction">The fraction of matches to keep</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatchesExact`1">
            <summary>
            An object representing a (possibly empty) set of matches in a graph before the rewrite has been applied,
            capable of handing out enumerators of exact match interface type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.GetEnumeratorExact">
            <summary>
            Returns enumerator over matches of exact type
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchesExact`1.FirstExact">
            <summary>
            Returns the first match of exact type (null if no match exists).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.GetMatchExact(System.Int32)">
            <summary>
            Returns the match of exact type with the given index. Invalid indices cause an exception.
            This may be slow. If you want to iterate over the elements the MatchesExact IEnumerable should be used.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.RemoveMatchExact(System.Int32)">
            <summary>
            Removes the match of exact type at the given index and returns it.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.ToList">
            <summary>
            Returns the content of the current matches list in form of an array which can be efficiently indexed and reordered.
            The array is destroyed when this method is called again, the content is destroyed when the rule is matched again (there is only one array existing).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IMatchesExact`1.FromList">
            <summary>
            Reincludes the array handed out with ToList, REPLACING the current matches with the ones from the list.
            The list might have been reordered, matches might have been removed, or even added.
            Elements which were null-ed count as deleted; this gives an O(1) mechanism to remove from the array.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ITypeModel">
            <summary>
            A type model for node or edge elements.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.IsNodeModel">
            <summary>
            Specifies whether this type model is model for nodes (= true) or for edges (= false).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.RootType">
            <summary>
            The root type of this type model. All other types of this model inherit from the root type (in the GrGen model, not in C#).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ITypeModel.GetType(System.String)">
            <summary>
            Returns the element type with the given type name or null, if no type with this name exists.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.Types">
            <summary>
            An array of all types in this type model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.TypeTypes">
            <summary>
            An array of C# types of model types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ITypeModel.AttributeTypes">
            <summary>
            Enumerates all attribute types of this model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.INodeModel">
            <summary>
            A type model for nodes.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INodeModel.RootType">
            <summary>
            The root type of this type model. All other types of this model inherit from the root type (in the GrGen model, not in C#).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.INodeModel.GetType(System.String)">
            <summary>
            Returns the node type with the given type name or null, if no type with this name exists.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.INodeModel.Types">
            <summary>
            An array of all types in this type model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IEdgeModel">
            <summary>
            A type model for edges.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdgeModel.RootType">
            <summary>
            The root type of this type model. All other types of this model inherit from the root type (in the GrGen model, not in C#).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IEdgeModel.GetType(System.String)">
            <summary>
            Returns the edge type with the given type name or null, if no type with this name exists.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IEdgeModel.Types">
            <summary>
            An array of all types in this type model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ValidateInfo">
            <summary>
            A representation of a GrGen connection assertion.
            Used by BaseGraph.Validate().
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.EdgeType">
            <summary>
            The edge type to which this constraint applies.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.SourceType">
            <summary>
            The node type to which applicable source nodes must be compatible.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.TargetType">
            <summary>
            The node type to which applicable target nodes must be compatible.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.SourceLower">
            <summary>
            The lower bound on the out-degree of the source node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.SourceUpper">
            <summary>
            The upper bound on the out-degree of the source node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.TargetLower">
            <summary>
            The lower bound on the in-degree of the target node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.TargetUpper">
            <summary>
            The upper bound on the in-degree of the target node according to edges compatible to EdgeType.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ValidateInfo.BothDirections">
            <summary>
            Check the connection assertion in both directions (i.e. for reverse source and target, too)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ValidateInfo.#ctor(de.unika.ipd.grGen.libGr.EdgeType,de.unika.ipd.grGen.libGr.NodeType,de.unika.ipd.grGen.libGr.NodeType,System.Int64,System.Int64,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Constructs a ValidateInfo instance.
            </summary>
            <param name="edgeType">The edge type to which this constraint applies.</param>
            <param name="sourceType">The node type to which applicable source nodes must be compatible.</param>
            <param name="targetType">The node type to which applicable target nodes must be compatible.</param>
            <param name="sourceLower">The lower bound on the out-degree of the source node according to edges compatible to EdgeType.</param>
            <param name="sourceUpper">The upper bound on the out-degree of the source node according to edges compatible to EdgeType.</param>
            <param name="targetLower">The lower bound on the in-degree of the target node according to edges compatible to EdgeType.</param>
            <param name="targetUpper">The upper bound on the in-degree of the target node according to edges compatible to EdgeType.</param>
            <param name="bothDirections">Both directions are to be checked (undirected edge or arbitrary direction)</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.CAEType">
            <summary>
            Specifies the type of a connection assertion error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.EdgeNotSpecified">
            <summary>
            An edge was not specified.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooFewSources">
            <summary>
            A node has too few outgoing edges of some type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooManySources">
            <summary>
            A node has too many outgoing edges of some type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooFewTargets">
            <summary>
            A node has too few incoming edges of some type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.CAEType.NodeTooManyTargets">
            <summary>
            A node has too many incoming edges of some type.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ConnectionAssertionError">
            <summary>
            A description of an error, found during the validation process.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.CAEType">
            <summary>
            The type of error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.Elem">
            <summary>
            Specifies the graph element, where the error was found.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.FoundEdges">
            <summary>
            The number of edges found in the graph, if CAEType != CAEType.EdgeNotSpecified.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ConnectionAssertionError.ValidateInfo">
            <summary>
            The corresponding ValidatedInfo object, if CAEType != CAEType.EdgeNotSpecified.
            Otherwise it is null.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ConnectionAssertionError.#ctor(de.unika.ipd.grGen.libGr.CAEType,de.unika.ipd.grGen.libGr.IGraphElement,System.Int64,de.unika.ipd.grGen.libGr.ValidateInfo)">
            <summary>
            Initializes a ConnectionAssertionError instance.
            </summary>
            <param name="caeType">The type of error.</param>
            <param name="elem">The graph element, where the error was found.</param>
            <param name="found">The number of edges found in the graph, if CAEType != CAEType.EdgeNotSpecified.</param>
            <param name="valInfo">The corresponding ValidatedInfo object, if CAEType != CAEType.EdgeNotSpecified, otherwise null.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IndexDescription">
            <summary>
            The description of a single index, base for all kinds of index descriptions.
            (You must typecheck and cast to the concrete description type for more information).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.IndexDescription.Name">
            <summary>
            The name the index was declared with
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeIndexDescription">
            <summary>
            The description of a single attribute index.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeIndexDescription.GraphElementType">
            <summary>
            The node or edge type the index is defined for.
            (May be a subtype of the type the attribute was defined for first.)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeIndexDescription.AttributeType">
            <summary>
            The attribute type the index is declared on.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IncidenceCountIndexDescription">
            <summary>
            The description of a single incidence count index.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.IncidenceCountIndexDescription.Direction">
            <summary>
            The direction of incidence followed.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.IncidenceCountIndexDescription.StartNodeType">
            <summary>
            The type of the start node that is taken into account for the incidence count.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.IncidenceCountIndexDescription.IncidentEdgeType">
            <summary>
            The type of the incident edge that is taken into account for the incidence count.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.IncidenceCountIndexDescription.AdjacentNodeType">
            <summary>
            The type of the adjacent node that is taken into account for the incidence count.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IGraphModel">
            <summary>
            A model of a GrGen graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.ModelName">
            <summary>
            The name of this model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.NodeModel">
            <summary>
            The model of the nodes.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.EdgeModel">
            <summary>
            The model of the edges.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.Packages">
            <summary>
            Enumerates all packages declared in this model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.EnumAttributeTypes">
            <summary>
            Enumerates all enum attribute types declared for this model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.ValidateInfo">
            <summary>
            Enumerates all ValidateInfo objects describing constraints on the graph structure.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.IndexDescriptions">
            <summary>
            Enumerates the descriptions of all attribute and incidence count indices declared in this model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.GraphElementUniquenessIsEnsured">
            <summary>
            If true you may query the graph elements with GetUniqueId for their unique id
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.GraphElementsAreAccessibleByUniqueId">
            <summary>
            If true you may query the graph with GetGraphElement for a graph element of a given unique id
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.BranchingFactorForEqualsAny">
            <summary>
            Tells about the number of threads to use for the equalsAny and equalsAnyStructurally functions
            The normal non-parallel isomorphy comparison functions are used if this value is below 2
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.CreateAndBindIndexSet(de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Called by the graph (generic implementation) to create and bind its index set (generated code).
            Always called by an empty graph just constructed.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.FillIndexSetAsClone(de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.IDictionary{de.unika.ipd.grGen.libGr.IGraphElement,de.unika.ipd.grGen.libGr.IGraphElement})">
            <summary>
            Called on an index set that was created and bound,
            when the graph was copy constructed from an original graph,
            to fill in the already available cloned content from the original graph.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.Parse(System.IO.TextReader,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Called during .grs import, at exactly the position in the text reader where the attribute begins.
            For attribute type object or a user defined type, which is treated as object.
            The implementation must parse from there on the attribute type requested.
            It must not parse beyond the serialized representation of the attribute, 
            i.e. Peek() must return the first character not belonging to the attribute type any more.
            Returns the parsed object.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.Serialize(System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Called during .grs export, the implementation must return a string representation for the attribute.
            For attribute type object or a user defined type, which is treated as object.
            The serialized string must be parseable by Parse.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.Emit(System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Called during debugging or emit writing, the implementation must return a string representation for the attribute.
            For attribute type object or a user defined type, which is treated as object.
            The attribute type may be null.
            The string is meant for consumption by humans, it does not need to be parseable.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.External(System.String,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Called when the grs importer or the shell hits a line starting with "external".
            The content of that line is handed in.
            This is typically used while replaying changes containing a method call of an external type
            -- after such a line was recorded, by the method called, by writing to the recorder.
            This is meant to replay fine-grain changes of graph attributes of external type,
            in contrast to full assignments handled by Parse and Serialize.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.AsGraph(System.Object,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Called during debugging on user request, the implementation must return a named graph representation for the attribute.
            For attribute type object or a user defined type, which is treated as object.
            The attribute type may be null. The return graph must be of the same model as the graph handed in.
            The named graph is meant for display in the debugger, to visualize the internal structure of some attribute type.
            This way you can graphically inspect your own data types which are opaque to GrGen with its debugger.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.ExternalTypes">
            <summary>
            The external types known to this model, it contains always and at least the object type,
            the bottom type of the external attribute types hierarchy.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.IsEqualClassDefined">
            <summary>
            Tells whether AttributeTypeObjectCopierComparer.IsEqual functions are available,
            for object and external types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.IsLowerClassDefined">
            <summary>
            Tells whether AttributeTypeObjectCopierComparer.IsLower functions are available,
            for object and external types.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.IsEqual(System.Object,System.Object)">
            <summary>
            Calls the AttributeTypeObjectCopierComparer.IsEqual function for object type arguments,
            when an attribute of object or external type is compared for equality in the interpreted sequences;
            you may dispatch from there to the type exact comparisons, which are called directly from the compiled sequences.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IGraphModel.IsLower(System.Object,System.Object)">
            <summary>
            Calls the AttributeTypeObjectCopierComparer.IsLower function for object type arguments,
            when an attribute of object or external type is compared for ordering in the interpreted sequences;
            you may dispatch from there to the type exact comparisons, which are called directly from the compiled sequences.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IGraphModel.MD5Hash">
            <summary>
            An MD5 hash sum of the model.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeKind">
            <summary>
            Specifies the kind of a GrGen attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.ByteAttr">
            <summary>The attribute is a byte (signed).</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.ShortAttr">
            <summary>The attribute is a short.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.IntegerAttr">
            <summary>The attribute is an integer.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.LongAttr">
            <summary>The attribute is a long.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.BooleanAttr">
            <summary>The attribute is a boolean.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.StringAttr">
            <summary>The attribute is a string.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.EnumAttr">
            <summary>The attribute is an enum.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.FloatAttr">
            <summary>The attribute is a float.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.DoubleAttr">
            <summary>The attribute is a double.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.ObjectAttr">
            <summary>The attribute is an object (this includes external attribute types).</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.MapAttr">
            <summary>The attribute is a map.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.SetAttr">
            <summary>The attribute is a set.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.ArrayAttr">
            <summary>The attribute is an array.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.DequeAttr">
            <summary>The attribute is a deque.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.NodeAttr">
            <summary>The attribute is a node (only valid for set/map/array key/value type).</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.EdgeAttr">
            <summary>The attribute is an edge (only valid for set/map/array key/value type).</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeKind.GraphAttr">
            <summary>The attribute is a graph (created as a subgraph of the host graph).</summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AttributeType">
            <summary>
            Describes a GrGen attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.Name">
            <summary>
            The name of the attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.OwnerType">
            <summary>
            The model type owning this attribute, i.e. the type which defined this attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.Kind">
            <summary>
            The kind of the attribute.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.EnumType">
            <summary>
            The enum type description, if Kind == AttributeKind.EnumAttr. Otherwise it is null.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.ValueType">
            <summary>
            The attribute type of the value of the set, if Kind == AttributeKind.SetAttr.
            The attribute type of the value of the map, if Kind == AttributeKind.MapAttr.
            The attribute type of the value of the array, if Kind == AttributeKind.ArrayAttr.
            The attribute type of the value of the deque, if Kind == AttributeKind.DequeAttr.
            Undefined otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.KeyType">
            <summary>
            The attribute type of the key of the map, if Kind == AttributeKind.MapAttr.
            Undefined otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.TypeName">
            <summary>
            The name of the attribute type, if Kind == AttributeKind.NodeAttr || Kind == AttributeKind.EdgeAttr
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.Package">
            <summary>
            The package name if this is a node or edge type that is contained in a package, otherwise null
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.PackagePrefixedTypeName">
            <summary>
            The name of the attribute type with the package as prefix if it is contained in a package, if Kind == AttributeKind.NodeAttr || Kind == AttributeKind.EdgeAttr
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.Type">
            <summary>
            The .NET type of the Attribute Type
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.AttributeType.Annotations">
            <summary>
            The annotations of the attribute
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AttributeType.annotations">
            <summary>
            The annotations of the attribute
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AttributeType.#ctor(System.String,de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.AttributeKind,de.unika.ipd.grGen.libGr.EnumAttributeType,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeType,System.String,System.String,System.String,System.Type)">
            <summary>
            Initializes an AttributeType instance.
            </summary>
            <param name="name">The name for the attribute.</param>
            <param name="ownerType">The owner model type.</param>
            <param name="kind">The kind of the attribute.</param>
            <param name="enumType">The enum type description, if Kind == AttributeKind.EnumAttr, otherwise null.</param>
            <param name="valueType">The attribute type of the value of the set, if Kind == AttributeKind.SetAttr; the attribute type of the value of the map, if Kind == AttributeKind.MapAttr; the attribute type of the value of the array, if Kind == AttributeKind.ArrayAttr; the attribute type of the value of the deque, if Kind == AttributeKind.DequeAttr; otherwise null. </param>
            <param name="keyType">The attribute type of the key of the map, if Kind == AttributeKind.MapAttr; otherwise null.</param>
            <param name="typeName">The name of the attribute type, if Kind == AttributeKind.NodeAttr || Kind == AttributeKind.EdgeAttr; otherwise null.</param>
            <param name="package">The package name if this is a node or edge type that is contained in a package, otherwise null.</param>
            <param name="packagePrefixedTypeName">The name of the attribute type with the package as prefix if it is contained in a package, if Kind == AttributeKind.NodeAttr || Kind == AttributeKind.EdgeAttr.</param>
            <param name="type">The type of the attribute type.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AttributeType.GetKindName(de.unika.ipd.grGen.libGr.AttributeKind)">
            <summary>
            Returns the name of the given basic attribute kind (enum,container not supported)
            </summary>
            <param name="attrKind">The AttributeKind value</param>
            <returns>The name of the attribute kind</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AttributeType.GetKindName">
            <summary>
            Returns the name of the kind
            </summary>
            <returns>The name of the kind of the attribute</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EnumMember">
            <summary>
            A description of a GrGen enum member.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumMember.Value">
            <summary>
            The integer value of the enum member.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumMember.Name">
            <summary>
            The name of the enum member.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EnumMember.#ctor(System.Int32,System.String)">
            <summary>
            Initializes an EnumMember instance.
            </summary>
            <param name="value">The value of the enum member.</param>
            <param name="name">The name of the enum member.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EnumMember.CompareTo(de.unika.ipd.grGen.libGr.EnumMember)">
            <summary>
            Defines order on enum members along the values (NOT the names)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EnumAttributeType">
            <summary>
            A description of a GrGen enum type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumAttributeType.Name">
            <summary>
            The name of the enum type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumAttributeType.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumAttributeType.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EnumAttributeType.EnumType">
            <summary>
            The .NET type for the enum type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EnumAttributeType.#ctor(System.String,System.String,System.String,System.Type,de.unika.ipd.grGen.libGr.EnumMember[])">
            <summary>
            Initializes an EnumAttributeType instance.
            </summary>
            <param name="name">The name of the enum type.</param>
            <param name="name">The package the enum is contained in, or null if it is not contained in a package.</param>
            <param name="name">The name of the enum type; prefixed by the package name plus a double colon, in case it is contain in a package.</param>
            <param name="enumType">The .NET type for the enum type.</param>
            <param name="memberArray">An array of all enum members.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EnumAttributeType.Members">
            <summary>
            Enumerates all enum members.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EnumAttributeType.Item(System.Int32)">
            <summary>
            Returns an enum member corresponding the given enum member integer or null if no such member exists
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SetValueType">
            <summary>
            A dummy type used as value type for dictionaries representing sets.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.GrGenType">
            <summary>
            A representation of a GrGen graph element type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.#ctor(System.Int32)">
            <summary>
            Initializes a GrGenType object.
            </summary>
            <param name="typeID">The type id for this GrGen type.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.TypeID">
            <summary>
            An identification number of the type, unique among all other types of the same kind (node/edge) in the owning type model.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.subOrSameGrGenTypes">
            <summary>
            Array containing this type first and following all sub types.
            </summary>
            <remarks>
            Must be assigned the same array as SubOrSameTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.directSubGrGenTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
            <remarks>
            Must be assigned the same array as DirectSubTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.superOrSameGrGenTypes">
            <summary>
            Array containing this type first and following all super types.
            </summary>
            <remarks>
            Must be assigned the same array as SubOrSameTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.GrGenType.directSuperGrGenTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
            <remarks>
            Must be assigned the same array as DirectSuperTypes of NodeType/EdgeType.
            It is ugly, but one of the few ways to override a property of
            an abstract class with another return type.
            Not meant to be used by users, but public because of assignments from
            generated code.
            </remarks>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SubOrSameTypes">
            <summary>
            Array containing this type first and following all sub types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.DirectSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SuperOrSameTypes">
            <summary>
            Array containing this type first and following all super types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SubTypes">
            <summary>
            Enumerates over all real subtypes of this type
            Warning: You should not use this property, but SubOrSameTypes starting from index 1,
                     because Enumerators in .NET are quite slow!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.SuperTypes">
            <summary>
            Enumerates over all real supertypes of this type
            Warning: You should not use this property, but SuperOrSameTypes starting from index 1,
                     because Enumerators in .NET are quite slow!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.HasSuperTypes">
            <summary>
            True, if this type has any super types, i.e. if it is not the node/edge root type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.HasSubTypes">
            <summary>
            True, if this type has any sub types.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.IsNodeType">
            <summary>
            True, if this type is a node type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.IsAbstract">
            <summary>
            True, if this type is an abstract element type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.IsConst">
            <summary>
            True, if this type is a const element type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.NumAttributes">
            <summary>
            The number of attributes of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.AttributeTypes">
            <summary>
            Enumerates all attribute types of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.GetAttributeType(System.String)">
            <summary>
            Returns an AttributeType object for the given attribute name.
            If this type does not have an attribute with this name, null is returned.
            </summary>
            <param name="name">Name of the attribute</param>
            <returns>The AttributeType matching the name, or null if there is no such</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.NumFunctionMethods">
            <summary>
            The number of function methods of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.FunctionMethods">
            <summary>
            Enumerates all function methods of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.GetFunctionMethod(System.String)">
            <summary>
            Returns a function definition object for the given function method name.
            If this type does not have a function method with this name, null is returned.
            </summary>
            <param name="name">Name of the function method</param>
            <returns>The function definition of the function method matching the name, or null if there is no such</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.NumProcedureMethods">
            <summary>
            The number of procedure methods of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.GrGenType.ProcedureMethods">
            <summary>
            Enumerates all procedure methods of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.GetProcedureMethod(System.String)">
            <summary>
            Returns a procedure definition object for the given procedure method name.
            If this type does not have a procedure method with this name, null is returned.
            </summary>
            <param name="name">Name of the procedure method</param>
            <returns>The procedure definition of the procedure method matching the name, or null if there is no such</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.IsA(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether this type is compatible to the given type, i.e. this type is the same type as the given type
            or it is a sub type of the given type.
            </summary>
            <param name="other">The type to be compared to.</param>
            <returns>True, if this type is compatible to the given type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_LessThanOrEqual(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a super type of the second type or the types are the same.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if otherType is compatible to type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_GreaterThanOrEqual(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a sub type of the second type or the types are the same.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if type is compatible to otherType.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_LessThan(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a super type of the second type.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if type is a super type of otherType.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.op_GreaterThan(de.unika.ipd.grGen.libGr.GrGenType,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether the first type is a sub type of the second type.
            </summary>
            <param name="type">The first type.</param>
            <param name="otherType">The second type.</param>
            <returns>True, if type is a sub type of otherType.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.GrGenType.ToString">
            <summary>
            Returns the name of the type.
            </summary>
            <returns>The name of the type.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.NodeType">
            <summary>
            A representation of a GrGen node type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.#ctor(System.Int32)">
            <summary>
            Constructs a NodeType instance with the given type ID.
            </summary>
            <param name="typeID">The unique type ID.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.IsNodeType">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.NodeInterfaceName">
            <summary>
            This NodeType describes nodes whose real .NET interface type is named as returned (fully qualified).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.NodeClassName">
            <summary>
            This NodeType describes nodes whose real .NET class type is named as returned (fully qualified).
            It might be null in case this type IsAbstract.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.CreateNode">
            <summary>
            Creates an INode object according to this type.
            </summary>
            <returns>The created INode object.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.CreateNodeWithCopyCommons(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Creates an INode object according to this type and copies all
            common attributes from the given node.
            </summary>
            <param name="oldNode">The old node.</param>
            <returns>The created INode object.</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.subOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.directSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.superOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.NodeType.directSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.SubOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.DirectSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.SuperOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.IsMyType(System.Int32)">
            <summary>
            Tells whether the given type is the same or a subtype of this type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.NodeType.IsA(System.Int32)">
            <summary>
            Tells whether this type is the same or a subtype of the given type
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.NodeType.Annotations">
            <summary>
            The annotations of the node type
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Directedness">
            <summary>
            Specifies the kind of directedness for an EdgeType
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Directedness.Arbitrary">
            <summary>Arbitrary directed. Only for abstract edge types.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Directedness.Directed">
            <summary>Directed.</summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Directedness.Undirected">
            <summary>Undirected.</summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EdgeType">
            <summary>
            A representation of a GrGen edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.#ctor(System.Int32)">
            <summary>
            Constructs an EdgeType instance with the given type ID.
            </summary>
            <param name="typeID">The unique type ID.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.IsNodeType">
            <summary>
            Always returns false.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.EdgeInterfaceName">
            <summary>
            This EdgeType describes edges whose real .NET interface type is named as returned (fully qualified).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.EdgeClassName">
            <summary>
            This EdgeType describes edges whose real .NET class type is named as returned (fully qualified).
            It might be null in case this type IsAbstract.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.Directedness">
            <summary>
            Specifies the directedness of this edge type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.CreateEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Creates an IEdge object according to this type.
            </summary>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <returns>The created IEdge object.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.CreateEdge">
            <summary>
            Creates an IEdge object according to this type.
            ATTENTION: You must call SetSourceAndTarget() before adding an edge created this way to a graph.
            This is an unsafe function that allows to first set the attributes of an edge, as needed in efficient .grs importing.
            </summary>
            <returns>The created IEdge object.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.SetSourceAndTarget(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Sets the source and target nodes of the edge after creation without.
            Must be called before an edge created with CreateEdge() is added to the graph.
            </summary>
            <param name="edge">The edge to set the source and target for.</param>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.CreateEdgeWithCopyCommons(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Creates an IEdge object according to this type and copies all
            common attributes from the given edge.
            </summary>
            <param name="source">The source of the edge.</param>
            <param name="target">The target of the edge.</param>
            <param name="oldEdge">The old edge.</param>
            <returns>The created IEdge object.</returns>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.subOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.directSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.superOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EdgeType.directSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.SubOrSameTypes">
            <summary>
            Array containing this type first and following all sub types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.DirectSubTypes">
            <summary>
            Array containing all direct sub types of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.SuperOrSameTypes">
            <summary>
            Array containing this type first and following all super types
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.IsMyType(System.Int32)">
            <summary>
            Tells whether the given type is the same or a subtype of this type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EdgeType.IsA(System.Int32)">
            <summary>
            Tells whether this type is the same or a subtype of the given type
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.EdgeType.Annotations">
            <summary>
            The annotations of the edge type
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VarType">
            <summary>
            A representation of a GrGen variable type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VarType.varTypeMap">
            <summary>
            A map from .NET types to singleton VarTypes.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.GetVarType(System.Type)">
            <summary>
            Gets the singleton VarType object for a given .NET type.
            </summary>
            <param name="type">The .NET type.</param>
            <returns>The singleton VarType object.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.VarType.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.VarType.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.VarType.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.VarType.Type">
            <summary>
            The .NET type of the variable.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.IsA(de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Checks, whether this type is compatible to the given type, i.e. this type is the same type as the given type
            or it is a sub type of the given type.
            </summary>
            <param name="other">The type to be compared to.</param>
            <returns>True, if this type is compatible to the given type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.Equals(System.Object)">
            <summary>
            Checks, whether the given type equals this type.
            </summary>
            <param name="other">The type to be compared to.</param>
            <returns>True, if the given type is the same as this type.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VarType.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ExternalType">
            <summary>
            A representation of an external type registered with GrGen.
            The bottom type of the external type hierarchy that is always available is type object.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ExternalType.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ExternalType.Type">
            <summary>
            The .NET type of the type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ExternalType.DirectSuperTypes">
            <summary>
            Array containing all direct super types of this type, the readonly interface.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ExternalType.directSuperTypes">
            <summary>
            Array containing all direct super types of this type, the real array.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ExternalType.IsA(de.unika.ipd.grGen.libGr.ExternalType)">
            <summary>
            Checks, whether this type is compatible to the given type, i.e. this type is the same type as the given type
            or it is a sub type of the given type.
            </summary>
            <param name="that">The type to be compared to.</param>
            <returns>True, if this type is compatible to the given type.</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ExternalType.NumFunctionMethods">
            <summary>
            The number of function methods of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ExternalType.FunctionMethods">
            <summary>
            Enumerates all function methods of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ExternalType.GetFunctionMethod(System.String)">
            <summary>
            Returns a function definition object for the given function method name.
            If this type does not have a function method with this name, null is returned.
            </summary>
            <param name="name">Name of the function method</param>
            <returns>The function definition of the function method matching the name, or null if there is no such</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ExternalType.NumProcedureMethods">
            <summary>
            The number of procedure methods of this type.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.ExternalType.ProcedureMethods">
            <summary>
            Enumerates all procedure methods of this type.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ExternalType.GetProcedureMethod(System.String)">
            <summary>
            Returns a procedure definition object for the given procedure method name.
            If this type does not have a procedure method with this name, null is returned.
            </summary>
            <param name="name">Name of the procedure method</param>
            <returns>The procedure definition of the procedure method matching the name, or null if there is no such</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ExternalType.ToString">
            <summary>
            Returns the name of the type.
            </summary>
            <returns>The name of the type.</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            </summary>
            <remarks>
            You can explicitly create objects of this exception type by
            calling the method GenerateParseException in the generated
            parser.
            <para>
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </para>
            </remarks>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.#ctor(de.unika.ipd.grGen.libGr.sequenceParser.Token,System.Int32[][],System.String[])" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.#ctor">
            The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.specialConstructor">
            This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.currentToken">
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.expectedTokenSequences">
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.tokenImage">
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.Message">
            This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.eol">
            The end of line string for this machine.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.ParseException.AddEscapes(System.String)">
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser">
            <summary>
            A parser class for xgrs strings.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.actions">
            <summary>
            The rules and sequences used in the specification, set if parsing an xgrs to be interpreted
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ruleNames">
            <summary>
            The names of the rules used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.sequenceNames">
            <summary>
            The names of the sequences used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.procedureNames">
            <summary>
            The names of the procedures used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.functionNames">
            <summary>
            The names of the functions used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.functionOutputTypes">
            <summary>
            The output types of the functions used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.filterFunctionNames">
            <summary>
            The names of the filter functions used in the specification, set if parsing an xgrs to be compiled
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.model">
            <summary>
            The model used in the specification
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.varDecls">
            <summary>
            Symbol table of the sequence variables, maps from name to the prefixed(by block nesting) name and the type;
            a graph-global variable maps to type "", a sequence-local to its type
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.packageContext">
            <summary>
            The name of the package the sequence is contained in (defining some context), null if it is not contained in a package. (Applies only to compiled sequences.)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ruleOfMatchThis">
            <summary>
            Gives the rule of the match this stands for in the if clause of the debug match event.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.typeOfGraphElementThis">
            <summary>
            Gives the graph element type of the graph element this stands for in the if clause of the debug new/delete/retype/set-attributes event.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.warnings">
            <summary>
            Stores the warnings which occur during parsing
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ParseSequence(System.String,de.unika.ipd.grGen.libGr.IActions,System.Collections.Generic.List{System.String})">
            <summary>
            Parses a given string in xgrs syntax and builds a Sequence object. Used for the interpreted xgrs.
            </summary>
            <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
            <param name="actions">The IActions object containing the rules used in the string.</param>
            <param name="warnings">A list which receives the warnings generated during parsing.</param>
            <returns>The sequence object according to sequenceStr.</returns>
            <exception cref="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">Thrown when a syntax error was found in the string.</exception>
            <exception cref="T:de.unika.ipd.grGen.libGr.SequenceParserException">Thrown when a rule is used with the wrong number of arguments
            or return parameters.</exception>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ParseSequenceExpression(System.String,System.Collections.Generic.Dictionary{System.String,System.String},de.unika.ipd.grGen.libGr.IActions,System.String,System.String,System.Collections.Generic.List{System.String})" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ParseSequenceDefinition(System.String,de.unika.ipd.grGen.libGr.IActions,System.Collections.Generic.List{System.String})">
            <summary>
            Parses a given string in sequence definition syntax and builds a SequenceDefinition object. Used for the interpreted xgrs.
            </summary>
            <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
            <param name="actions">The IActions object containing the rules used in the string.</param>
            <param name="warnings">A list which receives the warnings generated during parsing.</param>
            <returns>The sequence object according to sequenceStr.</returns>
            <exception cref="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">Thrown when a syntax error was found in the string.</exception>
            <exception cref="T:de.unika.ipd.grGen.libGr.SequenceParserException">Thrown when a rule is used with the wrong number of arguments
            or return parameters.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SequenceParser.ParseSequence(System.String,System.String,System.String[],System.String[],System.String[],System.String[],System.String[],System.String[],System.Collections.Generic.Dictionary{System.String,System.String},de.unika.ipd.grGen.libGr.IGraphModel,System.Collections.Generic.List{System.String})">
            <summary>
            Parses a given string in xgrs syntax and builds a Sequence object. Used for the compiled xgrs.
            </summary>
            <param name="sequenceStr">The string representing a xgrs (e.g. "test[7] &amp;&amp; (chicken+ || egg)*")</param>
            <param name="packageContext">The name of the package the sequence is contained in (defining some context), null if it is not contained in a package.</param>
            <param name="ruleNames">An array containing the names of the rules used in the specification.</param>
            <param name="sequenceNames">An array containing the names of the sequences used in the specification.</param>
            <param name="procedureNames">An array containing the names of the procedures used in the specification.</param>
            <param name="functionNames">An array containing the names of the functions used in the specification.</param>
            <param name="functionOutputTypes">An array containing the output types of the functions used in the specification.</param>
            <param name="filterFunctionNames">An array containing the names of the filter functions used in the specification.</param>
            <param name="predefinedVariables">A map from variables to types giving the parameters to the sequence, i.e. predefined variables.</param>
            <param name="model">The model used in the specification.</param>
            <param name="warnings">A list which receives the warnings generated during parsing.</param>
            <returns>The sequence object according to sequenceStr.</returns>
            <exception cref="T:de.unika.ipd.grGen.libGr.sequenceParser.ParseException">Thrown when a syntax error was found in the string.</exception>
            <exception cref="T:de.unika.ipd.grGen.libGr.SequenceParserException">Thrown when a rule is used with the wrong number of arguments
            or return parameters.</exception>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.sequenceParser.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.kind">
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.cs.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.beginLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.beginColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.endLine">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.endColumn">
            beginLine and beginColumn describe the position of the first character
            of this token; endLine and endColumn describe the position of the
            last character of this token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.image">
            The string image of the token.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.next">
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.Token.specialToken">
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.Token.ToString">
            Returns the image.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.Token.NewToken(System.Int32)">
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simlpy add something like :
            
                case MyParserConstants.ID : return new IDToken();
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use it in your lexical actions.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.LexicalError">
            Lexical error occured.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.StaticLexerError">
            An attempt wass made to create a second instance of a static token manager.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.InvalidLexicalState">
            Tried to change to an invalid lexical state.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.LoopDetected">
            Detected (and bailed out of) an infinite loop in the token manager.
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.errorCode">
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.AddEscapes(System.String)">
            Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.GetLexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            Returns a detailed message for the Exception when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
               EOFSeen     : indicates if EOF caused the lexicl error
               curLexState : lexical state in which this error occured
               errorLine   : line number when the error occured
               errorColumn : column number when the error occured
               errorAfter  : prefix that was seen before this error occured
               curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.sequenceParser.TokenMgrError.Message">
             You can also modify the body of this method to customize your error messages.
             For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
             of end-users concern, so you can return something like : 
            
                 "Internal Error : Please file a bug report .... "
            
             from this method for such cases in the release version of your parser.
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternElement">
            <summary>
            An element of a rule pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.Name">
            <summary>
            The name of the pattern element.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.UnprefixedName">
            <summary>
            The pure name of the pattern element as specified in the .grg without any prefixes.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.PointOfDefinition">
            <summary>
            The pattern where this element is contained the first time / gets matched (null if rule parameter).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.DefToBeYieldedTo">
            <summary>
            Iff true the element is only defined in its PointOfDefinition pattern,
            it gets matched in another, nested or called pattern which yields it to the containing pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.Annotations">
            <summary>
            The annotations of the pattern element.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternElement.Type">
            <summary>
            The base GrGenType of the pattern element (matching may be constrained further, this is only the base type)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternNode">
            <summary>
            A pattern node of a rule pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternNode.Type">
            <summary>
            The base NodeType of the pattern node (matching may be constrained further, this is only the base type)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternEdge">
            <summary>
            A pattern edge of a rule pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternEdge.Type">
            <summary>
            The base EdgeType of the pattern edge (matching may be constrained further, this is only the base type)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternVariable">
            <summary>
            A pattern variable of a rule pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternVariable.Type">
            <summary>
            The base VarType of the pattern variable (matching may be constrained further, this is only the base type)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternGraph">
            <summary>
            A pattern graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Name">
            <summary>
            The name of the pattern graph
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Package">
            <summary>
            null if this is a global pattern graph, otherwise the package the pattern graph is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.PackagePrefixedName">
            <summary>
            The name of the pattern graph in case of a global type,
            the name of the pattern graph is prefixed by the name of the package otherwise (package "::" name).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Nodes">
            <summary>
            An array of all pattern nodes.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Edges">
            <summary>
            An array of all pattern edges.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Variables">
            <summary>
            An array of all pattern variables;
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IPatternGraph.GetSource(de.unika.ipd.grGen.libGr.IPatternEdge)">
            <summary>
            Returns the source pattern node of the given edge, null if edge dangles to the left
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IPatternGraph.GetTarget(de.unika.ipd.grGen.libGr.IPatternEdge)">
            <summary>
            Returns the target pattern node of the given edge, null if edge dangles to the right
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicNodes">
            <summary>
            A two-dimensional array describing which pattern node may be matched non-isomorphic to which pattern node.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicEdges">
            <summary>
            A two-dimensional array describing which pattern edge may be matched non-isomorphic to which pattern edge.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicNodesGlobal">
            <summary>
            A two-dimensional array describing which pattern node may be matched non-isomorphic to which pattern node globally,
            i.e. the nodes are contained in different, but locally nested patterns (alternative cases, iterateds).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.HomomorphicEdgesGlobal">
            <summary>
            A two-dimensional array describing which pattern edge may be matched non-isomorphic to which pattern edge globally,
            i.e. the edges are contained in different, but locally nested patterns (alternative cases, iterateds).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.TotallyHomomorphicNodes">
            <summary>
            An array telling which pattern node is to be matched non-isomorphic(/independent) against any other node.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.TotallyHomomorphicEdges">
            <summary>
            An array telling which pattern edge is to be matched non-isomorphic(/independent) against any other edge.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.EmbeddedGraphs">
            <summary>
            An array with subpattern embeddings, i.e. subpatterns and the way they are connected to the pattern
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Alternatives">
            <summary>
            An array of alternatives, each alternative contains in its cases the subpatterns to choose out of.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.Iterateds">
            <summary>
            An array of iterateds, each iterated is matched as often as possible within the specified bounds.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.NegativePatternGraphs">
            <summary>
            An array of negative pattern graphs which make the search fail if they get matched
            (NACs - Negative Application Conditions).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.IndependentPatternGraphs">
            <summary>
            An array of independent pattern graphs which must get matched in addition to the main pattern
            (PACs - Positive Application Conditions).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraph.EmbeddingGraph">
            <summary>
            The pattern graph which contains this pattern graph, null if this is a top-level-graph
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding">
            <summary>
            Embedding of a subpattern into it's containing pattern
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding.Name">
            <summary>
            The name of the usage of the subpattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding.EmbeddedGraph">
            <summary>
            The embedded subpattern
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IPatternGraphEmbedding.Annotations">
            <summary>
            The annotations of the pattern element
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IAlternative">
            <summary>
            An alternative is a pattern graph element containing subpatterns
            of which one must get successfully matched so that the entire pattern gets matched successfully
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IAlternative.AlternativeCases">
            <summary>
            Array with the alternative cases
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IIterated">
            <summary>
            An iterated is a pattern graph element containing the subpattern to be matched iteratively
            and the information how much matches are needed for success and how much matches to obtain at most
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IIterated.IteratedPattern">
             <summary>
            The iterated pattern to be matched as often as possible within specified bounds.
             </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IIterated.MinMatches">
            <summary>
            How many matches to find so the iterated succeeds.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IIterated.MaxMatches">
            <summary>
            The upper bound to stop matching at, 0 means unlimited/as often as possible.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IMatchingPattern">
            <summary>
            A description of a GrGen matching pattern, that's a subpattern/subrule or the base for some rule.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.PatternGraph">
            <summary>
            The main pattern graph.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.Inputs">
            <summary>
            An array of GrGen types corresponding to rule parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.InputNames">
            <summary>
            An array of the names corresponding to rule parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.DefNames">
            <summary>
            An array of the names of the def elements yielded out of this pattern.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IMatchingPattern.Annotations">
            <summary>
            The annotations of the matching pattern (test/rule/subpattern)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IRulePattern">
            <summary>
            A description of a GrGen rule.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IRulePattern.Outputs">
            <summary>
            An array of GrGen types corresponding to rule return values.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IRulePattern.Filters">
            <summary>
            An array of the names of the available filters (external extensions)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IFilter">
            <summary>
            A description of a filter of a rule
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFilter.Package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFilter.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IFilterAutoGenerated">
            <summary>
            A description of an auto-generated filter
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IFilterFunction">
            <summary>
            A description of a filter function
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFilterFunction.Inputs">
            <summary>
            An array of GrGen types corresponding to filter parameters.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.IFilterFunction.InputNames">
            <summary>
            An array of the names corresponding to filter parameters.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Porter">
            <summary>
            Import and export support for graphs.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.Export(de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{System.String})">
            <summary>
            Exports the given graph to a file with the given filename.
            The format is determined by the file extension. 
            Currently available is: .gxl; the format .grs/.grsi needs the named graph export.
            Optionally suffixed by .gz; in this case they are saved gzipped.
            Any errors will be reported by exception.
            </summary>
            <param name="graph">The graph to export.</param>
            <param name="filenameParameters">The names of the files to be exported.
            The first must be a filename, the following may be used for giving export parameters
            (in fact currently no exporter supports multiple files).</param>
        </member>
        <!-- Ungültiger XML-Kommentar wurde für den Member "M:de.unika.ipd.grGen.libGr.Porter.Export(de.unika.ipd.grGen.libGr.INamedGraph,System.Collections.Generic.List{System.String})" ignoriert -->
        <member name="M:de.unika.ipd.grGen.libGr.Porter.Import(de.unika.ipd.grGen.libGr.IBackend,System.Collections.Generic.List{System.String},de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports a graph from the given files.
            If the filenames only specify a model, the graph is empty.
            The format is determined by the file extensions.
            Currently available are: .grs/.grsi or .gxl or .ecore with .xmi.
            Optionally suffixed by .gz; in this case they are expected to be gzipped.
            Any error will be reported by exception.
            </summary>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="filenameParameters">The names of the files to be imported.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            The .grs/.grsi importer returns an INamedGraph. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.Import(System.String,de.unika.ipd.grGen.libGr.IBackend,de.unika.ipd.grGen.libGr.IGraphModel,de.unika.ipd.grGen.libGr.IActions@)">
            <summary>
            Imports a graph from the given file.
            The format is determined by the file extension.
            Any errors will be reported by exception.
            </summary>
            <param name="importFilename">The filename of the file to be imported, 
                the model specification part will be ignored.</param>
            <param name="backend">The backend to use to create the graph.</param>
            <param name="graphModel">The graph model to be used, 
                it must be conformant to the model used in the file to be imported.</param>
            <param name="actions">Receives the actions object in case a .grg model is given.</param>
            <returns>The imported graph. 
            The .grs/.grsi importer returns an INamedGraph. If you don't need it: create an LGSPGraph from it and throw the named graph away.
            (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Porter.ListGet(System.Collections.Generic.List{System.String},System.Int32)">
            <summary>
            Returns the string at the given index, or null if the index is out of bounds.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ProcedureInfo">
            <summary>
            A description of a GrGen (attribute evaluation) procedure.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ProcedureInfo.#ctor(System.String,System.String,System.String,System.Boolean,System.String[],de.unika.ipd.grGen.libGr.GrGenType[],de.unika.ipd.grGen.libGr.GrGenType[])">
            <summary>
            Constructs a ProcedureInfo object.
            </summary>
            <param name="name">The name the procedure was defined with.</param>
            <param name="package">null if this is a global pattern graph, otherwise the package the pattern graph is contained in.</param>
            <param name="packagePrefixedName">The name of the pattern graph in case of a global type,
            the name of the pattern graph is prefixed by the name of the package otherwise (package "::" name).</param>
            <param name="isExternal">Tells whether the procedure is an externally defined one or an internal one.</param>
            <param name="inputNames">The names of the input parameters.</param>
            <param name="inputs">The types of the input parameters.</param>
            <param name="outputs">The types of the output parameters.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.name">
            <summary>
            The name of the procedure.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.annotations">
            <summary>
            The annotations of the procedure
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.package">
            <summary>
            null if this is a global type, otherwise the package the type is contained in.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.packagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.inputNames">
            <summary>
            Names of the procedure parameters.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.inputs">
            <summary>
            The GrGen types of the procedure parameters.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.outputs">
            <summary>
            The GrGen types of the procedure return values.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.ReturnArray">
            <summary>
            Performance optimization: saves us usage of new in implementing the Apply method for returning an array.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.ProcedureInfo.isExternal">
            <summary>
            Tells whether the procedure is an externally defined one or an internal one
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ProcedureInfo.Apply(de.unika.ipd.grGen.libGr.IActionExecutionEnvironment,de.unika.ipd.grGen.libGr.IGraph,de.unika.ipd.grGen.libGr.ProcedureInvocationParameterBindings)">
            <summary>
            Applies this procedure with the given action environment on the given graph.
            Takes the parameters from paramBindings as inputs.
            Returns an array of output values.
            Attention: at the next call of Apply, the array returned from previous call is overwritten with the new return values.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.RecordingState">
            <summary>
            A class holding the state/context of a recording session
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Recorder">
            <summary>
            A class for recording changes (and their causes) applied to a graph into a file,
            so that they can get replayed.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.#ctor(de.unika.ipd.grGen.libGr.INamedGraph,de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment)">
            <summary>
            Create a recorder
            </summary>
            <param name="graph">The named graph whose changes are to be recorded</param>
            <param name="subOutEnv">The subaction and output environment receiving some of the action events, may be null if only graph changes are requested</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.Initialize(de.unika.ipd.grGen.libGr.INamedGraph,de.unika.ipd.grGen.libGr.ISubactionAndOutputAdditionEnvironment)">
            <summary>
            Initializes a recorder after creation, needed if actions are selected later
            </summary>
            <param name="graph">The named graph whose changes are to be recorded</param>
            <param name="subOutEnv">The subaction and output environment receiving some of the action events, may be null if only graph changes are requested</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.NodeAdded(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Event handler for IGraph.OnNodeAdded.
            </summary>
            <param name="node">The added node.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.EdgeAdded(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Event handler for IGraph.OnEdgeAdded.
            </summary>
            <param name="edge">The added edge.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.RemovingNode(de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Event handler for IGraph.OnRemovingNode.
            </summary>
            <param name="node">The node to be deleted.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.RemovingEdge(de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Event handler for IGraph.OnRemovingEdge.
            </summary>
            <param name="edge">The edge to be deleted.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.RetypingNode(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode)">
            <summary>
            Event handler for IGraph.OnRetypingNode.
            </summary>
            <param name="oldNode">The node to be retyped.</param>
            <param name="newNode">The new node with the common attributes, but without the correct connections, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.RetypingEdge(de.unika.ipd.grGen.libGr.IEdge,de.unika.ipd.grGen.libGr.IEdge)">
            <summary>
            Event handler for IGraph.OnRetypingEdge.
            </summary>
            <param name="oldEdge">The edge to be retyped.</param>
            <param name="newEdge">The new edge with the common attributes, but without the correct connections, yet.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Recorder.ChangingAttribute(de.unika.ipd.grGen.libGr.IGraphElement,de.unika.ipd.grGen.libGr.AttributeType,de.unika.ipd.grGen.libGr.AttributeChangeType,System.Object,System.Object)">
            <summary>
            Event handler for IGraph.OnChangingNodeAttribute and IGraph.OnChangingEdgeAttribute.
            </summary>
            <param name="element">The node or edge whose attribute is changed.</param>
            <param name="attrType">The type of the attribute to be changed.</param>
            <param name="changeType">The type of the change which will be made.</param>
            <param name="newValue">The new value of the attribute, if changeType==Assign.
                                   Or the value to be inserted/removed if changeType==PutElement/RemoveElement on set.
                                   Or the new map pair value to be inserted if changeType==PutElement on map.
                                   Or the new value to be inserted/added if changeType==PutElement on array.
                                   Or the new value to be assigned to the given position if changeType==AssignElement on array.</param>
            <param name="keyValue">The map pair key to be inserted/removed if changeType==PutElement/RemoveElement on map.
                                   The array index to be removed/written to if changeType==RemoveElement/AssignElement on array.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceType">
            <summary>
            Specifies the actual subtype used for a Sequence.
            A new sequence type -> you must add the corresponding class down below,
            and adapt the lgspSequenceGenerator and the Debugger.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceExecutionState">
            <summary>
            States of executing sequences: not (yet) executed, execution underway, successful execution, fail execution
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Sequence">
            <summary>
            A sequence object with references to child sequences.
            A sequence is basically a rule application or a computation, or an operator combining them.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Sequence.SequenceType">
            <summary>
            The type of the sequence (e.g. LazyOr or Transaction)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.#ctor(de.unika.ipd.grGen.libGr.SequenceType)">
            <summary>
            Initializes a new Sequence object with the given sequence type.
            </summary>
            <param name="seqType">The sequence type.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.Check(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Checks the sequence for errors utilizing the given checking environment
            reports them by exception
            default behavior: check all the children 
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.Type(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Returns the type of the sequence, which is "boolean"
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.Copy(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the sequence deeply so that
            - the execution state of the copy is NotYet
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the sequence</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.ReplaceSequenceDefinition(de.unika.ipd.grGen.libGr.SequenceDefinition,de.unika.ipd.grGen.libGr.SequenceDefinition)">
            <summary>
            After a sequence definition was replaced by a new one, all references from then on will use the new one,
            but the old references are still there and must get replaced.
            </summary>
            <param name="oldDef">The old definition which is to be replaced</param>
            <param name="newDef">The new definition which replaces the old one</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.Apply(de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Applies this sequence.
            </summary>
            <param name="procEnv">The graph processing environment on which this sequence is to be applied.
                Contains especially the graph on which this sequence is to be applied.
                And the user proxy queried when choices are due.
                The rules will only be chosen during the Sequence object instantiation, so
                exchanging rules will have no effect for already existing Sequence objects.</param>
            <returns>True, iff the sequence succeeded</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.ApplyImpl(de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Applies this sequence. This function represents the actual implementation of the sequence.
            </summary>
            <param name="procEnv">The graph processing environment on which this sequence is to be applied.
                Contains especially the graph on which this sequence is to be applied.
                And the user proxy queried when choices are due.</param>
            <returns>True, iff the sequence succeeded</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.ResetExecutionState">
            <summary>
            Reset the execution state after a run (for following runs).
            The sequence to be iterated gets reset before each iteration.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.GetCurrentlyExecutedSequence">
            <summary>
            Returns the innermost sequence beneath this as root
            which gets currently executed (for sequences on call stack this is the call).
            A path in the sequence tree gets executed, the innermost is the important one.
            </summary>
            <returns>The innermost sequence currently executed, or null if there is no such</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.Sequence.GetLocalVariables(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.List{de.unika.ipd.grGen.libGr.SequenceExpressionContainerConstructor},de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            Walks the sequence tree from this on to the given target sequence (inclusive),
            collecting all variables found on the way into the variables dictionary,
            and all container constructors used into the constructors array.
            </summary>
            <param name="variables">Contains the variables found</param>
            <param name="containerConstructors">Contains the container constructors walked by</param>
            <param name="target">The target sequence up to which to walk</param>
            <returns>Returns whether the target was hit, so the parent can abort walking</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.Sequence.Children">
            <summary>
            Enumerates all child sequence objects
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.Sequence.ExecutionState">
            <summary>
            the state of executing this sequence
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.Sequence.executionState">
            <summary>
            the state of executing this sequence, implementation
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceSpecial">
            <summary>
            A Sequence with a Special flag
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceSpecial.Special">
            <summary>
            The "Special" flag. Usage is implementation specific.
            GrShell uses this flag to indicate breakpoints when in debug mode and
            to dump matches when in normal mode.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceSpecial.#ctor(System.Boolean,de.unika.ipd.grGen.libGr.SequenceType)">
            <summary>
            Initializes a new instance of the SequenceSpecial class.
            </summary>
            <param name="special">The initial value for the "Special" flag.</param>
            <param name="seqType">The sequence type.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceRandomChoice">
            <summary>
            A Sequence with a random decision which might be interactively overriden by a user choice.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceRandomChoice.Random">
            <summary>
            The "Random" flag "$" telling whether the sequence operates in random mode.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceRandomChoice.Choice">
            <summary>
            The "Choice" flag "%".
            Only applicable to a random decision sequence.
            GrShell uses this flag to indicate choicepoints when in debug mode.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceUnary">
            <summary>
            A sequence consisting of a unary operator and another sequence.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceBinary">
            <summary>
            A sequence consisting of a binary operator and two sequences.
            Decision on order of execution by random, by user choice possible.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceNAry">
            <summary>
            A sequence consisting of a list of subsequences.
            Decision on order of execution always by random, by user choice possible.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceAssignToVar">
            <summary>
            A sequence which assigns something to a destination variable.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceSomeFromSet">
            <summary>
            A sequence consisting of a list of subsequences.
            Decision on order of execution by random, by user choice possible.
            First all the contained rules are matched, then they get rewritten
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceDefinition">
            <summary>
            A sequence representing a sequence definition.
            It must be applied with a different method than the other sequences because it requires the parameter information.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceDefinition.Apply(de.unika.ipd.grGen.libGr.SequenceInvocationParameterBindings,de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Applies this sequence.
            </summary>
            <param name="sequenceInvocation">Sequence invocation object for this sequence application,
                containing the input parameter sources and output parameter targets</param>
            <param name="procEnv">The graph processing environment on which this sequence is to be applied.
                Contains especially the graph on which this sequence is to be applied.
                The rules will only be chosen during the Sequence object instantiation, so
                exchanging rules will have no effect for already existing Sequence objects.</param>
            <param name="env">The execution environment giving access to the names and user interface (null if not available)</param>
            <returns>True, iff the sequence succeeded</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceDefinition.Annotations">
            <summary>
            The annotations of the sequence
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceDefinitionInterpreted">
            <summary>
            An sequence representing an interpreted sequence definition.
            Like the other sequences it can be directly interpreted (but with a different apply method),
            in contrast to the others it always must be the root sequence.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceDefinitionCompiled">
            <summary>
            A sequence representing a compiled sequence definition.
            The subclass contains the method implementing the real sequence,
            and ApplyImpl calling that method mapping SequenceInvocationParameterBindings to the exact parameters of that method.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AssignmentTargetType">
            <summary>
            Specifies the assignment target type (the lhs expression).
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.AssignmentTarget">
            <summary>
            An assignment target object with references to used sequence computations.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.AssignmentTarget.AssignmentTargetType">
            <summary>
            The type of the assignment target (e.g. Variable or IndexedVariable)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AssignmentTarget.#ctor(de.unika.ipd.grGen.libGr.AssignmentTargetType)">
            <summary>
            Initializes a new AssignmentTargetType object with the given assignment target type.
            </summary>
            <param name="seqCompType">The sequence computation type.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AssignmentTarget.Copy(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the sequence computation deeply so that
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the sequence computation</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AssignmentTarget.CopyTarget(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the assignment target deeply so that
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the assignment target</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.AssignmentTarget.Assign(System.Object,de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Assigns a value to this assignment target.
            </summary>
            <param name="value">The value to assign.</param>
            <param name="procEnv">The graph processing environment on which this assignment is to be executed.
                Containing especially the graph on which this assignment is to be executed.
                And the user proxy queried when choices are due.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution">
            <summary>
            A proxy querying or simulating a user for choices during sequence execution
            TODO: general user proxy, not just for sequence execution
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseDirection(System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered direction of execution for the sequence given
            the randomly chosen directions is supplied; 0: execute left operand first, 1: execute right operand first
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseSequence(System.Int32,System.Collections.Generic.List{de.unika.ipd.grGen.libGr.Sequence},de.unika.ipd.grGen.libGr.SequenceNAry)">
            <summary>
            returns the maybe user altered sequence to execute next for the sequence given
            the randomly chosen sequence is supplied; the object with all available sequences is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChoosePoint(System.Double,de.unika.ipd.grGen.libGr.SequenceWeightedOne)">
            <summary>
            returns the maybe user altered point within the interval series, denoting the sequence to execute next
            the randomly chosen point is supplied; the sequence with the intervals and their corresponding sequences is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseMatch(System.Int32,de.unika.ipd.grGen.libGr.SequenceSomeFromSet)">
            <summary>
            returns the maybe user altered match to execute next for the sequence given
            the randomly chosen total match is supplied; the sequence with the rules and matches is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseMatch(System.Int32,de.unika.ipd.grGen.libGr.IMatches,System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered match to apply next for the sequence given
            the randomly chosen match is supplied; the object with all available matches is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseRandomNumber(System.Int32,System.Int32,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered random number in the range 0 - upperBound exclusive for the sequence given
            the random number chosen is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseRandomNumber(System.Double,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns the maybe user altered random number in the range 0.0 - 1.0 exclusive for the sequence given
            the random number chosen is supplied
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.IUserProxyForSequenceExecution.ChooseValue(System.String,de.unika.ipd.grGen.libGr.Sequence)">
            <summary>
            returns a user chosen/input value of the given type
            no random input value is supplied, the user must give a value
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment">
            <summary>
            Environment for sequence checking giving access to model and action signatures.
            Abstract base class, there are two concrete subclasses, one for interpreted, one for compiled sequences.
            The compiled version in addition resolves names that are given without package context but do not reference global names
            because they are used from a sequence that is contained in a package (only possible for compiled sequences from rule language).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.Model">
            <summary>
            The model giving access to graph element types for checking.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckCall(de.unika.ipd.grGen.libGr.Sequence,System.Boolean)">
            <summary>
            Helper for checking rule calls, rule all calls, and sequence calls.
            Checks whether called entity exists, type checks the input, type checks the output.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence to check, must be a rule call, a rule all call, or a sequence call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckProcedureCallBase(de.unika.ipd.grGen.libGr.SequenceComputation,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Helper for checking procedure calls.
            Checks whether called entity exists, type checks the input, type checks the output.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence computation to check, must be a procedure call</param>
            <param name="ownerType">Gives the owner type of the procedure method call, in case this is a method call, otherwise null</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckFunctionCallBase(de.unika.ipd.grGen.libGr.SequenceExpression,de.unika.ipd.grGen.libGr.GrGenType)">
            <summary>
            Helper for checking function calls.
            Checks whether called entity exists, and type checks the input.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence expression to check, must be a function call</param>
            <param name="ownerType">Gives the owner type of the function method call, in case this is a method call, otherwise null</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckProcedureCall(de.unika.ipd.grGen.libGr.SequenceComputation)">
            <summary>
            Helper for checking procedure calls.
            Checks whether called entity exists, type checks the input, type checks the output.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence computation to check, must be a procedure call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckProcedureMethodCall(de.unika.ipd.grGen.libGr.SequenceExpression,de.unika.ipd.grGen.libGr.SequenceComputation)">
            <summary>
            Helper for checking procedure method calls.
            Checks whether called entity exists, type checks the input, type checks the output.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence computation to check, must be a procedure call</param>
            <param name="targetExpr">The target of the procedure method call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckProcedureMethodCall(de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceComputation)">
            <summary>
            Helper for checking procedure method calls.
            Checks whether called entity exists, type checks the input, type checks the output.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence computation to check, must be a procedure call</param>
            <param name="targetVar">The target of the procedure method call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckFunctionCall(de.unika.ipd.grGen.libGr.SequenceExpression)">
            <summary>
            Helper for checking function calls.
            Checks whether called entity exists, type checks the input, type checks the output.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence expression to check, must be a function call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.CheckFunctionMethodCall(de.unika.ipd.grGen.libGr.SequenceExpression,de.unika.ipd.grGen.libGr.SequenceExpression)">
            <summary>
            Helper for checking function method calls.
            Checks whether called entity exists, and type checks the input.
            Throws an exception when an error is found.
            </summary>
            <param name="seq">The sequence expression to check, must be a function call</param>
            <param name="targetExpr">The target of the procedure function call</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment.TypeOfTopLevelEntityInRule(System.String,System.String)">
            <summary>
            Helper which returns the type of the given top level entity of the given rule.
            Throws an exception in case the rule of the given name does not exist 
            or in case it does not contain an entity of the given name.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironmentInterpreted">
            <summary>
            Environment for sequence checking giving access to model and action signatures.
            Concrete subclass for interpreted sequences.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironmentCompiled">
            <summary>
            Environment for sequence checking giving access to model and action signatures.
            Concrete subclass for compiled sequences.
            This environment in addition resolves names that are given without package context but do not reference global names
            because they are used from a sequence that is contained in a package (only possible for compiled sequences from rule language).
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceCheckingEnvironmentCompiled.Model">
            <summary>
            the model giving access to graph element types for checking
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceBase">
            <summary>
            The common base of sequence, sequence computation, and sequence expression objects,
            with some common infrastructure.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceBase.Check(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Checks the sequence /expression for errors utilizing the given checking environment
            reports them by exception
            </summary>s
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceBase.Type(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Returns the type of the sequence /expression (for sequences always "boolean")
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceBase.randomGenerator">
            <summary>
            A common random number generator for all sequence /expression objects.
            It uses a time-dependent seed.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBase.Precedence">
            <summary>
            The precedence of this operator. Zero is the highest priority, int.MaxValue the lowest.
            Used to add needed parentheses for printing sequences /expressions
            TODO: WTF? das ist im Parser genau umgekehrt implementiert!
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBase.Symbol">
            <summary>
            A string symbol representing this sequence /expression kind.
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBase.Id">
            <summary>
            returns the sequence /expresion id - every sequence /expression is assigned a unique id used in xgrs code generation
            for copies the old id is just taken over, does not cause problems as code is only generated once per defined sequence
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceBase.id">
            <summary>
            stores the sequence /expression unique id
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceBase.idSource">
            <summary>
            the static member used to assign the unique ids to the sequence /expression instances
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBase.ChildrenBase">
            <summary>
            Enumerates all child sequence computation objects
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceBase.SetNeedForProfiling(System.Boolean)">
            <summary>
            sets for the very node the profiling flag (does not recurse)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceBase.SetNeedForProfilingRecursive(System.Boolean)">
            <summary>
            sets for the node and all children, i.e. the entire tree the profiling flag
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceComputationType">
            <summary>
            Specifies the actual subtype of a sequence computation.
            A new expression type -> you must add the corresponding class down below 
            and adapt the lgspSequenceGenerator.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceComputation">
            <summary>
            A sequence computation object with references to child sequence computations.
            The computations are basically: visited flags management, container manipulation,
            assignments and special functions; they may or may not return values.
            They do change things, in contrast to the side-effect free sequence expressions.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceComputation.SequenceComputationType">
            <summary>
            The type of the sequence computation (e.g. Assignment or MethodCall)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceComputation.#ctor(de.unika.ipd.grGen.libGr.SequenceComputationType)">
            <summary>
            Initializes a new SequenceComputation object with the given sequence computation type.
            </summary>
            <param name="seqCompType">The sequence computation type.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceComputation.Check(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Checks the sequence computation for errors utilizing the given checking environment
            reports them by exception
            default behavior: check all the children 
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceComputation.Type(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Returns the type of the sequence
            default behaviour: returns "void"
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceComputation.Copy(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the sequence computation deeply so that
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the sequence computation</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceComputation.Execute(de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Executes this sequence computation.
            </summary>
            <param name="procEnv">The graph processing environment on which this sequence computation is to be evaluated.
                Contains especially the graph on which this sequence computation is to be evaluated.
                And the user proxy queried when choices are due.</param>
            <returns>The value resulting from computing this sequence computation, 
                     null if there is no result value</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceComputation.GetLocalVariables(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SetValueType},System.Collections.Generic.List{de.unika.ipd.grGen.libGr.SequenceExpressionContainerConstructor})">
            <summary>
            Collects all variables of the sequence expression tree into the variables dictionary,
            and all container constructors used into the constructors array.
            </summary>
            <param name="variables">Contains the variables found</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceComputation.Children">
            <summary>
            Enumerates all child sequence computation objects
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceComputation.ReturnsValue">
            <summary>
            Tells whether Execute returns a value to be used as a result determining value for a boolean computation sequence.
            Only expressions do so, the values returned by plain computations don't bubble up to sequence level, are computation internal only.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceComputationContainer">
            <summary>
            A sequence computation on a container object (resulting from a variable or a method call; yielding a container object again)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo">
            <summary>
            Represents an XGRS used in an exec statement.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.#ctor(System.String[],de.unika.ipd.grGen.libGr.GrGenType[],System.String[],de.unika.ipd.grGen.libGr.GrGenType[],System.String,System.String,System.Int32)">
            <summary>
            Constructs an EmbeddedSequenceInfo object.
            </summary>
            <param name="parameters">The names of the needed graph elements of the containing action.</param>
            <param name="parameterTypes">The types of the needed graph elements of the containing action.</param>
            <param name="outParameters">The names of the graph elements of the containing action yielded to.</param>
            <param name="outParameterTypes">The types of the graph elements of the containing action yielded to.</param>
            <param name="package">null if this is a global embedded sequence, otherwise the package the embedded sequence is contained in.</param>
            <param name="xgrs">The XGRS string.</param>
            <param name="lineNr">The line number the sequence appears on in the source.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.Parameters">
            <summary>
            The names of the needed graph elements of the containing action.
            Or the names of the graph elements needed from the calling action in case of a defined sequence.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.ParameterTypes">
            <summary>
            The types of the needed graph elements of the containing action.
            Or the types of the graph elements needed from the calling action in case of a definted sequence.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.OutParameters">
            <summary>
            The names of the graph elements of the containing action yielded to.
            Or the names of the graph elements returned to the calling action in case of a defined sequence.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.OutParameterTypes">
            <summary>
            The types of the graph elements of the containing action yielded to.
            Or the types of the graph elements returned to the calling action in case of a defined sequence.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.Package">
            <summary>
            null if this is a global embedded sequence, otherwise the package the embedded sequence is contained in.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.XGRS">
            <summary>
            The XGRS string.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.EmbeddedSequenceInfo.LineNr">
            <summary>
            The line in the source code on which this sequence appears, printed in case of an error.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.DefinedSequenceInfo">
            <summary>
            Represents a sequence definition.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.DefinedSequenceInfo.#ctor(System.String[],de.unika.ipd.grGen.libGr.GrGenType[],System.String[],de.unika.ipd.grGen.libGr.GrGenType[],System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            Constructs an DefinedSequenceInfo object.
            </summary>
            <param name="parameters">The names of the graph elements needed from the calling action.</param>
            <param name="parameterTypes">The types of the graph elements needed from the calling action.</param>
            <param name="outParameters">The names of the graph elements returned to the calling action.</param>
            <param name="outParameterTypes">The types of the graph elements returned to the calling action.</param>
            <param name="name">The name the sequence was defined with.</param>
            <param name="package">null if this is a global sequence, otherwise the package the sequence is contained in.</param>
            <param name="packagePrefixedName">The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.</param>
            <param name="xgrs">The XGRS string.</param>
            <param name="lineNr">The line number the sequence appears on in the source.</param>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DefinedSequenceInfo.Name">
            <summary>
            The name the sequence was defined with
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DefinedSequenceInfo.PackagePrefixedName">
            <summary>
            The name of the type in case of a global type,
            the name of the type prefixed by the name of the package otherwise.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.DefinedSequenceInfo.annotations">
            <summary>
            The annotations of the sequence definition
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ExternalDefinedSequenceInfo">
            <summary>
            Represents a sequence definition implemented externally.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.ExternalDefinedSequenceInfo.#ctor(System.String[],de.unika.ipd.grGen.libGr.GrGenType[],System.String[],de.unika.ipd.grGen.libGr.GrGenType[],System.String,System.Int32)">
            <summary>
            Constructs an ExternalDefinedSequenceInfo object.
            </summary>
            <param name="parameters">The names of the graph elements needed from the calling action.</param>
            <param name="parameterTypes">The types of the graph elements needed from the calling action.</param>
            <param name="outParameters">The names of the graph elements returned to the calling action.</param>
            <param name="outParameterTypes">The types of the graph elements returned to the calling action.</param>
            <param name="name">The name the sequence was defined with.</param>
            <param name="lineNr">The line number the sequence appears on in the source.</param>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceExpressionType">
            <summary>
            Specifies the actual subtype of a sequence expression.
            A new expression type -> you must add the corresponding class down below 
            and adapt the lgspSequenceGenerator.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceExpression">
            <summary>
            A sequence expression object with references to child sequence expressions.
            A sequence expression is a side effect free computation returning a value (a query).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceExpression.SequenceExpressionType">
            <summary>
            The type of the sequence expression (e.g. Variable or IsVisited)
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpression.#ctor(de.unika.ipd.grGen.libGr.SequenceExpressionType)">
            <summary>
            Initializes a new SequenceExpression object with the given sequence expression type.
            </summary>
            <param name="seqExprType">The sequence expression type.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpression.Type(de.unika.ipd.grGen.libGr.SequenceCheckingEnvironment)">
            <summary>
            Returns the type of the sequence expression
            default behaviour: returns "boolean"
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpression.Copy(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the sequence computation deeply so that
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the sequence computation</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpression.CopyExpression(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the sequence expression deeply so that
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the sequence expression</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpression.Evaluate(de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Evaluates this sequence expression.
            Implemented by calling execute, every expression is a computation.
            </summary>
            <param name="procEnv">The graph processing environment on which this sequence expression is to be evaluated.
                Contains especially the graph on which this sequence expression is to be evaluated.
                And the user proxy queried when choices are due.</param>
            <returns>The value resulting from computing this sequence expression</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceExpression.ChildrenExpression">
            <summary>
            Enumerates all child sequence expression objects
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceExpressionContainer">
            <summary>
            A sequence expression over a container object (resulting from a variable or a method call)
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceBinaryExpression">
            <summary>
            A sequence binary expression object with references to the left and right child sequence expressions.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceBinaryExpression.#ctor(de.unika.ipd.grGen.libGr.SequenceExpressionType,de.unika.ipd.grGen.libGr.SequenceExpression,de.unika.ipd.grGen.libGr.SequenceExpression)">
            <summary>
            Initializes a new SequenceBinaryExpression object with the given sequence expression type.
            </summary>
            <param name="seqExprType">The sequence expression type.</param>
            <param name="left">The left sequence expression.</param>
            <param name="right">The right sequence expression.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceBinaryExpression.CopyExpression(System.Collections.Generic.Dictionary{de.unika.ipd.grGen.libGr.SequenceVariable,de.unika.ipd.grGen.libGr.SequenceVariable},de.unika.ipd.grGen.libGr.IGraphProcessingEnvironment)">
            <summary>
            Copies the sequence expression deeply so that
            - the global Variables are kept
            - the local Variables are replaced by copies initialized to null
            Used for cloning defined sequences before executing them if needed.
            Needed if the defined sequence is currently executed to prevent state corruption.
            </summary>
            <param name="originalToCopy">A map used to ensure that every instance of a variable is mapped to the same copy</param>
            <returns>The copy of the sequence expression</returns>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBinaryExpression.ChildrenExpression">
            <summary>
            Enumerates all child sequence expression objects
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBinaryExpression.Symbol">
            <summary>
            Returns this expression as string, in the form of left expression then operator then right expression;
            same for all binary expressions
            </summary>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceBinaryExpression.Operator">
            <summary>
            Returns the operator of this binary expression (enclosed in spaces);
            abstract property, to be overwritten by concrete operator symbol
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpressionHelper.Adjust(System.String,System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the type to which the operand must be casted to,
            to satisfy the expected type (i.e. the expected type itself).
            Returns "" if the type can only be determined at runtime.
            Returns "-" in case of a type error (not allowed cast).
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpressionHelper.Balance(de.unika.ipd.grGen.libGr.SequenceExpressionType,System.String,System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the types to which the operands must be casted to, 
            for the types of the left and right operands and the operator given.
            Used for type checking and casting at compile time.
            Returns "" if the type can only be determined at runtime.
            Returns "-" in case of a type error.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpressionHelper.BalanceArithmetic(System.String,System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the types to which the operands must be casted to, 
            assuming an arithmetic operator.
            Returns "" if the type can only be determined at runtime.
            Returns "-" in case of a type error and/or if no operator working on numbers can be applied.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpressionHelper.BalanceString(System.String,System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the types to which the operands must be casted to, 
            assuming a string operator.
            Returns "" if the type can only be determined at runtime.
            Returns "-" in case of a type error and/or if no operator working on strings can be applied.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpressionHelper.BalanceGraphElement(System.String,System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the types to which the operands must be casted to, 
            assuming the graph element (in)equality operator.
            Returns "" if the type can only be determined at runtime.
            Returns "-" in case of a type error and/or if no operator working on strings can be applied.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceExpressionHelper.BalanceExternalType(System.String,System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns the types to which the operands must be casted to, 
            assuming an external type equality or ordering operator.
            Returns "" if the type can only be determined at runtime.
            Returns "-" in case of a type error and/or if no operator working on external types can be applied.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceParserError">
            <summary>
            Specifies the kind of sequence parser error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownRuleOrSequence">
            <summary>
            The rule or sequence is unknown.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownProcedure">
            <summary>
            The procedure is unknown.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownFunction">
            <summary>
            The function is unknown.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.BadNumberOfParametersOrReturnParameters">
            <summary>
            The number of parameters and/or return parameters does not match the signature of the definition.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.BadParameter">
            <summary>
            The type of a parameter does not match the signature of the definition.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.BadReturnParameter">
            <summary>
            The type of a return parameter does not match the signature of the definition.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.RuleNameUsedByVariable">
            <summary>
            A variable has been declared with the name of an action.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.VariableUsedWithParametersOrReturnParameters">
            <summary>
            A variable has been used with parameters and/or return parameters.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownAttribute">
            <summary>
            The attribute is not known
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.TypeMismatch">
            <summary>
            Type check error
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.OperatorNotFound">
            <summary>
            The operator is not available for the given types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.FilterError">
            <summary>
            The given filter can't be applied to the given rule 
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.FilterParameterError">
            <summary>
            The parameters of the given filter applied to the given rule don't fit to the declaration
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.SubgraphTypeError">
            <summary>
            The given subgraph is of wrong type
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.SubgraphError">
            <summary>
            The construct does not accept a subgraph
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownPatternElement">
            <summary>
            The element is not contained in the rule pattern (thus in the match of the rule)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownRule">
            <summary>
            The rule is unknown (only rule name available, originating from match type)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UserMethodsOnlyAvailableForGraphElements">
            <summary>
            Method call notations of a not-builtin-method was used on a non-graph-type
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.UnknownIndexAccessDirection">
            <summary>
            The index access direction is unknown (must be ascending or descending)
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.TwoDifferentIndexNames">
            <summary>
            Two different index names are given for an index access, must be a single one
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.TwoLowerBounds">
            <summary>
            Two lower bounds are given
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserError.TwoUpperBounds">
            <summary>
            Two upper bounds are given
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceParserException">
            <summary>
            An exception thrown by SequenceParser,
            describing the error, e.g. which rule caused the problem and how it was used
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.Kind">
            <summary>
            The kind of error.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.DefType">
            <summary>
            The type of the definition that caused the error, Unknown if no definition was involved.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.Name">
            <summary>
            The name of the definition (rule/test/sequence/procedure/function/procedure method/function method).
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.FilterName">
            <summary>
            The name of the filter which was mis-applied.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.EntityName">
            <summary>
            The name of the entity which does not exist in the pattern of the rule.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.Action">
            <summary>
            The associated action instance. If it is null, there was no rule with the name specified in RuleName.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.NumGivenInputs">
            <summary>
            The number of inputs given to the rule.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.NumGivenOutputs">
            <summary>
            The number of outputs given to the rule.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.BadParamIndex">
            <summary>
            The index of a bad parameter or -1 if another error occurred.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.VariableOrFunctionName">
            <summary>
            The variable which caused the type error or the function/operator which caused the type error
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.ExpectedType">
            <summary>
            The expected type or types
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.GivenType">
            <summary>
            The given type
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.LeftType">
            <summary>
            The left type given for the operator
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.RightType">
            <summary>
            The right type given for the operator
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.SequenceParserException.Expression">
            <summary>
            The sub-expression as string for which the operator given in VariableOrFunctionName 
            was not defined for the types given in LeftType and RightType
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,de.unika.ipd.grGen.libGr.IAction,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule with the
            given name does not exist or input or output parameters do not match.
            </summary>
            <param name="ruleName">The name of the rule.</param>
            <param name="action">The associated action instance.
            If it is null, there was no rule with the name specified in RuleName.</param>
            <param name="numGivenInputs">The number of inputs given to the rule.</param>
            <param name="numGivenOutputs">The number of outputs given to the rule.</param>
            <param name="badParamIndex">The index of a bad parameter or -1 if another error occurred.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,de.unika.ipd.grGen.libGr.SequenceParserError)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule with the
            given name does not exist or input or output parameters do not match, or a method was called on a type not supporting this.
            </summary>
            <param name="ruleName">Name of the rule or sequence or variable.</param>
            <param name="errorKind">The kind of error.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(de.unika.ipd.grGen.libGr.InvocationParameterBindingsWithReturns,de.unika.ipd.grGen.libGr.SequenceParserError)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule or sequence
            with the given name does not exist or input or output parameters do not match.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule/sequence invocation.</param>
            <param name="errorKind">The kind of error.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(de.unika.ipd.grGen.libGr.InvocationParameterBindingsWithReturns,de.unika.ipd.grGen.libGr.SequenceParserError,System.Int32)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the rule or sequence 
            with the given name does not exist or input or output parameters do not match.
            </summary>
            <param name="paramBindings">The parameter bindings of the rule/sequence invocation.</param>
            <param name="errorKind">The kind of error.</param>
            <param name="badParamIndex">The index of a bad parameter or -1 if another error occurred.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(de.unika.ipd.grGen.libGr.InvocationParameterBindings,de.unika.ipd.grGen.libGr.SequenceParserError)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the function
            with the given name does not exist or input or output parameters do not match.
            </summary>
            <param name="paramBindings">The parameter bindings of the function invocation.</param>
            <param name="errorKind">The kind of error.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(de.unika.ipd.grGen.libGr.InvocationParameterBindings,de.unika.ipd.grGen.libGr.SequenceParserError,System.Int32)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, when the function 
            with the given name does not exist or input or output parameters do not match.
            </summary>
            <param name="paramBindings">The parameter bindings of the function invocation.</param>
            <param name="errorKind">The kind of error.</param>
            <param name="badParamIndex">The index of a bad parameter or -1 if another error occurred.</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser,
            when the expected type does not match the given type of the variable of function.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser,
            when an operator is not available for the supplied types.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SequenceParserException.#ctor(System.String,System.String,de.unika.ipd.grGen.libGr.SequenceParserError)">
            <summary>
            Creates an instance of a SequenceParserException used by the SequenceParser, 
            when the filter with the given name can't be applied to the rule of the given name
            or when the pattern of the rule of the given name does not contain an entity of the given name.
            </summary>
            <param name="ruleName">Name of the rule.</param>
            <param name="filterNameOrEntityName">Name of the filter which was mis-applied or name of the entity which is not conained in the rule.</param>
            <param name="errorKind">The kind of error.</param>
        </member>
        <member name="P:de.unika.ipd.grGen.libGr.SequenceParserException.Message">
            <summary>
            The error message of the exception.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SequenceVariable">
            <summary>
            A variable declared/used within a sequence,
            might be a sequence-local variable or a reference to a graph-global variable.
            It is first stored within the symbol table belonging to the sequence on sequence parsing,
            after parsing only on the heap, with references from the sequence AST pointing to it.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.Set`1">
            <summary>
            Set class only used by the dumping code in BaseGraph.
            The value of this class is questionable...
            </summary>
            <typeparam name="T">The type of the contained elements.</typeparam>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SingleLinkedList`1">
            <summary>
            Deprecated...
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.ScopeType">
            <summary>
            The possible scope opening types
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SymbolTable">
            <summary>
            class of symbol table containing the variables declared in the sequence
            variables might be implicitely(graph-global) or explicitely(sequence-local) declared
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.SymmetryChecker">
            <summary>
            A class which contains the AreSymmetric function to check to matches of a pattern for being symmetric,
            i.e. to be matches of a pattern which is automorph to itself.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.AreSymmetric(de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Checks whether the matches are symmetric, 
            i.e. are covering the same spot in the graph with a permutation of the pattern to graph mapping; 
            that might be the case if they are matches of a pattern which is automorph to itself.
            This function is employed by the generated automorph filters for rule \ auto.
            Ths subpattern derivations must be structurally identical, modulo permutations of matches of the same subpattern type.
            </summary>
            <param name="this_">The one match to check for being symmetric to the other</param>
            <param name="that">The other match to check for being symmetric to the one match</param>
            <param name="graph">The graph in which the matches were found</param>
            <returns>True if the matches are symmetric, i.e. covering the same spot in the graph, otherwise false.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.Mark(de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Mark the elements of the match in the graph with a visited flag.
            Allocates a visited flag.
            </summary>
            <param name="match">The match to mark in the graph with a visited flag</param>
            <param name="graph">The graph in which the match was found, needed for visited flag access</param>
            <returns>The visited flag id, for later checks and the unmarking</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.Unmark(de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Unmark the elements of the match in the graph, regarding the given visited flag.
            Deallocates the visited flag.
            </summary>
            <param name="match">The match to mark in the graph with a visited flag</param>
            <param name="graph">The graph in which the match was found, needed for visited flag access</param>
            <param name="id">The visited flag id</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.AreAllMarked(de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Checks whether all elements of the match are marked in the graph, regarding the given visited flag.
            </summary>
            <param name="match">The match to check for being marked</param>
            <param name="graph">The graph in which the match was found, needed for visited flag access</param>
            <param name="id">The visited flag id</param>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.AreIterationsSymmetric(de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Checks whether the iterated matches are symmetric, 
            i.e. are covering the same spot in the graph with a permutation of the single matches
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.AreIterationsSymmetric(de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.IMatches,de.unika.ipd.grGen.libGr.IGraph,System.Int32)">
            <summary>
            Searches for a symmetric partner for the match at the index in this
            Returns true if it was possible in the end to map every match in this to a match in that
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.AreSubpatternsSymmetric(de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IGraph)">
            <summary>
            Checks whether the subpattern matches are symmetric, 
            i.e. are covering the same spot in the graph with a permutation of the matches of same subpattern type
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.SymmetryChecker.AreSubpatternsSymmetric(de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IMatch,de.unika.ipd.grGen.libGr.IGraph,System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Checks whether the subpattern matches of the partition are symmetric, 
            i.e. are covering the same spot in the graph with a permutation of the matches in the partition
            Searches for a symmetric partner for the subpattern match at the index in the partition in this
            Returns true if it was possible in the end to map every match in the partition in this to a match in that
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.TypesHelper.PrefixedTypeFromType(System.Type)">
            <summary>
            Returns type string with correct namespace prefix for the type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.TypesHelper.XgrsTypeToCSharpType(System.String,de.unika.ipd.grGen.libGr.IGraphModel)">
            <summary>
            Returns type with correct namespace prefix for the type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.TypesHelper.XgrsTypeToCSharpTypeNodeEdge(System.String)">
            <summary>
            Returns type with correct namespace prefix for the node or edge type given
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.TypesHelper.Clone(System.Object)">
            <summary>
            Returns a clone of either a graph or a match or a container
            </summary>
            <param name="toBeCloned">The graph or match or container to be cloned</param>
            <returns>The cloned graph or match or container</returns>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VCGFlags">
            <summary>
            Specifies flags how the graph should be displayed by a graph layouter.
            </summary>
            <remarks>YComp does not support all flags.</remarks>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientTopToBottom">
            <summary>
            Orient layout from top to bottom.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientBottomToTop">
            <summary>
            Orient layout from bottom to top.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientLeftToRight">
            <summary>
            Orient layout from left to right.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientRightToLeft">
            <summary>
            Orient layout from right to left.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.OrientMask">
            <summary>
            Mask of orientation bits.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.EdgeLabels">
            <summary>
            Show edge labels.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.PortSharing">
            <summary>
            Enable port sharing.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.Splines">
            <summary>
            Use splines for edge drawing.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.ManhattanEdges">
            <summary>
            Use manhattan edges.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.SManhattanEdges">
            <summary>
            Use smanhattan edges.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.SuppressEdges">
            <summary>
            Suppress edge drawing.
            </summary>
        </member>
        <member name="F:de.unika.ipd.grGen.libGr.VCGFlags.SuppressNodes">
            <summary>
            Suppress node drawing
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.VCGDumper">
            <summary>
            A VCG graph dumper.
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.GetColor(de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Gets the VCG string representation of a GrColor object.
            </summary>
            <param name="color">The GrColor object.</param>
            <returns>The VCG string representation of <c>color</c>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.GetLineStyle(de.unika.ipd.grGen.libGr.GrLineStyle)">
            <summary>
            Gets the VCG string representation of a GrLineStyle object.
            </summary>
            <param name="style">The GrLineStyle object.</param>
            <returns>The VCG string representation of <c>style</c>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.GetNodeShape(de.unika.ipd.grGen.libGr.GrNodeShape)">
            <summary>
            Gets the VCG string representation of a GrNodeShape object.
            </summary>
            <param name="shape">The GrNodeShape object.</param>
            <returns>The VCG string representation of <c>shape</c>.</returns>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.#ctor(System.String,de.unika.ipd.grGen.libGr.VCGFlags,System.String)">
            <summary>
            Initializes a new instance of the VCGDumper.
            </summary>
            <param name="filename">Destination file.</param>
            <param name="flags">Flags to control the dumper's behavior.</param>
            <param name="layouter">Specifies the yComp layouter to be used.</param>
            <exception cref="T:System.IO.IOException">Thrown when the destination cannot be created.</exception>
            <remarks>Currently (YComp 1.3.9) valid layouters are:
             - "Random"
             - "Hierarchic"
             - "Organic"
             - "Orthogonal"
             - "Circular"
             - "Tree"
             - "Diagonal"
             - "Incremental Hierarchic"
             - "Compilergraph"
            </remarks>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.#ctor(System.String)">
            <summary>
            Initializes a new instance of the VCGDumper with standard flags (VCGFlags.OrientBottomToTop) and the "Orthogonal" layouter.
            </summary>
            <param name="filename">Destination file.</param>
            <exception cref="T:System.IO.IOException">Thrown when the destination cannot be created.</exception>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.DumpNode(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrNodeShape)">
             <summary>
             Dump a node to the VCG graph.
             </summary>
             <param name="node">The node to be dumped.</param>
             <param name="label">The label to use for the node.</param>
             <param name="attributes">An enumerable of attribute strings.</param>
             <param name="textColor">The color of the text.</param>
             <param name="nodeColor">The color of the node.</param>
             <param name="borderColor">The color of the node border.</param>
             <param name="nodeShape">The shape of the node.</param>
            
             TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
            
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.DumpEdge(de.unika.ipd.grGen.libGr.INode,de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrLineStyle,System.Int32)">
             <summary>
             Dump an edge to the VCG graph
             </summary>
             <param name="srcNode">The source node of the edge</param>
             <param name="tgtNode">The target node of the edge</param>
             <param name="label">The label of the edge, may be null</param>
             <param name="attributes">An enumerable of attribute strings</param>
             <param name="textColor">The color of the text</param>
             <param name="edgeColor">The color of the edge</param>
             <param name="lineStyle">The linestyle of the edge</param>
             <param name="thickness">The thickness of the edge (1-5)</param>
            
             TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
            
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.StartSubgraph(de.unika.ipd.grGen.libGr.INode,System.String,System.Collections.Generic.IEnumerable{System.String},de.unika.ipd.grGen.libGr.GrColor,de.unika.ipd.grGen.libGr.GrColor)">
            <summary>
            Creates a new sub-graph to the VCG graph
            </summary>
            <param name="node">The node starting the new sub-graph</param>
            <param name="label">The label to use for the node</param>
            <param name="attributes">An enumerable of attribute strings</param>
            <param name="textColor">The color of the text</param>
            <param name="subgraphColor">The color of the subgraph node</param>
            TODO: Check whether GetHashCode should really be used or better Graph.GetElementName()
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.FinishSubgraph">
            <summary>
            Finishes a subgraph
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.FinishDump">
            <summary>
            Finishes the dump and closes the file
            </summary>
        </member>
        <member name="M:de.unika.ipd.grGen.libGr.VCGDumper.Dispose">
            <summary>
            Disposes this object. If <see cref="M:de.unika.ipd.grGen.libGr.VCGDumper.FinishDump"/> has not been called yet, it is called.
            This allows using "using" with the dumper object.
            </summary>
        </member>
        <member name="T:de.unika.ipd.grGen.libGr.UberEstimator">
            <summary>
            The Über-Statistical-Estimator implementing a staged, present leaning, truncated average.
            Staged similar to the remedian for efficient computation in case of a large number of samples,
            present leaning with weights to get a preference for more current values, going into the direction of a sliding average, 
            truncated average to achieve resilience against outliers (compared to the average),
            and to not underestimate the volume (compared to the median in case about half of the values are small).
            </summary>
        </member>
    </members>
</doc>
