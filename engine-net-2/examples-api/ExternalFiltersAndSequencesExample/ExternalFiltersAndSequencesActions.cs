// This file has been generated automatically by GrGen (www.grgen.net)
// Do not modify this file! Any changes will be lost!
// Generated from "..\..\examples\ExternalFiltersAndSequencesExample\ExternalFiltersAndSequences.grg" on Sun May 24 19:21:36 CEST 2020

using System;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Threading;
using System.Diagnostics;
using GRGEN_LIBGR = de.unika.ipd.grGen.libGr;
using GRGEN_LGSP = de.unika.ipd.grGen.lgsp;
using GRGEN_EXPR = de.unika.ipd.grGen.expression;
using GRGEN_MODEL = de.unika.ipd.grGen.Model_ExternalFiltersAndSequences;
using GRGEN_ACTIONS = de.unika.ipd.grGen.Action_ExternalFiltersAndSequences;

namespace de.unika.ipd.grGen.Action_ExternalFiltersAndSequences
{
	public class Rule_filterBase : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_filterBase instance = null;
		public static Rule_filterBase Instance { get { if(instance==null) { instance = new Rule_filterBase(); instance.initialize(); } return instance; } }

		public enum filterBase_NodeNums { };
		public enum filterBase_EdgeNums { };
		public enum filterBase_VariableNums { };
		public enum filterBase_SubNums { };
		public enum filterBase_AltNums { };
		public enum filterBase_IterNums { };





		public GRGEN_LGSP.PatternGraph pat_filterBase;


		private Rule_filterBase()
			: base("filterBase",
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoGenerated("auto", null, "auto", null, "auto", new String[] { }, new GRGEN_LIBGR.GrGenType[] { }),
					new GRGEN_LGSP.LGSPFilterFunction("f1", null, "f1", true, null, new GRGEN_LIBGR.GrGenType[] {}, new String[] {}),
 					new GRGEN_LGSP.LGSPFilterFunction("nomnomnom", null, "nomnomnom", true, null, new GRGEN_LIBGR.GrGenType[] {}, new String[] {}),
 				},
				new GRGEN_LIBGR.MatchClassInfo[] { }
			)
		{
		}
		private void initialize()
		{
			bool[,] filterBase_isNodeHomomorphicGlobal = new bool[0, 0];
			bool[,] filterBase_isEdgeHomomorphicGlobal = new bool[0, 0];
			bool[] filterBase_isNodeTotallyHomomorphic = new bool[0];
			bool[] filterBase_isEdgeTotallyHomomorphic = new bool[0];
			pat_filterBase = new GRGEN_LGSP.PatternGraph(
				"filterBase",
				"",
				null, "filterBase",
				false, false,
				new GRGEN_LGSP.PatternNode[] {  }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[0, 0] ,
				new bool[0, 0] ,
				filterBase_isNodeHomomorphicGlobal,
				filterBase_isEdgeHomomorphicGlobal,
				filterBase_isNodeTotallyHomomorphic,
				filterBase_isEdgeTotallyHomomorphic
			);


			patternGraph = pat_filterBase;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_filterBase curMatch = (Match_filterBase)_curMatch;
			graph.SettingAddedNodeNames( filterBase_addedNodeNames );
			graph.SettingAddedEdgeNames( filterBase_addedEdgeNames );
			return;
		}
		private static string[] filterBase_addedNodeNames = new string[] {  };
		private static string[] filterBase_addedEdgeNames = new string[] {  };

		static Rule_filterBase() {
		}

		public interface IMatch_filterBase : GRGEN_LIBGR.IMatch
		{
			//Nodes
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_filterBase : GRGEN_LGSP.MatchListElement<Match_filterBase>, IMatch_filterBase
		{
			public enum filterBase_NodeNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 0;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBase_EdgeNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 0;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBase_VariableNums { END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 0;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBase_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBase_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBase_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBase_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_filterBase.instance.pat_filterBase; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_filterBase(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_filterBase nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_filterBase cur = this;
				while(cur != null) {
					Match_filterBase next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_filterBase that)
			{
			}

			public Match_filterBase(Match_filterBase that)
			{
				CopyMatchContent(that);
			}
			public Match_filterBase()
			{
			}

			public bool IsEqual(Match_filterBase that)
			{
				if(that==null) return false;
				return true;
			}
		}


		public class Extractor
		{
		}

	}

	public partial class MatchFilters
	{
	}

	public class Rule_filterBass : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_filterBass instance = null;
		public static Rule_filterBass Instance { get { if(instance==null) { instance = new Rule_filterBass(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] filterBass_node_n_AllowedTypes = null;
		public static bool[] filterBass_node_n_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] filterBass_edge_e_AllowedTypes = null;
		public static bool[] filterBass_edge_e_IsAllowedType = null;
		public enum filterBass_NodeNums { @n, };
		public enum filterBass_EdgeNums { @e, };
		public enum filterBass_VariableNums { @s, };
		public enum filterBass_SubNums { };
		public enum filterBass_AltNums { };
		public enum filterBass_IterNums { };





		public GRGEN_LGSP.PatternGraph pat_filterBass;


		private Rule_filterBass()
			: base("filterBass",
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoGenerated("auto", null, "auto", null, "auto", new String[] { }, new GRGEN_LIBGR.GrGenType[] { }),
					new GRGEN_LGSP.LGSPFilterFunction("fil", null, "fil", false, null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"f", }),
 					new GRGEN_LGSP.LGSPFilterFunction("f2", null, "f2", true, null, new GRGEN_LIBGR.GrGenType[] {}, new String[] {}),
 					new GRGEN_LGSP.LGSPFilterFunction("f3", null, "f3", true, null, new GRGEN_LIBGR.GrGenType[] {}, new String[] {}),
 				},
				new GRGEN_LIBGR.MatchClassInfo[] { }
			)
		{
		}
		private void initialize()
		{
			bool[,] filterBass_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] filterBass_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] filterBass_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] filterBass_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable filterBass_var_s = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(string)), "filterBass_var_s", "s", -1, true, null);
			GRGEN_LGSP.PatternNode filterBass_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@N, GRGEN_MODEL.NodeType_N.typeVar, "GRGEN_MODEL.IN", "filterBass_node_n", "n", filterBass_node_n_AllowedTypes, filterBass_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternEdge filterBass_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@E, GRGEN_MODEL.EdgeType_E.typeVar, "GRGEN_MODEL.IE", "filterBass_edge_e", "e", filterBass_edge_e_AllowedTypes, filterBass_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			pat_filterBass = new GRGEN_LGSP.PatternGraph(
				"filterBass",
				"",
				null, "filterBass",
				false, false,
				new GRGEN_LGSP.PatternNode[] { filterBass_node_n }, 
				new GRGEN_LGSP.PatternEdge[] { filterBass_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { filterBass_var_s }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				filterBass_isNodeHomomorphicGlobal,
				filterBass_isEdgeHomomorphicGlobal,
				filterBass_isNodeTotallyHomomorphic,
				filterBass_isEdgeTotallyHomomorphic
			);
			pat_filterBass.edgeToSourceNode.Add(filterBass_edge_e, filterBass_node_n);
			pat_filterBass.edgeToTargetNode.Add(filterBass_edge_e, filterBass_node_n);

			filterBass_var_s.pointOfDefinition = pat_filterBass;
			filterBass_node_n.pointOfDefinition = pat_filterBass;
			filterBass_edge_e.pointOfDefinition = pat_filterBass;

			patternGraph = pat_filterBass;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_filterBass curMatch = (Match_filterBass)_curMatch;
			graph.SettingAddedNodeNames( filterBass_addedNodeNames );
			graph.SettingAddedEdgeNames( filterBass_addedEdgeNames );
			return;
		}
		private static string[] filterBass_addedNodeNames = new string[] {  };
		private static string[] filterBass_addedEdgeNames = new string[] {  };

		static Rule_filterBass() {
		}

		public interface IMatch_filterBass : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IN node_n { get; set; }
			//Edges
			GRGEN_MODEL.IE edge_e { get; set; }
			//Variables
			string @var_s { get; set; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_filterBass : GRGEN_LGSP.MatchListElement<Match_filterBass>, IMatch_filterBass
		{
			public GRGEN_MODEL.IN node_n { get { return (GRGEN_MODEL.IN)_node_n; } set { _node_n = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum filterBass_NodeNums { @n, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 1;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)filterBass_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				case "n": return _node_n;
				default: return null;
				}
			}

			public GRGEN_MODEL.IE edge_e { get { return (GRGEN_MODEL.IE)_edge_e; } set { _edge_e = (GRGEN_LGSP.LGSPEdge)value; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum filterBass_EdgeNums { @e, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 1;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)filterBass_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				case "e": return _edge_e;
				default: return null;
				}
			}

			public string var_s { get { return _var_s; } set { _var_s = value; } }
			public string _var_s;
			public enum filterBass_VariableNums { @s, END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 1;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				case (int)filterBass_VariableNums.@s: return _var_s;
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				case "s": return _var_s;
				default: return null;
				}
			}

			public enum filterBass_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBass_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBass_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterBass_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_filterBass.instance.pat_filterBass; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_filterBass(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_filterBass nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_filterBass cur = this;
				while(cur != null) {
					Match_filterBass next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_filterBass that)
			{
				_node_n = that._node_n;
				_edge_e = that._edge_e;
				_var_s = that._var_s;
			}

			public Match_filterBass(Match_filterBass that)
			{
				CopyMatchContent(that);
			}
			public Match_filterBass()
			{
			}

			public bool IsEqual(Match_filterBass that)
			{
				if(that==null) return false;
				if(_node_n != that._node_n) return false;
				if(_edge_e != that._edge_e) return false;
				return true;
			}
		}


		public class Extractor
		{
			public static List<GRGEN_MODEL.IN> Extract_n(List<IMatch_filterBass> matchList)
			{
				List<GRGEN_MODEL.IN> resultList = new List<GRGEN_MODEL.IN>(matchList.Count);
				foreach(IMatch_filterBass match in matchList)
					resultList.Add(match.node_n);
				return resultList;
			}
			public static List<GRGEN_MODEL.IE> Extract_e(List<IMatch_filterBass> matchList)
			{
				List<GRGEN_MODEL.IE> resultList = new List<GRGEN_MODEL.IE>(matchList.Count);
				foreach(IMatch_filterBass match in matchList)
					resultList.Add(match.edge_e);
				return resultList;
			}
			public static List<string> Extract_s(List<IMatch_filterBass> matchList)
			{
				List<string> resultList = new List<string>(matchList.Count);
				foreach(IMatch_filterBass match in matchList)
					resultList.Add(match.var_s);
				return resultList;
			}
		}

	}

	public partial class MatchFilters
	{
		public static List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> Array_filterBass_orderAscendingBy_s(List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> newList = new List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>(list);
			newList.Sort(new Comparer_filterBass_orderAscendingBy_s());
			return newList;
		}
		class Comparer_filterBass_orderAscendingBy_s : Comparer<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass a, GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass b)
			{
				return StringComparer.InvariantCulture.Compare(a.@var_s, b.@var_s);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> Array_filterBass_orderDescendingBy_s(List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> newList = new List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>(list);
			newList.Sort(new Comparer_filterBass_orderDescendingBy_s());
			return newList;
		}
		class Comparer_filterBass_orderDescendingBy_s : Comparer<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass b, GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass a)
			{
				return StringComparer.InvariantCulture.Compare(a.@var_s, b.@var_s);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> Array_filterBass_keepOneForEachBy_s(List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> newList = new List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>();
			Dictionary<string, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<string, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@var_s)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@var_s, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> Array_filterBass_keepOneForEachBy_n(List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> newList = new List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>();
			Dictionary<GRGEN_MODEL.IN, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IN, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_n)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_n, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> Array_filterBass_keepOneForEachBy_e(List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> newList = new List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>();
			Dictionary<GRGEN_MODEL.IE, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IE, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@edge_e)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@edge_e, null);
				}
			}
			return newList;
		}
	}

	public class Rule_filterHass : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_filterHass instance = null;
		public static Rule_filterHass Instance { get { if(instance==null) { instance = new Rule_filterHass(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] filterHass_node_n_AllowedTypes = null;
		public static bool[] filterHass_node_n_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] filterHass_edge_e_AllowedTypes = null;
		public static bool[] filterHass_edge_e_IsAllowedType = null;
		public enum filterHass_NodeNums { @n, };
		public enum filterHass_EdgeNums { @e, };
		public enum filterHass_VariableNums { @i, };
		public enum filterHass_SubNums { };
		public enum filterHass_AltNums { };
		public enum filterHass_IterNums { };



		public GRGEN_LGSP.PatternGraph pat_filterHass;


		private Rule_filterHass()
			: base("filterHass",
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_N.typeVar, },
				new string[] { "filterHass_node_n", },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.EdgeType_E.typeVar, },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoGenerated("orderAscendingBy<i>", null, "orderAscendingBy<i>", null, "orderAscendingBy", new String[] { "i"}, new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int))}),
					new GRGEN_LGSP.LGSPFilterFunction("f4", null, "f4", true, null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), GRGEN_LIBGR.VarType.GetVarType(typeof(string)), }, new String[] {"i", "s", }),
 				},
				new GRGEN_LIBGR.MatchClassInfo[] { }
			)
		{
		}
		private void initialize()
		{
			bool[,] filterHass_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] filterHass_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] filterHass_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] filterHass_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable filterHass_var_i = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "filterHass_var_i", "i", -1, true, null);
			GRGEN_LGSP.PatternNode filterHass_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@N, GRGEN_MODEL.NodeType_N.typeVar, "GRGEN_MODEL.IN", "filterHass_node_n", "n", filterHass_node_n_AllowedTypes, filterHass_node_n_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternEdge filterHass_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@E, GRGEN_MODEL.EdgeType_E.typeVar, "GRGEN_MODEL.IE", "filterHass_edge_e", "e", filterHass_edge_e_AllowedTypes, filterHass_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			pat_filterHass = new GRGEN_LGSP.PatternGraph(
				"filterHass",
				"",
				null, "filterHass",
				false, false,
				new GRGEN_LGSP.PatternNode[] { filterHass_node_n }, 
				new GRGEN_LGSP.PatternEdge[] { filterHass_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] { filterHass_var_i }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				filterHass_isNodeHomomorphicGlobal,
				filterHass_isEdgeHomomorphicGlobal,
				filterHass_isNodeTotallyHomomorphic,
				filterHass_isEdgeTotallyHomomorphic
			);
			pat_filterHass.edgeToSourceNode.Add(filterHass_edge_e, filterHass_node_n);
			pat_filterHass.edgeToTargetNode.Add(filterHass_edge_e, filterHass_node_n);

			filterHass_var_i.pointOfDefinition = pat_filterHass;
			filterHass_node_n.pointOfDefinition = null;
			filterHass_edge_e.pointOfDefinition = pat_filterHass;

			patternGraph = pat_filterHass;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IE output_0)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_filterHass curMatch = (Match_filterHass)_curMatch;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			output_0 = (GRGEN_MODEL.IE)(edge_e);
			return;
		}

		static Rule_filterHass() {
		}

		public interface IMatch_filterHass : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IN node_n { get; set; }
			//Edges
			GRGEN_MODEL.IE edge_e { get; set; }
			//Variables
			int @var_i { get; set; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_filterHass : GRGEN_LGSP.MatchListElement<Match_filterHass>, IMatch_filterHass
		{
			public GRGEN_MODEL.IN node_n { get { return (GRGEN_MODEL.IN)_node_n; } set { _node_n = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum filterHass_NodeNums { @n, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 1;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)filterHass_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				case "n": return _node_n;
				default: return null;
				}
			}

			public GRGEN_MODEL.IE edge_e { get { return (GRGEN_MODEL.IE)_edge_e; } set { _edge_e = (GRGEN_LGSP.LGSPEdge)value; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum filterHass_EdgeNums { @e, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 1;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)filterHass_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				case "e": return _edge_e;
				default: return null;
				}
			}

			public int var_i { get { return _var_i; } set { _var_i = value; } }
			public int _var_i;
			public enum filterHass_VariableNums { @i, END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 1;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				case (int)filterHass_VariableNums.@i: return _var_i;
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				case "i": return _var_i;
				default: return null;
				}
			}

			public enum filterHass_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterHass_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterHass_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum filterHass_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_filterHass.instance.pat_filterHass; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_filterHass(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_filterHass nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_filterHass cur = this;
				while(cur != null) {
					Match_filterHass next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_filterHass that)
			{
				_node_n = that._node_n;
				_edge_e = that._edge_e;
				_var_i = that._var_i;
			}

			public Match_filterHass(Match_filterHass that)
			{
				CopyMatchContent(that);
			}
			public Match_filterHass()
			{
			}

			public bool IsEqual(Match_filterHass that)
			{
				if(that==null) return false;
				if(_node_n != that._node_n) return false;
				if(_edge_e != that._edge_e) return false;
				return true;
			}
		}


		public class Extractor
		{
			public static List<GRGEN_MODEL.IN> Extract_n(List<IMatch_filterHass> matchList)
			{
				List<GRGEN_MODEL.IN> resultList = new List<GRGEN_MODEL.IN>(matchList.Count);
				foreach(IMatch_filterHass match in matchList)
					resultList.Add(match.node_n);
				return resultList;
			}
			public static List<GRGEN_MODEL.IE> Extract_e(List<IMatch_filterHass> matchList)
			{
				List<GRGEN_MODEL.IE> resultList = new List<GRGEN_MODEL.IE>(matchList.Count);
				foreach(IMatch_filterHass match in matchList)
					resultList.Add(match.edge_e);
				return resultList;
			}
			public static List<int> Extract_i(List<IMatch_filterHass> matchList)
			{
				List<int> resultList = new List<int>(matchList.Count);
				foreach(IMatch_filterHass match in matchList)
					resultList.Add(match.var_i);
				return resultList;
			}
		}

	}

	public partial class MatchFilters
	{
		public static List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> Array_filterHass_orderAscendingBy_i(List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> newList = new List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>(list);
			newList.Sort(new Comparer_filterHass_orderAscendingBy_i());
			return newList;
		}
		class Comparer_filterHass_orderAscendingBy_i : Comparer<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass a, GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass b)
			{
				return a.@var_i.CompareTo(b.@var_i);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> Array_filterHass_orderDescendingBy_i(List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> newList = new List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>(list);
			newList.Sort(new Comparer_filterHass_orderDescendingBy_i());
			return newList;
		}
		class Comparer_filterHass_orderDescendingBy_i : Comparer<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass b, GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass a)
			{
				return a.@var_i.CompareTo(b.@var_i);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> Array_filterHass_keepOneForEachBy_i(List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> newList = new List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>();
			Dictionary<int, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<int, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@var_i)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@var_i, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> Array_filterHass_keepOneForEachBy_n(List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> newList = new List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>();
			Dictionary<GRGEN_MODEL.IN, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IN, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_n)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_n, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> Array_filterHass_keepOneForEachBy_e(List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> list)
		{
			List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> newList = new List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>();
			Dictionary<GRGEN_MODEL.IE, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IE, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@edge_e)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@edge_e, null);
				}
			}
			return newList;
		}
	}

	public class Rule_init : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_init instance = null;
		public static Rule_init Instance { get { if(instance==null) { instance = new Rule_init(); instance.initialize(); } return instance; } }

		public enum init_NodeNums { };
		public enum init_EdgeNums { };
		public enum init_VariableNums { };
		public enum init_SubNums { };
		public enum init_AltNums { };
		public enum init_IterNums { };





		public GRGEN_LGSP.PatternGraph pat_init;


		private Rule_init()
			: base("init",
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_N.typeVar, },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
				},
				new GRGEN_LIBGR.MatchClassInfo[] { }
			)
		{
		}
		private void initialize()
		{
			bool[,] init_isNodeHomomorphicGlobal = new bool[0, 0];
			bool[,] init_isEdgeHomomorphicGlobal = new bool[0, 0];
			bool[] init_isNodeTotallyHomomorphic = new bool[0];
			bool[] init_isEdgeTotallyHomomorphic = new bool[0];
			pat_init = new GRGEN_LGSP.PatternGraph(
				"init",
				"",
				null, "init",
				false, false,
				new GRGEN_LGSP.PatternNode[] {  }, 
				new GRGEN_LGSP.PatternEdge[] {  }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[0, 0] ,
				new bool[0, 0] ,
				init_isNodeHomomorphicGlobal,
				init_isEdgeHomomorphicGlobal,
				init_isNodeTotallyHomomorphic,
				init_isEdgeTotallyHomomorphic
			);


			patternGraph = pat_init;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IN output_0)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_init curMatch = (Match_init)_curMatch;
			graph.SettingAddedNodeNames( init_addedNodeNames );
			GRGEN_MODEL.@N node_n1 = GRGEN_MODEL.@N.CreateNode(graph);
			GRGEN_MODEL.@N node_n2 = GRGEN_MODEL.@N.CreateNode(graph);
			graph.SettingAddedEdgeNames( init_addedEdgeNames );
			GRGEN_MODEL.@E edge__edge0 = GRGEN_MODEL.@E.CreateEdge(graph, node_n1, node_n1);
			GRGEN_MODEL.@E edge__edge1 = GRGEN_MODEL.@E.CreateEdge(graph, node_n2, node_n2);
			output_0 = (GRGEN_MODEL.IN)(node_n1);
			return;
		}
		private static string[] init_addedNodeNames = new string[] { "n1", "n2" };
		private static string[] init_addedEdgeNames = new string[] { "_edge0", "_edge1" };

		static Rule_init() {
		}

		public interface IMatch_init : GRGEN_LIBGR.IMatch
		{
			//Nodes
			//Edges
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_init : GRGEN_LGSP.MatchListElement<Match_init>, IMatch_init
		{
			public enum init_NodeNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 0;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum init_EdgeNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 0;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum init_VariableNums { END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 0;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum init_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum init_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum init_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum init_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_init.instance.pat_init; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_init(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_init nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_init cur = this;
				while(cur != null) {
					Match_init next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_init that)
			{
			}

			public Match_init(Match_init that)
			{
				CopyMatchContent(that);
			}
			public Match_init()
			{
			}

			public bool IsEqual(Match_init that)
			{
				if(that==null) return false;
				return true;
			}
		}


		public class Extractor
		{
		}

	}

	public partial class MatchFilters
	{
	}

	public class Rule_r : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_r instance = null;
		public static Rule_r Instance { get { if(instance==null) { instance = new Rule_r(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] r_node_n_AllowedTypes = null;
		public static bool[] r_node_n_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] r_edge_e_AllowedTypes = null;
		public static bool[] r_edge_e_IsAllowedType = null;
		public enum r_NodeNums { @n, };
		public enum r_EdgeNums { @e, };
		public enum r_VariableNums { };
		public enum r_SubNums { };
		public enum r_AltNums { };
		public enum r_IterNums { };





		public GRGEN_LGSP.PatternGraph pat_r;


		private Rule_r()
			: base("r",
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
				},
				new GRGEN_LIBGR.MatchClassInfo[] { }
			)
		{
		}
		private void initialize()
		{
			bool[,] r_isNodeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[,] r_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] r_isNodeTotallyHomomorphic = new bool[1] { false,  };
			bool[] r_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternNode r_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@N, GRGEN_MODEL.NodeType_N.typeVar, "GRGEN_MODEL.IN", "r_node_n", "n", r_node_n_AllowedTypes, r_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternEdge r_edge_e = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@E, GRGEN_MODEL.EdgeType_E.typeVar, "GRGEN_MODEL.IE", "r_edge_e", "e", r_edge_e_AllowedTypes, r_edge_e_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			pat_r = new GRGEN_LGSP.PatternGraph(
				"r",
				"",
				null, "r",
				false, false,
				new GRGEN_LGSP.PatternNode[] { r_node_n }, 
				new GRGEN_LGSP.PatternEdge[] { r_edge_e }, 
				new GRGEN_LGSP.PatternVariable[] {  }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[1, 1] {
					{ true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				r_isNodeHomomorphicGlobal,
				r_isEdgeHomomorphicGlobal,
				r_isNodeTotallyHomomorphic,
				r_isEdgeTotallyHomomorphic
			);
			pat_r.edgeToSourceNode.Add(r_edge_e, r_node_n);
			pat_r.edgeToTargetNode.Add(r_edge_e, r_node_n);

			r_node_n.pointOfDefinition = pat_r;
			r_edge_e.pointOfDefinition = pat_r;

			patternGraph = pat_r;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_r curMatch = (Match_r)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_MODEL.IN inode_n = curMatch.node_n;
			GRGEN_LGSP.LGSPEdge edge_e = curMatch._edge_e;
			graph.SettingAddedNodeNames( r_addedNodeNames );
			GRGEN_MODEL.@N node_m = GRGEN_MODEL.@N.CreateNode(graph);
			graph.SettingAddedEdgeNames( r_addedEdgeNames );
			int tempvar_node_n_i = inode_n.@i;
			double tempvar_node_n_d = inode_n.@d;
			GRGEN_MODEL.ENUM_Enu tempvar_node_n_enu = inode_n.@enu;
			string tempvar_node_n_s = inode_n.@s;
			bool tempvar_node_n_b = inode_n.@b;
			Object tempvar_node_n_o = inode_n.@o;
			GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv = (GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv;
			ApplyXGRS_r_0(procEnv, (GRGEN_MODEL.IN)node_n, (GRGEN_MODEL.IN)node_m, (GRGEN_MODEL.IE)edge_e);
			ApplyXGRS_r_1(procEnv, (GRGEN_MODEL.IN)node_n);
			return;
		}
		private static string[] r_addedNodeNames = new string[] { "m" };
		private static string[] r_addedEdgeNames = new string[] {  };

        public static bool ApplyXGRS_r_0(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, GRGEN_MODEL.IN var_n, GRGEN_MODEL.IN var_m, GRGEN_MODEL.IE var_e)
        {
            GRGEN_LGSP.LGSPGraph graph = procEnv.graph;
            GRGEN_LGSP.LGSPActions actions = procEnv.curActions;
            procEnv.DebugEntering("r.exec_0", "(::x,::y,::z,::u,::v)=foo(42,3.141,Enu::hurz,\"S21-heiteitei\",true) ;> foo(n.i,n.d,n.enu,n.s,n.b) ;> (::nul)=bar(null,n.o) ;> isnull(::x) ;> (::a,::b)=bla(m,e) ;> (::a,::b)=blo(m,e) ;> huh ;> (ehh:AEdge)=createEdge(n,n)");
            bool res_39;
            bool res_35;
            bool res_33;
            bool res_29;
            bool res_25;
            bool res_22;
            bool res_17;
            bool res_5;
                                                                        bool res_16;
            bool res_21;
                        bool res_24;
            bool res_28;
                                    bool res_32;
            bool res_34;
            bool res_38;
            GRGEN_LIBGR.IEdge var_ehh = null;
            int tmpvar_0x = 0;double tmpvar_1y = 0.0;GRGEN_MODEL.ENUM_Enu tmpvar_2z = (GRGEN_MODEL.ENUM_Enu)0;string tmpvar_3u = "";bool tmpvar_4v = false;
            if(GRGEN_ACTIONS.Sequence_foo.ApplyXGRS_foo(procEnv, (int)42, (double)((double)3.141), (GRGEN_MODEL.ENUM_Enu)de.unika.ipd.grGen.Model_ExternalFiltersAndSequences.ENUM_Enu.hurz, (string)"S21-heiteitei", (bool)true, ref tmpvar_0x, ref tmpvar_1y, ref tmpvar_2z, ref tmpvar_3u, ref tmpvar_4v)) {
                procEnv.SetVariableValue("x", tmpvar_0x);
procEnv.SetVariableValue("y", tmpvar_1y);
procEnv.SetVariableValue("z", tmpvar_2z);
procEnv.SetVariableValue("u", tmpvar_3u);
procEnv.SetVariableValue("v", tmpvar_4v);

                res_5 = (bool)(true);
            } else {
                res_5 = (bool)(false);
            }
            int tmpvar_5 = 0;double tmpvar_6 = 0.0;GRGEN_MODEL.ENUM_Enu tmpvar_7 = (GRGEN_MODEL.ENUM_Enu)0;string tmpvar_8 = "";bool tmpvar_9 = false;
            if(GRGEN_ACTIONS.Sequence_foo.ApplyXGRS_foo(procEnv, (int)(int)(((GRGEN_LIBGR.IGraphElement)var_n).GetAttribute("i")), (double)(double)(((GRGEN_LIBGR.IGraphElement)var_n).GetAttribute("d")), (GRGEN_MODEL.ENUM_Enu)(GRGEN_MODEL.ENUM_Enu)(((GRGEN_LIBGR.IGraphElement)var_n).GetAttribute("enu")), (string)(string)(((GRGEN_LIBGR.IGraphElement)var_n).GetAttribute("s")), (bool)(bool)(((GRGEN_LIBGR.IGraphElement)var_n).GetAttribute("b")), ref tmpvar_5, ref tmpvar_6, ref tmpvar_7, ref tmpvar_8, ref tmpvar_9)) {
                res_16 = (bool)(true);
            } else {
                res_16 = (bool)(false);
            }
            res_17 = (bool)(res_16);
            object tmpvar_10nul = null;
            if(GRGEN_ACTIONS.Sequence_bar.ApplyXGRS_bar(procEnv, (object)null, (object)(object)(((GRGEN_LIBGR.IGraphElement)var_n).GetAttribute("o")), ref tmpvar_10nul)) {
                procEnv.SetVariableValue("nul", tmpvar_10nul);

                res_21 = (bool)(true);
            } else {
                res_21 = (bool)(false);
            }
            res_22 = (bool)(res_21);
            if(GRGEN_ACTIONS.Sequence_isnull.ApplyXGRS_isnull(procEnv, (object)procEnv.GetVariableValue("x"))) {
                res_24 = (bool)(true);
            } else {
                res_24 = (bool)(false);
            }
            res_25 = (bool)(res_24);
            GRGEN_MODEL.IN tmpvar_11a = null;GRGEN_MODEL.IE tmpvar_12b = null;
            if(GRGEN_ACTIONS.Sequence_bla.ApplyXGRS_bla(procEnv, (GRGEN_MODEL.IN)var_m, (GRGEN_MODEL.IE)var_e, ref tmpvar_11a, ref tmpvar_12b)) {
                procEnv.SetVariableValue("a", tmpvar_11a);
procEnv.SetVariableValue("b", tmpvar_12b);

                res_28 = (bool)(true);
            } else {
                res_28 = (bool)(false);
            }
            res_29 = (bool)(res_28);
            GRGEN_LIBGR.INode tmpvar_13a = null;GRGEN_LIBGR.IEdge tmpvar_14b = null;
            if(GRGEN_ACTIONS.Sequence_blo.ApplyXGRS_blo(procEnv, (GRGEN_LIBGR.INode)var_m, (GRGEN_LIBGR.IDEdge)var_e, ref tmpvar_13a, ref tmpvar_14b)) {
                procEnv.SetVariableValue("a", tmpvar_13a);
procEnv.SetVariableValue("b", tmpvar_14b);

                res_32 = (bool)(true);
            } else {
                res_32 = (bool)(false);
            }
            res_33 = (bool)(res_32);
            if(GRGEN_ACTIONS.Sequence_huh.ApplyXGRS_huh(procEnv)) {
                res_34 = (bool)(true);
            } else {
                res_34 = (bool)(false);
            }
            res_35 = (bool)(res_34);
            GRGEN_LIBGR.IEdge tmpvar_15ehh = null;
            if(GRGEN_ACTIONS.Sequence_createEdge.ApplyXGRS_createEdge(procEnv, (GRGEN_LIBGR.INode)var_n, (GRGEN_LIBGR.INode)var_n, ref tmpvar_15ehh)) {
                var_ehh = (GRGEN_LIBGR.IEdge)(tmpvar_15ehh);

                res_38 = (bool)(true);
            } else {
                res_38 = (bool)(false);
            }
            res_39 = (bool)(res_38);
            procEnv.DebugExiting("r.exec_0");
            return res_39;
        }

        public static bool ApplyXGRS_r_1(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, GRGEN_MODEL.IN var_n)
        {
            GRGEN_LGSP.LGSPGraph graph = procEnv.graph;
            GRGEN_LGSP.LGSPActions actions = procEnv.curActions;
            procEnv.DebugEntering("r.exec_1", "filterBase\\f1 ;> filterBase\\nomnomnom ;> filterBase\\auto ;> [filterBass\\f2\\fil(42)] ;> $::x[filterBass\\f3] ;> [filterBass\\auto] ;> (::ee)=filterHass(::n)\\f4(::n.i,\"foo\")\\orderAscendingBy<i> \\keepFirst(42) ;>  <<filterBase\\f1;;filterBase\\f1>>  ;> ${<filterBase\\f1,[filterBass\\f2]>}");
            bool res_72;
            bool res_68;
            bool res_64;
            bool res_57;
            bool res_55;
            bool res_53;
            bool res_50;
            bool res_48;
            bool res_46;
            GRGEN_ACTIONS.Action_filterBase rule_filterBase = GRGEN_ACTIONS.Action_filterBase.Instance;
            bool res_47;
            bool res_49;
            bool res_51;
            GRGEN_ACTIONS.Action_filterBass rule_filterBass = GRGEN_ACTIONS.Action_filterBass.Instance;
            bool res_54;
            bool res_56;
            bool res_59;
            GRGEN_ACTIONS.Action_filterHass rule_filterHass = GRGEN_ACTIONS.Action_filterHass.Instance;
                        bool res_67;
            bool res_65;
            bool res_66;
            bool res_71;
            bool res_69;
            bool res_70;
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> matches_46 = rule_filterBase.Match(procEnv, 1);
            procEnv.PerformanceInfo.MatchesFound += matches_46.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f1(procEnv, matches_46);
            if(matches_46.Count == 0) {
                res_46 = (bool)(false);
            } else {
                res_46 = (bool)(true);
                procEnv.Matched(matches_46, null, false);
                procEnv.Finishing(matches_46, false);
                GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase match_46 = matches_46.FirstExact;
                rule_filterBase.Modify(procEnv, match_46);
                procEnv.PerformanceInfo.RewritesPerformed++;
                procEnv.Finished(matches_46, false);
            }
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> matches_47 = rule_filterBase.Match(procEnv, 1);
            procEnv.PerformanceInfo.MatchesFound += matches_47.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_nomnomnom(procEnv, matches_47);
            if(matches_47.Count == 0) {
                res_47 = (bool)(false);
            } else {
                res_47 = (bool)(true);
                procEnv.Matched(matches_47, null, false);
                procEnv.Finishing(matches_47, false);
                GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase match_47 = matches_47.FirstExact;
                rule_filterBase.Modify(procEnv, match_47);
                procEnv.PerformanceInfo.RewritesPerformed++;
                procEnv.Finished(matches_47, false);
            }
            res_48 = (bool)(res_47);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> matches_49 = rule_filterBase.Match(procEnv, 1);
            procEnv.PerformanceInfo.MatchesFound += matches_49.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_filterBase_auto(procEnv, matches_49);
            if(matches_49.Count == 0) {
                res_49 = (bool)(false);
            } else {
                res_49 = (bool)(true);
                procEnv.Matched(matches_49, null, false);
                procEnv.Finishing(matches_49, false);
                GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase match_49 = matches_49.FirstExact;
                rule_filterBase.Modify(procEnv, match_49);
                procEnv.PerformanceInfo.RewritesPerformed++;
                procEnv.Finished(matches_49, false);
            }
            res_50 = (bool)(res_49);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> matches_51 = rule_filterBass.Match(procEnv, procEnv.MaxMatches);
            procEnv.PerformanceInfo.MatchesFound += matches_51.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f2(procEnv, matches_51);
            GRGEN_ACTIONS.MatchFilters.Filter_fil(procEnv, matches_51, (int)(42));
            if(matches_51.Count == 0) {
                res_51 = (bool)(false);
            } else {
                res_51 = (bool)(true);
                procEnv.Matched(matches_51, null, false);
                procEnv.Finishing(matches_51, false);
                IEnumerator<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> enum_51 = matches_51.GetEnumeratorExact();
                while(enum_51.MoveNext())
                {
                    GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass match_51 = enum_51.Current;
                    if(match_51!=matches_51.FirstExact) procEnv.RewritingNextMatch();
                    rule_filterBass.Modify(procEnv, match_51);
                    procEnv.PerformanceInfo.RewritesPerformed++;
                }
                procEnv.Finished(matches_51, false);
            }
            res_53 = (bool)(res_51);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> matches_54 = rule_filterBass.Match(procEnv, procEnv.MaxMatches);
            procEnv.PerformanceInfo.MatchesFound += matches_54.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f3(procEnv, matches_54);
            if(matches_54.Count == 0) {
                res_54 = (bool)(false);
            } else {
                res_54 = (bool)(true);
                procEnv.Matched(matches_54, null, false);
                procEnv.Finishing(matches_54, false);
                int numchooserandomvar_54 = (int)procEnv.GetVariableValue("x");
                if(matches_54.Count < numchooserandomvar_54) numchooserandomvar_54 = matches_54.Count;
                for(int i = 0; i < numchooserandomvar_54; ++i)
                {
                    if(i != 0) procEnv.RewritingNextMatch();
                    GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass match_54 = matches_54.RemoveMatchExact(GRGEN_LIBGR.Sequence.randomGenerator.Next(matches_54.Count));
                    rule_filterBass.Modify(procEnv, match_54);
                    procEnv.PerformanceInfo.RewritesPerformed++;
                }
                procEnv.Finished(matches_54, false);
            }
            res_55 = (bool)(res_54);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> matches_56 = rule_filterBass.Match(procEnv, procEnv.MaxMatches);
            procEnv.PerformanceInfo.MatchesFound += matches_56.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_filterBass_auto(procEnv, matches_56);
            if(matches_56.Count == 0) {
                res_56 = (bool)(false);
            } else {
                res_56 = (bool)(true);
                procEnv.Matched(matches_56, null, false);
                procEnv.Finishing(matches_56, false);
                IEnumerator<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> enum_56 = matches_56.GetEnumeratorExact();
                while(enum_56.MoveNext())
                {
                    GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass match_56 = enum_56.Current;
                    if(match_56!=matches_56.FirstExact) procEnv.RewritingNextMatch();
                    rule_filterBass.Modify(procEnv, match_56);
                    procEnv.PerformanceInfo.RewritesPerformed++;
                }
                procEnv.Finished(matches_56, false);
            }
            res_57 = (bool)(res_56);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> matches_59 = rule_filterHass.Match(procEnv, 1, (GRGEN_MODEL.IN)procEnv.GetVariableValue("n"));
            procEnv.PerformanceInfo.MatchesFound += matches_59.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f4(procEnv, matches_59, (int)(GRGEN_LIBGR.ContainerHelper.GetGraphElementAttributeOrElementOfMatch(procEnv.GetVariableValue("n"), (string)("i"))), (string)("foo"));
            GRGEN_ACTIONS.MatchFilters.Filter_filterHass_orderAscendingBy_i(procEnv, matches_59);
            matches_59.Filter_keepFirst((System.Int32)(42));
            if(matches_59.Count == 0) {
                res_59 = (bool)(false);
            } else {
                res_59 = (bool)(true);
                procEnv.Matched(matches_59, null, false);
                procEnv.Finishing(matches_59, false);
                GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass match_59 = matches_59.FirstExact;
                GRGEN_MODEL.IE tmpvar_16ee; 
                rule_filterHass.Modify(procEnv, match_59, out tmpvar_16ee);
                procEnv.SetVariableValue("ee", tmpvar_16ee);

                procEnv.PerformanceInfo.RewritesPerformed++;
                procEnv.Finished(matches_59, false);
            }
            res_64 = (bool)(res_59);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> matches_67 = rule_filterBase.Match(procEnv, procEnv.MaxMatches);
            procEnv.PerformanceInfo.MatchesFound += matches_67.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f1(procEnv, matches_67);
            if(matches_67.Count == 0) {
                res_67 = (bool)(false);
            } else {
                res_67 = (bool)(true);
                matches_67 = (GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase>)matches_67.Clone();
                procEnv.Finishing(matches_67, false);
                int matchesTried_67 = 0;
                IEnumerator<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> enum_67 = matches_67.GetEnumeratorExact();
                while(enum_67.MoveNext())
                {
                    GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase match_67 = enum_67.Current;
                    ++matchesTried_67;
                    int transID_67 = procEnv.TransactionManager.Start();
                    int oldRewritesPerformed_67 = procEnv.PerformanceInfo.RewritesPerformed;
                    procEnv.Matched(matches_67, match_67, false);
                    rule_filterBase.Modify(procEnv, match_67);
                    ++procEnv.PerformanceInfo.RewritesPerformed;
                    procEnv.Finished(matches_67, false);
                    GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> matches_66 = rule_filterBase.Match(procEnv, 1);
                    procEnv.PerformanceInfo.MatchesFound += matches_66.Count;
                    GRGEN_ACTIONS.MatchFilters.Filter_f1(procEnv, matches_66);
                    if(matches_66.Count == 0) {
                        res_66 = (bool)(false);
                    } else {
                        res_66 = (bool)(true);
                        procEnv.Matched(matches_66, null, false);
                        procEnv.Finishing(matches_66, false);
                        GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase match_66 = matches_66.FirstExact;
                        rule_filterBase.Modify(procEnv, match_66);
                        procEnv.PerformanceInfo.RewritesPerformed++;
                        procEnv.Finished(matches_66, false);
                    }
                    if(!res_66) {
                        procEnv.TransactionManager.Rollback(transID_67);
                        procEnv.PerformanceInfo.RewritesPerformed = oldRewritesPerformed_67;
                        if(matchesTried_67 < matches_67.Count) {
                            continue;
                        } else {
                            res_67 = (bool)(false);
                            break;
                        }
                    }
                    procEnv.TransactionManager.Commit(transID_67);
                    res_67 = (bool)(true);
                    break;
                }
            }
            res_68 = (bool)(res_67);
            res_71 = (bool)(false);
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> matches_69 = rule_filterBase.Match(procEnv, 1);
            procEnv.PerformanceInfo.MatchesFound += matches_69.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f1(procEnv, matches_69);
            if(matches_69.Count != 0) {
                res_71 = (bool)(true);
            }
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> matches_70 = rule_filterBass.Match(procEnv, procEnv.MaxMatches);
            procEnv.PerformanceInfo.MatchesFound += matches_70.Count;
            GRGEN_ACTIONS.MatchFilters.Filter_f2(procEnv, matches_70);
            if(matches_70.Count != 0) {
                res_71 = (bool)(true);
            }
            int total_match_to_apply_71 = 0;
            total_match_to_apply_71 += matches_69.Count;
            if(matches_70.Count>0) ++total_match_to_apply_71;
            total_match_to_apply_71 = GRGEN_LIBGR.Sequence.randomGenerator.Next(total_match_to_apply_71);
            int cur_total_match_71 = 0;
            bool first_rewrite_71 = true;
            if(matches_69.Count != 0 && cur_total_match_71 <= total_match_to_apply_71) {
                if(cur_total_match_71 == total_match_to_apply_71) {
                    GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase match_69 = matches_69.FirstExact;
                    procEnv.Matched(matches_69, null, false);
                    procEnv.Finishing(matches_69, false);
                    if(!first_rewrite_71) procEnv.RewritingNextMatch();
                    rule_filterBase.Modify(procEnv, match_69);
                    procEnv.PerformanceInfo.RewritesPerformed++;
                    first_rewrite_71 = false;
                }
                ++cur_total_match_71;
            }
            if(matches_70.Count != 0 && cur_total_match_71 <= total_match_to_apply_71) {
                if(cur_total_match_71 == total_match_to_apply_71) {
                    IEnumerator<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> enum_70 = matches_70.GetEnumeratorExact();
                    while(enum_70.MoveNext())
                    {
                        GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass match_70 = enum_70.Current;
                        procEnv.Matched(matches_70, null, false);
                        procEnv.Finishing(matches_70, false);
                        if(!first_rewrite_71) procEnv.RewritingNextMatch();
                        rule_filterBass.Modify(procEnv, match_70);
                        procEnv.PerformanceInfo.RewritesPerformed++;
                        first_rewrite_71 = false;
                        procEnv.Finished(matches_70, false);
                    }
                }
                ++cur_total_match_71;
            }
            res_72 = (bool)(res_71);
            procEnv.DebugExiting("r.exec_1");
            return res_72;
        }

		static Rule_r() {
		}

		public interface IMatch_r : GRGEN_LIBGR.IMatch
		{
			//Nodes
			GRGEN_MODEL.IN node_n { get; set; }
			//Edges
			GRGEN_MODEL.IE edge_e { get; set; }
			//Variables
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_r : GRGEN_LGSP.MatchListElement<Match_r>, IMatch_r
		{
			public GRGEN_MODEL.IN node_n { get { return (GRGEN_MODEL.IN)_node_n; } set { _node_n = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LGSP.LGSPNode _node_n;
			public enum r_NodeNums { @n, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 1;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)r_NodeNums.@n: return _node_n;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				case "n": return _node_n;
				default: return null;
				}
			}

			public GRGEN_MODEL.IE edge_e { get { return (GRGEN_MODEL.IE)_edge_e; } set { _edge_e = (GRGEN_LGSP.LGSPEdge)value; } }
			public GRGEN_LGSP.LGSPEdge _edge_e;
			public enum r_EdgeNums { @e, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 1;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)r_EdgeNums.@e: return _edge_e;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				case "e": return _edge_e;
				default: return null;
				}
			}

			public enum r_VariableNums { END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 0;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum r_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum r_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum r_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum r_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_r.instance.pat_r; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_r(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_r nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_r cur = this;
				while(cur != null) {
					Match_r next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_r that)
			{
				_node_n = that._node_n;
				_edge_e = that._edge_e;
			}

			public Match_r(Match_r that)
			{
				CopyMatchContent(that);
			}
			public Match_r()
			{
			}

			public bool IsEqual(Match_r that)
			{
				if(that==null) return false;
				if(_node_n != that._node_n) return false;
				if(_edge_e != that._edge_e) return false;
				return true;
			}
		}


		public class Extractor
		{
			public static List<GRGEN_MODEL.IN> Extract_n(List<IMatch_r> matchList)
			{
				List<GRGEN_MODEL.IN> resultList = new List<GRGEN_MODEL.IN>(matchList.Count);
				foreach(IMatch_r match in matchList)
					resultList.Add(match.node_n);
				return resultList;
			}
			public static List<GRGEN_MODEL.IE> Extract_e(List<IMatch_r> matchList)
			{
				List<GRGEN_MODEL.IE> resultList = new List<GRGEN_MODEL.IE>(matchList.Count);
				foreach(IMatch_r match in matchList)
					resultList.Add(match.edge_e);
				return resultList;
			}
		}

	}

	public partial class MatchFilters
	{
		public static List<GRGEN_ACTIONS.Rule_r.IMatch_r> Array_r_keepOneForEachBy_n(List<GRGEN_ACTIONS.Rule_r.IMatch_r> list)
		{
			List<GRGEN_ACTIONS.Rule_r.IMatch_r> newList = new List<GRGEN_ACTIONS.Rule_r.IMatch_r>();
			Dictionary<GRGEN_MODEL.IN, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IN, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_r.IMatch_r element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_n)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_n, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_r.IMatch_r> Array_r_keepOneForEachBy_e(List<GRGEN_ACTIONS.Rule_r.IMatch_r> list)
		{
			List<GRGEN_ACTIONS.Rule_r.IMatch_r> newList = new List<GRGEN_ACTIONS.Rule_r.IMatch_r>();
			Dictionary<GRGEN_MODEL.IE, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IE, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_r.IMatch_r element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@edge_e)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@edge_e, null);
				}
			}
			return newList;
		}
	}

	public class Rule_rs : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_rs instance = null;
		public static Rule_rs Instance { get { if(instance==null) { instance = new Rule_rs(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] rs_node_start_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] rs_node_n_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] rs_node_x_AllowedTypes = null;
		public static bool[] rs_node_start_IsAllowedType = null;
		public static bool[] rs_node_n_IsAllowedType = null;
		public static bool[] rs_node_x_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] rs_edge__edge0_AllowedTypes = null;
		public static bool[] rs_edge__edge0_IsAllowedType = null;
		public enum rs_NodeNums { @start, @n, @x, };
		public enum rs_EdgeNums { @_edge0, };
		public enum rs_VariableNums { @v, };
		public enum rs_SubNums { };
		public enum rs_AltNums { };
		public enum rs_IterNums { };





		public GRGEN_LGSP.PatternGraph pat_rs;


		private Rule_rs()
			: base("rs",
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Node.typeVar, },
				new string[] { "rs_node_start", },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
				},
				new GRGEN_LIBGR.MatchClassInfo[] { MatchClassInfo_shared.Instance, }
			)
		{
		}
		private void initialize()
		{
			bool[,] rs_isNodeHomomorphicGlobal = new bool[3, 3] {
				{ false, false, false, },
				{ false, false, false, },
				{ false, false, false, },
			};
			bool[,] rs_isEdgeHomomorphicGlobal = new bool[1, 1] {
				{ false, },
			};
			bool[] rs_isNodeTotallyHomomorphic = new bool[3] { false, false, false,  };
			bool[] rs_isEdgeTotallyHomomorphic = new bool[1] { false,  };
			GRGEN_LGSP.PatternVariable rs_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "rs_var_v", "v", -1, true, null);
			GRGEN_LGSP.PatternNode rs_node_start = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, GRGEN_MODEL.NodeType_Node.typeVar, "GRGEN_LIBGR.INode", "rs_node_start", "start", rs_node_start_AllowedTypes, rs_node_start_IsAllowedType, 5.5F, 0, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternNode rs_node_n = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, GRGEN_MODEL.NodeType_Node.typeVar, "GRGEN_LIBGR.INode", "rs_node_n", "n", rs_node_n_AllowedTypes, rs_node_n_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternNode rs_node_x = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, GRGEN_MODEL.NodeType_Node.typeVar, "GRGEN_LIBGR.INode", "rs_node_x", "x", rs_node_x_AllowedTypes, rs_node_x_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, true,null);
			GRGEN_LGSP.PatternEdge rs_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@Edge, GRGEN_MODEL.EdgeType_Edge.typeVar, "GRGEN_LIBGR.IDEdge", "rs_edge__edge0", "_edge0", rs_edge__edge0_AllowedTypes, rs_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternCondition rs_cond_0 = new GRGEN_LGSP.PatternCondition(
				new GRGEN_EXPR.LOG_NOT(new GRGEN_EXPR.Visited(new GRGEN_EXPR.GraphEntityExpression("rs_node_n"), new GRGEN_EXPR.Constant("0"))),
				new string[] { "rs_node_n" }, new string[] {  }, new string[] {  },
				new GRGEN_LGSP.PatternNode[] { rs_node_n }, new GRGEN_LGSP.PatternEdge[] {  }, new GRGEN_LGSP.PatternVariable[] {  });
			pat_rs = new GRGEN_LGSP.PatternGraph(
				"rs",
				"",
				null, "rs",
				false, false,
				new GRGEN_LGSP.PatternNode[] { rs_node_start, rs_node_n, rs_node_x }, 
				new GRGEN_LGSP.PatternEdge[] { rs_edge__edge0 }, 
				new GRGEN_LGSP.PatternVariable[] { rs_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] { rs_cond_0,  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[3, 3] {
					{ true, false, true, },
					{ false, true, true, },
					{ true, true, true, },
				},
				new bool[1, 1] {
					{ true, },
				},
				rs_isNodeHomomorphicGlobal,
				rs_isEdgeHomomorphicGlobal,
				rs_isNodeTotallyHomomorphic,
				rs_isEdgeTotallyHomomorphic
			);
			pat_rs.edgeToSourceNode.Add(rs_edge__edge0, rs_node_start);
			pat_rs.edgeToTargetNode.Add(rs_edge__edge0, rs_node_n);

			rs_var_v.pointOfDefinition = pat_rs;
			rs_node_start.pointOfDefinition = null;
			rs_node_n.pointOfDefinition = pat_rs;
			rs_node_x.pointOfDefinition = pat_rs;
			rs_edge__edge0.pointOfDefinition = pat_rs;

			patternGraph = pat_rs;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_rs curMatch = (Match_rs)_curMatch;
			GRGEN_LGSP.LGSPNode node_n = curMatch._node_n;
			GRGEN_LGSP.LGSPEdge edge__edge0 = curMatch._edge__edge0;
			graph.SettingAddedNodeNames( rs_addedNodeNames );
			graph.SettingAddedEdgeNames( rs_addedEdgeNames );
			graph.Remove(edge__edge0);
			graph.RemoveEdges(node_n);
			graph.Remove(node_n);
			return;
		}
		private static string[] rs_addedNodeNames = new string[] {  };
		private static string[] rs_addedEdgeNames = new string[] {  };

		static Rule_rs() {
		}

		public interface IMatch_rs : IMatch_shared
		{
			//Nodes
			GRGEN_LIBGR.INode node_start { get; set; }
			GRGEN_LIBGR.INode node_n { get; set; }
			new GRGEN_LIBGR.INode node_x { get; set; }
			//Edges
			GRGEN_LIBGR.IDEdge edge__edge0 { get; set; }
			//Variables
			new int @var_v { get; set; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_rs : GRGEN_LGSP.MatchListElement<Match_rs>, IMatch_rs
		{
			public GRGEN_LIBGR.INode node_start { get { return (GRGEN_LIBGR.INode)_node_start; } set { _node_start = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LIBGR.INode node_n { get { return (GRGEN_LIBGR.INode)_node_n; } set { _node_n = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LIBGR.INode node_x { get { return (GRGEN_LIBGR.INode)_node_x; } set { _node_x = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LGSP.LGSPNode _node_start;
			public GRGEN_LGSP.LGSPNode _node_n;
			public GRGEN_LGSP.LGSPNode _node_x;
			public enum rs_NodeNums { @start, @n, @x, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 3;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)rs_NodeNums.@start: return _node_start;
				case (int)rs_NodeNums.@n: return _node_n;
				case (int)rs_NodeNums.@x: return _node_x;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				case "start": return _node_start;
				case "n": return _node_n;
				case "x": return _node_x;
				default: return null;
				}
			}

			public GRGEN_LIBGR.IDEdge edge__edge0 { get { return (GRGEN_LIBGR.IDEdge)_edge__edge0; } set { _edge__edge0 = (GRGEN_LGSP.LGSPEdge)value; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public enum rs_EdgeNums { @_edge0, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 1;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)rs_EdgeNums.@_edge0: return _edge__edge0;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				case "_edge0": return _edge__edge0;
				default: return null;
				}
			}

			public int var_v { get { return _var_v; } set { _var_v = value; } }
			public int _var_v;
			public enum rs_VariableNums { @v, END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 1;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				case (int)rs_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				case "v": return _var_v;
				default: return null;
				}
			}

			public enum rs_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum rs_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum rs_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum rs_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_rs.instance.pat_rs; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_rs(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_rs nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_rs cur = this;
				while(cur != null) {
					Match_rs next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_rs that)
			{
				_node_start = that._node_start;
				_node_n = that._node_n;
				_node_x = that._node_x;
				_edge__edge0 = that._edge__edge0;
				_var_v = that._var_v;
			}

			public Match_rs(Match_rs that)
			{
				CopyMatchContent(that);
			}
			public Match_rs()
			{
			}

			public bool IsEqual(Match_rs that)
			{
				if(that==null) return false;
				if(_node_start != that._node_start) return false;
				if(_node_n != that._node_n) return false;
				if(_edge__edge0 != that._edge__edge0) return false;
				return true;
			}
		}


		public class Extractor
		{
			public static List<GRGEN_LIBGR.INode> Extract_start(List<IMatch_rs> matchList)
			{
				List<GRGEN_LIBGR.INode> resultList = new List<GRGEN_LIBGR.INode>(matchList.Count);
				foreach(IMatch_rs match in matchList)
					resultList.Add(match.node_start);
				return resultList;
			}
			public static List<GRGEN_LIBGR.INode> Extract_n(List<IMatch_rs> matchList)
			{
				List<GRGEN_LIBGR.INode> resultList = new List<GRGEN_LIBGR.INode>(matchList.Count);
				foreach(IMatch_rs match in matchList)
					resultList.Add(match.node_n);
				return resultList;
			}
			public static List<GRGEN_LIBGR.INode> Extract_x(List<IMatch_rs> matchList)
			{
				List<GRGEN_LIBGR.INode> resultList = new List<GRGEN_LIBGR.INode>(matchList.Count);
				foreach(IMatch_rs match in matchList)
					resultList.Add(match.node_x);
				return resultList;
			}
			public static List<GRGEN_LIBGR.IDEdge> Extract__edge0(List<IMatch_rs> matchList)
			{
				List<GRGEN_LIBGR.IDEdge> resultList = new List<GRGEN_LIBGR.IDEdge>(matchList.Count);
				foreach(IMatch_rs match in matchList)
					resultList.Add(match.edge__edge0);
				return resultList;
			}
			public static List<int> Extract_v(List<IMatch_rs> matchList)
			{
				List<int> resultList = new List<int>(matchList.Count);
				foreach(IMatch_rs match in matchList)
					resultList.Add(match.var_v);
				return resultList;
			}
		}

	}

	public partial class MatchFilters
	{
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_orderAscendingBy_v(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>(list);
			newList.Sort(new Comparer_rs_orderAscendingBy_v());
			return newList;
		}
		class Comparer_rs_orderAscendingBy_v : Comparer<GRGEN_ACTIONS.Rule_rs.IMatch_rs>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_rs.IMatch_rs a, GRGEN_ACTIONS.Rule_rs.IMatch_rs b)
			{
				return a.@var_v.CompareTo(b.@var_v);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_orderDescendingBy_v(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>(list);
			newList.Sort(new Comparer_rs_orderDescendingBy_v());
			return newList;
		}
		class Comparer_rs_orderDescendingBy_v : Comparer<GRGEN_ACTIONS.Rule_rs.IMatch_rs>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_rs.IMatch_rs b, GRGEN_ACTIONS.Rule_rs.IMatch_rs a)
			{
				return a.@var_v.CompareTo(b.@var_v);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_keepOneForEachBy_v(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>();
			Dictionary<int, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<int, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_rs.IMatch_rs element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@var_v)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@var_v, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_keepOneForEachBy_start(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>();
			Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_rs.IMatch_rs element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_start)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_start, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_keepOneForEachBy_n(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>();
			Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_rs.IMatch_rs element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_n)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_n, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_keepOneForEachBy_x(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>();
			Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_rs.IMatch_rs element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_x)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_x, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> Array_rs_keepOneForEachBy__edge0(List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> list)
		{
			List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> newList = new List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>();
			Dictionary<GRGEN_LIBGR.IDEdge, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.IDEdge, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_rs.IMatch_rs element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@edge__edge0)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@edge__edge0, null);
				}
			}
			return newList;
		}
	}

	public class Rule_ss : GRGEN_LGSP.LGSPRulePattern
	{
		private static Rule_ss instance = null;
		public static Rule_ss Instance { get { if(instance==null) { instance = new Rule_ss(); instance.initialize(); } return instance; } }

		public static GRGEN_LIBGR.NodeType[] ss_node_root_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] ss_node_m1_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] ss_node_m2_AllowedTypes = null;
		public static GRGEN_LIBGR.NodeType[] ss_node_x_AllowedTypes = null;
		public static bool[] ss_node_root_IsAllowedType = null;
		public static bool[] ss_node_m1_IsAllowedType = null;
		public static bool[] ss_node_m2_IsAllowedType = null;
		public static bool[] ss_node_x_IsAllowedType = null;
		public static GRGEN_LIBGR.EdgeType[] ss_edge__edge0_AllowedTypes = null;
		public static GRGEN_LIBGR.EdgeType[] ss_edge__edge1_AllowedTypes = null;
		public static bool[] ss_edge__edge0_IsAllowedType = null;
		public static bool[] ss_edge__edge1_IsAllowedType = null;
		public enum ss_NodeNums { @root, @m1, @m2, @x, };
		public enum ss_EdgeNums { @_edge0, @_edge1, };
		public enum ss_VariableNums { @v, };
		public enum ss_SubNums { };
		public enum ss_AltNums { };
		public enum ss_IterNums { };





		public GRGEN_LGSP.PatternGraph pat_ss;


		private Rule_ss()
			: base("ss",
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { },
				new string[] { },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_M.typeVar, GRGEN_MODEL.NodeType_M.typeVar, },
				new GRGEN_LGSP.LGSPFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
				},
				new GRGEN_LIBGR.MatchClassInfo[] { MatchClassInfo_shared.Instance, }
			)
		{
		}
		private void initialize()
		{
			bool[,] ss_isNodeHomomorphicGlobal = new bool[4, 4] {
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
				{ false, false, false, false, },
			};
			bool[,] ss_isEdgeHomomorphicGlobal = new bool[2, 2] {
				{ false, false, },
				{ false, false, },
			};
			bool[] ss_isNodeTotallyHomomorphic = new bool[4] { false, false, false, false,  };
			bool[] ss_isEdgeTotallyHomomorphic = new bool[2] { false, false,  };
			GRGEN_LGSP.PatternVariable ss_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "ss_var_v", "v", -1, true, null);
			GRGEN_LGSP.PatternNode ss_node_root = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, GRGEN_MODEL.NodeType_Node.typeVar, "GRGEN_LIBGR.INode", "ss_node_root", "root", ss_node_root_AllowedTypes, ss_node_root_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternNode ss_node_m1 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@M, GRGEN_MODEL.NodeType_M.typeVar, "GRGEN_MODEL.IM", "ss_node_m1", "m1", ss_node_m1_AllowedTypes, ss_node_m1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternNode ss_node_m2 = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@M, GRGEN_MODEL.NodeType_M.typeVar, "GRGEN_MODEL.IM", "ss_node_m2", "m2", ss_node_m2_AllowedTypes, ss_node_m2_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternNode ss_node_x = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, GRGEN_MODEL.NodeType_Node.typeVar, "GRGEN_LIBGR.INode", "ss_node_x", "x", ss_node_x_AllowedTypes, ss_node_x_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, true,null);
			GRGEN_LGSP.PatternEdge ss_edge__edge0 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@Edge, GRGEN_MODEL.EdgeType_Edge.typeVar, "GRGEN_LIBGR.IDEdge", "ss_edge__edge0", "_edge0", ss_edge__edge0_AllowedTypes, ss_edge__edge0_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			GRGEN_LGSP.PatternEdge ss_edge__edge1 = new GRGEN_LGSP.PatternEdge(true, (int) GRGEN_MODEL.EdgeTypes.@Edge, GRGEN_MODEL.EdgeType_Edge.typeVar, "GRGEN_LIBGR.IDEdge", "ss_edge__edge1", "_edge1", ss_edge__edge1_AllowedTypes, ss_edge__edge1_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, false,null);
			pat_ss = new GRGEN_LGSP.PatternGraph(
				"ss",
				"",
				null, "ss",
				false, false,
				new GRGEN_LGSP.PatternNode[] { ss_node_root, ss_node_m1, ss_node_m2, ss_node_x }, 
				new GRGEN_LGSP.PatternEdge[] { ss_edge__edge0, ss_edge__edge1 }, 
				new GRGEN_LGSP.PatternVariable[] { ss_var_v }, 
				new GRGEN_LGSP.PatternGraphEmbedding[] {  }, 
				new GRGEN_LGSP.Alternative[] {  }, 
				new GRGEN_LGSP.Iterated[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternGraph[] {  }, 
				new GRGEN_LGSP.PatternCondition[] {  }, 
				new GRGEN_LGSP.PatternYielding[] {  }, 
				new bool[4, 4] {
					{ true, false, false, true, },
					{ false, true, false, true, },
					{ false, false, true, true, },
					{ true, true, true, true, },
				},
				new bool[2, 2] {
					{ true, false, },
					{ false, true, },
				},
				ss_isNodeHomomorphicGlobal,
				ss_isEdgeHomomorphicGlobal,
				ss_isNodeTotallyHomomorphic,
				ss_isEdgeTotallyHomomorphic
			);
			pat_ss.edgeToSourceNode.Add(ss_edge__edge0, ss_node_root);
			pat_ss.edgeToTargetNode.Add(ss_edge__edge0, ss_node_m1);
			pat_ss.edgeToSourceNode.Add(ss_edge__edge1, ss_node_root);
			pat_ss.edgeToTargetNode.Add(ss_edge__edge1, ss_node_m2);

			ss_var_v.pointOfDefinition = pat_ss;
			ss_node_root.pointOfDefinition = pat_ss;
			ss_node_m1.pointOfDefinition = pat_ss;
			ss_node_m2.pointOfDefinition = pat_ss;
			ss_node_x.pointOfDefinition = pat_ss;
			ss_edge__edge0.pointOfDefinition = pat_ss;
			ss_edge__edge1.pointOfDefinition = pat_ss;

			patternGraph = pat_ss;
		}


		public void Modify(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch _curMatch, out GRGEN_MODEL.IM output_0, out GRGEN_MODEL.IM output_1)
		{
			GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
			Match_ss curMatch = (Match_ss)_curMatch;
			GRGEN_LGSP.LGSPNode node_m1 = curMatch._node_m1;
			GRGEN_LGSP.LGSPNode node_m2 = curMatch._node_m2;
			GRGEN_LGSP.LGSPNode node_root = curMatch._node_root;
			graph.SettingAddedNodeNames( ss_addedNodeNames );
			GRGEN_LGSP.LGSPNode node__node0 = graph.Retype(node_root, GRGEN_MODEL.NodeType_N.typeVar);
			graph.SettingAddedEdgeNames( ss_addedEdgeNames );
			output_0 = (GRGEN_MODEL.IM)(node_m1);
			output_1 = (GRGEN_MODEL.IM)(node_m2);
			return;
		}
		private static string[] ss_addedNodeNames = new string[] {  };
		private static string[] ss_addedEdgeNames = new string[] {  };

		static Rule_ss() {
		}

		public interface IMatch_ss : IMatch_shared
		{
			//Nodes
			GRGEN_LIBGR.INode node_root { get; set; }
			GRGEN_MODEL.IM node_m1 { get; set; }
			GRGEN_MODEL.IM node_m2 { get; set; }
			new GRGEN_LIBGR.INode node_x { get; set; }
			//Edges
			GRGEN_LIBGR.IDEdge edge__edge0 { get; set; }
			GRGEN_LIBGR.IDEdge edge__edge1 { get; set; }
			//Variables
			new int @var_v { get; set; }
			//EmbeddedGraphs
			//Alternatives
			//Iterateds
			//Independents
			// further match object stuff
			void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern);
		}

		public class Match_ss : GRGEN_LGSP.MatchListElement<Match_ss>, IMatch_ss
		{
			public GRGEN_LIBGR.INode node_root { get { return (GRGEN_LIBGR.INode)_node_root; } set { _node_root = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_MODEL.IM node_m1 { get { return (GRGEN_MODEL.IM)_node_m1; } set { _node_m1 = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_MODEL.IM node_m2 { get { return (GRGEN_MODEL.IM)_node_m2; } set { _node_m2 = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LIBGR.INode node_x { get { return (GRGEN_LIBGR.INode)_node_x; } set { _node_x = (GRGEN_LGSP.LGSPNode)value; } }
			public GRGEN_LGSP.LGSPNode _node_root;
			public GRGEN_LGSP.LGSPNode _node_m1;
			public GRGEN_LGSP.LGSPNode _node_m2;
			public GRGEN_LGSP.LGSPNode _node_x;
			public enum ss_NodeNums { @root, @m1, @m2, @x, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.INode> Nodes { get { return new GRGEN_LGSP.Nodes_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.INode> NodesEnumerator { get { return new GRGEN_LGSP.Nodes_Enumerator(this); } }
			public override int NumberOfNodes { get { return 4;} }
			public override GRGEN_LIBGR.INode getNodeAt(int index)
			{
				switch(index) {
				case (int)ss_NodeNums.@root: return _node_root;
				case (int)ss_NodeNums.@m1: return _node_m1;
				case (int)ss_NodeNums.@m2: return _node_m2;
				case (int)ss_NodeNums.@x: return _node_x;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.INode getNode(string name)
			{
				switch(name) {
				case "root": return _node_root;
				case "m1": return _node_m1;
				case "m2": return _node_m2;
				case "x": return _node_x;
				default: return null;
				}
			}

			public GRGEN_LIBGR.IDEdge edge__edge0 { get { return (GRGEN_LIBGR.IDEdge)_edge__edge0; } set { _edge__edge0 = (GRGEN_LGSP.LGSPEdge)value; } }
			public GRGEN_LIBGR.IDEdge edge__edge1 { get { return (GRGEN_LIBGR.IDEdge)_edge__edge1; } set { _edge__edge1 = (GRGEN_LGSP.LGSPEdge)value; } }
			public GRGEN_LGSP.LGSPEdge _edge__edge0;
			public GRGEN_LGSP.LGSPEdge _edge__edge1;
			public enum ss_EdgeNums { @_edge0, @_edge1, END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IEdge> Edges { get { return new GRGEN_LGSP.Edges_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IEdge> EdgesEnumerator { get { return new GRGEN_LGSP.Edges_Enumerator(this); } }
			public override int NumberOfEdges { get { return 2;} }
			public override GRGEN_LIBGR.IEdge getEdgeAt(int index)
			{
				switch(index) {
				case (int)ss_EdgeNums.@_edge0: return _edge__edge0;
				case (int)ss_EdgeNums.@_edge1: return _edge__edge1;
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IEdge getEdge(string name)
			{
				switch(name) {
				case "_edge0": return _edge__edge0;
				case "_edge1": return _edge__edge1;
				default: return null;
				}
			}

			public int var_v { get { return _var_v; } set { _var_v = value; } }
			public int _var_v;
			public enum ss_VariableNums { @v, END_OF_ENUM };
			public override IEnumerable<object> Variables { get { return new GRGEN_LGSP.Variables_Enumerable(this); } }
			public override IEnumerator<object> VariablesEnumerator { get { return new GRGEN_LGSP.Variables_Enumerator(this); } }
			public override int NumberOfVariables { get { return 1;} }
			public override object getVariableAt(int index)
			{
				switch(index) {
				case (int)ss_VariableNums.@v: return _var_v;
				default: return null;
				}
			}
			public override object getVariable(string name)
			{
				switch(name) {
				case "v": return _var_v;
				default: return null;
				}
			}

			public enum ss_SubNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> EmbeddedGraphs { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> EmbeddedGraphsEnumerator { get { return new GRGEN_LGSP.EmbeddedGraphs_Enumerator(this); } }
			public override int NumberOfEmbeddedGraphs { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getEmbeddedGraphAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getEmbeddedGraph(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum ss_AltNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Alternatives { get { return new GRGEN_LGSP.Alternatives_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> AlternativesEnumerator { get { return new GRGEN_LGSP.Alternatives_Enumerator(this); } }
			public override int NumberOfAlternatives { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getAlternativeAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getAlternative(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum ss_IterNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatches> Iterateds { get { return new GRGEN_LGSP.Iterateds_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatches> IteratedsEnumerator { get { return new GRGEN_LGSP.Iterateds_Enumerator(this); } }
			public override int NumberOfIterateds { get { return 0;} }
			public override GRGEN_LIBGR.IMatches getIteratedAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatches getIterated(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public enum ss_IdptNums { END_OF_ENUM };
			public override IEnumerable<GRGEN_LIBGR.IMatch> Independents { get { return new GRGEN_LGSP.Independents_Enumerable(this); } }
			public override IEnumerator<GRGEN_LIBGR.IMatch> IndependentsEnumerator { get { return new GRGEN_LGSP.Independents_Enumerator(this); } }
			public override int NumberOfIndependents { get { return 0;} }
			public override GRGEN_LIBGR.IMatch getIndependentAt(int index)
			{
				switch(index) {
				default: return null;
				}
			}
			public override GRGEN_LIBGR.IMatch getIndependent(string name)
			{
				switch(name) {
				default: return null;
				}
			}

			public override GRGEN_LIBGR.IPatternGraph Pattern { get { return Rule_ss.instance.pat_ss; } }
			public override GRGEN_LIBGR.IMatch Clone() { return new Match_ss(this); }
			public void SetMatchOfEnclosingPattern(GRGEN_LIBGR.IMatch matchOfEnclosingPattern) { _matchOfEnclosingPattern = matchOfEnclosingPattern; }
			public Match_ss nextWithSameHash;
			public void CleanNextWithSameHash() {
				Match_ss cur = this;
				while(cur != null) {
					Match_ss next = cur.nextWithSameHash;
					cur.nextWithSameHash = null;
					cur = next;
				}
			}

			public void CopyMatchContent(Match_ss that)
			{
				_node_root = that._node_root;
				_node_m1 = that._node_m1;
				_node_m2 = that._node_m2;
				_node_x = that._node_x;
				_edge__edge0 = that._edge__edge0;
				_edge__edge1 = that._edge__edge1;
				_var_v = that._var_v;
			}

			public Match_ss(Match_ss that)
			{
				CopyMatchContent(that);
			}
			public Match_ss()
			{
			}

			public bool IsEqual(Match_ss that)
			{
				if(that==null) return false;
				if(_node_root != that._node_root) return false;
				if(_node_m1 != that._node_m1) return false;
				if(_node_m2 != that._node_m2) return false;
				if(_edge__edge0 != that._edge__edge0) return false;
				if(_edge__edge1 != that._edge__edge1) return false;
				return true;
			}
		}


		public class Extractor
		{
			public static List<GRGEN_LIBGR.INode> Extract_root(List<IMatch_ss> matchList)
			{
				List<GRGEN_LIBGR.INode> resultList = new List<GRGEN_LIBGR.INode>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.node_root);
				return resultList;
			}
			public static List<GRGEN_MODEL.IM> Extract_m1(List<IMatch_ss> matchList)
			{
				List<GRGEN_MODEL.IM> resultList = new List<GRGEN_MODEL.IM>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.node_m1);
				return resultList;
			}
			public static List<GRGEN_MODEL.IM> Extract_m2(List<IMatch_ss> matchList)
			{
				List<GRGEN_MODEL.IM> resultList = new List<GRGEN_MODEL.IM>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.node_m2);
				return resultList;
			}
			public static List<GRGEN_LIBGR.INode> Extract_x(List<IMatch_ss> matchList)
			{
				List<GRGEN_LIBGR.INode> resultList = new List<GRGEN_LIBGR.INode>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.node_x);
				return resultList;
			}
			public static List<GRGEN_LIBGR.IDEdge> Extract__edge0(List<IMatch_ss> matchList)
			{
				List<GRGEN_LIBGR.IDEdge> resultList = new List<GRGEN_LIBGR.IDEdge>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.edge__edge0);
				return resultList;
			}
			public static List<GRGEN_LIBGR.IDEdge> Extract__edge1(List<IMatch_ss> matchList)
			{
				List<GRGEN_LIBGR.IDEdge> resultList = new List<GRGEN_LIBGR.IDEdge>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.edge__edge1);
				return resultList;
			}
			public static List<int> Extract_v(List<IMatch_ss> matchList)
			{
				List<int> resultList = new List<int>(matchList.Count);
				foreach(IMatch_ss match in matchList)
					resultList.Add(match.var_v);
				return resultList;
			}
		}

	}

	public partial class MatchFilters
	{
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_orderAscendingBy_v(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>(list);
			newList.Sort(new Comparer_ss_orderAscendingBy_v());
			return newList;
		}
		class Comparer_ss_orderAscendingBy_v : Comparer<GRGEN_ACTIONS.Rule_ss.IMatch_ss>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_ss.IMatch_ss a, GRGEN_ACTIONS.Rule_ss.IMatch_ss b)
			{
				return a.@var_v.CompareTo(b.@var_v);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_orderDescendingBy_v(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>(list);
			newList.Sort(new Comparer_ss_orderDescendingBy_v());
			return newList;
		}
		class Comparer_ss_orderDescendingBy_v : Comparer<GRGEN_ACTIONS.Rule_ss.IMatch_ss>
		{
			public override int Compare(GRGEN_ACTIONS.Rule_ss.IMatch_ss b, GRGEN_ACTIONS.Rule_ss.IMatch_ss a)
			{
				return a.@var_v.CompareTo(b.@var_v);
			}
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy_v(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<int, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<int, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@var_v)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@var_v, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy_root(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_root)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_root, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy_m1(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<GRGEN_MODEL.IM, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IM, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_m1)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_m1, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy_m2(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<GRGEN_MODEL.IM, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_MODEL.IM, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_m2)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_m2, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy_x(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@node_x)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@node_x, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy__edge0(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<GRGEN_LIBGR.IDEdge, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.IDEdge, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@edge__edge0)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@edge__edge0, null);
				}
			}
			return newList;
		}
		public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> Array_ss_keepOneForEachBy__edge1(List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> list)
		{
			List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> newList = new List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>();
			Dictionary<GRGEN_LIBGR.IDEdge, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.IDEdge, GRGEN_LIBGR.SetValueType>();
			foreach(GRGEN_ACTIONS.Rule_ss.IMatch_ss element in list)
			{
				if(!alreadySeenMembers.ContainsKey(element.@edge__edge1)) {
					newList.Add(element);
					alreadySeenMembers.Add(element.@edge__edge1, null);
				}
			}
			return newList;
		}
	}

	public class SequenceInfo_foo : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_foo instance = null;
		public static SequenceInfo_foo Instance { get { if(instance==null) { instance = new SequenceInfo_foo(); } return instance; } }

		private SequenceInfo_foo()
			: base(
				new String[] { "v1", "v2", "v3", "v4", "v5",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), GRGEN_LIBGR.VarType.GetVarType(typeof(double)), GRGEN_LIBGR.VarType.GetVarType(typeof(GRGEN_MODEL.ENUM_Enu)), GRGEN_LIBGR.VarType.GetVarType(typeof(string)), GRGEN_LIBGR.VarType.GetVarType(typeof(bool)),  },
				new String[] { "r1", "r2", "r3", "r4", "r5",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), GRGEN_LIBGR.VarType.GetVarType(typeof(double)), GRGEN_LIBGR.VarType.GetVarType(typeof(GRGEN_MODEL.ENUM_Enu)), GRGEN_LIBGR.VarType.GetVarType(typeof(string)), GRGEN_LIBGR.VarType.GetVarType(typeof(bool)),  },
				"foo",
				5
			)
		{
		}
	}

	public class SequenceInfo_bar : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_bar instance = null;
		public static SequenceInfo_bar Instance { get { if(instance==null) { instance = new SequenceInfo_bar(); } return instance; } }

		private SequenceInfo_bar()
			: base(
				new String[] { "v1", "v2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(object)), GRGEN_LIBGR.VarType.GetVarType(typeof(object)),  },
				new String[] { "r1",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(object)),  },
				"bar",
				6
			)
		{
		}
	}

	public class SequenceInfo_isnull : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_isnull instance = null;
		public static SequenceInfo_isnull Instance { get { if(instance==null) { instance = new SequenceInfo_isnull(); } return instance; } }

		private SequenceInfo_isnull()
			: base(
				new String[] { "v1",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(object)),  },
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				"isnull",
				7
			)
		{
		}
	}

	public class SequenceInfo_bla : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_bla instance = null;
		public static SequenceInfo_bla Instance { get { if(instance==null) { instance = new SequenceInfo_bla(); } return instance; } }

		private SequenceInfo_bla()
			: base(
				new String[] { "v1", "v2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_N.typeVar, GRGEN_MODEL.EdgeType_E.typeVar,  },
				new String[] { "r1", "r2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_N.typeVar, GRGEN_MODEL.EdgeType_E.typeVar,  },
				"bla",
				8
			)
		{
		}
	}

	public class SequenceInfo_blo : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_blo instance = null;
		public static SequenceInfo_blo Instance { get { if(instance==null) { instance = new SequenceInfo_blo(); } return instance; } }

		private SequenceInfo_blo()
			: base(
				new String[] { "v1", "v2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Node.typeVar, GRGEN_MODEL.EdgeType_Edge.typeVar,  },
				new String[] { "r1", "r2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Node.typeVar, GRGEN_MODEL.EdgeType_AEdge.typeVar,  },
				"blo",
				9
			)
		{
		}
	}

	public class SequenceInfo_createEdge : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_createEdge instance = null;
		public static SequenceInfo_createEdge Instance { get { if(instance==null) { instance = new SequenceInfo_createEdge(); } return instance; } }

		private SequenceInfo_createEdge()
			: base(
				new String[] { "n1", "n2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.NodeType_Node.typeVar, GRGEN_MODEL.NodeType_Node.typeVar,  },
				new String[] { "e",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_MODEL.EdgeType_AEdge.typeVar,  },
				"createEdge",
				10
			)
		{
		}
	}

	public class SequenceInfo_huh : GRGEN_LIBGR.ExternalDefinedSequenceInfo
	{
		private static SequenceInfo_huh instance = null;
		public static SequenceInfo_huh Instance { get { if(instance==null) { instance = new SequenceInfo_huh(); } return instance; } }

		private SequenceInfo_huh()
			: base(
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				"huh",
				11
			)
		{
		}
	}

	public class SequenceInfo_counterExample1 : GRGEN_LIBGR.DefinedSequenceInfo
	{
		private static SequenceInfo_counterExample1 instance = null;
		public static SequenceInfo_counterExample1 Instance { get { if(instance==null) { instance = new SequenceInfo_counterExample1(); } return instance; } }

		private SequenceInfo_counterExample1()
			: base(
				new String[] { "v1", "v2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), GRGEN_MODEL.NodeType_Node.typeVar,  },
				new String[] { "r1", "r2",  },
				new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int)), GRGEN_MODEL.NodeType_Node.typeVar,  },
				"counterExample1",
				null, "counterExample1",
				"{r1=v1;r2=v2}",
				13
			)
		{
		}
	}

	public class SequenceInfo_counterExample2 : GRGEN_LIBGR.DefinedSequenceInfo
	{
		private static SequenceInfo_counterExample2 instance = null;
		public static SequenceInfo_counterExample2 Instance { get { if(instance==null) { instance = new SequenceInfo_counterExample2(); } return instance; } }

		private SequenceInfo_counterExample2()
			: base(
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				"counterExample2",
				null, "counterExample2",
				"true",
				14
			)
		{
		}
	}

	public class SequenceInfo_seq : GRGEN_LIBGR.DefinedSequenceInfo
	{
		private static SequenceInfo_seq instance = null;
		public static SequenceInfo_seq Instance { get { if(instance==null) { instance = new SequenceInfo_seq(); } return instance; } }

		private SequenceInfo_seq()
			: base(
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				new String[] {  },
				new GRGEN_LIBGR.GrGenType[] {  },
				"seq",
				null, "seq",
				"[[rs(::n),(m1:array<M>,::m2)=ss()]\\shared.shf(42)\\shared.extshf(42)\\shared.orderAscendingBy<v> \\shared.keepFirst(3)]",
				123
			)
		{
		}
	}

	public class Functions
	{

		static Functions() {
		}

	}

	public class Procedures
	{

		static Procedures() {
		}

	}

	public partial class MatchFilters
	{
		public static void Filter_fil(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> matches, int var_f)
		{
			GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv = procEnv;
			GRGEN_LGSP.LGSPGraph graph = (GRGEN_LGSP.LGSPGraph)procEnv.Graph;
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> this_matches = matches.ToListExact();
			List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> entry_1 = (List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>) this_matches;
			for(int index_0=0; index_0<entry_1.Count; ++index_0)
			{
				GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass var_m = entry_1[index_0];
				string tempvar_2 = (string )(GRGEN_LIBGR.GraphHelper.Nameof(var_m.node_n, graph) + GRGEN_LIBGR.EmitHelper.ToStringNonNull(var_f, graph));
				var_m.var_s = tempvar_2;
			}
			matches.FromListExact();
			return;
		}


		static MatchFilters() {
		}

	}

	public partial class MatchClassFilters
	{
		public static void Filter_shf(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, IList<GRGEN_LIBGR.IMatch> matches, int var_f)
		{
			GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv = procEnv;
			GRGEN_LGSP.LGSPGraph graph = (GRGEN_LGSP.LGSPGraph)procEnv.Graph;
			List<GRGEN_ACTIONS.IMatch_shared> this_matches = GRGEN_LIBGR.MatchListHelper.ToList<IMatch_shared>(matches);
			List<GRGEN_ACTIONS.IMatch_shared> entry_1 = (List<GRGEN_ACTIONS.IMatch_shared>) this_matches;
			for(int index_0=0; index_0<entry_1.Count; ++index_0)
			{
				GRGEN_ACTIONS.IMatch_shared var_m = entry_1[index_0];
				int tempvar_2 = (int )(var_m.var_v * var_f);
				var_m.var_v = tempvar_2;
			}
			GRGEN_LIBGR.MatchListHelper.FromList(matches, this_matches);
			return;
}


		static MatchClassFilters() {
		}

	}

	public interface IMatch_shared : GRGEN_LIBGR.IMatch
	{
		//Nodes
		GRGEN_LIBGR.INode node_x { get; set; }
		//Edges
		//Variables
		int @var_v { get; set; }
		//EmbeddedGraphs
		//Alternatives
		//Iterateds
		//Independents
		// further match object stuff
	}


	public class MatchClassInfo_shared : GRGEN_LIBGR.MatchClassInfo
	{
		private static MatchClassInfo_shared instance = null;
		public static MatchClassInfo_shared Instance { get { if(instance==null) { instance = new MatchClassInfo_shared(); } return instance; } }

		private MatchClassInfo_shared()
			: base(
				"shared",
				null, "shared",
				new GRGEN_LIBGR.IPatternNode[] { shared_node_x },
				new GRGEN_LIBGR.IPatternEdge[] {  },
				new GRGEN_LIBGR.IPatternVariable[] { shared_var_v },
				new GRGEN_LIBGR.IFilter[] {
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirst", null, "keepFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLast", null, "keepLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepFirstFraction", null, "keepFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("keepLastFraction", null, "keepLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirst", null, "removeFirst", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLast", null, "removeLast", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeFirstFraction", null, "removeFirstFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoSupplied("removeLastFraction", null, "removeLastFraction", null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(double)), }, new String[] {"param"}),
					new GRGEN_LGSP.LGSPFilterAutoGenerated("orderAscendingBy<v>", null, "orderAscendingBy<v>", null, "orderAscendingBy", new String[] { "v"}, new GRGEN_LIBGR.GrGenType[] { GRGEN_LIBGR.VarType.GetVarType(typeof(int))}),
					new GRGEN_LGSP.LGSPFilterFunction("shf", null, "shf", false, null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"f", }),
					new GRGEN_LGSP.LGSPFilterFunction("extshf", null, "extshf", true, null, new GRGEN_LIBGR.GrGenType[] {GRGEN_LIBGR.VarType.GetVarType(typeof(int)), }, new String[] {"f", }),
				}
			)
		{
			shared_var_v.pointOfDefinition = null;
			shared_node_x.pointOfDefinition = null;
		}

static GRGEN_LGSP.PatternVariable shared_var_v = new GRGEN_LGSP.PatternVariable(GRGEN_LIBGR.VarType.GetVarType(typeof(int)), "shared_var_v", "v", -1, true, null);
static GRGEN_LGSP.PatternNode shared_node_x = new GRGEN_LGSP.PatternNode((int) GRGEN_MODEL.NodeTypes.@Node, GRGEN_MODEL.NodeType_Node.typeVar, "GRGEN_LIBGR.INode", "shared_node_x", "x", shared_node_x_AllowedTypes, shared_node_x_IsAllowedType, 5.5F, -1, false, null, null, null, null, null, null, true,null);
public static GRGEN_LIBGR.NodeType[] shared_node_x_AllowedTypes = null;
		public static bool[] shared_node_x_IsAllowedType = null;

		public class Extractor
		{
		public static List<GRGEN_LIBGR.INode> Extract_x(List<IMatch_shared> matchList)
		{
			List<GRGEN_LIBGR.INode> resultList = new List<GRGEN_LIBGR.INode>(matchList.Count);
			foreach(IMatch_shared match in matchList)
				resultList.Add(match.node_x);
			return resultList;
		}
		public static List<int> Extract_v(List<IMatch_shared> matchList)
		{
			List<int> resultList = new List<int>(matchList.Count);
			foreach(IMatch_shared match in matchList)
				resultList.Add(match.var_v);
			return resultList;
		}
	}

}


public partial class MatchClassFilters
{
	public static List<GRGEN_ACTIONS.IMatch_shared> Array_shared_orderAscendingBy_v(List<GRGEN_ACTIONS.IMatch_shared> list)
	{
		List<GRGEN_ACTIONS.IMatch_shared> newList = new List<GRGEN_ACTIONS.IMatch_shared>(list);
		newList.Sort(new Comparer_shared_orderAscendingBy_v());
		return newList;
	}
	class Comparer_shared_orderAscendingBy_v : Comparer<GRGEN_ACTIONS.IMatch_shared>
	{
		public override int Compare(GRGEN_ACTIONS.IMatch_shared a, GRGEN_ACTIONS.IMatch_shared b)
		{
			return a.@var_v.CompareTo(b.@var_v);
		}
	}
	public static List<GRGEN_ACTIONS.IMatch_shared> Array_shared_orderDescendingBy_v(List<GRGEN_ACTIONS.IMatch_shared> list)
	{
		List<GRGEN_ACTIONS.IMatch_shared> newList = new List<GRGEN_ACTIONS.IMatch_shared>(list);
		newList.Sort(new Comparer_shared_orderDescendingBy_v());
		return newList;
	}
	class Comparer_shared_orderDescendingBy_v : Comparer<GRGEN_ACTIONS.IMatch_shared>
	{
		public override int Compare(GRGEN_ACTIONS.IMatch_shared b, GRGEN_ACTIONS.IMatch_shared a)
		{
			return a.@var_v.CompareTo(b.@var_v);
		}
	}
	public static List<GRGEN_ACTIONS.IMatch_shared> Array_shared_keepOneForEachBy_v(List<GRGEN_ACTIONS.IMatch_shared> list)
	{
		List<GRGEN_ACTIONS.IMatch_shared> newList = new List<GRGEN_ACTIONS.IMatch_shared>();
		Dictionary<int, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<int, GRGEN_LIBGR.SetValueType>();
		foreach(GRGEN_ACTIONS.IMatch_shared element in list)
		{
			if(!alreadySeenMembers.ContainsKey(element.@var_v)) {
				newList.Add(element);
				alreadySeenMembers.Add(element.@var_v, null);
			}
		}
		return newList;
	}
	public static List<GRGEN_ACTIONS.IMatch_shared> Array_shared_keepOneForEachBy_x(List<GRGEN_ACTIONS.IMatch_shared> list)
	{
		List<GRGEN_ACTIONS.IMatch_shared> newList = new List<GRGEN_ACTIONS.IMatch_shared>();
		Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType> alreadySeenMembers = new Dictionary<GRGEN_LIBGR.INode, GRGEN_LIBGR.SetValueType>();
		foreach(GRGEN_ACTIONS.IMatch_shared element in list)
		{
			if(!alreadySeenMembers.ContainsKey(element.@node_x)) {
				newList.Add(element);
				alreadySeenMembers.Add(element.@node_x, null);
			}
		}
		return newList;
	}
}



//-----------------------------------------------------------

public class ExternalFiltersAndSequences_RuleAndMatchingPatterns : GRGEN_LGSP.LGSPRuleAndMatchingPatterns
{
	public ExternalFiltersAndSequences_RuleAndMatchingPatterns()
	{
		subpatterns = new GRGEN_LGSP.LGSPMatchingPattern[0];
		rules = new GRGEN_LGSP.LGSPRulePattern[7];
		rulesAndSubpatterns = new GRGEN_LGSP.LGSPMatchingPattern[0+7];
		definedSequences = new GRGEN_LIBGR.DefinedSequenceInfo[10];
		functions = new GRGEN_LIBGR.FunctionInfo[0+0];
		procedures = new GRGEN_LIBGR.ProcedureInfo[0+0];
		matchClasses = new GRGEN_LIBGR.MatchClassInfo[1];
		packages = new string[0];
		rules[0] = Rule_filterBase.Instance;
		rulesAndSubpatterns[0+0] = Rule_filterBase.Instance;
		rules[1] = Rule_filterBass.Instance;
		rulesAndSubpatterns[0+1] = Rule_filterBass.Instance;
		rules[2] = Rule_filterHass.Instance;
		rulesAndSubpatterns[0+2] = Rule_filterHass.Instance;
		rules[3] = Rule_init.Instance;
		rulesAndSubpatterns[0+3] = Rule_init.Instance;
		rules[4] = Rule_r.Instance;
		rulesAndSubpatterns[0+4] = Rule_r.Instance;
		rules[5] = Rule_rs.Instance;
		rulesAndSubpatterns[0+5] = Rule_rs.Instance;
		rules[6] = Rule_ss.Instance;
		rulesAndSubpatterns[0+6] = Rule_ss.Instance;
		definedSequences[0] = SequenceInfo_foo.Instance;
		definedSequences[1] = SequenceInfo_bar.Instance;
		definedSequences[2] = SequenceInfo_isnull.Instance;
		definedSequences[3] = SequenceInfo_bla.Instance;
		definedSequences[4] = SequenceInfo_blo.Instance;
		definedSequences[5] = SequenceInfo_createEdge.Instance;
		definedSequences[6] = SequenceInfo_huh.Instance;
		definedSequences[7] = SequenceInfo_counterExample1.Instance;
		definedSequences[8] = SequenceInfo_counterExample2.Instance;
		definedSequences[9] = SequenceInfo_seq.Instance;
		matchClasses[0] = MatchClassInfo_shared.Instance;
	}
	public override GRGEN_LGSP.LGSPRulePattern[] Rules { get { return rules; } }
	private GRGEN_LGSP.LGSPRulePattern[] rules;
	public override GRGEN_LGSP.LGSPMatchingPattern[] Subpatterns { get { return subpatterns; } }
	private GRGEN_LGSP.LGSPMatchingPattern[] subpatterns;
	public override GRGEN_LGSP.LGSPMatchingPattern[] RulesAndSubpatterns { get { return rulesAndSubpatterns; } }
	private GRGEN_LGSP.LGSPMatchingPattern[] rulesAndSubpatterns;
	public override GRGEN_LIBGR.DefinedSequenceInfo[] DefinedSequences { get { return definedSequences; } }
	private GRGEN_LIBGR.DefinedSequenceInfo[] definedSequences;
	public override GRGEN_LIBGR.FunctionInfo[] Functions { get { return functions; } }
	private GRGEN_LIBGR.FunctionInfo[] functions;
	public override GRGEN_LIBGR.ProcedureInfo[] Procedures { get { return procedures; } }
	private GRGEN_LIBGR.ProcedureInfo[] procedures;
	public override GRGEN_LIBGR.MatchClassInfo[] MatchClasses { get { return matchClasses; } }
	private GRGEN_LIBGR.MatchClassInfo[] matchClasses;
	public override string[] Packages { get { return packages; } }
	private string[] packages;
}


    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_filterBase
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_filterBase.IMatch_filterBase match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max);
    }
    
    public class Action_filterBase : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_filterBase
    {
        public Action_filterBase()
            : base(Rule_filterBase.Instance.patternGraph, new object[0])
        {
            _rulePattern = Rule_filterBase.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_filterBase.Match_filterBase, Rule_filterBase.IMatch_filterBase>(this);
        }

        public Rule_filterBase _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "filterBase"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_filterBase.Match_filterBase, Rule_filterBase.IMatch_filterBase> matches;

        public static Action_filterBase Instance { get { return instance; } set { instance = value; } }
        private static Action_filterBase instance = new Action_filterBase();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            Rule_filterBase.Match_filterBase match = matches.GetNextUnfilledPosition();
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_filterBase.IMatch_filterBase match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches)
        {
            foreach(Rule_filterBase.IMatch_filterBase match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
            if(matches.Count <= 0) return 0;
            foreach(Rule_filterBase.IMatch_filterBase match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(actionEnv, (Rule_filterBase.IMatch_filterBase)match);
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase>)matches);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            
            if(Apply(actionEnv)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            
            if(Apply(actionEnv)) {
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                case "auto": GRGEN_ACTIONS.MatchFilters.Filter_filterBase_auto((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase>)matches); break;
                case "f1": GRGEN_ACTIONS.MatchFilters.Filter_f1((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase>)matches); break;
                case "nomnomnom": GRGEN_ACTIONS.MatchFilters.Filter_nomnomnom((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBase.IMatch_filterBase>)matches); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase>)
                return ((List<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_filterBase.IMatch_filterBase>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    
    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_filterBass
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_filterBass.IMatch_filterBass match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max);
    }
    
    public class Action_filterBass : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_filterBass
    {
        public Action_filterBass()
            : base(Rule_filterBass.Instance.patternGraph, new object[0])
        {
            _rulePattern = Rule_filterBass.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_filterBass.Match_filterBass, Rule_filterBass.IMatch_filterBass>(this);
        }

        public Rule_filterBass _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "filterBass"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_filterBass.Match_filterBass, Rule_filterBass.IMatch_filterBass> matches;

        public static Action_filterBass Instance { get { return instance; } set { instance = value; } }
        private static Action_filterBass instance = new Action_filterBass();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            // Lookup filterBass_edge_e 
            int type_id_candidate_filterBass_edge_e = 3;
            for(GRGEN_LGSP.LGSPEdge head_candidate_filterBass_edge_e = graph.edgesByTypeHeads[type_id_candidate_filterBass_edge_e], candidate_filterBass_edge_e = head_candidate_filterBass_edge_e.lgspTypeNext; candidate_filterBass_edge_e != head_candidate_filterBass_edge_e; candidate_filterBass_edge_e = candidate_filterBass_edge_e.lgspTypeNext)
            {
                // Implicit Source filterBass_node_n from filterBass_edge_e 
                GRGEN_LGSP.LGSPNode candidate_filterBass_node_n = candidate_filterBass_edge_e.lgspSource;
                if(candidate_filterBass_node_n.lgspType.TypeID!=1) {
                    continue;
                }
                if(candidate_filterBass_edge_e.lgspSource != candidate_filterBass_node_n) {
                    continue;
                }
                if(candidate_filterBass_edge_e.lgspTarget != candidate_filterBass_node_n) {
                    continue;
                }
                System.String var_filterBass_var_s = (System.String)"";
                Rule_filterBass.Match_filterBass match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_filterBass_node_n;
                match._edge_e = candidate_filterBass_edge_e;
                match._var_s = var_filterBass_var_s;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_filterBass_edge_e);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_filterBass.IMatch_filterBass match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches)
        {
            foreach(Rule_filterBass.IMatch_filterBass match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
            if(matches.Count <= 0) return 0;
            foreach(Rule_filterBass.IMatch_filterBass match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(actionEnv, (Rule_filterBass.IMatch_filterBass)match);
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass>)matches);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            
            if(Apply(actionEnv)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            
            if(Apply(actionEnv)) {
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                case "auto": GRGEN_ACTIONS.MatchFilters.Filter_filterBass_auto((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass>)matches); break;
                case "fil": GRGEN_ACTIONS.MatchFilters.Filter_fil((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass>)matches, (System.Int32)(filter.Arguments[0])); break;
                case "f2": GRGEN_ACTIONS.MatchFilters.Filter_f2((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass>)matches); break;
                case "f3": GRGEN_ACTIONS.MatchFilters.Filter_f3((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterBass.IMatch_filterBass>)matches); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>)
                return ((List<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_filterBass.IMatch_filterBass>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    
    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_filterHass
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_MODEL.IN filterHass_node_n);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_filterHass.IMatch_filterHass match, out GRGEN_MODEL.IE output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches, List<GRGEN_MODEL.IE> output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n, ref GRGEN_MODEL.IE output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n, List<GRGEN_MODEL.IE> output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, GRGEN_MODEL.IN filterHass_node_n);
    }
    
    public class Action_filterHass : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_filterHass
    {
        public Action_filterHass()
            : base(Rule_filterHass.Instance.patternGraph, new object[1])
        {
            _rulePattern = Rule_filterHass.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_filterHass.Match_filterHass, Rule_filterHass.IMatch_filterHass>(this);
        }

        public Rule_filterHass _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "filterHass"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_filterHass.Match_filterHass, Rule_filterHass.IMatch_filterHass> matches;

        public static Action_filterHass Instance { get { return instance; } set { instance = value; } }
        private static Action_filterHass instance = new Action_filterHass();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_MODEL.IN filterHass_node_n)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            // Preset filterHass_node_n 
            GRGEN_LGSP.LGSPNode candidate_filterHass_node_n = (GRGEN_LGSP.LGSPNode)filterHass_node_n;
            if(candidate_filterHass_node_n.lgspType.TypeID!=1) {
                return matches;
            }
            // Extend Outgoing filterHass_edge_e from filterHass_node_n 
            GRGEN_LGSP.LGSPEdge head_candidate_filterHass_edge_e = candidate_filterHass_node_n.lgspOuthead;
            if(head_candidate_filterHass_edge_e != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_filterHass_edge_e = head_candidate_filterHass_edge_e;
                do
                {
                    if(candidate_filterHass_edge_e.lgspType.TypeID!=3) {
                        continue;
                    }
                    if(candidate_filterHass_edge_e.lgspTarget != candidate_filterHass_node_n) {
                        continue;
                    }
                    System.Int32 var_filterHass_var_i = (System.Int32)0;
                    Rule_filterHass.Match_filterHass match = matches.GetNextUnfilledPosition();
                    match._node_n = candidate_filterHass_node_n;
                    match._edge_e = candidate_filterHass_edge_e;
                    match._var_i = var_filterHass_var_i;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_filterHass_node_n.MoveOutHeadAfter(candidate_filterHass_edge_e);
                        return matches;
                    }
                }
                while( (candidate_filterHass_edge_e = candidate_filterHass_edge_e.lgspOutNext) != head_candidate_filterHass_edge_e );
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_MODEL.IN filterHass_node_n);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        List<GRGEN_MODEL.IE> output_list_0 = new List<GRGEN_MODEL.IE>();
        public GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_MODEL.IN filterHass_node_n)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches, filterHass_node_n);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_filterHass.IMatch_filterHass match, out GRGEN_MODEL.IE output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches, List<GRGEN_MODEL.IE> output_0)
        {
            foreach(Rule_filterHass.IMatch_filterHass match in matches)
            {
                GRGEN_MODEL.IE output_local_0; 
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_local_0);
                output_0.Add(output_local_0);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n, ref GRGEN_MODEL.IE output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, filterHass_node_n);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n, List<GRGEN_MODEL.IE> output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches, filterHass_node_n);
            if(matches.Count <= 0) return 0;
            foreach(Rule_filterHass.IMatch_filterHass match in matches)
            {
                GRGEN_MODEL.IE output_local_0; 
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_local_0);
                output_0.Add(output_local_0);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches;
            GRGEN_MODEL.IE output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, filterHass_node_n);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_MODEL.IN filterHass_node_n)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, filterHass_node_n);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IE output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, filterHass_node_n);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, GRGEN_MODEL.IN filterHass_node_n)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass> matches;
            GRGEN_MODEL.IE output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, filterHass_node_n);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches, (GRGEN_MODEL.IN) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IE output_0; 
            Modify(actionEnv, (Rule_filterHass.IMatch_filterHass)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            output_list_0.Clear();
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass>)matches, output_list_0);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            GRGEN_MODEL.IE output_0 = null; 
            if(Apply(actionEnv, (GRGEN_MODEL.IN) parameters[0], ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception();
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            output_list_0.Clear();
            int matchesCount = ApplyAll(maxMatches, actionEnv, (GRGEN_MODEL.IN) parameters[0], output_list_0);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv, (GRGEN_MODEL.IN) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv, (GRGEN_MODEL.IN) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max, (GRGEN_MODEL.IN) parameters[0]);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                case "orderAscendingBy<i>": GRGEN_ACTIONS.MatchFilters.Filter_filterHass_orderAscendingBy_i((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass>)matches); break;
                case "f4": GRGEN_ACTIONS.MatchFilters.Filter_f4((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_filterHass.IMatch_filterHass>)matches, (System.Int32)(filter.Arguments[0]), (System.String)(filter.Arguments[1])); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>)
                return ((List<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_filterHass.IMatch_filterHass>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    
    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_init
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_init.IMatch_init match, out GRGEN_MODEL.IN output_0);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches, List<GRGEN_MODEL.IN> output_0);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, ref GRGEN_MODEL.IN output_0);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, List<GRGEN_MODEL.IN> output_0);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max);
    }
    
    public class Action_init : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_init
    {
        public Action_init()
            : base(Rule_init.Instance.patternGraph, new object[1])
        {
            _rulePattern = Rule_init.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_init.Match_init, Rule_init.IMatch_init>(this);
        }

        public Rule_init _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "init"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_init.Match_init, Rule_init.IMatch_init> matches;

        public static Action_init Instance { get { return instance; } set { instance = value; } }
        private static Action_init instance = new Action_init();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            Rule_init.Match_init match = matches.GetNextUnfilledPosition();
            matches.PositionWasFilledFixIt();
            // if enough matches were found, we leave
            if(maxMatches > 0 && matches.Count >= maxMatches)
            {
                return matches;
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        List<GRGEN_MODEL.IN> output_list_0 = new List<GRGEN_MODEL.IN>();
        public GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_init.IMatch_init match, out GRGEN_MODEL.IN output_0)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_0);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches, List<GRGEN_MODEL.IN> output_0)
        {
            foreach(Rule_init.IMatch_init match in matches)
            {
                GRGEN_MODEL.IN output_local_0; 
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_local_0);
                output_0.Add(output_local_0);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, ref GRGEN_MODEL.IN output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, List<GRGEN_MODEL.IN> output_0)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
            if(matches.Count <= 0) return 0;
            foreach(Rule_init.IMatch_init match in matches)
            {
                GRGEN_MODEL.IN output_local_0; 
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_local_0);
                output_0.Add(output_local_0);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches;
            GRGEN_MODEL.IN output_0; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IN output_0; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init> matches;
            GRGEN_MODEL.IN output_0; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IN output_0; 
            Modify(actionEnv, (Rule_init.IMatch_init)match, out output_0);
            ReturnArray[0] = output_0;
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            output_list_0.Clear();
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_init.IMatch_init>)matches, output_list_0);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_MODEL.IN output_0 = null; 
            if(Apply(actionEnv, ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            GRGEN_MODEL.IN output_0 = null; 
            if(Apply(actionEnv, ref output_0)) {
                ReturnArray[0] = output_0;
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            output_list_0.Clear();
            int matchesCount = ApplyAll(maxMatches, actionEnv, output_list_0);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            output_list_0.Clear();
            int matchesCount = ApplyAll(maxMatches, actionEnv, output_list_0);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[1]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_init.IMatch_init> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_init.IMatch_init>)
                return ((List<GRGEN_ACTIONS.Rule_init.IMatch_init>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_init.IMatch_init>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    
    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_r
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_r.IMatch_r match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max);
    }
    
    public class Action_r : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_r
    {
        public Action_r()
            : base(Rule_r.Instance.patternGraph, new object[0])
        {
            _rulePattern = Rule_r.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_r.Match_r, Rule_r.IMatch_r>(this);
        }

        public Rule_r _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "r"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_r.Match_r, Rule_r.IMatch_r> matches;

        public static Action_r Instance { get { return instance; } set { instance = value; } }
        private static Action_r instance = new Action_r();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            // Lookup r_edge_e 
            int type_id_candidate_r_edge_e = 3;
            for(GRGEN_LGSP.LGSPEdge head_candidate_r_edge_e = graph.edgesByTypeHeads[type_id_candidate_r_edge_e], candidate_r_edge_e = head_candidate_r_edge_e.lgspTypeNext; candidate_r_edge_e != head_candidate_r_edge_e; candidate_r_edge_e = candidate_r_edge_e.lgspTypeNext)
            {
                // Implicit Source r_node_n from r_edge_e 
                GRGEN_LGSP.LGSPNode candidate_r_node_n = candidate_r_edge_e.lgspSource;
                if(candidate_r_node_n.lgspType.TypeID!=1) {
                    continue;
                }
                if(candidate_r_edge_e.lgspSource != candidate_r_node_n) {
                    continue;
                }
                if(candidate_r_edge_e.lgspTarget != candidate_r_node_n) {
                    continue;
                }
                Rule_r.Match_r match = matches.GetNextUnfilledPosition();
                match._node_n = candidate_r_node_n;
                match._edge_e = candidate_r_edge_e;
                matches.PositionWasFilledFixIt();
                // if enough matches were found, we leave
                if(maxMatches > 0 && matches.Count >= maxMatches)
                {
                    graph.MoveHeadAfter(candidate_r_edge_e);
                    return matches;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_r.IMatch_r match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches)
        {
            foreach(Rule_r.IMatch_r match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
            if(matches.Count <= 0) return 0;
            foreach(Rule_r.IMatch_r match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(actionEnv, (Rule_r.IMatch_r)match);
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_r.IMatch_r>)matches);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            
            if(Apply(actionEnv)) {
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            
            if(Apply(actionEnv)) {
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_r.IMatch_r> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_r.IMatch_r>)
                return ((List<GRGEN_ACTIONS.Rule_r.IMatch_r>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_r.IMatch_r>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    
    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_rs
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_LIBGR.INode rs_node_start);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_rs.IMatch_rs match);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, GRGEN_LIBGR.INode rs_node_start);
    }
    
    public class Action_rs : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_rs
    {
        public Action_rs()
            : base(Rule_rs.Instance.patternGraph, new object[0])
        {
            _rulePattern = Rule_rs.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_rs.Match_rs, Rule_rs.IMatch_rs>(this);
        }

        public Rule_rs _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "rs"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_rs.Match_rs, Rule_rs.IMatch_rs> matches;

        public static Action_rs Instance { get { return instance; } set { instance = value; } }
        private static Action_rs instance = new Action_rs();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_LIBGR.INode rs_node_start)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            // Preset rs_node_start 
            GRGEN_LGSP.LGSPNode candidate_rs_node_start = (GRGEN_LGSP.LGSPNode)rs_node_start;
            uint prev__candidate_rs_node_start;
            prev__candidate_rs_node_start = candidate_rs_node_start.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
            candidate_rs_node_start.lgspFlags |= (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
            // Extend Outgoing rs_edge__edge0 from rs_node_start 
            GRGEN_LGSP.LGSPEdge head_candidate_rs_edge__edge0 = candidate_rs_node_start.lgspOuthead;
            if(head_candidate_rs_edge__edge0 != null)
            {
                GRGEN_LGSP.LGSPEdge candidate_rs_edge__edge0 = head_candidate_rs_edge__edge0;
                do
                {
                    if(candidate_rs_edge__edge0.lgspType.TypeID!=1 && candidate_rs_edge__edge0.lgspType.TypeID!=3) {
                        continue;
                    }
                    // Implicit Target rs_node_n from rs_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_rs_node_n = candidate_rs_edge__edge0.lgspTarget;
                    if((candidate_rs_node_n.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) != 0)
                    {
                        continue;
                    }
                    // Condition 
                    if(!(!graph.IsVisited(candidate_rs_node_n, 0))) {
                        continue;
                    }
                    GRGEN_LGSP.LGSPNode candidate_rs_node_x = (GRGEN_LGSP.LGSPNode)null;
                    System.Int32 var_rs_var_v = (System.Int32)0;
                    Rule_rs.Match_rs match = matches.GetNextUnfilledPosition();
                    match._node_start = candidate_rs_node_start;
                    match._node_n = candidate_rs_node_n;
                    match._edge__edge0 = candidate_rs_edge__edge0;
                    match._node_x = candidate_rs_node_x;
                    match._var_v = var_rs_var_v;
                    matches.PositionWasFilledFixIt();
                    // if enough matches were found, we leave
                    if(maxMatches > 0 && matches.Count >= maxMatches)
                    {
                        candidate_rs_node_start.MoveOutHeadAfter(candidate_rs_edge__edge0);
                        candidate_rs_node_start.lgspFlags = candidate_rs_node_start.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_rs_node_start;
                        return matches;
                    }
                }
                while( (candidate_rs_edge__edge0 = candidate_rs_edge__edge0.lgspOutNext) != head_candidate_rs_edge__edge0 );
            }
            candidate_rs_node_start.lgspFlags = candidate_rs_node_start.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_rs_node_start;
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_LIBGR.INode rs_node_start);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        public GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, GRGEN_LIBGR.INode rs_node_start)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches, rs_node_start);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_rs.IMatch_rs match)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches)
        {
            foreach(Rule_rs.IMatch_rs match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, rs_node_start);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches, rs_node_start);
            if(matches.Count <= 0) return 0;
            foreach(Rule_rs.IMatch_rs match in matches)
            {
                
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches;
            
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, rs_node_start);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.INode rs_node_start)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, rs_node_start);
            if(matches.Count <= 0) return false;
            
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, rs_node_start);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, GRGEN_LIBGR.INode rs_node_start)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs> matches;
            
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1, rs_node_start);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches, (GRGEN_LIBGR.INode) parameters[0]);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            
            Modify(actionEnv, (Rule_rs.IMatch_rs)match);
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_rs.IMatch_rs>)matches);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception();
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            
            if(Apply(actionEnv, (GRGEN_LIBGR.INode) parameters[0])) {
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception();
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            int matchesCount = ApplyAll(maxMatches, actionEnv, (GRGEN_LIBGR.INode) parameters[0]);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[0]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv, (GRGEN_LIBGR.INode) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv, (GRGEN_LIBGR.INode) parameters[0]);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            throw new Exception(); return false;
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max, (GRGEN_LIBGR.INode) parameters[0]);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_rs.IMatch_rs> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>)
                return ((List<GRGEN_ACTIONS.Rule_rs.IMatch_rs>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_rs.IMatch_rs>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    
    /// <summary>
    /// An object representing an executable rule - same as IAction, but with exact types and distinct parameters.
    /// </summary>
    public interface IAction_ss
    {
        /// <summary> same as IAction.Match, but with exact types and distinct parameters. </summary>
        GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> same as IAction.Modify, but with exact types and distinct parameters. </summary>
        void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_ss.IMatch_ss match, out GRGEN_MODEL.IM output_0, out GRGEN_MODEL.IM output_1);
        /// <summary> same as IAction.ModifyAll, but with exact types and distinct parameters. </summary>
        void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches, List<GRGEN_MODEL.IM> output_0, List<GRGEN_MODEL.IM> output_1);
        /// <summary> same as IAction.Apply, but with exact types and distinct parameters; returns true if applied </summary>
        bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, ref GRGEN_MODEL.IM output_0, ref GRGEN_MODEL.IM output_1);
        /// <summary> same as IAction.ApplyAll, but with exact types and distinct parameters; returns the number of matches found/applied. </summary>
        int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, List<GRGEN_MODEL.IM> output_0, List<GRGEN_MODEL.IM> output_1);
        /// <summary> same as IAction.ApplyStar, but with exact types and distinct parameters. </summary>
        bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyPlus, but with exact types and distinct parameters. </summary>
        bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv);
        /// <summary> same as IAction.ApplyMinMax, but with exact types and distinct parameters. </summary>
        bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max);
    }
    
    public class Action_ss : GRGEN_LGSP.LGSPAction, GRGEN_LIBGR.IAction, IAction_ss
    {
        public Action_ss()
            : base(Rule_ss.Instance.patternGraph, new object[2])
        {
            _rulePattern = Rule_ss.Instance;
            DynamicMatch = myMatch;
            matches = new GRGEN_LGSP.LGSPMatchesList<Rule_ss.Match_ss, Rule_ss.IMatch_ss>(this);
        }

        public Rule_ss _rulePattern;
        public override GRGEN_LGSP.LGSPRulePattern rulePattern { get { return _rulePattern; } }
        public override string Name { get { return "ss"; } }
        private GRGEN_LGSP.LGSPMatchesList<Rule_ss.Match_ss, Rule_ss.IMatch_ss> matches;

        public static Action_ss Instance { get { return instance; } set { instance = value; } }
        private static Action_ss instance = new Action_ss();
        
        public GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> myMatch(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches)
        {
            GRGEN_LGSP.LGSPGraph graph = actionEnv.graph;
            matches.Clear();
            int isoSpace = 0;
            // Lookup ss_edge__edge0 
            foreach(GRGEN_LIBGR.EdgeType type_candidate_ss_edge__edge0 in GRGEN_MODEL.EdgeType_Edge.typeVar.SubOrSameTypes)
            {
                int type_id_candidate_ss_edge__edge0 = type_candidate_ss_edge__edge0.TypeID;
                for(GRGEN_LGSP.LGSPEdge head_candidate_ss_edge__edge0 = graph.edgesByTypeHeads[type_id_candidate_ss_edge__edge0], candidate_ss_edge__edge0 = head_candidate_ss_edge__edge0.lgspTypeNext; candidate_ss_edge__edge0 != head_candidate_ss_edge__edge0; candidate_ss_edge__edge0 = candidate_ss_edge__edge0.lgspTypeNext)
                {
                    uint prev__candidate_ss_edge__edge0;
                    prev__candidate_ss_edge__edge0 = candidate_ss_edge__edge0.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
                    candidate_ss_edge__edge0.lgspFlags |= (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
                    // Implicit Source ss_node_root from ss_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_ss_node_root = candidate_ss_edge__edge0.lgspSource;
                    uint prev__candidate_ss_node_root;
                    prev__candidate_ss_node_root = candidate_ss_node_root.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
                    candidate_ss_node_root.lgspFlags |= (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
                    // Implicit Target ss_node_m1 from ss_edge__edge0 
                    GRGEN_LGSP.LGSPNode candidate_ss_node_m1 = candidate_ss_edge__edge0.lgspTarget;
                    if(candidate_ss_node_m1.lgspType.TypeID!=2) {
                        candidate_ss_node_root.lgspFlags = candidate_ss_node_root.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_node_root;
                        candidate_ss_edge__edge0.lgspFlags = candidate_ss_edge__edge0.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_edge__edge0;
                        continue;
                    }
                    if((candidate_ss_node_m1.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) != 0)
                    {
                        candidate_ss_node_root.lgspFlags = candidate_ss_node_root.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_node_root;
                        candidate_ss_edge__edge0.lgspFlags = candidate_ss_edge__edge0.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_edge__edge0;
                        continue;
                    }
                    uint prev__candidate_ss_node_m1;
                    prev__candidate_ss_node_m1 = candidate_ss_node_m1.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
                    candidate_ss_node_m1.lgspFlags |= (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace;
                    // Extend Outgoing ss_edge__edge1 from ss_node_root 
                    GRGEN_LGSP.LGSPEdge head_candidate_ss_edge__edge1 = candidate_ss_node_root.lgspOuthead;
                    if(head_candidate_ss_edge__edge1 != null)
                    {
                        GRGEN_LGSP.LGSPEdge candidate_ss_edge__edge1 = head_candidate_ss_edge__edge1;
                        do
                        {
                            if(candidate_ss_edge__edge1.lgspType.TypeID!=1 && candidate_ss_edge__edge1.lgspType.TypeID!=3) {
                                continue;
                            }
                            if((candidate_ss_edge__edge1.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) != 0)
                            {
                                continue;
                            }
                            // Implicit Target ss_node_m2 from ss_edge__edge1 
                            GRGEN_LGSP.LGSPNode candidate_ss_node_m2 = candidate_ss_edge__edge1.lgspTarget;
                            if(candidate_ss_node_m2.lgspType.TypeID!=2) {
                                continue;
                            }
                            if((candidate_ss_node_m2.lgspFlags & (uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) != 0)
                            {
                                continue;
                            }
                            GRGEN_LGSP.LGSPNode candidate_ss_node_x = (GRGEN_LGSP.LGSPNode)null;
                            System.Int32 var_ss_var_v = (System.Int32)0;
                            Rule_ss.Match_ss match = matches.GetNextUnfilledPosition();
                            match._node_root = candidate_ss_node_root;
                            match._node_m1 = candidate_ss_node_m1;
                            match._node_m2 = candidate_ss_node_m2;
                            match._edge__edge0 = candidate_ss_edge__edge0;
                            match._edge__edge1 = candidate_ss_edge__edge1;
                            match._node_x = candidate_ss_node_x;
                            match._var_v = var_ss_var_v;
                            matches.PositionWasFilledFixIt();
                            // if enough matches were found, we leave
                            if(maxMatches > 0 && matches.Count >= maxMatches)
                            {
                                candidate_ss_node_root.MoveOutHeadAfter(candidate_ss_edge__edge1);
                                graph.MoveHeadAfter(candidate_ss_edge__edge0);
                                candidate_ss_node_m1.lgspFlags = candidate_ss_node_m1.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_node_m1;
                                candidate_ss_node_root.lgspFlags = candidate_ss_node_root.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_node_root;
                                candidate_ss_edge__edge0.lgspFlags = candidate_ss_edge__edge0.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_edge__edge0;
                                return matches;
                            }
                        }
                        while( (candidate_ss_edge__edge1 = candidate_ss_edge__edge1.lgspOutNext) != head_candidate_ss_edge__edge1 );
                    }
                    candidate_ss_node_m1.lgspFlags = candidate_ss_node_m1.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_node_m1;
                    candidate_ss_node_root.lgspFlags = candidate_ss_node_root.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_node_root;
                    candidate_ss_edge__edge0.lgspFlags = candidate_ss_edge__edge0.lgspFlags & ~((uint)GRGEN_LGSP.LGSPElemFlags.IS_MATCHED << isoSpace) | prev__candidate_ss_edge__edge0;
                }
            }
            return matches;
        }
        /// <summary> Type of the matcher method (with parameters processing environment containing host graph, maximum number of matches to search for (zero=unlimited), and rule parameters; returning found matches). </summary>
        public delegate GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> MatchInvoker(GRGEN_LGSP.LGSPActionExecutionEnvironment actionEnv, int maxMatches);
        /// <summary> A delegate pointing to the current matcher program for this rule. </summary>
        public MatchInvoker DynamicMatch;
        /// <summary> The RulePattern object from which this LGSPAction object has been created. </summary>
        public GRGEN_LIBGR.IRulePattern RulePattern { get { return _rulePattern; } }
        List<GRGEN_MODEL.IM> output_list_0 = new List<GRGEN_MODEL.IM>();
        List<GRGEN_MODEL.IM> output_list_1 = new List<GRGEN_MODEL.IM>();
        public GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches)
        {
            return DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
        }
        public void Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, Rule_ss.IMatch_ss match, out GRGEN_MODEL.IM output_0, out GRGEN_MODEL.IM output_1)
        {
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_0, out output_1);
        }
        public void ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches, List<GRGEN_MODEL.IM> output_0, List<GRGEN_MODEL.IM> output_1)
        {
            foreach(Rule_ss.IMatch_ss match in matches)
            {
                GRGEN_MODEL.IM output_local_0; GRGEN_MODEL.IM output_local_1; 
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_local_0, out output_local_1);
                output_0.Add(output_local_0);
                output_1.Add(output_local_1);
            }
        }
        public bool Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, ref GRGEN_MODEL.IM output_0, ref GRGEN_MODEL.IM output_1)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0, out output_1);
            return true;
        }
        public int ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, List<GRGEN_MODEL.IM> output_0, List<GRGEN_MODEL.IM> output_1)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, maxMatches);
            if(matches.Count <= 0) return 0;
            foreach(Rule_ss.IMatch_ss match in matches)
            {
                GRGEN_MODEL.IM output_local_0; GRGEN_MODEL.IM output_local_1; 
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, match, out output_local_0, out output_local_1);
                output_0.Add(output_local_0);
                output_1.Add(output_local_1);
            }
            return matches.Count;
        }
        public bool ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches;
            GRGEN_MODEL.IM output_0; GRGEN_MODEL.IM output_1; 
            while(true)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return true;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0, out output_1);
            }
        }
        public bool ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            if(matches.Count <= 0) return false;
            GRGEN_MODEL.IM output_0; GRGEN_MODEL.IM output_1; 
            do
            {
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0, out output_1);
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
            }
            while(matches.Count > 0) ;
            return true;
        }
        public bool ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss> matches;
            GRGEN_MODEL.IM output_0; GRGEN_MODEL.IM output_1; 
            for(int i = 0; i < max; i++)
            {
                matches = DynamicMatch((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, 1);
                if(matches.Count <= 0) return i >= min;
                _rulePattern.Modify((GRGEN_LGSP.LGSPActionExecutionEnvironment)actionEnv, matches.First, out output_0, out output_1);
            }
            return true;
        }
        // implementation of inexact action interface by delegation to exact action interface
        public GRGEN_LIBGR.IMatches Match(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int maxMatches, object[] parameters)
        {
            return Match(actionEnv, maxMatches);
        }
        public object[] Modify(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatch match)
        {
            GRGEN_MODEL.IM output_0; GRGEN_MODEL.IM output_1; 
            Modify(actionEnv, (Rule_ss.IMatch_ss)match, out output_0, out output_1);
            ReturnArray[0] = output_0;
            ReturnArray[1] = output_1;
            return ReturnArray;
        }
        public List<object[]> ModifyAll(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches)
        {
            output_list_0.Clear();
            output_list_1.Clear();
            ModifyAll(actionEnv, (GRGEN_LIBGR.IMatchesExact<Rule_ss.IMatch_ss>)matches, output_list_0, output_list_1);
            while(AvailableReturnArrays.Count < matches.Count) AvailableReturnArrays.Add(new object[2]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matches.Count; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
                ReturnArrayListForAll[i][1] = output_list_1[i];
            }
            return ReturnArrayListForAll;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            GRGEN_MODEL.IM output_0 = null; GRGEN_MODEL.IM output_1 = null; 
            if(Apply(actionEnv, ref output_0, ref output_1)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                return ReturnArray;
            }
            else return null;
        }
        object[] GRGEN_LIBGR.IAction.Apply(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            GRGEN_MODEL.IM output_0 = null; GRGEN_MODEL.IM output_1 = null; 
            if(Apply(actionEnv, ref output_0, ref output_1)) {
                ReturnArray[0] = output_0;
                ReturnArray[1] = output_1;
                return ReturnArray;
            }
            else return null;
        }
        public List<object[]> Reserve(int numReturns)
        {
            while(AvailableReturnArrays.Count < numReturns) AvailableReturnArrays.Add(new object[2]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<numReturns; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            output_list_0.Clear();
            output_list_1.Clear();
            int matchesCount = ApplyAll(maxMatches, actionEnv, output_list_0, output_list_1);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[2]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
                ReturnArrayListForAll[i][1] = output_list_1[i];
            }
            return ReturnArrayListForAll;
        }
        List<object[]> GRGEN_LIBGR.IAction.ApplyAll(int maxMatches, GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            output_list_0.Clear();
            output_list_1.Clear();
            int matchesCount = ApplyAll(maxMatches, actionEnv, output_list_0, output_list_1);
            while(AvailableReturnArrays.Count < matchesCount) AvailableReturnArrays.Add(new object[2]);
            ReturnArrayListForAll.Clear();
            for(int i=0; i<matchesCount; ++i)
            {
                ReturnArrayListForAll.Add(AvailableReturnArrays[i]);
                ReturnArrayListForAll[i][0] = output_list_0[i];
                ReturnArrayListForAll[i][1] = output_list_1[i];
            }
            return ReturnArrayListForAll;
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyStar(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyStar(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyPlus(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, params object[] parameters)
        {
            return ApplyPlus(actionEnv);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        bool GRGEN_LIBGR.IAction.ApplyMinMax(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, int min, int max, params object[] parameters)
        {
            return ApplyMinMax(actionEnv, min, max);
        }
        public void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, GRGEN_LIBGR.IMatches matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": matches.Filter_keepFirst((System.Int32)(filter.Arguments[0])); break;
                case "keepLast": matches.Filter_keepLast((System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": matches.Filter_keepFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": matches.Filter_keepLastFraction((System.Double)(filter.Arguments[0])); break;
                case "removeFirst": matches.Filter_removeFirst((System.Int32)(filter.Arguments[0])); break;
                case "removeLast": matches.Filter_removeLast((System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": matches.Filter_removeFirstFraction((System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": matches.Filter_removeLastFraction((System.Double)(filter.Arguments[0])); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.Rule_ss.IMatch_ss> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>)
                return ((List<GRGEN_ACTIONS.Rule_ss.IMatch_ss>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.Rule_ss.IMatch_ss>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }
    

    public class Sequence_counterExample1 : GRGEN_LIBGR.SequenceDefinitionCompiled
    {
        private static Sequence_counterExample1 instance = null;
        public static Sequence_counterExample1 Instance { get { if(instance==null) instance = new Sequence_counterExample1(); return instance; } }
        private Sequence_counterExample1() : base("counterExample1", SequenceInfo_counterExample1.Instance) { }

        private object[] ReturnValues = new object[2];

        public static bool ApplyXGRS_counterExample1(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, int var_v1, GRGEN_LIBGR.INode var_v2, ref int var_r1, ref GRGEN_LIBGR.INode var_r2)
        {
            GRGEN_LGSP.LGSPGraph graph = procEnv.graph;
            GRGEN_LGSP.LGSPActions actions = procEnv.curActions;
            procEnv.DebugEntering("counterExample1", var_v1, var_v2);
            bool res_80;
            object res_79;
            object res_75;
            object res_73;
            object res_78;
            object res_76;
            var_r1 = (int)(var_v1);
            res_73 = var_r1;
            res_75 = res_73;
            var_r2 = (GRGEN_LIBGR.INode)(var_v2);
            res_76 = var_r2;
            res_78 = res_76;
            res_79 = res_78;
            res_80 = (bool)(true);
            procEnv.DebugExiting("counterExample1", var_r1, var_r2);
            return res_80;
        }

        public static bool Apply_counterExample1(GRGEN_LIBGR.IGraphProcessingEnvironment procEnv, int var_v1, GRGEN_LIBGR.INode var_v2, ref int var_r1, ref GRGEN_LIBGR.INode var_r2)
        {
            int vari_r1 = 0;
            GRGEN_LIBGR.INode vari_r2 = null;
            bool result = ApplyXGRS_counterExample1((GRGEN_LGSP.LGSPGraphProcessingEnvironment)procEnv, var_v1, var_v2, ref var_r1, ref var_r2);
            if(result) {
                var_r1 = vari_r1;
                var_r2 = vari_r2;
            }
            return result;
        }

        public override bool Apply(GRGEN_LIBGR.IGraphProcessingEnvironment procEnv, object[] arguments, out object[] returnValues)        {
            GRGEN_LGSP.LGSPGraph graph = ((GRGEN_LGSP.LGSPActionExecutionEnvironment)procEnv).graph;
            int var_v1 = (int)arguments[0];
            GRGEN_LIBGR.INode var_v2 = (GRGEN_LIBGR.INode)arguments[1];
            int var_r1 = 0;
            GRGEN_LIBGR.INode var_r2 = null;
            bool result = ApplyXGRS_counterExample1((GRGEN_LGSP.LGSPGraphProcessingEnvironment)procEnv, var_v1, var_v2, ref var_r1, ref var_r2);
            returnValues = ReturnValues;
            if(result) {
                returnValues[0] = var_r1;
                returnValues[1] = var_r2;
            }
            return result;
        }
    }

    public class Sequence_counterExample2 : GRGEN_LIBGR.SequenceDefinitionCompiled
    {
        private static Sequence_counterExample2 instance = null;
        public static Sequence_counterExample2 Instance { get { if(instance==null) instance = new Sequence_counterExample2(); return instance; } }
        private Sequence_counterExample2() : base("counterExample2", SequenceInfo_counterExample2.Instance) { }

        private object[] ReturnValues = new object[0];

        public static bool ApplyXGRS_counterExample2(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv)
        {
            GRGEN_LGSP.LGSPGraph graph = procEnv.graph;
            GRGEN_LGSP.LGSPActions actions = procEnv.curActions;
            procEnv.DebugEntering("counterExample2");
            bool res_82;
            object res_81;
            res_81 = true;
            res_82 = (bool)(!GRGEN_LIBGR.TypesHelper.IsDefaultValue(res_81));
            procEnv.DebugExiting("counterExample2");
            return res_82;
        }

        public static bool Apply_counterExample2(GRGEN_LIBGR.IGraphProcessingEnvironment procEnv)
        {
            bool result = ApplyXGRS_counterExample2((GRGEN_LGSP.LGSPGraphProcessingEnvironment)procEnv);
            return result;
        }

        public override bool Apply(GRGEN_LIBGR.IGraphProcessingEnvironment procEnv, object[] arguments, out object[] returnValues)        {
            GRGEN_LGSP.LGSPGraph graph = ((GRGEN_LGSP.LGSPActionExecutionEnvironment)procEnv).graph;
            bool result = ApplyXGRS_counterExample2((GRGEN_LGSP.LGSPGraphProcessingEnvironment)procEnv);
            returnValues = ReturnValues;
            return result;
        }
    }

    public class Sequence_seq : GRGEN_LIBGR.SequenceDefinitionCompiled
    {
        private static Sequence_seq instance = null;
        public static Sequence_seq Instance { get { if(instance==null) instance = new Sequence_seq(); return instance; } }
        private Sequence_seq() : base("seq", SequenceInfo_seq.Instance) { }

        private object[] ReturnValues = new object[0];

        public static bool ApplyXGRS_seq(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv)
        {
            GRGEN_LGSP.LGSPGraph graph = procEnv.graph;
            GRGEN_LGSP.LGSPActions actions = procEnv.curActions;
            procEnv.DebugEntering("seq");
            bool res_86;
            bool res_84;
            GRGEN_ACTIONS.Action_rs rule_rs = GRGEN_ACTIONS.Action_rs.Instance;
            bool res_85;
            GRGEN_ACTIONS.Action_ss rule_ss = GRGEN_ACTIONS.Action_ss.Instance;
            List<GRGEN_MODEL.IM> var_m1 = null;
                        res_86 = (bool)(false);
            List<GRGEN_LIBGR.IMatch> MatchList_86 = new List<GRGEN_LIBGR.IMatch>();
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_rs.IMatch_rs> matches_84 = rule_rs.Match(procEnv, procEnv.MaxMatches, (GRGEN_LIBGR.INode)procEnv.GetVariableValue("n"));
            procEnv.PerformanceInfo.MatchesFound += matches_84.Count;
            if(matches_84.Count != 0) {
                matches_84 = (GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_rs.IMatch_rs>)matches_84.Clone();
                MatchList_86.AddRange(matches_84);
            }
            GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_ss.IMatch_ss> matches_85 = rule_ss.Match(procEnv, procEnv.MaxMatches);
            procEnv.PerformanceInfo.MatchesFound += matches_85.Count;
            if(matches_85.Count != 0) {
                matches_85 = (GRGEN_LIBGR.IMatchesExact<GRGEN_ACTIONS.Rule_ss.IMatch_ss>)matches_85.Clone();
                MatchList_86.AddRange(matches_85);
            }
            GRGEN_ACTIONS.MatchClassFilters.Filter_shf(procEnv, MatchList_86, (int)(42));
            GRGEN_ACTIONS.MatchClassFilters.Filter_extshf(procEnv, MatchList_86, (int)(42));
            GRGEN_ACTIONS.MatchClassFilters.Filter_shared_orderAscendingBy_v(procEnv, MatchList_86);
            GRGEN_LIBGR.MatchListHelper.Filter_keepFirst(MatchList_86, (System.Int32)(3));
            List<GRGEN_MODEL.IM> tmpvarlist_17m1 = new List<GRGEN_MODEL.IM>(); List<GRGEN_MODEL.IM> tmpvarlist_18m2 = new List<GRGEN_MODEL.IM>(); 
            bool first_rewrite_86 = true;
            if(MatchList_86.Count != 0) {
                res_86 = (bool)(true);
                IEnumerator<GRGEN_LIBGR.IMatch> enum_86 = MatchList_86.GetEnumerator();
                while(enum_86.MoveNext())
                {
                    switch(enum_86.Current.Pattern.PackagePrefixedName)
                    {
                        case "rs":
                        {
                            GRGEN_ACTIONS.Rule_rs.IMatch_rs match_84 = (GRGEN_ACTIONS.Rule_rs.IMatch_rs)enum_86.Current;
                            procEnv.Matched(matches_84, null, false);
                            procEnv.Finishing(matches_84, false);
                            if(!first_rewrite_86) procEnv.RewritingNextMatch();
                            rule_rs.Modify(procEnv, match_84);
                            ++procEnv.PerformanceInfo.RewritesPerformed;
                            first_rewrite_86 = false;
                            procEnv.Finished(matches_84, false);
                            break;
                        }
                        case "ss":
                        {
                            GRGEN_ACTIONS.Rule_ss.IMatch_ss match_85 = (GRGEN_ACTIONS.Rule_ss.IMatch_ss)enum_86.Current;
                            procEnv.Matched(matches_85, null, false);
                            procEnv.Finishing(matches_85, false);
                            if(!first_rewrite_86) procEnv.RewritingNextMatch();
                            GRGEN_MODEL.IM tmpvar_17m1; GRGEN_MODEL.IM tmpvar_18m2; 
                            rule_ss.Modify(procEnv, match_85, out tmpvar_17m1, out tmpvar_18m2);
                            tmpvarlist_17m1.Add((GRGEN_MODEL.IM)tmpvar_17m1); tmpvarlist_18m2.Add((GRGEN_MODEL.IM)tmpvar_18m2); 
                            ++procEnv.PerformanceInfo.RewritesPerformed;
                            first_rewrite_86 = false;
                            procEnv.Finished(matches_85, false);
                            break;
                        }
                        default: throw new Exception("Unknown pattern " + enum_86.Current.Pattern.PackagePrefixedName + " in match!");                    }
                }
                var_m1 = (List<GRGEN_MODEL.IM>)(tmpvarlist_17m1);
procEnv.SetVariableValue("m2", tmpvarlist_18m2);

            }
            procEnv.DebugExiting("seq");
            return res_86;
        }

        public static bool Apply_seq(GRGEN_LIBGR.IGraphProcessingEnvironment procEnv)
        {
            bool result = ApplyXGRS_seq((GRGEN_LGSP.LGSPGraphProcessingEnvironment)procEnv);
            return result;
        }

        public override bool Apply(GRGEN_LIBGR.IGraphProcessingEnvironment procEnv, object[] arguments, out object[] returnValues)        {
            GRGEN_LGSP.LGSPGraph graph = ((GRGEN_LGSP.LGSPActionExecutionEnvironment)procEnv).graph;
            bool result = ApplyXGRS_seq((GRGEN_LGSP.LGSPGraphProcessingEnvironment)procEnv);
            returnValues = ReturnValues;
            return result;
        }
    }
    
    public class MatchClassFilterer_shared : GRGEN_LIBGR.MatchClassFilterer
    {
        private static MatchClassFilterer_shared instance = null;
        public static MatchClassFilterer_shared Instance { get { if (instance==null) { instance = new MatchClassFilterer_shared(); } return instance; } }
        
        private MatchClassFilterer_shared()
            : base(MatchClassInfo_shared.Instance)
        {
        }
        
        public override void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, IList<GRGEN_LIBGR.IMatch> matches, GRGEN_LIBGR.FilterCall filter)
        {
            switch(filter.PackagePrefixedName) {
                case "keepFirst": GRGEN_LIBGR.MatchListHelper.Filter_keepFirst((List<GRGEN_LIBGR.IMatch>)matches, (System.Int32)(filter.Arguments[0])); break;
                case "keepLast": GRGEN_LIBGR.MatchListHelper.Filter_keepLast((List<GRGEN_LIBGR.IMatch>)matches, (System.Int32)(filter.Arguments[0])); break;
                case "keepFirstFraction": GRGEN_LIBGR.MatchListHelper.Filter_keepFirstFraction((List<GRGEN_LIBGR.IMatch>)matches, (System.Double)(filter.Arguments[0])); break;
                case "keepLastFraction": GRGEN_LIBGR.MatchListHelper.Filter_keepLastFraction((List<GRGEN_LIBGR.IMatch>)matches, (System.Double)(filter.Arguments[0])); break;
                case "removeFirst": GRGEN_LIBGR.MatchListHelper.Filter_removeFirst((List<GRGEN_LIBGR.IMatch>)matches, (System.Int32)(filter.Arguments[0])); break;
                case "removeLast": GRGEN_LIBGR.MatchListHelper.Filter_removeLast((List<GRGEN_LIBGR.IMatch>)matches, (System.Int32)(filter.Arguments[0])); break;
                case "removeFirstFraction": GRGEN_LIBGR.MatchListHelper.Filter_removeFirstFraction((List<GRGEN_LIBGR.IMatch>)matches, (System.Double)(filter.Arguments[0])); break;
                case "removeLastFraction": GRGEN_LIBGR.MatchListHelper.Filter_removeLastFraction((List<GRGEN_LIBGR.IMatch>)matches, (System.Double)(filter.Arguments[0])); break;
                case "orderAscendingBy<v>": GRGEN_ACTIONS.MatchClassFilters.Filter_shared_orderAscendingBy_v((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (List<GRGEN_LIBGR.IMatch>)matches); break;
                case "shf": GRGEN_ACTIONS.MatchClassFilters.Filter_shf((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (List<GRGEN_LIBGR.IMatch>)matches, (System.Int32)(filter.Arguments[0])); break;
                case "extshf": GRGEN_ACTIONS.MatchClassFilters.Filter_extshf((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, (List<GRGEN_LIBGR.IMatch>)matches, (System.Int32)(filter.Arguments[0])); break;
                default: throw new Exception("Unknown filter name " + filter.PackagePrefixedName + "!");
            }
        }
        public static List<GRGEN_ACTIONS.IMatch_shared> ConvertAsNeeded(object parameter)
        {
            if(parameter is List<GRGEN_ACTIONS.IMatch_shared>)
                return ((List<GRGEN_ACTIONS.IMatch_shared>)parameter);
            else
                return GRGEN_LIBGR.MatchListHelper.ToList<GRGEN_ACTIONS.IMatch_shared>((IList<GRGEN_LIBGR.IMatch>)parameter);
        }
    }

    // class which instantiates and stores all the compiled actions of the module,
    // dynamic regeneration and compilation causes the old action to be overwritten by the new one
    // matching/rule patterns are analyzed at creation time here, once, so that later regeneration runs have all the information available
    public class ExternalFiltersAndSequencesActions : GRGEN_LGSP.LGSPActions
    {
        public ExternalFiltersAndSequencesActions(GRGEN_LGSP.LGSPGraph lgspgraph, string modelAsmName, string actionsAsmName)
            : base(lgspgraph, modelAsmName, actionsAsmName)
        {
            InitActions();
        }

        public ExternalFiltersAndSequencesActions(GRGEN_LGSP.LGSPGraph lgspgraph)
            : base(lgspgraph)
        {
            InitActions();
        }

        private void InitActions()
        {
            packages = new string[0];
            GRGEN_LGSP.PatternGraphAnalyzer analyzer = new GRGEN_LGSP.PatternGraphAnalyzer();
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_filterBase.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_filterBase.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_filterBase.Instance);
            actions.Add("filterBase", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_filterBase.Instance);
            @filterBase = GRGEN_ACTIONS.Action_filterBase.Instance;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_filterBass.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_filterBass.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_filterBass.Instance);
            actions.Add("filterBass", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_filterBass.Instance);
            @filterBass = GRGEN_ACTIONS.Action_filterBass.Instance;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_filterHass.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_filterHass.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_filterHass.Instance);
            actions.Add("filterHass", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_filterHass.Instance);
            @filterHass = GRGEN_ACTIONS.Action_filterHass.Instance;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_init.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_init.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_init.Instance);
            actions.Add("init", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_init.Instance);
            @init = GRGEN_ACTIONS.Action_init.Instance;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_r.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_r.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_r.Instance);
            actions.Add("r", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_r.Instance);
            @r = GRGEN_ACTIONS.Action_r.Instance;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_rs.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_rs.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_rs.Instance);
            actions.Add("rs", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_rs.Instance);
            @rs = GRGEN_ACTIONS.Action_rs.Instance;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_ss.Instance.patternGraph, false);
            GRGEN_LGSP.PatternGraphAnalyzer.PrepareInline(GRGEN_ACTIONS.Rule_ss.Instance.patternGraph);
            analyzer.RememberMatchingPattern(GRGEN_ACTIONS.Rule_ss.Instance);
            actions.Add("ss", (GRGEN_LGSP.LGSPAction) GRGEN_ACTIONS.Action_ss.Instance);
            @ss = GRGEN_ACTIONS.Action_ss.Instance;
            analyzer.ComputeInterPatternRelations(false);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_filterBase.Instance.patternGraph);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_filterBass.Instance.patternGraph);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_filterHass.Instance.patternGraph);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_init.Instance.patternGraph);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_r.Instance.patternGraph);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_rs.Instance.patternGraph);
            analyzer.AnalyzeWithInterPatternRelationsKnown(GRGEN_ACTIONS.Rule_ss.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_filterBase.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_filterBass.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_filterHass.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_init.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_r.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_rs.Instance.patternGraph);
            analyzer.InlineSubpatternUsages(GRGEN_ACTIONS.Rule_ss.Instance.patternGraph);
            GRGEN_ACTIONS.Rule_filterBase.Instance.patternGraph.maxIsoSpace = 0;
            GRGEN_ACTIONS.Rule_filterBass.Instance.patternGraph.maxIsoSpace = 0;
            GRGEN_ACTIONS.Rule_filterHass.Instance.patternGraph.maxIsoSpace = 0;
            GRGEN_ACTIONS.Rule_init.Instance.patternGraph.maxIsoSpace = 0;
            GRGEN_ACTIONS.Rule_r.Instance.patternGraph.maxIsoSpace = 0;
            GRGEN_ACTIONS.Rule_rs.Instance.patternGraph.maxIsoSpace = 0;
            GRGEN_ACTIONS.Rule_ss.Instance.patternGraph.maxIsoSpace = 0;
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_filterBase.Instance.patternGraph, true);
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_filterBass.Instance.patternGraph, true);
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_filterHass.Instance.patternGraph, true);
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_init.Instance.patternGraph, true);
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_r.Instance.patternGraph, true);
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_rs.Instance.patternGraph, true);
            analyzer.AnalyzeNestingOfPatternGraph(GRGEN_ACTIONS.Rule_ss.Instance.patternGraph, true);
            analyzer.ComputeInterPatternRelations(true);
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_foo.Instance);
            @foo = GRGEN_ACTIONS.Sequence_foo.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_bar.Instance);
            @bar = GRGEN_ACTIONS.Sequence_bar.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_isnull.Instance);
            @isnull = GRGEN_ACTIONS.Sequence_isnull.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_bla.Instance);
            @bla = GRGEN_ACTIONS.Sequence_bla.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_blo.Instance);
            @blo = GRGEN_ACTIONS.Sequence_blo.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_createEdge.Instance);
            @createEdge = GRGEN_ACTIONS.Sequence_createEdge.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_huh.Instance);
            @huh = GRGEN_ACTIONS.Sequence_huh.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_counterExample1.Instance);
            @counterExample1 = GRGEN_ACTIONS.Sequence_counterExample1.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_counterExample2.Instance);
            @counterExample2 = GRGEN_ACTIONS.Sequence_counterExample2.Instance;
            RegisterGraphRewriteSequenceDefinition(GRGEN_ACTIONS.Sequence_seq.Instance);
            @seq = GRGEN_ACTIONS.Sequence_seq.Instance;
            namesToMatchClassFilterers.Add("shared", GRGEN_ACTIONS.MatchClassFilterer_shared.Instance);
        }
        
        public GRGEN_ACTIONS.IAction_filterBase @filterBase;
        public GRGEN_ACTIONS.IAction_filterBass @filterBass;
        public GRGEN_ACTIONS.IAction_filterHass @filterHass;
        public GRGEN_ACTIONS.IAction_init @init;
        public GRGEN_ACTIONS.IAction_r @r;
        public GRGEN_ACTIONS.IAction_rs @rs;
        public GRGEN_ACTIONS.IAction_ss @ss;
        
        public GRGEN_ACTIONS.Sequence_foo @foo;
        public GRGEN_ACTIONS.Sequence_bar @bar;
        public GRGEN_ACTIONS.Sequence_isnull @isnull;
        public GRGEN_ACTIONS.Sequence_bla @bla;
        public GRGEN_ACTIONS.Sequence_blo @blo;
        public GRGEN_ACTIONS.Sequence_createEdge @createEdge;
        public GRGEN_ACTIONS.Sequence_huh @huh;
        public GRGEN_ACTIONS.Sequence_counterExample1 @counterExample1;
        public GRGEN_ACTIONS.Sequence_counterExample2 @counterExample2;
        public GRGEN_ACTIONS.Sequence_seq @seq;
        
        public override string[] Packages { get { return packages; } }
        private string[] packages;
        
        public override string Name { get { return "ExternalFiltersAndSequencesActions"; } }
        public override string StatisticsPath { get { return null; } }
        public override bool LazyNIC { get { return false; } }
        public override bool InlineIndependents { get { return true; } }
        public override bool Profile { get { return false; } }

        public override void FailAssertion() { Debug.Assert(false); }
        public override string ModelMD5Hash { get { return "d117fe33b154ad3192df1300b58f58ea"; } }
    }
}