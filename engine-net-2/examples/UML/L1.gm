abstract edge class association;
abstract edge class attribute;

//An integer is a primitive type representing integer values.
node class Integer {
	
	value : int;

}

//A Boolean type is used for logical expression, consisting of the predefined values true and false.
node class Boolean {
	
	value : boolean;

}

//A string is a sequence of characters in some suitable character set used to display information about the model. Character sets may include non-Roman alphabets and characters.
node class String {
	
	value : string;

}

//An unlimited natural is a primitive type representing unlimited natural values.
node class UnlimitedNatural {
	
	value : int;

}

//AggregationKind is an enumeration type that specifies the literals for defining the kind of aggregation of a property.
enum AggregationKind {
	
	//Indicates that the property has no aggregation.
	none, 
	//Indicates that the property has a shared aggregation.
	shared, 
	//Indicates that the property is aggregated compositely, i.e., the composite object has responsibility for the existence and storage of the composed objects (parts).
	composite
	
}

node class AggregationKind_Value {
	
	value : AggregationKind;
	
}

//Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.
enum ParameterDirectionKind {
	
	//Indicates that parameter values are passed into the behavioral element by the caller.
	in, 
	//Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.
	inout, 
	//Indicates that parameter values are passed from a behavioral element out to the caller.
	out, 
	//Indicates that parameter values are passed as return values from a behavioral element back to the caller.
	return_
	
}

node class ParameterDirectionKind_Value {
	
	value : ParameterDirectionKind;
	
}

//VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.
enum VisibilityKind {
	
	//A public element is visible to all elements that can access the contents of the namespace that owns it.
	public, 
	//A private element is only visible inside the namespace that owns it.
	private, 
	//A protected element is visible to elements that have a generalization relationship to the namespace that owns it.
	protected, 
	//A package element is owned by a namespace that is not a package, and is visible to elements that are in the same package as its owning namespace. Only named elements that are not owned by packages can be marked as having package visibility. Any element marked as having package visibility is visible to all elements within the nearest enclosing package (given that other owning elements have proper visibility). Outside the nearest enclosing package, an element marked as having package visibility is not visible.
	package
	
}

node class VisibilityKind_Value {
	
	value : VisibilityKind;
	
}

//This is an enumerated type that identifies the type of message.
enum MessageKind {
	
	//sendEvent and receiveEvent are present
	complete, 
	//sendEvent present and receiveEvent absent
	lost, 
	//sendEvent absent and receiveEvent present
	found, 
	//sendEvent and receiveEvent absent (should not appear)
	unknown
	
}

node class MessageKind_Value {
	
	value : MessageKind;
	
}

//This is an enumerated type that identifies the type of communication action that was used to generate the message.
enum MessageSort {
	
	//The message was generated by a synchronous call to an operation.
	synchCall, 
	//The message was generated by an asynchronous call to an operation; i.e., a CallAction with isSynchronous = false.
	asynchCall, 
	//The message was generated by an asynchronous send action.
	asynchSignal, 
	//The message designating the creation of another lifeline object.
	createMessage, 
	//The message designating the termination of another lifeline.
	deleteMessage, 
	//The message is a reply message to an operation call.
	reply
	
}

node class MessageSort_Value {
	
	value : MessageSort;
	
}

//CallConcurrencyKind is an enumeration type.
enum CallConcurrencyKind {
	
	//No concurrency management mechanism is associated with the operation and, therefore, concurrency conflicts may occur. Instances that invoke a behavioral feature need to coordinate so that only one invocation to a target on any behavioral feature occurs at once.
	sequential, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance, but only one is allowed to commence. The others are blocked until the performance of the first behavioral feature is complete. It is the responsibility of the system designer to ensure that deadlocks do not occur due to simultaneous blocks.
	guarded, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance and all of them may proceed concurrently.
	concurrent
	
}

node class CallConcurrencyKind_Value {
	
	value : CallConcurrencyKind;
	
}

//An element is a constituent of a model. As such, it has the capability of owning other elements.
abstract node class Element {
	
	
}
edge class ownedElement extends attribute connect 
		Element[0:*] --> Element[*];
edge class owner extends attribute connect 
		Element[0:1] --> Element[*];
edge class ownedComment extends attribute connect 
		Element[0:*] --> Comment[*];

//A comment is a textual annotation that can be attached to a set of elements.
node class Comment extends Element {
	
	
}
edge class body_ extends association connect 
		Comment[0:1] --> String[*],
		OpaqueExpression[0:*] --> String[*],
		OpaqueBehavior[0:*] --> String[*],
		OpaqueAction[0:*] --> String[*];
edge class annotatedElement extends attribute connect 
		Comment[0:*] --> Element[*];

//A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.
abstract node class DirectedRelationship extends Relationship {
	
	
}
edge class source extends attribute connect 
		DirectedRelationship[1:*] --> Element[*],
		ActivityEdge[1:1] --> ActivityNode[*];
edge class target extends attribute connect 
		DirectedRelationship[1:*] --> Element[*],
		SendSignalAction[1:1] --> InputPin[*],
		CallOperationAction[1:1] --> InputPin[*],
		ActivityEdge[1:1] --> ActivityNode[*];

//A literal specification identifies a literal constant being modeled.
abstract node class LiteralSpecification extends ValueSpecification;

//A literal integer is a specification of an integer value.
node class LiteralInteger extends LiteralSpecification;

//A literal string is a specification of a string value.
node class LiteralString extends LiteralSpecification {
	
	
}

//A literal Boolean is a specification of a Boolean value.
node class LiteralBoolean extends LiteralSpecification;

//A literal null specifies the lack of a value.
node class LiteralNull extends LiteralSpecification;

//A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.
node class Constraint extends PackageableElement {
	
	
}
edge class constrainedElement extends attribute connect 
		Constraint[0:*] --> Element[*];
edge class specification extends attribute connect 
		Constraint[1:1] --> ValueSpecification[*],
		InstanceSpecification[0:1] --> ValueSpecification[*],
		Behavior[0:1] --> BehavioralFeature[*];
edge class context extends attribute connect 
		Constraint[0:1] --> Namespace[*],
		Behavior[0:1] --> BehavioredClassifier[*],
		Action[0:1] --> Classifier[*];

//An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.
node class ElementImport extends DirectedRelationship {
	
	visibility : VisibilityKind = VisibilityKind::public;
	
}
edge class alias extends association connect 
		ElementImport[0:1] --> String[*];
edge class importedElement extends attribute connect 
		ElementImport[1:1] --> PackageableElement[*];
edge class importingNamespace extends attribute connect 
		ElementImport[1:1] --> Namespace[*],
		PackageImport[1:1] --> Namespace[*];

//A typed element is a kind of named element that represents an element with a type.
abstract node class TypedElement extends NamedElement {
	
	
}
edge class type extends attribute connect 
		TypedElement[0:1] --> Type[*],
		Connector[0:1] --> Association[*],
		Operation[0:1] --> Type[*];

//A feature declares a behavioral or structural characteristic of instances of classifiers.
abstract node class Feature extends RedefinableElement {
	
	isStatic : boolean = false;
	
}
edge class featuringClassifier extends attribute connect 
		Feature[0:*] --> Classifier[*];

//A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.
abstract node class RedefinableElement extends NamedElement {
	
	isLeaf : boolean = false;
	
}
edge class redefinedElement extends attribute connect 
		RedefinableElement[0:*] --> RedefinableElement[*];
edge class redefinitionContext extends attribute connect 
		RedefinableElement[0:*] --> Classifier[*];

//A generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the features of the more general classifier.
node class Generalization extends DirectedRelationship {
	
	
}
edge class isSubstitutable extends association connect 
		Generalization[0:1] --> Boolean[*];
edge class specific extends attribute connect 
		Generalization[1:1] --> Classifier[*];
edge class general extends attribute connect 
		Generalization[1:1] --> Classifier[*],
		Classifier[0:*] --> Classifier[*];

//A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.
node class Parameter extends TypedElement, MultiplicityElement {
	
	direction : ParameterDirectionKind = ParameterDirectionKind::in;
	
}
edge class default extends association connect 
		Parameter[0:1] --> String[*],
		Property[0:1] --> String[*];
edge class defaultValue extends attribute connect 
		Parameter[0:1] --> ValueSpecification[*],
		Property[0:1] --> ValueSpecification[*];
edge class operation extends attribute connect 
		Parameter[0:1] --> Operation[*],
		CallOperationAction[1:1] --> Operation[*],
		SendOperationEvent[1:1] --> Operation[*],
		ReceiveOperationEvent[1:1] --> Operation[*],
		CallEvent[1:1] --> Operation[*];

//A structural feature is a typed feature of a classifier that specifies the structure of instances of the classifier.
abstract node class StructuralFeature extends Feature, TypedElement, MultiplicityElement;

//An instance specification is a model element that represents an instance in a modeled system.
node class InstanceSpecification extends PackageableElement {
	
	
}
edge class classifier extends attribute connect 
		InstanceSpecification[0:*] --> Classifier[*];
edge class slot extends attribute connect 
		InstanceSpecification[0:*] --> Slot[*];

//A slot specifies that an entity modeled by an instance specification has a value or values for a specific structural feature.
node class Slot extends Element {
	
	
}
edge class owningInstance extends attribute connect 
		Slot[1:1] --> InstanceSpecification[*];
edge class definingFeature extends attribute connect 
		Slot[1:1] --> StructuralFeature[*];

//A package is used to group elements, and provides a namespace for the grouped elements.
node class Package extends PackageableElement, Namespace {
	
	
}
edge class packageMerge extends attribute connect 
		Package[0:*] --> PackageMerge[*];
edge class packagedElement extends attribute connect 
		Package[0:*] --> PackageableElement[*];
edge class ownedType extends attribute connect 
		Package[0:*] --> Type[*];
edge class nestedPackage extends attribute connect 
		Package[0:*] --> Package[*];
edge class nestingPackage extends attribute connect 
		Package[0:1] --> Package[*];

//A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.
node class PackageImport extends DirectedRelationship {
	
	visibility : VisibilityKind = VisibilityKind::public;
	
}
edge class importedPackage extends attribute connect 
		PackageImport[1:1] --> Package[*];

//A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.
node class DataType extends Classifier {
	
	
}
edge class ownedAttribute extends attribute connect 
		DataType[0:*] --> Property[*],
		StructuredClassifier[0:*] --> Property[*],
		Class[0:*] --> Property[*],
		Interface[0:*] --> Property[*],
		Signal[0:*] --> Property[*];
edge class ownedOperation extends attribute connect 
		DataType[0:*] --> Operation[*],
		Class[0:*] --> Operation[*],
		Interface[0:*] --> Operation[*];

//An enumeration is a data type whose values are enumerated in the model as enumeration literals.
node class Enumeration extends DataType {
	
	
}
edge class ownedLiteral extends attribute connect 
		Enumeration[0:*] --> EnumerationLiteral[*];

//An enumeration literal is a user-defined data value for an enumeration.
node class EnumerationLiteral extends InstanceSpecification {
	
	
}
edge class enumeration extends attribute connect 
		EnumerationLiteral[0:1] --> Enumeration[*];

//A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.
node class PrimitiveType extends DataType;

//An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.
node class Association extends Relationship, Classifier {
	
	isDerived : boolean = false;
	
}
edge class ownedEnd extends attribute connect 
		Association[0:*] --> Property[*];
edge class endType extends attribute connect 
		Association[1:*] --> Type[*];
edge class memberEnd extends attribute connect 
		Association[2:*] --> Property[*];
edge class navigableOwnedEnd extends attribute connect 
		Association[0:*] --> Property[*];

//A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.
abstract node class ValueSpecification extends TypedElement, PackageableElement;

//Relationship is an abstract concept that specifies some kind of relationship between elements.
abstract node class Relationship extends Element {
	
	
}
edge class relatedElement extends attribute connect 
		Relationship[1:*] --> Element[*];

//A package merge defines how the contents of one package are extended by the contents of another package.
node class PackageMerge extends DirectedRelationship {
	
	
}
edge class receivingPackage extends attribute connect 
		PackageMerge[1:1] --> Package[*];
edge class mergedPackage extends attribute connect 
		PackageMerge[1:1] --> Package[*];

//An instance value is a value specification that identifies an instance.
node class InstanceValue extends ValueSpecification {
	
	
}
edge class instance extends attribute connect 
		InstanceValue[1:1] --> InstanceSpecification[*];

//A literal unlimited natural is a specification of an unlimited natural number.
node class LiteralUnlimitedNatural extends LiteralSpecification;

//A type is a named element that is used as the type for a typed element. A type can be contained in a package.
abstract node class Type extends PackageableElement {
	
	
}
edge class package extends attribute connect 
		Type[0:1] --> Package[*];

//An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.
node class Expression extends ValueSpecification {
	
	
}
edge class symbol extends association connect 
		Expression[0:1] --> String[*];
edge class operand extends attribute connect 
		Expression[0:*] --> ValueSpecification[*];

//Behavior is a specification of how its context classifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.
abstract node class Behavior extends Class {
	
	isReentrant : boolean = false;
	
}
edge class redefinedBehavior extends attribute connect 
		Behavior[0:*] --> Behavior[*];
edge class ownedParameter extends attribute connect 
		Behavior[0:*] --> Parameter[*],
		BehavioralFeature[0:*] --> Parameter[*],
		Operation[0:*] --> Parameter[*];
edge class precondition extends attribute connect 
		Behavior[0:*] --> Constraint[*],
		Operation[0:*] --> Constraint[*];
edge class postcondition extends attribute connect 
		Behavior[0:*] --> Constraint[*],
		Operation[0:*] --> Constraint[*];

//An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.
node class OpaqueExpression extends ValueSpecification {
	
	
}
edge class language extends association connect 
		OpaqueExpression[0:*] --> String[*],
		OpaqueBehavior[0:*] --> String[*],
		OpaqueAction[0:*] --> String[*];
edge class result extends attribute connect 
		OpaqueExpression[0:1] --> Parameter[*],
		CallAction[0:*] --> OutputPin[*];
edge class behavior extends attribute connect 
		OpaqueExpression[0:1] --> Behavior[*],
		CallBehaviorAction[1:1] --> Behavior[*],
		BehaviorExecutionSpecification[0:1] --> Behavior[*];

//An behavior with implementation-specific semantics.
node class OpaqueBehavior extends Behavior {
	
	
}

//A function behavior is an opaque behavior that does not access or modify any objects or other external data.
node class FunctionBehavior extends OpaqueBehavior;

//An action with implementation-specific semantics.
node class OpaqueAction extends Action {
	
	
}
edge class inputValue extends attribute connect 
		OpaqueAction[0:*] --> InputPin[*];
edge class outputValue extends attribute connect 
		OpaqueAction[0:*] --> OutputPin[*];

//An output pin is a pin that holds output values produced by an action.
node class OutputPin extends Pin;

//An input pin is a pin that holds input values to be consumed by an action.
node class InputPin extends Pin;

//InvocationAction is an abstract class for the various actions that invoke behavior.
abstract node class InvocationAction extends Action {
	
	
}
edge class argument extends attribute connect 
		InvocationAction[0:*] --> InputPin[*],
		Message[0:*] --> ValueSpecification[*];

//CallAction is an abstract class for actions that invoke behavior and receive return values.
abstract node class CallAction extends InvocationAction {
	
	isSynchronous : boolean = true;
	
}

//A send signal action is an action that creates a signal instance from its inputs, and transmits it to the target object, where it may cause the firing of a state machine transition or the execution of an activity. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor. If the input is already a signal instance, use a send object action.
node class SendSignalAction extends InvocationAction {
	
	
}
edge class signal extends attribute connect 
		SendSignalAction[1:1] --> Signal[*],
		SendSignalEvent[1:1] --> Signal[*],
		ReceiveSignalEvent[1:1] --> Signal[*],
		Reception[0:1] --> Signal[*],
		SignalEvent[1:1] --> Signal[*];

//A call operation action is an action that transmits an operation call request to the target object, where it may cause the invocation of associated behavior. The argument values of the action are available to the execution of the invoked behavior. If the action is marked synchronous, the execution of the call operation action waits until the execution of the invoked behavior completes and a reply transmission is returned to the caller; otherwise execution of the action is complete when the invocation of the operation is established and the execution of the invoked operation proceeds concurrently with the execution of the calling behavior. Any values returned as part of the reply transmission are put on the result output pins of the call operation action. Upon receipt of the reply transmission, execution of the call operation action is complete.
node class CallOperationAction extends CallAction {
	
	
}

//A call behavior action is a call action that invokes a behavior directly rather than invoking a behavioral feature that, in turn, results in the invocation of that behavior. The argument values of the action are available to the execution of the invoked behavior. For synchronous calls the execution of the call behavior action waits until the execution of the invoked behavior completes and a result is returned on its output pin. The action completes immediately without a result, if the call is asynchronous. In particular, the invoked behavior may be an activity.
node class CallBehaviorAction extends CallAction {
	
	
}

//A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.
abstract node class MultiplicityElement extends Element {
	
	isOrdered : boolean = false;
	isUnique : boolean = true;
	
}
edge class upper extends association connect 
		MultiplicityElement[0:1] --> UnlimitedNatural[*],
		Operation[0:1] --> UnlimitedNatural[*];
edge class lower extends association connect 
		MultiplicityElement[0:1] --> Integer[*],
		Operation[0:1] --> Integer[*];
edge class upperValue extends attribute connect 
		MultiplicityElement[0:1] --> ValueSpecification[*];
edge class lowerValue extends attribute connect 
		MultiplicityElement[0:1] --> ValueSpecification[*];

//An action is a named element that is the fundamental unit of executable functionality. The execution of an action represents some transformation or processing in the modeled system, be it a computer system or otherwise.
abstract node class Action extends ActivityNode {
	
	
}
edge class output extends attribute connect 
		Action[0:*] --> OutputPin[*];
edge class input extends attribute connect 
		Action[0:*] --> InputPin[*];

//An object node is an abstract activity node that is part of defining object flow in an activity.
abstract node class ObjectNode extends ActivityNode, TypedElement;

//A control node is an abstract activity node that coordinates flows in an activity.
abstract node class ControlNode extends ActivityNode;

//An activity edge is an abstract class for directed connections between two activity nodes.
abstract node class ActivityEdge extends RedefinableElement {
	
	
}
edge class activity extends attribute connect 
		ActivityEdge[0:1] --> Activity[*],
		ActivityNode[0:1] --> Activity[*];
edge class inGroup extends attribute connect 
		ActivityEdge[0:*] --> ActivityGroup[*],
		ActivityNode[0:*] --> ActivityGroup[*];
edge class redefinedEdge extends attribute connect 
		ActivityEdge[0:*] --> ActivityEdge[*];

//A control flow is an edge that starts an activity node after the previous one is finished.
node class ControlFlow extends ActivityEdge;

//An object flow is an activity edge that can have objects or data passing along it.
node class ObjectFlow extends ActivityEdge;

//An initial node is a control node at which flow starts when the activity is invoked.
node class InitialNode extends ControlNode;

//An activity final node is a final node that stops all flows in an activity.
node class ActivityFinalNode extends ControlNode;

//ActivityGroup is an abstract class for defining sets of nodes and edges in an activity.
abstract node class ActivityGroup extends Element {
	
	
}
edge class containedNode extends attribute connect 
		ActivityGroup[0:*] --> ActivityNode[*];
edge class inActivity extends attribute connect 
		ActivityGroup[0:1] --> Activity[*];
edge class subgroup extends attribute connect 
		ActivityGroup[0:*] --> ActivityGroup[*];
edge class superGroup extends attribute connect 
		ActivityGroup[0:1] --> ActivityGroup[*];
edge class containedEdge extends attribute connect 
		ActivityGroup[0:*] --> ActivityEdge[*];

//An activity parameter node is an object node for inputs and outputs to activities.
node class ActivityParameterNode extends ObjectNode {
	
	
}
edge class parameter extends attribute connect 
		ActivityParameterNode[1:1] --> Parameter[*];

//ActivityNode is an abstract class for points in the flow of an activity connected by edges.
abstract node class ActivityNode extends RedefinableElement {
	
	
}
edge class outgoing extends attribute connect 
		ActivityNode[0:*] --> ActivityEdge[*];
edge class incoming extends attribute connect 
		ActivityNode[0:*] --> ActivityEdge[*];
edge class redefinedNode extends attribute connect 
		ActivityNode[0:*] --> ActivityNode[*];

//A pin is a typed element and multiplicity element that provides values to actions and accept result values from them.
node class Pin extends MultiplicityElement, ObjectNode;

//An activity is the specification of parameterized behavior as the coordinated sequencing of subordinate units whose individual elements are actions.
node class Activity extends Behavior {
	
	isReadOnly : boolean = false;
	
}
edge class node_ extends attribute connect 
		Activity[0:*] --> ActivityNode[*];
edge class group extends attribute connect 
		Activity[0:*] --> ActivityGroup[*];
edge class edge_ extends attribute connect 
		Activity[0:*] --> ActivityEdge[*];

//A value pin is an input pin that provides a value by evaluating a value specification.
node class ValuePin extends InputPin {
	
	
}

//A usage is a relationship in which one element requires another element (or set of elements) for its full implementation or operation. A usage is a dependency in which the client requires the presence of the supplier.
node class Usage extends Dependency;

//An abstraction is a relationship that relates two elements or sets of elements that represent the same concept at different levels of abstraction or from different viewpoints.
node class Abstraction extends Dependency {
	
	
}
edge class mapping extends attribute connect 
		Abstraction[0:1] --> OpaqueExpression[*];

//A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s).
node class Dependency extends DirectedRelationship, PackageableElement {
	
	
}
edge class supplier extends attribute connect 
		Dependency[1:*] --> NamedElement[*];
edge class client extends attribute connect 
		Dependency[1:*] --> NamedElement[*];

//Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
node class Realization extends Abstraction;

//A substitution is a relationship between two classifiers signifies that the substituting classifier complies with the contract specified by the contract classifier. This implies that instances of the substituting classifier are runtime substitutable where instances of the contract classifier are expected.
node class Substitution extends Realization {
	
	
}
edge class contract extends attribute connect 
		Substitution[1:1] --> Classifier[*],
		InterfaceRealization[1:1] --> Interface[*];
edge class substitutingClassifier extends attribute connect 
		Substitution[1:1] --> Classifier[*];

//A named element is an element in a model that may have a name.
abstract node class NamedElement extends Element {
	
	
}
edge class name extends association connect 
		NamedElement[0:1] --> String[*];
edge class qualifiedName extends association connect 
		NamedElement[0:1] --> String[*];
edge class clientDependency extends attribute connect 
		NamedElement[0:*] --> Dependency[*];
edge class namespace extends attribute connect 
		NamedElement[0:1] --> Namespace[*];

//A packageable element indicates a named element that may be owned directly by a package.
abstract node class PackageableElement extends NamedElement;

//A namespace is an element in a model that contains a set of named elements that can be identified by name.
abstract node class Namespace extends NamedElement {
	
	
}
edge class elementImport extends attribute connect 
		Namespace[0:*] --> ElementImport[*];
edge class packageImport extends attribute connect 
		Namespace[0:*] --> PackageImport[*];
edge class ownedRule extends attribute connect 
		Namespace[0:*] --> Constraint[*];
edge class member extends attribute connect 
		Namespace[0:*] --> NamedElement[*];
edge class importedMember extends attribute connect 
		Namespace[0:*] --> PackageableElement[*];
edge class ownedMember extends attribute connect 
		Namespace[0:*] --> NamedElement[*];

//An interface realization is a specialized realization relationship between a classifier and an interface. This relationship signifies that the realizing classifier conforms to the contract specified by the interface.
node class InterfaceRealization extends Realization {
	
	
}
edge class implementingClassifier extends attribute connect 
		InterfaceRealization[1:1] --> BehavioredClassifier[*];

//A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector.
node class ConnectorEnd extends MultiplicityElement {
	
	
}
edge class definingEnd extends attribute connect 
		ConnectorEnd[0:1] --> Property[*];
edge class role extends attribute connect 
		ConnectorEnd[1:1] --> ConnectableElement[*],
		StructuredClassifier[0:*] --> ConnectableElement[*];

//Specifies a link that enables communication between two or more instances. This link may be an instance of an association, or it may represent the possibility of the instances being able to communicate because their identities are known by virtue of being passed in as parameters, held in variables or slots, or because the communicating instances are the same instance. The link may be realized by something as simple as a pointer or by something as complex as a network connection. In contrast to associations, which specify links between any instance of the associated classifiers, connectors specify links between instances playing the connected parts only.
node class Connector extends Feature {
	
	
}
edge class redefinedConnector extends attribute connect 
		Connector[0:*] --> Connector[*];
edge class end extends attribute connect 
		Connector[2:*] --> ConnectorEnd[*],
		ConnectableElement[0:*] --> ConnectorEnd[*];

//A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.
node class Property extends ConnectableElement, StructuralFeature {
	
	isDerived : boolean = false;
	isReadOnly : boolean = false;
	isDerivedUnion : boolean = false;
	aggregation : AggregationKind = AggregationKind::none;
	isComposite : boolean = false;
	
}
edge class class_ extends attribute connect 
		Property[0:1] --> Class[*],
		Operation[0:1] --> Class[*];
edge class redefinedProperty extends attribute connect 
		Property[0:*] --> Property[*];
edge class owningAssociation extends attribute connect 
		Property[0:1] --> Association[*];
edge class datatype extends attribute connect 
		Property[0:1] --> DataType[*],
		Operation[0:1] --> DataType[*];
edge class opposite extends attribute connect 
		Property[0:1] --> Property[*];
edge class subsettedProperty extends attribute connect 
		Property[0:*] --> Property[*];
edge class association_ extends attribute connect 
		Property[0:1] --> Association[*];

//A structured classifier is an abstract metaclass that represents any classifier whose behavior can be fully or partly described by the collaboration of owned or referenced instances.
abstract node class StructuredClassifier extends Classifier {
	
	
}
edge class part extends attribute connect 
		StructuredClassifier[0:*] --> Property[*];
edge class ownedConnector extends attribute connect 
		StructuredClassifier[0:*] --> Connector[*];

//ConnectableElement is an abstract metaclass representing a set of instances that play roles of a classifier. Connectable elements may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier.
abstract node class ConnectableElement extends TypedElement {
	
	
}

//An interaction is a unit of behavior that focuses on the observable exchange of information between connectable elements.
node class Interaction extends InteractionFragment, Behavior {
	
	
}
edge class lifeline extends attribute connect 
		Interaction[0:*] --> Lifeline[*];
edge class message extends attribute connect 
		Interaction[0:*] --> Message[*],
		MessageEnd[0:1] --> Message[*];
edge class fragment extends attribute connect 
		Interaction[0:*] --> InteractionFragment[*];
edge class action extends attribute connect 
		Interaction[0:*] --> Action[*],
		ActionExecutionSpecification[1:1] --> Action[*];

//A lifeline represents an individual participant in the interaction. While parts and structural features may have multiplicity greater than 1, lifelines represent only one interacting entity.
node class Lifeline extends NamedElement {
	
	
}
edge class coveredBy extends attribute connect 
		Lifeline[0:*] --> InteractionFragment[*];
edge class represents extends attribute connect 
		Lifeline[0:1] --> ConnectableElement[*];
edge class interaction extends attribute connect 
		Lifeline[1:1] --> Interaction[*],
		Message[1:1] --> Interaction[*];
edge class selector extends attribute connect 
		Lifeline[0:1] --> ValueSpecification[*];

//InteractionFragment is an abstract notion of the most general interaction unit. An interaction fragment is a piece of an interaction. Each interaction fragment is conceptually like an interaction by itself.
abstract node class InteractionFragment extends NamedElement {
	
	
}
edge class covered extends attribute connect 
		InteractionFragment[0:*] --> Lifeline[*],
		OccurrenceSpecification[1:1] --> Lifeline[*],
		StateInvariant[1:1] --> Lifeline[*];
edge class generalOrdering extends attribute connect 
		InteractionFragment[0:*] --> GeneralOrdering[*];
edge class enclosingInteraction extends attribute connect 
		InteractionFragment[0:1] --> Interaction[*];

//A message defines a particular communication between lifelines of an interaction.
node class Message extends NamedElement {
	
	messageKind : MessageKind = MessageKind::unknown;
	messageSort : MessageSort = MessageSort::synchCall;
	
}
edge class receiveEvent extends attribute connect 
		Message[0:1] --> MessageEnd[*];
edge class sendEvent extends attribute connect 
		Message[0:1] --> MessageEnd[*];
edge class connector extends attribute connect 
		Message[0:1] --> Connector[*];
edge class signature extends attribute connect 
		Message[0:1] --> NamedElement[*];

//A general ordering represents a binary relation between two occurrence specifications, to describe that one occurrence specification must occur before the other in a valid trace. This mechanism provides the ability to define partial orders of occurrence cpecifications that may otherwise not have a specified order.
node class GeneralOrdering extends NamedElement {
	
	
}
edge class before extends attribute connect 
		GeneralOrdering[1:1] --> OccurrenceSpecification[*];
edge class after extends attribute connect 
		GeneralOrdering[1:1] --> OccurrenceSpecification[*];

//An execution specification is a specification of the execution of a unit of behavior or action within the lifeline. The duration of an execution specification is represented by two cccurrence specifications, the start occurrence specification and the finish occurrence specification.
abstract node class ExecutionSpecification extends InteractionFragment {
	
	
}
edge class start extends attribute connect 
		ExecutionSpecification[1:1] --> OccurrenceSpecification[*];
edge class finish extends attribute connect 
		ExecutionSpecification[1:1] --> OccurrenceSpecification[*];

//An occurrence specification is the basic semantic unit of interactions. The sequences of occurrences specified by them are the meanings of interactions.
node class OccurrenceSpecification extends InteractionFragment {
	
	
}
edge class toAfter extends attribute connect 
		OccurrenceSpecification[0:*] --> GeneralOrdering[*];
edge class toBefore extends attribute connect 
		OccurrenceSpecification[0:*] --> GeneralOrdering[*];
edge class event extends attribute connect 
		OccurrenceSpecification[1:1] --> Event[*],
		ExecutionOccurrenceSpecification[1:1] --> ExecutionEvent[*],
		Trigger[1:1] --> Event[*];

//MessageEnd is an abstract specialization of NamedElement that represents what can occur at the end of a message.
abstract node class MessageEnd extends NamedElement {
	
	
}

//A state invariant is a runtime constraint on the participants of the interaction. It may be used to specify a variety of different kinds of constraints, such as values of attributes or variables, internal or external states, and so on. A state invariant is an interaction fragment and it is placed on a lifeline.
node class StateInvariant extends InteractionFragment {
	
	
}
edge class invariant extends attribute connect 
		StateInvariant[1:1] --> Constraint[*];

//An action execution specification is a kind of execution specification representing the execution of an action.
node class ActionExecutionSpecification extends ExecutionSpecification {
	
	
}

//A behavior execution specification is a kind of execution specification representing the execution of a behavior.
node class BehaviorExecutionSpecification extends ExecutionSpecification {
	
	
}

//An execution event models the start or finish of an execution occurrence.
node class ExecutionEvent extends Event;

//A creation event models the creation of an object.
node class CreationEvent extends Event;

//A destruction event models the destruction of an object.
node class DestructionEvent extends Event;

//A send operation event models the invocation of an operation call.
node class SendOperationEvent extends MessageEvent {
	
	
}

//A send signal event models the sending of a signal.
node class SendSignalEvent extends MessageEvent {
	
	
}

//A message occurrence specification pecifies the occurrence of message events, such as sending and receiving of signals or invoking or receiving of operation calls. A message occurrence specification is a kind of message end. Messages are generated either by synchronous operation calls or asynchronous signal sends. They are received by the execution of corresponding accept event actions.
node class MessageOccurrenceSpecification extends MessageEnd, OccurrenceSpecification;

//An execution occurrence specification represents moments in time at which actions or behaviors start or finish.
node class ExecutionOccurrenceSpecification extends OccurrenceSpecification {
	
	
}
edge class execution extends attribute connect 
		ExecutionOccurrenceSpecification[1:1] --> ExecutionSpecification[*];

//A receive operation event specifies the event of receiving an operation invocation for a particular operation by the target entity.
node class ReceiveOperationEvent extends MessageEvent {
	
	
}

//A receive signal event specifies the event of receiving a signal by the target entity.
node class ReceiveSignalEvent extends MessageEvent {
	
	
}

//An actor specifies a role played by a user or any other system that interacts with the subject.
node class Actor extends BehavioredClassifier;

//A relationship from an extending use case to an extended use case that specifies how and when the behavior defined in the extending use case can be inserted into the behavior defined in the extended use case.
node class Extend extends DirectedRelationship, NamedElement {
	
	
}
edge class extendedCase extends attribute connect 
		Extend[1:1] --> UseCase[*];
edge class extension extends attribute connect 
		Extend[1:1] --> UseCase[*];
edge class condition extends attribute connect 
		Extend[0:1] --> Constraint[*];
edge class extensionLocation extends attribute connect 
		Extend[1:*] --> ExtensionPoint[*];

//An include relationship defines that a use case contains the behavior defined in another use case.
node class Include extends DirectedRelationship, NamedElement {
	
	
}
edge class includingCase extends attribute connect 
		Include[1:1] --> UseCase[*];
edge class addition extends attribute connect 
		Include[1:1] --> UseCase[*];

//A use case is the specification of a set of actions performed by a system, which yields an observable result that is, typically, of value for one or more actors or other stakeholders of the system.
node class UseCase extends BehavioredClassifier {
	
	
}
edge class include_ extends attribute connect 
		UseCase[0:*] --> Include[*];
edge class extend extends attribute connect 
		UseCase[0:*] --> Extend[*];
edge class extensionPoint extends attribute connect 
		UseCase[0:*] --> ExtensionPoint[*];
edge class subject extends attribute connect 
		UseCase[0:*] --> Classifier[*];

//An extension point identifies a point in the behavior of a use case where that behavior can be extended by the behavior of some other (extending) use case, as specified by an extend relationship.
node class ExtensionPoint extends RedefinableElement {
	
	
}
edge class useCase extends attribute connect 
		ExtensionPoint[1:1] --> UseCase[*],
		Classifier[0:*] --> UseCase[*];

//A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.
abstract node class Classifier extends RedefinableElement, Type, Namespace {
	
	isAbstract : boolean = false;
	
}
edge class generalization extends attribute connect 
		Classifier[0:*] --> Generalization[*];
edge class feature extends attribute connect 
		Classifier[0:*] --> Feature[*];
edge class inheritedMember extends attribute connect 
		Classifier[0:*] --> NamedElement[*];
edge class redefinedClassifier extends attribute connect 
		Classifier[0:*] --> Classifier[*];
edge class substitution extends attribute connect 
		Classifier[0:*] --> Substitution[*];
edge class attribute_ extends attribute connect 
		Classifier[0:*] --> Property[*];
edge class ownedUseCase extends attribute connect 
		Classifier[0:*] --> UseCase[*];

//A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
abstract node class BehavioralFeature extends Feature, Namespace {
	
	isAbstract : boolean = false;
	concurrency : CallConcurrencyKind = CallConcurrencyKind::sequential;
	
}
edge class method extends attribute connect 
		BehavioralFeature[0:*] --> Behavior[*];
edge class raisedException extends attribute connect 
		BehavioralFeature[0:*] --> Type[*],
		Operation[0:*] --> Type[*];

//A call event models the receipt by an object of a message invoking a call of an operation.
node class CallEvent extends MessageEvent {
	
	
}

//A change event models a change in the system configuration that makes a condition true.
node class ChangeEvent extends Event {
	
	
}
edge class changeExpression extends attribute connect 
		ChangeEvent[1:1] --> ValueSpecification[*];

//A class describes a set of objects that share the same specifications of features, constraints, and semantics.
node class Class extends BehavioredClassifier {
	
	isAbstract : boolean = false;
	isActive : boolean = false;
	
}
edge class nestedClassifier extends attribute connect 
		Class[0:*] --> Classifier[*],
		Interface[0:*] --> Classifier[*];
edge class superClass extends attribute connect 
		Class[0:*] --> Class[*];
edge class ownedReception extends attribute connect 
		Class[0:*] --> Reception[*],
		Interface[0:*] --> Reception[*];

//A trigger relates an event to a behavior that may affect an instance of the classifier.
node class Trigger extends NamedElement {
	
	
}

//An interface is a kind of classifier that represents a declaration of a set of coherent public features and obligations. An interface specifies a contract; any instance of a classifier that realizes the interface must fulfill that contract. The obligations that may be associated with an interface are in the form of various kinds of constraints (such as pre- and post-conditions) or protocol specifications, which may impose ordering restrictions on interactions through the interface.
node class Interface extends Classifier {
	
	
}
edge class redefinedInterface extends attribute connect 
		Interface[0:*] --> Interface[*];

//A reception is a declaration stating that a classifier is prepared to react to the receipt of a signal. A reception designates a signal and specifies the expected behavioral response. The details of handling a signal are specified by the behavior associated with the reception or the classifier itself.
node class Reception extends BehavioralFeature {
	
	
}

//A signal is a specification of send request instances communicated between objects. The receiving object handles the received request instances as specified by its receptions. The data carried by a send request (which was passed to it by the send invocation occurrence that caused that request) are represented as attributes of the signal. A signal is defined independently of the classifiers handling the signal occurrence.
node class Signal extends Classifier {
	
	
}

//A signal event represents the receipt of an asynchronous signal instance. A signal event may, for example, cause a state machine to trigger a transition.
node class SignalEvent extends MessageEvent {
	
	
}

//A time event specifies a point in time. At the specified time, the event occurs.
node class TimeEvent extends Event {
	
	isRelative : boolean = false;
	
}
edge class when extends attribute connect 
		TimeEvent[1:1] --> ValueSpecification[*];

//A message event specifies the receipt by an object of either a call or a signal.
abstract node class MessageEvent extends Event;

//A transition trigger associated with an any receive event specifies that the transition is to be triggered by the receipt of any message that is not explicitly referenced in another transition from the same vertex.
node class AnyReceiveEvent extends MessageEvent;

//A behaviored classifier may have an interface realization.
abstract node class BehavioredClassifier extends Classifier {
	
	
}
edge class ownedBehavior extends attribute connect 
		BehavioredClassifier[0:*] --> Behavior[*];
edge class classifierBehavior extends attribute connect 
		BehavioredClassifier[0:1] --> Behavior[*];
edge class interfaceRealization extends attribute connect 
		BehavioredClassifier[0:*] --> InterfaceRealization[*];
edge class ownedTrigger extends attribute connect 
		BehavioredClassifier[0:*] --> Trigger[*];

//An event is the specification of some occurrence that may potentially trigger effects by an object.
abstract node class Event extends PackageableElement;

//An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.
node class Operation extends BehavioralFeature {
	
	isQuery : boolean = false;
	isOrdered : boolean = false;
	isUnique : boolean = true;
	
}
edge class redefinedOperation extends attribute connect 
		Operation[0:*] --> Operation[*];
edge class bodyCondition extends attribute connect 
		Operation[0:1] --> Constraint[*];
edge class interface extends attribute connect 
		Operation[0:1] --> Interface[*];