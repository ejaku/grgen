abstract edge class association;
abstract edge class attribute;

//An integer is a primitive type representing integer values.
node class Integer {
	
	value : int;

}

//A Boolean type is used for logical expression, consisting of the predefined values true and false.
node class Boolean {
	
	value : boolean;

}

//A string is a sequence of characters in some suitable character set used to display information about the model. Character sets may include non-Roman alphabets and characters.
node class String {
	
	value : string;

}

//An unlimited natural is a primitive type representing unlimited natural values.
node class UnlimitedNatural {
	
	value : int;

}

//AggregationKind is an enumeration type that specifies the literals for defining the kind of aggregation of a property.
enum AggregationKind {
	
	//Indicates that the property has no aggregation.
	none, 
	//Indicates that the property has a shared aggregation.
	shared, 
	//Indicates that the property is aggregated compositely, i.e., the composite object has responsibility for the existence and storage of the composed objects (parts).
	composite
	
}

node class AggregationKind_Value {
	
	value : AggregationKind;
	
}

//Parameter direction kind is an enumeration type that defines literals used to specify direction of parameters.
enum ParameterDirectionKind {
	
	//Indicates that parameter values are passed into the behavioral element by the caller.
	in, 
	//Indicates that parameter values are passed into a behavioral element by the caller and then back out to the caller from the behavioral element.
	inout, 
	//Indicates that parameter values are passed from a behavioral element out to the caller.
	out, 
	//Indicates that parameter values are passed as return values from a behavioral element back to the caller.
	return_
	
}

node class ParameterDirectionKind_Value {
	
	value : ParameterDirectionKind;
	
}

//VisibilityKind is an enumeration type that defines literals to determine the visibility of elements in a model.
enum VisibilityKind {
	
	//A public element is visible to all elements that can access the contents of the namespace that owns it.
	public, 
	//A private element is only visible inside the namespace that owns it.
	private, 
	//A protected element is visible to elements that have a generalization relationship to the namespace that owns it.
	protected, 
	//A package element is owned by a namespace that is not a package, and is visible to elements that are in the same package as its owning namespace. Only named elements that are not owned by packages can be marked as having package visibility. Any element marked as having package visibility is visible to all elements within the nearest enclosing package (given that other owning elements have proper visibility). Outside the nearest enclosing package, an element marked as having package visibility is not visible.
	package
	
}

node class VisibilityKind_Value {
	
	value : VisibilityKind;
	
}

//This is an enumerated type that identifies the type of message.
enum MessageKind {
	
	//sendEvent and receiveEvent are present
	complete, 
	//sendEvent present and receiveEvent absent
	lost, 
	//sendEvent absent and receiveEvent present
	found, 
	//sendEvent and receiveEvent absent (should not appear)
	unknown
	
}

node class MessageKind_Value {
	
	value : MessageKind;
	
}

//This is an enumerated type that identifies the type of communication action that was used to generate the message.
enum MessageSort {
	
	//The message was generated by a synchronous call to an operation.
	synchCall, 
	//The message was generated by an asynchronous call to an operation; i.e., a CallAction with isSynchronous = false.
	asynchCall, 
	//The message was generated by an asynchronous send action.
	asynchSignal, 
	//The message designating the creation of another lifeline object.
	createMessage, 
	//The message designating the termination of another lifeline.
	deleteMessage, 
	//The message is a reply message to an operation call.
	reply
	
}

node class MessageSort_Value {
	
	value : MessageSort;
	
}

//CallConcurrencyKind is an enumeration type.
enum CallConcurrencyKind {
	
	//No concurrency management mechanism is associated with the operation and, therefore, concurrency conflicts may occur. Instances that invoke a behavioral feature need to coordinate so that only one invocation to a target on any behavioral feature occurs at once.
	sequential, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance, but only one is allowed to commence. The others are blocked until the performance of the first behavioral feature is complete. It is the responsibility of the system designer to ensure that deadlocks do not occur due to simultaneous blocks.
	guarded, 
	//Multiple invocations of a behavioral feature may occur simultaneously to one instance and all of them may proceed concurrently.
	concurrent
	
}

node class CallConcurrencyKind_Value {
	
	value : CallConcurrencyKind;
	
}

//ConnectorKind is an enumeration type.
enum ConnectorKind {
	
	//Indicates that the connector is an assembly connector.
	assembly, 
	//Indicates that the connector is a delegation connector.
	delegation
	
}

node class ConnectorKind_Value {
	
	value : ConnectorKind;
	
}

//InteractionOperatorKind is an enumeration designating the different kinds of operators of combined fragments. The interaction operand defines the type of operator of a combined fragment.
enum InteractionOperatorKind {
	
	//The interactionOperator seq designates that the CombinedFragment represents a weak sequencing between the behaviors of the operands.
	seq, 
	//The interactionOperator alt designates that the CombinedFragment represents a choice of behavior. At most one of the operands will be chosen. The chosen operand must have an explicit or implicit guard expression that evaluates to true at this point in the interaction. An implicit true guard is implied if the operand has no guard.
	alt, 
	//The interactionOperator opt designates that the CombinedFragment represents a choice of behavior where either the (sole) operand happens or nothing happens. An option is semantically equivalent to an alternative CombinedFragment where there is one operand with non-empty content and the second operand is empty.
	opt, 
	//The interactionOperator break designates that the CombinedFragment represents a breaking scenario in the sense that the operand is a scenario that is performed instead of the remainder of the enclosing InteractionFragment. A break operator with a guard is chosen when the guard is true and the rest of the enclosing Interaction Fragment is ignored. When the guard of the break operand is false, the break operand is ignored and the rest of the enclosing InteractionFragment is chosen. The choice between a break operand without a guard and the rest of the enclosing InteractionFragment is done non-deterministically.
	break, 
	//The interactionOperator par designates that the CombinedFragment represents a parallel merge between the behaviors of the operands. The OccurrenceSpecifications of the different operands can be interleaved in any way as long as the ordering imposed by each operand as such is preserved.
	par, 
	//The interactionOperator strict designates that the CombinedFragment represents a strict sequencing between the behaviors of the operands. The semantics of strict sequencing defines a strict ordering of the operands on the first level within the CombinedFragment with interactionOperator strict. Therefore OccurrenceSpecifications within contained CombinedFragment will not directly be compared with other OccurrenceSpecifications of the enclosing CombinedFragment.
	strict, 
	//The interactionOperator loop designates that the CombinedFragment represents a loop. The loop operand will be repeated a number of times.
	loop, 
	//The interactionOperator critical designates that the CombinedFragment represents a critical region. A critical region means that the traces of the region cannot be interleaved by other OccurrenceSpecifications (on those Lifelines covered by the region). This means that the region is treated atomically by the enclosing fragment when determining the set of valid traces. Even though enclosing CombinedFragments may imply that some OccurrenceSpecifications may interleave into the region, such as e.g. with par-operator, this is prevented by defining a region.
	critical, 
	//The interactionOperator neg designates that the CombinedFragment represents traces that are defined to be invalid.
	neg, 
	//The interactionOperator assert designates that the CombinedFragment represents an assertion. The sequences of the operand of the assertion are the only valid continuations. All other continuations result in an invalid trace.
	assert, 
	//The interacionOperator ignore designates that there are some message types that are not shown within this combined fragment. These message types can be considered insignificant and are implicitly ignored if they appear in a corresponding execution. Alternatively, one can understand ignore to mean that the message types that are ignored can appear anywhere in the traces.
	ignore, 
	//The interactionOperator consider designates which messages should be considered within this combined fragment. This is equivalent to defining every other message to be ignored.
	consider
	
}

node class InteractionOperatorKind_Value {
	
	value : InteractionOperatorKind;
	
}

//PseudostateKind is an enumeration type.
enum PseudostateKind {
	
	//An initial pseudostate represents a default vertex that is the source for a single transition to the default state of a composite state. There can be at most one initial vertex in a region. The outgoing transition from the initial vertex may have a behavior, but not a trigger or guard.
	initial, 
	//DeepHistory represents the most recent active configuration of the composite state that directly contains this pseudostate; e.g. the state configuration that was active when the composite state was last exited. A composite state can have at most one deep history vertex. At most one transition may originate from the history connector to the default deep history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a deep history are performed.
	deepHistory, 
	//ShallowHistory represents the most recent active substate of its containing state (but not the substates of that substate). A composite state can have at most one shallow history vertex. A transition coming into the shallow history vertex is equivalent to a transition coming into the most recent active substate of a state. At most one transition may originate from the history connector to the default shallow history state. This transition is taken in case the composite state had never been active before. Entry actions of states entered on the path to the state represented by a shallow history are performed.
	shallowHistory, 
	//Join vertices serve to merge several transitions emanating from source vertices in different orthogonal regions. The transitions entering a join vertex cannot have guards or triggers.
	join, 
	//Fork vertices serve to split an incoming transition into two or more transitions terminating on orthogonal target vertices (i.e. vertices in different regions of a composite state). The segments outgoing from a fork vertex must not have guards or triggers.
	fork, 
	//Junction vertices are semantic-free vertices that are used to chain together multiple transitions. They are used to construct compound transition paths between states. For example, a junction can be used to converge multiple incoming transitions into a single outgoing transition representing a shared transition path (this is known as an merge). Conversely, they can be used to split an incoming transition into multiple outgoing transition segments with different guard conditions. This realizes a static conditional branch. (In the latter case, outgoing transitions whose guard conditions evaluate to false are disabled. A predefined guard denoted 'else' may be defined for at most one outgoing transition. This transition is enabled if all the guards labeling the other transitions are false.) Static conditional branches are distinct from dynamic conditional branches that are realized by choice vertices (described below).
	junction, 
	//Choice vertices which, when reached, result in the dynamic evaluation of the guards of the triggers of its outgoing transitions. This realizes a dynamic conditional branch. It allows splitting of transitions into multiple outgoing paths such that the decision on which path to take may be a function of the results of prior actions performed in the same run-tocompletion step. If more than one of the guards evaluates to true, an arbitrary one is selected. If none of the guards evaluates to true, then the model is considered ill-formed. (To avoid this, it is recommended to define one outgoing transition with the predefined else guard for every choice vertex.) Choice vertices should be distinguished from static branch points that are based on junction points (described above).
	choice, 
	//An entry point pseudostate is an entry point of a state machine or composite state. In each region of the state machine or composite state it has a single transition to a vertex within the same region.
	entryPoint, 
	//An exit point pseudostate is an exit point of a state machine or composite state. Entering an exit point within any region of the composite state or state machine referenced by a submachine state implies the exit of this composite state or submachine state and the triggering of the transition that has this exit point as source in the state machine enclosing the submachine or composite state.
	exitPoint, 
	//Entering a terminate pseudostate implies that the execution of this state machine by means of its context object is terminated. The state machine does not exit any states nor does it perform any exit actions other than those associated with the transition leading to the terminate pseudostate. Entering a terminate pseudostate is equivalent to invoking a DestroyObjectAction.
	terminate
	
}

node class PseudostateKind_Value {
	
	value : PseudostateKind;
	
}

//TransitionKind is an enumeration type.
enum TransitionKind {
	
	//Implies that the transition, if triggered, occurs without exiting or entering the source state. Thus, it does not cause a state change. This means that the entry or exit condition of the source state will not be invoked. An internal transition can be taken even if the state machine is in one or more regions nested within this state.
	internal, 
	//Implies that the transition, if triggered, will not exit the composite (source) state, but it will apply to any state within the composite state, and these will be exited and entered.
	local, 
	//Implies that the transition, if triggered, will exit the composite (source) state.
	external
	
}

node class TransitionKind_Value {
	
	value : TransitionKind;
	
}

//A comment is a textual annotation that can be attached to a set of elements.
node class Comment extends Element {
	
	
}
edge class body_ extends association connect 
		Comment[0:1] -> String[*],
		OpaqueExpression[0:*] -> String[*],
		OpaqueBehavior[0:*] -> String[*],
		OpaqueAction[0:*] -> String[*],
		Clause[0:*] -> ExecutableNode[*];
edge class annotatedElement extends attribute connect 
		Comment[0:*] -> Element[*];

//A directed relationship represents a relationship between a collection of source model elements and a collection of target model elements.
abstract node class DirectedRelationship extends Relationship {
	
	
}
edge class source extends attribute connect 
		DirectedRelationship[1:*] -> Element[*],
		ActivityEdge[1:1] -> ActivityNode[*],
		Transition[1:1] -> Vertex[*];
edge class target extends attribute connect 
		DirectedRelationship[1:*] -> Element[*],
		SendSignalAction[1:1] -> InputPin[*],
		CallOperationAction[1:1] -> InputPin[*],
		ActivityEdge[1:1] -> ActivityNode[*],
		DestroyObjectAction[1:1] -> InputPin[*],
		SendObjectAction[1:1] -> InputPin[*],
		Transition[1:1] -> Vertex[*];

//A literal specification identifies a literal constant being modeled.
abstract node class LiteralSpecification extends ValueSpecification;

//A literal integer is a specification of an integer value.
node class LiteralInteger extends LiteralSpecification;

//A literal string is a specification of a string value.
node class LiteralString extends LiteralSpecification {
	
	
}

//A literal Boolean is a specification of a Boolean value.
node class LiteralBoolean extends LiteralSpecification;

//A literal null specifies the lack of a value.
node class LiteralNull extends LiteralSpecification;

//A constraint is a condition or restriction expressed in natural language text or in a machine readable language for the purpose of declaring some of the semantics of an element.
node class Constraint extends PackageableElement {
	
	
}
edge class constrainedElement extends attribute connect 
		Constraint[0:*] -> Element[*];
edge class specification extends attribute connect 
		Constraint[1:1] -> ValueSpecification[*],
		Behavior[0:1] -> BehavioralFeature[*],
		InstanceSpecification[0:1] -> ValueSpecification[*],
		TimeConstraint[1:1] -> TimeInterval[*],
		DurationConstraint[1:1] -> DurationInterval[*],
		IntervalConstraint[1:1] -> Interval[*];
edge class context extends attribute connect 
		Constraint[0:1] -> Namespace[*],
		Behavior[0:1] -> BehavioredClassifier[*],
		Action[0:1] -> Classifier[*];

//An element import identifies an element in another package, and allows the element to be referenced using its name without a qualifier.
node class ElementImport extends DirectedRelationship {
	
	visibility : VisibilityKind = VisibilityKind::public;
	
}
edge class alias extends association connect 
		ElementImport[0:1] -> String[*];
edge class importedElement extends attribute connect 
		ElementImport[1:1] -> PackageableElement[*];
edge class importingNamespace extends attribute connect 
		ElementImport[1:1] -> Namespace[*],
		PackageImport[1:1] -> Namespace[*];

//A typed element is a kind of named element that represents an element with a type.
abstract node class TypedElement extends NamedElement {
	
	
}
edge class type extends attribute connect 
		TypedElement[0:1] -> Type[*],
		Operation[0:1] -> Type[*],
		Connector[0:1] -> Association[*],
		ExtensionEnd[1:1] -> Stereotype[*];

//A feature declares a behavioral or structural characteristic of instances of classifiers.
abstract node class Feature extends RedefinableElement {
	
	isStatic : boolean = false;
	
}
edge class featuringClassifier extends attribute connect 
		Feature[0:*] -> Classifier[*];

//A redefinable element is an element that, when defined in the context of a classifier, can be redefined more specifically or differently in the context of another classifier that specializes (directly or indirectly) the context classifier.
abstract node class RedefinableElement extends NamedElement {
	
	isLeaf : boolean = false;
	
}
edge class redefinedElement extends attribute connect 
		RedefinableElement[0:*] -> RedefinableElement[*];
edge class redefinitionContext extends attribute connect 
		RedefinableElement[0:*] -> Classifier[*],
		State[1:1] -> Classifier[*],
		Transition[1:1] -> Classifier[*],
		Region[1:1] -> Classifier[*];

//A generalization is a taxonomic relationship between a more general classifier and a more specific classifier. Each instance of the specific classifier is also an indirect instance of the general classifier. Thus, the specific classifier inherits the features of the more general classifier.
node class Generalization extends DirectedRelationship {
	
	
}
edge class isSubstitutable extends association connect 
		Generalization[0:1] -> Boolean[*];
edge class specific extends attribute connect 
		Generalization[1:1] -> Classifier[*];
edge class general extends attribute connect 
		Generalization[1:1] -> Classifier[*],
		Classifier[0:*] -> Classifier[*];

//A parameter is a specification of an argument used to pass information into or out of an invocation of a behavioral feature.
node class Parameter extends TypedElement, MultiplicityElement {
	
	direction : ParameterDirectionKind = ParameterDirectionKind::in;
	
}
edge class default extends association connect 
		Parameter[0:1] -> String[*],
		Property[0:1] -> String[*];
edge class defaultValue extends attribute connect 
		Parameter[0:1] -> ValueSpecification[*],
		Property[0:1] -> ValueSpecification[*];
edge class operation extends attribute connect 
		Parameter[0:1] -> Operation[*],
		CallOperationAction[1:1] -> Operation[*],
		SendOperationEvent[1:1] -> Operation[*],
		ReceiveOperationEvent[1:1] -> Operation[*],
		CallEvent[1:1] -> Operation[*];

//A structural feature is a typed feature of a classifier that specifies the structure of instances of the classifier.
abstract node class StructuralFeature extends Feature, TypedElement, MultiplicityElement;

//A slot specifies that an entity modeled by an instance specification has a value or values for a specific structural feature.
node class Slot extends Element {
	
	
}
edge class owningInstance extends attribute connect 
		Slot[1:1] -> InstanceSpecification[*];
edge class definingFeature extends attribute connect 
		Slot[1:1] -> StructuralFeature[*];

//A package import is a relationship that allows the use of unqualified names to refer to package members from other namespaces.
node class PackageImport extends DirectedRelationship {
	
	visibility : VisibilityKind = VisibilityKind::public;
	
}
edge class importedPackage extends attribute connect 
		PackageImport[1:1] -> Package[*];

//A data type is a type whose instances are identified only by their value. A data type may contain attributes to support the modeling of structured data types.
node class DataType extends Classifier {
	
	
}
edge class ownedAttribute extends attribute connect 
		DataType[0:*] -> Property[*],
		StructuredClassifier[0:*] -> Property[*],
		Interface[0:*] -> Property[*],
		Signal[0:*] -> Property[*],
		Artifact[0:*] -> Property[*],
		Class[0:*] -> Property[*];
edge class ownedOperation extends attribute connect 
		DataType[0:*] -> Operation[*],
		Interface[0:*] -> Operation[*],
		Artifact[0:*] -> Operation[*],
		Class[0:*] -> Operation[*];

//An enumeration is a data type whose values are enumerated in the model as enumeration literals.
node class Enumeration extends DataType {
	
	
}
edge class ownedLiteral extends attribute connect 
		Enumeration[0:*] -> EnumerationLiteral[*];

//An enumeration literal is a user-defined data value for an enumeration.
node class EnumerationLiteral extends InstanceSpecification {
	
	
}
edge class enumeration extends attribute connect 
		EnumerationLiteral[0:1] -> Enumeration[*];

//A primitive type defines a predefined data type, without any relevant substructure (i.e., it has no parts in the context of UML). A primitive datatype may have an algebra and operations defined outside of UML, for example, mathematically.
node class PrimitiveType extends DataType;

//An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a link.
node class Association extends Relationship, Classifier {
	
	isDerived : boolean = false;
	
}
edge class ownedEnd extends attribute connect 
		Association[0:*] -> Property[*],
		Extension[1:1] -> ExtensionEnd[*];
edge class endType extends attribute connect 
		Association[1:*] -> Type[*];
edge class memberEnd extends attribute connect 
		Association[2:*] -> Property[*];
edge class navigableOwnedEnd extends attribute connect 
		Association[0:*] -> Property[*];

//A value specification is the specification of a (possibly empty) set of instances, including both objects and data values.
abstract node class ValueSpecification extends TypedElement, PackageableElement;

//Relationship is an abstract concept that specifies some kind of relationship between elements.
abstract node class Relationship extends Element {
	
	
}
edge class relatedElement extends attribute connect 
		Relationship[1:*] -> Element[*];

//A package merge defines how the contents of one package are extended by the contents of another package.
node class PackageMerge extends DirectedRelationship {
	
	
}
edge class receivingPackage extends attribute connect 
		PackageMerge[1:1] -> Package[*];
edge class mergedPackage extends attribute connect 
		PackageMerge[1:1] -> Package[*];

//An instance value is a value specification that identifies an instance.
node class InstanceValue extends ValueSpecification {
	
	
}
edge class instance extends attribute connect 
		InstanceValue[1:1] -> InstanceSpecification[*];

//A literal unlimited natural is a specification of an unlimited natural number.
node class LiteralUnlimitedNatural extends LiteralSpecification;

//A type is a named element that is used as the type for a typed element. A type can be contained in a package.
abstract node class Type extends PackageableElement {
	
	
}
edge class package extends attribute connect 
		Type[0:1] -> Package[*];

//An expression is a structured tree of symbols that denotes a (possibly empty) set of values when evaluated in a context.
node class Expression extends ValueSpecification {
	
	
}
edge class symbol extends association connect 
		Expression[0:1] -> String[*];
edge class operand extends attribute connect 
		Expression[0:*] -> ValueSpecification[*],
		CombinedFragment[1:*] -> InteractionOperand[*];

//Behavior is a specification of how its context classifier changes state over time. This specification may be either a definition of possible behavior execution or emergent behavior, or a selective illustration of an interesting subset of possible executions. The latter form is typically used for capturing examples, such as a trace of a particular execution.
abstract node class Behavior extends Class {
	
	isReentrant : boolean = false;
	
}
edge class redefinedBehavior extends attribute connect 
		Behavior[0:*] -> Behavior[*];
edge class ownedParameter extends attribute connect 
		Behavior[0:*] -> Parameter[*],
		BehavioralFeature[0:*] -> Parameter[*],
		Operation[0:*] -> Parameter[*];
edge class precondition extends attribute connect 
		Behavior[0:*] -> Constraint[*],
		Operation[0:*] -> Constraint[*];
edge class postcondition extends attribute connect 
		Behavior[0:*] -> Constraint[*],
		Operation[0:*] -> Constraint[*];

//An opaque expression is an uninterpreted textual statement that denotes a (possibly empty) set of values when evaluated in a context.
node class OpaqueExpression extends ValueSpecification {
	
	
}

edge class language extends association connect 
		OpaqueExpression[0:*] -> String[*],
		OpaqueBehavior[0:*] -> String[*],
		OpaqueAction[0:*] -> String[*];
edge class result extends attribute connect 
		OpaqueExpression[0:1] -> Parameter[*],
		CallAction[0:*] -> OutputPin[*],
		CreateObjectAction[1:1] -> OutputPin[*],
		TestIdentityAction[1:1] -> OutputPin[*],
		ReadSelfAction[1:1] -> OutputPin[*],
		ReadStructuralFeatureAction[1:1] -> OutputPin[*],
		ReadLinkAction[1:1] -> OutputPin[*],
		ValueSpecificationAction[1:1] -> OutputPin[*],
		ReadVariableAction[1:1] -> OutputPin[*];
edge class behavior extends attribute connect 
		OpaqueExpression[0:1] -> Behavior[*],
		CallBehaviorAction[1:1] -> Behavior[*],
		BehaviorExecutionSpecification[0:1] -> Behavior[*];

//An behavior with implementation-specific semantics.
node class OpaqueBehavior extends Behavior {
	
	
}

//A function behavior is an opaque behavior that does not access or modify any objects or other external data.
node class FunctionBehavior extends OpaqueBehavior;

//An action with implementation-specific semantics.
node class OpaqueAction extends Action {
	
	
}
edge class inputValue extends attribute connect 
		OpaqueAction[0:*] -> InputPin[*],
		LinkAction[1:*] -> InputPin[*];
edge class outputValue extends attribute connect 
		OpaqueAction[0:*] -> OutputPin[*];

//CallAction is an abstract class for actions that invoke behavior and receive return values.
abstract node class CallAction extends InvocationAction {
	
	isSynchronous : boolean = true;
	
}

//A send signal action is an action that creates a signal instance from its inputs, and transmits it to the target object, where it may cause the firing of a state machine transition or the execution of an activity. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor. If the input is already a signal instance, use a send object action.
node class SendSignalAction extends InvocationAction {
	
	
}
edge class signal extends attribute connect 
		SendSignalAction[1:1] -> Signal[*],
		SendSignalEvent[1:1] -> Signal[*],
		ReceiveSignalEvent[1:1] -> Signal[*],
		Reception[0:1] -> Signal[*],
		SignalEvent[1:1] -> Signal[*],
		BroadcastSignalAction[1:1] -> Signal[*];

//A call operation action is an action that transmits an operation call request to the target object, where it may cause the invocation of associated behavior. The argument values of the action are available to the execution of the invoked behavior. If the action is marked synchronous, the execution of the call operation action waits until the execution of the invoked behavior completes and a reply transmission is returned to the caller; otherwise execution of the action is complete when the invocation of the operation is established and the execution of the invoked operation proceeds concurrently with the execution of the calling behavior. Any values returned as part of the reply transmission are put on the result output pins of the call operation action. Upon receipt of the reply transmission, execution of the call operation action is complete.
node class CallOperationAction extends CallAction {
	
	
}

//A call behavior action is a call action that invokes a behavior directly rather than invoking a behavioral feature that, in turn, results in the invocation of that behavior. The argument values of the action are available to the execution of the invoked behavior. For synchronous calls the execution of the call behavior action waits until the execution of the invoked behavior completes and a result is returned on its output pin. The action completes immediately without a result, if the call is asynchronous. In particular, the invoked behavior may be an activity.
node class CallBehaviorAction extends CallAction {
	
	
}

//A multiplicity is a definition of an inclusive interval of non-negative integers beginning with a lower bound and ending with a (possibly infinite) upper bound. A multiplicity element embeds this information to specify the allowable cardinalities for an instantiation of this element.
abstract node class MultiplicityElement extends Element {
	
	isOrdered : boolean = false;
	isUnique : boolean = true;
	
}
edge class upper extends association connect 
		MultiplicityElement[0:1] -> UnlimitedNatural[*],
		Operation[0:1] -> UnlimitedNatural[*];
edge class lower extends association connect 
		MultiplicityElement[0:1] -> Integer[*],
		Operation[0:1] -> Integer[*],
		ExtensionEnd[0:1] -> Integer[*];
edge class upperValue extends attribute connect 
		MultiplicityElement[0:1] -> ValueSpecification[*];
edge class lowerValue extends attribute connect 
		MultiplicityElement[0:1] -> ValueSpecification[*];

//An object node is an abstract activity node that is part of defining object flow in an activity.
abstract node class ObjectNode extends ActivityNode, TypedElement;

//A control node is an abstract activity node that coordinates flows in an activity.
abstract node class ControlNode extends ActivityNode;

//A control flow is an edge that starts an activity node after the previous one is finished.
node class ControlFlow extends ActivityEdge;

//An object flow is an activity edge that can have objects or data passing along it.
node class ObjectFlow extends ActivityEdge;

//An initial node is a control node at which flow starts when the activity is invoked.
node class InitialNode extends ControlNode;

//An activity parameter node is an object node for inputs and outputs to activities.
node class ActivityParameterNode extends ObjectNode {
	
	
}
edge class parameter extends attribute connect 
		ActivityParameterNode[1:1] -> Parameter[*];

//A pin is a typed element and multiplicity element that provides values to actions and accept result values from them.
node class Pin extends MultiplicityElement, ObjectNode;

//A value pin is an input pin that provides a value by evaluating a value specification.
node class ValuePin extends InputPin {
	
	
}

//A usage is a relationship in which one element requires another element (or set of elements) for its full implementation or operation. A usage is a dependency in which the client requires the presence of the supplier.
node class Usage extends Dependency;

//An abstraction is a relationship that relates two elements or sets of elements that represent the same concept at different levels of abstraction or from different viewpoints.
node class Abstraction extends Dependency {
	
	
}
edge class mapping extends attribute connect 
		Abstraction[0:1] -> OpaqueExpression[*];

//A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation. This means that the complete semantics of the depending elements is either semantically or structurally dependent on the definition of the supplier element(s).
node class Dependency extends DirectedRelationship, PackageableElement {
	
	
}
edge class supplier extends attribute connect 
		Dependency[1:*] -> NamedElement[*];
edge class client extends attribute connect 
		Dependency[1:*] -> NamedElement[*];

//Realization is a specialized abstraction relationship between two sets of model elements, one representing a specification (the supplier) and the other represents an implementation of the latter (the client). Realization can be used to model stepwise refinement, optimizations, transformations, templates, model synthesis, framework composition, etc.
node class Realization extends Abstraction;

//A substitution is a relationship between two classifiers signifies that the substituting classifier complies with the contract specified by the contract classifier. This implies that instances of the substituting classifier are runtime substitutable where instances of the contract classifier are expected.
node class Substitution extends Realization {
	
	
}
edge class contract extends attribute connect 
		Substitution[1:1] -> Classifier[*],
		InterfaceRealization[1:1] -> Interface[*],
		Connector[0:*] -> Behavior[*];
edge class substitutingClassifier extends attribute connect 
		Substitution[1:1] -> Classifier[*];

//A packageable element indicates a named element that may be owned directly by a package.
abstract node class PackageableElement extends NamedElement;

//A namespace is an element in a model that contains a set of named elements that can be identified by name.
abstract node class Namespace extends NamedElement {
	
	
}
edge class elementImport extends attribute connect 
		Namespace[0:*] -> ElementImport[*];
edge class packageImport extends attribute connect 
		Namespace[0:*] -> PackageImport[*];
edge class ownedRule extends attribute connect 
		Namespace[0:*] -> Constraint[*];
edge class member extends attribute connect 
		Namespace[0:*] -> NamedElement[*];
edge class importedMember extends attribute connect 
		Namespace[0:*] -> PackageableElement[*];
edge class ownedMember extends attribute connect 
		Namespace[0:*] -> NamedElement[*];

//An interface realization is a specialized realization relationship between a classifier and an interface. This relationship signifies that the realizing classifier conforms to the contract specified by the interface.
node class InterfaceRealization extends Realization {
	
	
}
edge class implementingClassifier extends attribute connect 
		InterfaceRealization[1:1] -> BehavioredClassifier[*];

//A structured classifier is an abstract metaclass that represents any classifier whose behavior can be fully or partly described by the collaboration of owned or referenced instances.
abstract node class StructuredClassifier extends Classifier {
	
	
}
edge class part extends attribute connect 
		StructuredClassifier[0:*] -> Property[*];
edge class role extends attribute connect 
		StructuredClassifier[0:*] -> ConnectableElement[*],
		ConnectorEnd[1:1] -> ConnectableElement[*];
edge class ownedConnector extends attribute connect 
		StructuredClassifier[0:*] -> Connector[*];

//ConnectableElement is an abstract metaclass representing a set of instances that play roles of a classifier. Connectable elements may be joined by attached connectors and specify configurations of linked instances to be created within an instance of the containing classifier.
abstract node class ConnectableElement extends TypedElement {
	
	
}
edge class end extends attribute connect 
		ConnectableElement[0:*] -> ConnectorEnd[*],
		Connector[2:*] -> ConnectorEnd[*],
		LinkEndData[1:1] -> Property[*];

//A message defines a particular communication between lifelines of an interaction.
node class Message extends NamedElement {
	
	messageKind : MessageKind = MessageKind::unknown;
	messageSort : MessageSort = MessageSort::synchCall;
	
}
edge class receiveEvent extends attribute connect 
		Message[0:1] -> MessageEnd[*];
edge class sendEvent extends attribute connect 
		Message[0:1] -> MessageEnd[*];
edge class connector extends attribute connect 
		Message[0:1] -> Connector[*];
edge class interaction extends attribute connect 
		Message[1:1] -> Interaction[*],
		Lifeline[1:1] -> Interaction[*];
edge class argument extends attribute connect 
		Message[0:*] -> ValueSpecification[*],
		InteractionUse[0:*] -> Action[*],
		InvocationAction[0:*] -> InputPin[*];
edge class signature extends attribute connect 
		Message[0:1] -> NamedElement[*];

//A general ordering represents a binary relation between two occurrence specifications, to describe that one occurrence specification must occur before the other in a valid trace. This mechanism provides the ability to define partial orders of occurrence cpecifications that may otherwise not have a specified order.
node class GeneralOrdering extends NamedElement {
	
	
}
edge class before extends attribute connect 
		GeneralOrdering[1:1] -> OccurrenceSpecification[*];
edge class after extends attribute connect 
		GeneralOrdering[1:1] -> OccurrenceSpecification[*];

//An execution specification is a specification of the execution of a unit of behavior or action within the lifeline. The duration of an execution specification is represented by two cccurrence specifications, the start occurrence specification and the finish occurrence specification.
abstract node class ExecutionSpecification extends InteractionFragment {
	
	
}
edge class start extends attribute connect 
		ExecutionSpecification[1:1] -> OccurrenceSpecification[*];
edge class finish extends attribute connect 
		ExecutionSpecification[1:1] -> OccurrenceSpecification[*];

//An occurrence specification is the basic semantic unit of interactions. The sequences of occurrences specified by them are the meanings of interactions.
node class OccurrenceSpecification extends InteractionFragment {
	
	
}
edge class covered extends attribute connect 
		OccurrenceSpecification[1:1] -> Lifeline[*],
		StateInvariant[1:1] -> Lifeline[*],
		InteractionFragment[0:*] -> Lifeline[*];
edge class toAfter extends attribute connect 
		OccurrenceSpecification[0:*] -> GeneralOrdering[*];
edge class toBefore extends attribute connect 
		OccurrenceSpecification[0:*] -> GeneralOrdering[*];
edge class event extends attribute connect 
		OccurrenceSpecification[1:1] -> Event[*],
		ExecutionOccurrenceSpecification[1:1] -> ExecutionEvent[*],
		TimeObservation[1:1] -> NamedElement[*],
		DurationObservation[1:2] -> NamedElement[*],
		Trigger[1:1] -> Event[*];

//MessageEnd is an abstract specialization of NamedElement that represents what can occur at the end of a message.
abstract node class MessageEnd extends NamedElement {
	
	
}
edge class message extends attribute connect 
		MessageEnd[0:1] -> Message[*],
		Interaction[0:*] -> Message[*],
		ConsiderIgnoreFragment[0:*] -> NamedElement[*];

//A state invariant is a runtime constraint on the participants of the interaction. It may be used to specify a variety of different kinds of constraints, such as values of attributes or variables, internal or external states, and so on. A state invariant is an interaction fragment and it is placed on a lifeline.
node class StateInvariant extends InteractionFragment {
	
	
}
edge class invariant extends attribute connect 
		StateInvariant[1:1] -> Constraint[*];

//An action execution specification is a kind of execution specification representing the execution of an action.
node class ActionExecutionSpecification extends ExecutionSpecification {
	
	
}
edge class action extends attribute connect 
		ActionExecutionSpecification[1:1] -> Action[*],
		Interaction[0:*] -> Action[*];

//A behavior execution specification is a kind of execution specification representing the execution of a behavior.
node class BehaviorExecutionSpecification extends ExecutionSpecification {
	
	
}

//An execution event models the start or finish of an execution occurrence.
node class ExecutionEvent extends Event;

//A creation event models the creation of an object.
node class CreationEvent extends Event;

//A destruction event models the destruction of an object.
node class DestructionEvent extends Event;

//A send operation event models the invocation of an operation call.
node class SendOperationEvent extends MessageEvent {
	
	
}

//A send signal event models the sending of a signal.
node class SendSignalEvent extends MessageEvent {
	
	
}

//A message occurrence specification pecifies the occurrence of message events, such as sending and receiving of signals or invoking or receiving of operation calls. A message occurrence specification is a kind of message end. Messages are generated either by synchronous operation calls or asynchronous signal sends. They are received by the execution of corresponding accept event actions.
node class MessageOccurrenceSpecification extends MessageEnd, OccurrenceSpecification;

//An execution occurrence specification represents moments in time at which actions or behaviors start or finish.
node class ExecutionOccurrenceSpecification extends OccurrenceSpecification {
	
	
}
edge class execution extends attribute connect 
		ExecutionOccurrenceSpecification[1:1] -> ExecutionSpecification[*];

//A receive operation event specifies the event of receiving an operation invocation for a particular operation by the target entity.
node class ReceiveOperationEvent extends MessageEvent {
	
	
}

//A receive signal event specifies the event of receiving a signal by the target entity.
node class ReceiveSignalEvent extends MessageEvent {
	
	
}

//An actor specifies a role played by a user or any other system that interacts with the subject.
node class Actor extends BehavioredClassifier;

//A relationship from an extending use case to an extended use case that specifies how and when the behavior defined in the extending use case can be inserted into the behavior defined in the extended use case.
node class Extend extends DirectedRelationship, NamedElement {
	
	
}
edge class extendedCase extends attribute connect 
		Extend[1:1] -> UseCase[*];
edge class extension extends attribute connect 
		Extend[1:1] -> UseCase[*],
		Class[0:*] -> Extension[*];
edge class condition extends attribute connect 
		Extend[0:1] -> Constraint[*];
edge class extensionLocation extends attribute connect 
		Extend[1:*] -> ExtensionPoint[*];

//An include relationship defines that a use case contains the behavior defined in another use case.
node class Include extends DirectedRelationship, NamedElement {
	
	
}
edge class includingCase extends attribute connect 
		Include[1:1] -> UseCase[*];
edge class addition extends attribute connect 
		Include[1:1] -> UseCase[*];

//A use case is the specification of a set of actions performed by a system, which yields an observable result that is, typically, of value for one or more actors or other stakeholders of the system.
node class UseCase extends BehavioredClassifier {
	
	
}
edge class include_ extends attribute connect 
		UseCase[0:*] -> Include[*];
edge class extend extends attribute connect 
		UseCase[0:*] -> Extend[*];
edge class extensionPoint extends attribute connect 
		UseCase[0:*] -> ExtensionPoint[*];
edge class subject extends attribute connect 
		UseCase[0:*] -> Classifier[*];

//An extension point identifies a point in the behavior of a use case where that behavior can be extended by the behavior of some other (extending) use case, as specified by an extend relationship.
node class ExtensionPoint extends RedefinableElement {
	
	
}
edge class useCase extends attribute connect 
		ExtensionPoint[1:1] -> UseCase[*],
		Classifier[0:*] -> UseCase[*];

//A classifier is a classification of instances - it describes a set of instances that have features in common. A classifier can specify a generalization hierarchy by referencing its general classifiers.
abstract node class Classifier extends RedefinableElement, Type, Namespace {
	
	isAbstract : boolean = false;
	
}
edge class generalization extends attribute connect 
		Classifier[0:*] -> Generalization[*];
edge class feature extends attribute connect 
		Classifier[0:*] -> Feature[*];
edge class inheritedMember extends attribute connect 
		Classifier[0:*] -> NamedElement[*];
edge class redefinedClassifier extends attribute connect 
		Classifier[0:*] -> Classifier[*];
edge class substitution extends attribute connect 
		Classifier[0:*] -> Substitution[*];
edge class attribute_ extends attribute connect 
		Classifier[0:*] -> Property[*];
edge class ownedUseCase extends attribute connect 
		Classifier[0:*] -> UseCase[*];

//A behavioral feature is a feature of a classifier that specifies an aspect of the behavior of its instances.
abstract node class BehavioralFeature extends Feature, Namespace {
	
	isAbstract : boolean = false;
	concurrency : CallConcurrencyKind = CallConcurrencyKind::sequential;
	
}
edge class method extends attribute connect 
		BehavioralFeature[0:*] -> Behavior[*];
edge class raisedException extends attribute connect 
		BehavioralFeature[0:*] -> Type[*],
		Operation[0:*] -> Type[*];

//A call event models the receipt by an object of a message invoking a call of an operation.
node class CallEvent extends MessageEvent {
	
	
}

//A change event models a change in the system configuration that makes a condition true.
node class ChangeEvent extends Event {
	
	
}
edge class changeExpression extends attribute connect 
		ChangeEvent[1:1] -> ValueSpecification[*];

//An interface is a kind of classifier that represents a declaration of a set of coherent public features and obligations. An interface specifies a contract; any instance of a classifier that realizes the interface must fulfill that contract. The obligations that may be associated with an interface are in the form of various kinds of constraints (such as pre- and post-conditions) or protocol specifications, which may impose ordering restrictions on interactions through the interface.
node class Interface extends Classifier {
	
	
}
edge class nestedClassifier extends attribute connect 
		Interface[0:*] -> Classifier[*],
		Class[0:*] -> Classifier[*];
edge class redefinedInterface extends attribute connect 
		Interface[0:*] -> Interface[*];
edge class ownedReception extends attribute connect 
		Interface[0:*] -> Reception[*],
		Class[0:*] -> Reception[*];

//A reception is a declaration stating that a classifier is prepared to react to the receipt of a signal. A reception designates a signal and specifies the expected behavioral response. The details of handling a signal are specified by the behavior associated with the reception or the classifier itself.
node class Reception extends BehavioralFeature {
	
	
}

//A signal is a specification of send request instances communicated between objects. The receiving object handles the received request instances as specified by its receptions. The data carried by a send request (which was passed to it by the send invocation occurrence that caused that request) are represented as attributes of the signal. A signal is defined independently of the classifiers handling the signal occurrence.
node class Signal extends Classifier {
	
	
}

//A signal event represents the receipt of an asynchronous signal instance. A signal event may, for example, cause a state machine to trigger a transition.
node class SignalEvent extends MessageEvent {
	
	
}

//A message event specifies the receipt by an object of either a call or a signal.
abstract node class MessageEvent extends Event;

//A transition trigger associated with an any receive event specifies that the transition is to be triggered by the receipt of any message that is not explicitly referenced in another transition from the same vertex.
node class AnyReceiveEvent extends MessageEvent;

//A behaviored classifier may have an interface realization.
abstract node class BehavioredClassifier extends Classifier {
	
	
}
edge class ownedBehavior extends attribute connect 
		BehavioredClassifier[0:*] -> Behavior[*];
edge class classifierBehavior extends attribute connect 
		BehavioredClassifier[0:1] -> Behavior[*];
edge class interfaceRealization extends attribute connect 
		BehavioredClassifier[0:*] -> InterfaceRealization[*];
edge class ownedTrigger extends attribute connect 
		BehavioredClassifier[0:*] -> Trigger[*];

//An event is the specification of some occurrence that may potentially trigger effects by an object.
abstract node class Event extends PackageableElement;

//An operation is a behavioral feature of a classifier that specifies the name, type, parameters, and constraints for invoking an associated behavior.
node class Operation extends BehavioralFeature {
	
	isQuery : boolean = false;
	isOrdered : boolean = false;
	isUnique : boolean = true;
	
}
edge class class_ extends attribute connect 
		Operation[0:1] -> Class[*],
		Property[0:1] -> Class[*];
edge class redefinedOperation extends attribute connect 
		Operation[0:*] -> Operation[*];
edge class datatype extends attribute connect 
		Operation[0:1] -> DataType[*],
		Property[0:1] -> DataType[*];
edge class bodyCondition extends attribute connect 
		Operation[0:1] -> Constraint[*];
edge class interface extends attribute connect 
		Operation[0:1] -> Interface[*];

//A fork node is a control node that splits a flow into multiple concurrent flows.
node class ForkNode extends ControlNode;

//A flow final node is a final node that terminates a flow.
node class FlowFinalNode extends FinalNode;

//A central buffer node is an object node for managing flows from multiple sources and destinations.
node class CentralBufferNode extends ObjectNode;

//An activity partition is a kind of activity group for identifying actions that have some characteristic in common.
node class ActivityPartition extends NamedElement, ActivityGroup {
	
	isDimension : boolean = false;
	isExternal : boolean = false;
	
}
edge class edge_ extends attribute connect 
		ActivityPartition[0:*] -> ActivityEdge[*],
		Activity[0:*] -> ActivityEdge[*];
edge class node_ extends attribute connect 
		ActivityPartition[0:*] -> ActivityNode[*],
		StructuredActivityNode[0:*] -> ActivityNode[*],
		Activity[0:*] -> ActivityNode[*];
edge class subpartition extends attribute connect 
		ActivityPartition[0:*] -> ActivityPartition[*];
edge class superPartition extends attribute connect 
		ActivityPartition[0:1] -> ActivityPartition[*];
edge class represents extends attribute connect 
		ActivityPartition[0:1] -> Element[*],
		Lifeline[0:1] -> ConnectableElement[*];

//An activity edge is an abstract class for directed connections between two activity nodes.
abstract node class ActivityEdge extends RedefinableElement {
	
	
}
edge class activity extends attribute connect 
		ActivityEdge[0:1] -> Activity[*],
		StructuredActivityNode[0:1] -> Activity[*],
		ActivityNode[0:1] -> Activity[*];
edge class redefinedEdge extends attribute connect 
		ActivityEdge[0:*] -> ActivityEdge[*];
edge class inPartition extends attribute connect 
		ActivityEdge[0:*] -> ActivityPartition[*],
		ActivityNode[0:*] -> ActivityPartition[*];
edge class guard extends attribute connect 
		ActivityEdge[1:1] -> ValueSpecification[*],
		InteractionOperand[0:1] -> InteractionConstraint[*],
		Transition[0:1] -> Constraint[*];
edge class inGroup extends attribute connect 
		ActivityEdge[0:*] -> ActivityGroup[*],
		ActivityNode[0:*] -> ActivityGroup[*];

//A merge node is a control node that brings together multiple alternate flows. It is not used to synchronize concurrent flows but to accept one among several alternate flows.
node class MergeNode extends ControlNode;

//A decision node is a control node that chooses between outgoing flows.
node class DecisionNode extends ControlNode {
	
	
}
edge class decisionInput extends attribute connect 
		DecisionNode[0:1] -> Behavior[*];

//A final node is an abstract control node at which a flow in an activity stops.
abstract node class FinalNode extends ControlNode;

//An activity final node is a final node that stops all flows in an activity.
node class ActivityFinalNode extends FinalNode;

//A join node is a control node that synchronizes multiple flows.
node class JoinNode extends ControlNode;

//A port is a property of a classifier that specifies a distinct interaction point between that classifier and its environment or between the (behavior of the) classifier and its internal parts. Ports are connected to properties of the classifier by connectors through which requests can be made to invoke the behavioral features of a classifier. A Port may specify the services a classifier provides (offers) to its environment as well as the services that a classifier expects (requires) of its environment.
node class Port extends Property {
	
	isBehavior : boolean = false;
	isService : boolean = true;
	
}
edge class required extends attribute connect 
		Port[0:*] -> Interface[*],
		Component[0:*] -> Interface[*];
edge class redefinedPort extends attribute connect 
		Port[0:*] -> Port[*];
edge class provided extends attribute connect 
		Port[0:*] -> Interface[*],
		Component[0:*] -> Interface[*];

//A classifier has the ability to own ports as specific and type checked interaction points.
abstract node class EncapsulatedClassifier extends StructuredClassifier {
	
	
}
edge class ownedPort extends attribute connect 
		EncapsulatedClassifier[0:*] -> Port[*];

//A connector end is an endpoint of a connector, which attaches the connector to a connectable element. Each connector end is part of one connector.
node class ConnectorEnd extends MultiplicityElement {
	
	
}
edge class definingEnd extends attribute connect 
		ConnectorEnd[0:1] -> Property[*];
edge class partWithPort extends attribute connect 
		ConnectorEnd[0:1] -> Property[*];

//A component represents a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment.
node class Component extends Class {
	
	isIndirectlyInstantiated : boolean = true;
	
}
edge class realization extends attribute connect 
		Component[0:*] -> ComponentRealization[*];

//The realization concept is specialized to (optionally) define the classifiers that realize the contract offered by a component in terms of its provided and required interfaces. The component forms an abstraction from these various classifiers.
node class ComponentRealization extends Realization {
	
	
}
edge class abstraction extends attribute connect 
		ComponentRealization[0:1] -> Component[*];
edge class realizingClassifier extends attribute connect 
		ComponentRealization[1:1] -> Classifier[*];

//Specifies a link that enables communication between two or more instances. This link may be an instance of an association, or it may represent the possibility of the instances being able to communicate because their identities are known by virtue of being passed in as parameters, held in variables or slots, or because the communicating instances are the same instance. The link may be realized by something as simple as a pointer or by something as complex as a network connection. In contrast to associations, which specify links between any instance of the associated classifiers, connectors specify links between instances playing the connected parts only.
node class Connector extends Feature {
	
	
}
edge class redefinedConnector extends attribute connect 
		Connector[0:*] -> Connector[*];
edge class kind extends association connect 
		Connector[0:1] -> ConnectorKind_Value[*],
		Transition[1:1] -> TransitionKind_Value[*],
		Pseudostate[1:1] -> PseudostateKind_Value[*];

//A manifestation is the concrete physical rendering of one or more model elements by an artifact.
node class Manifestation extends Abstraction {
	
	
}
edge class utilizedElement extends attribute connect 
		Manifestation[1:1] -> PackageableElement[*];

//A deployment is the allocation of an artifact or artifact instance to a deployment target.
node class Deployment extends Dependency {
	
	
}
edge class deployedArtifact extends attribute connect 
		Deployment[0:*] -> DeployedArtifact[*];
edge class location extends attribute connect 
		Deployment[1:1] -> DeploymentTarget[*],
		Image[0:1] -> String[*];

//A node is computational resource upon which artifacts may be deployed for execution. Nodes can be interconnected through communication paths to define network structures.
node class Node_ extends Class, DeploymentTarget {
	
	
}
edge class nestedNode extends attribute connect 
		Node_[0:*] -> Node_[*];

//A device is a physical computational resource with processing capability upon which artifacts may be deployed for execution. Devices may be complex (i.e., they may consist of other devices).
node class Device extends Node_;

//An execution environment is a node that offers an execution environment for specific types of components that are deployed on it in the form of executable artifacts.
node class ExecutionEnvironment extends Node_;

//A deployment target is the location for a deployed artifact.
abstract node class DeploymentTarget extends NamedElement {
	
	
}
edge class deployment extends attribute connect 
		DeploymentTarget[0:*] -> Deployment[*];
edge class deployedElement extends attribute connect 
		DeploymentTarget[0:*] -> PackageableElement[*];

//A deployed artifact is an artifact or artifact instance that has been deployed to a deployment target.
abstract node class DeployedArtifact extends NamedElement;

//A communication path is an association between two deployment targets, through which they are able to exchange signals and messages.
node class CommunicationPath extends Association;

//A property is a structural feature of a classifier that characterizes instances of the classifier. A property related by ownedAttribute to a classifier (other than an association) represents an attribute and might also represent an association end. It relates an instance of the class to a value or set of values of the type of the attribute. A property related by memberEnd or its specializations to an association represents an end of the association. The type of the property is the type of the end of the association.
node class Property extends ConnectableElement, StructuralFeature, DeploymentTarget {
	
	isDerived : boolean = false;
	isReadOnly : boolean = false;
	isDerivedUnion : boolean = false;
	aggregation : AggregationKind = AggregationKind::none;
	isComposite : boolean = false;
	
}
edge class redefinedProperty extends attribute connect 
		Property[0:*] -> Property[*];
edge class owningAssociation extends attribute connect 
		Property[0:1] -> Association[*];
edge class opposite extends attribute connect 
		Property[0:1] -> Property[*];
edge class subsettedProperty extends attribute connect 
		Property[0:*] -> Property[*];
edge class association_ extends attribute connect 
		Property[0:1] -> Association[*],
		ClearAssociationAction[1:1] -> Association[*];

//An instance specification is a model element that represents an instance in a modeled system.
node class InstanceSpecification extends PackageableElement, DeploymentTarget, DeployedArtifact {
	
	
}
edge class classifier extends attribute connect 
		InstanceSpecification[0:*] -> Classifier[*],
		CreateObjectAction[1:1] -> Classifier[*];
edge class slot extends attribute connect 
		InstanceSpecification[0:*] -> Slot[*];

//An artifact is the specification of a physical piece of information that is used or produced by a software development process, or by deployment and operation of a system. Examples of artifacts include model files, source files, scripts, and binary executable files, a table in a database system, a development deliverable, or a word-processing document, a mail message.
node class Artifact extends Classifier, DeployedArtifact {
	
	
}
edge class fileName extends association connect 
		Artifact[0:1] -> String[*];
edge class nestedArtifact extends attribute connect 
		Artifact[0:*] -> Artifact[*];
edge class manifestation extends attribute connect 
		Artifact[0:*] -> Manifestation[*];

//An interaction use refers to an interaction. The interaction use is a shorthand for copying the contents of the referenced interaction where the interaction use is. To be accurate the copying must take into account substituting parameters with arguments and connect the formal gates with the actual ones.
node class InteractionUse extends InteractionFragment {
	
	
}
edge class refersTo extends attribute connect 
		InteractionUse[1:1] -> Interaction[*];
edge class actualGate extends attribute connect 
		InteractionUse[0:*] -> Gate[*];

//A part decomposition is a description of the internal interactions of one lifeline relative to an interaction.
node class PartDecomposition extends InteractionUse;

//An interaction operand is contained in a combined fragment. An interaction operand represents one operand of the expression given by the enclosing combined fragment.
node class InteractionOperand extends InteractionFragment, Namespace {
	
	
}
edge class fragment extends attribute connect 
		InteractionOperand[0:*] -> InteractionFragment[*],
		Interaction[0:*] -> InteractionFragment[*];

//An interaction constraint is a Boolean expression that guards an operand in a combined fragment.
node class InteractionConstraint extends Constraint {
	
	
}
edge class minint extends attribute connect 
		InteractionConstraint[0:1] -> ValueSpecification[*];
edge class maxint extends attribute connect 
		InteractionConstraint[0:1] -> ValueSpecification[*];

//A gate is a connection point for relating a message outside an interaction fragment with a message inside the interaction fragment.
node class Gate extends MessageEnd;

//A combined fragment defines an expression of interaction fragments. A combined fragment is defined by an interaction operator and corresponding interaction operands. Through the use of combined fragments the user will be able to describe a number of traces in a compact and concise manner.
node class CombinedFragment extends InteractionFragment {
	
	interactionOperator : InteractionOperatorKind = InteractionOperatorKind::seq;
	
}
edge class cfragmentGate extends attribute connect 
		CombinedFragment[0:*] -> Gate[*];

//An interaction is a unit of behavior that focuses on the observable exchange of information between connectable elements.
node class Interaction extends InteractionFragment, Behavior {
	
	
}
edge class lifeline extends attribute connect 
		Interaction[0:*] -> Lifeline[*];
edge class formalGate extends attribute connect 
		Interaction[0:*] -> Gate[*];

//A lifeline represents an individual participant in the interaction. While parts and structural features may have multiplicity greater than 1, lifelines represent only one interacting entity.
node class Lifeline extends NamedElement {
	
	
}
edge class coveredBy extends attribute connect 
		Lifeline[0:*] -> InteractionFragment[*];
edge class selector extends attribute connect 
		Lifeline[0:1] -> ValueSpecification[*];
edge class decomposedAs extends attribute connect 
		Lifeline[0:1] -> PartDecomposition[*];

//A continuation is a syntactic way to define continuations of different branches of an alternative combined fragment. Continuations is intuitively similar to labels representing intermediate points in a flow of control.
node class Continuation extends InteractionFragment;

//InteractionFragment is an abstract notion of the most general interaction unit. An interaction fragment is a piece of an interaction. Each interaction fragment is conceptually like an interaction by itself.
abstract node class InteractionFragment extends NamedElement {
	
	
}
edge class generalOrdering extends attribute connect 
		InteractionFragment[0:*] -> GeneralOrdering[*];
edge class enclosingInteraction extends attribute connect 
		InteractionFragment[0:1] -> Interaction[*];
edge class enclosingOperand extends attribute connect 
		InteractionFragment[0:1] -> InteractionOperand[*];

//A consider ignore fragment is a kind of combined fragment that is used for the consider and ignore cases, which require lists of pertinent messages to be specified.
node class ConsiderIgnoreFragment extends CombinedFragment {
	
	
}

//A create object action is an action that creates an object that conforms to a statically specified classifier and puts it on an output pin at runtime.
node class CreateObjectAction extends Action {
	
	
}

//A destroy object action is an action that destroys objects.
node class DestroyObjectAction extends Action {
	
	isDestroyLinks : boolean = false;
	isDestroyOwnedObjects : boolean = false;
	
}

//A test identity action is an action that tests if two values are identical objects.
node class TestIdentityAction extends Action {
	
	
}
edge class first extends attribute connect 
		TestIdentityAction[1:1] -> InputPin[*];
edge class second extends attribute connect 
		TestIdentityAction[1:1] -> InputPin[*];

//A read self action is an action that retrieves the host object of an action.
node class ReadSelfAction extends Action {
	
	
}

//StructuralFeatureAction is an abstract class for all structural feature actions.
abstract node class StructuralFeatureAction extends Action {
	
	
}
edge class structuralFeature extends attribute connect 
		StructuralFeatureAction[1:1] -> StructuralFeature[*];
edge class object_ extends attribute connect 
		StructuralFeatureAction[1:1] -> InputPin[*],
		ClearAssociationAction[1:1] -> InputPin[*];

//A read structural feature action is a structural feature action that retrieves the values of a structural feature.
node class ReadStructuralFeatureAction extends StructuralFeatureAction {
	
	
}

//WriteStructuralFeatureAction is an abstract class for structural feature actions that change structural feature values.
abstract node class WriteStructuralFeatureAction extends StructuralFeatureAction {
	
	
}

//A clear structural feature action is a structural feature action that removes all values of a structural feature.
node class ClearStructuralFeatureAction extends StructuralFeatureAction;

//A remove structural feature value action is a write structural feature action that removes values from structural features.
node class RemoveStructuralFeatureValueAction extends WriteStructuralFeatureAction {
	
	isRemoveDuplicates : boolean = false;
	
}
edge class removeAt extends attribute connect 
		RemoveStructuralFeatureValueAction[0:1] -> InputPin[*],
		RemoveVariableValueAction[0:1] -> InputPin[*];

//An add structural feature value action is a write structural feature action for adding values to a structural feature.
node class AddStructuralFeatureValueAction extends WriteStructuralFeatureAction {
	
	isReplaceAll : boolean = false;
	
}
edge class insertAt extends attribute connect 
		AddStructuralFeatureValueAction[0:1] -> InputPin[*],
		LinkEndCreationData[0:1] -> InputPin[*],
		AddVariableValueAction[0:1] -> InputPin[*];

//LinkAction is an abstract class for all link actions that identify their links by the objects at the ends of the links and by the qualifiers at ends of the links.
abstract node class LinkAction extends Action {
	
	
}
edge class endData extends attribute connect 
		LinkAction[2:*] -> LinkEndData[*],
		CreateLinkAction[2:*] -> LinkEndCreationData[*],
		DestroyLinkAction[2:*] -> LinkEndDestructionData[*];

//A link end data is not an action. It is an element that identifies links. It identifies one end of a link to be read or written by the children of a link action. A link cannot be passed as a runtime value to or from an action. Instead, a link is identified by its end objects and qualifier values, if any. This requires more than one piece of data, namely, the statically-specified end in the user model, the object on the end, and the qualifier values for that end, if any. These pieces are brought together around a link end data. Each association end is identified separately with an instance of the LinkEndData class.
node class LinkEndData extends Element {
	
	
}

//A read link action is a link action that navigates across associations to retrieve objects on one end.
node class ReadLinkAction extends LinkAction {
	
	
}

//A link end creation data is not an action. It is an element that identifies links. It identifies one end of a link to be created by a create link action.
node class LinkEndCreationData extends LinkEndData {
	
	isReplaceAll : boolean = false;
	
}

//A create link action is a write link action for creating links.
node class CreateLinkAction extends WriteLinkAction {
	
	
}

//A destroy link action is a write link action that destroys links and link objects.
node class DestroyLinkAction extends WriteLinkAction {
	
	
}

//WriteLinkAction is an abstract class for link actions that create and destroy links.
abstract node class WriteLinkAction extends LinkAction;

//A clear association action is an action that destroys all links of an association in which a particular object participates.
node class ClearAssociationAction extends Action {
	
	
}

//A broadcast signal action is an action that transmits a signal instance to all the potential target objects in the system, which may cause the firing of a state machine transitions or the execution of associated activities of a target object. The argument values are available to the execution of associated behaviors. The requestor continues execution immediately after the signals are sent out. It does not wait for receipt. Any reply messages are ignored and are not transmitted to the requestor.
node class BroadcastSignalAction extends InvocationAction {
	
	
}

//A send object action is an action that transmits an object to the target object, where it may invoke behavior such as the firing of state machine transitions or the execution of an activity. The value of the object is available to the execution of invoked behaviors. The requestor continues execution immediately. Any reply message is ignored and is not transmitted to the requestor.
node class SendObjectAction extends InvocationAction {
	
	
}
edge class request extends attribute connect 
		SendObjectAction[1:1] -> InputPin[*];

//A link end destruction data is not an action. It is an element that identifies links. It identifies one end of a link to be destroyed by destroy link action.
node class LinkEndDestructionData extends LinkEndData {
	
	isDestroyDuplicates : boolean = false;
	
}
edge class destroyAt extends attribute connect 
		LinkEndDestructionData[0:1] -> InputPin[*];

//A value specification action is an action that evaluates a value specification.
node class ValueSpecificationAction extends Action {
	
	
}

//A time expression defines a value specification that represents a time value.
node class TimeExpression extends ValueSpecification {
	
	
}
edge class expr extends attribute connect 
		TimeExpression[0:1] -> ValueSpecification[*],
		Duration[0:1] -> ValueSpecification[*];
edge class observation extends attribute connect 
		TimeExpression[0:*] -> Observation[*],
		Duration[0:*] -> Observation[*];

//Duration defines a value specification that specifies the temporal distance between two time instants.
node class Duration extends ValueSpecification {
	
	
}

//A duration interval defines the range between two durations.
node class DurationInterval extends Interval {
	
	
}
edge class min extends attribute connect 
		DurationInterval[1:1] -> Duration[*],
		TimeInterval[1:1] -> TimeExpression[*],
		Interval[1:1] -> ValueSpecification[*];
edge class max extends attribute connect 
		DurationInterval[1:1] -> Duration[*],
		TimeInterval[1:1] -> TimeExpression[*],
		Interval[1:1] -> ValueSpecification[*];

//A time constraint is a constraint that refers to a time interval.
node class TimeConstraint extends IntervalConstraint {
	
	
}
edge class firstEvent extends association connect 
		TimeConstraint[0:1] -> Boolean[*],
		DurationConstraint[0:2] -> Boolean[*],
		TimeObservation[1:1] -> Boolean[*],
		DurationObservation[0:2] -> Boolean[*];

//A time interval defines the range between two time expressions.
node class TimeInterval extends Interval {
	
	
}

//A duration constraint is a constraint that refers to a duration interval.
node class DurationConstraint extends IntervalConstraint {
	
	
}

//An interval constraint is a constraint that refers to an interval.
node class IntervalConstraint extends Constraint {
	
	
}

//An interval defines the range between two value specifications.
node class Interval extends ValueSpecification {
	
	
}

//Observation is a superclass of TimeObservation and DurationObservation in order for TimeExpression and Duration to refer to either in a simple way.
abstract node class Observation extends PackageableElement;

//A time observation is a reference to a time instant during an execution. It points out the element in the model to observe and whether the observation is when this model element is entered or when it is exited.
node class TimeObservation extends Observation {
	
	firstEvent : boolean = true;
	
}

//A duration observation is a reference to a duration during an execution. It points out the element(s) in the model to observe and whether the observations are when this model element is entered or when it is exited.
node class DurationObservation extends Observation {
	
	
}

//InvocationAction is an abstract class for the various actions that invoke behavior.
abstract node class InvocationAction extends Action {
	
	
}
edge class onPort extends attribute connect 
		InvocationAction[0:1] -> Port[*];

//A trigger relates an event to a behavior that may affect an instance of the classifier.
node class Trigger extends NamedElement {
	
	
}
edge class port extends attribute connect 
		Trigger[0:*] -> Port[*];

//State machines can be used to express the behavior of part of a system. Behavior is modeled as a traversal of a graph of state nodes interconnected by one or more joined transition arcs that are triggered by the dispatching of series of (event) occurrences. During this traversal, the state machine executes a series of activities associated with various elements of the state machine.
node class StateMachine extends Behavior {
	
	
}
edge class region extends attribute connect 
		StateMachine[1:*] -> Region[*],
		State[0:*] -> Region[*];
edge class connectionPoint extends attribute connect 
		StateMachine[0:*] -> Pseudostate[*],
		State[0:*] -> Pseudostate[*];
edge class extendedStateMachine extends attribute connect 
		StateMachine[0:*] -> StateMachine[*];
edge class submachineState extends attribute connect 
		StateMachine[0:*] -> State[*];

//A state models a situation during which some (usually implicit) invariant condition holds.
node class State extends Vertex, RedefinableElement, Namespace {
	
	isComposite : boolean = false;
	isOrthogonal : boolean = false;
	isSimple : boolean = true;
	isSubmachineState : boolean = false;
	
}
edge class submachine extends attribute connect 
		State[0:1] -> StateMachine[*];
edge class connection extends attribute connect 
		State[0:*] -> ConnectionPointReference[*];
edge class redefinedState extends attribute connect 
		State[0:1] -> State[*];
edge class stateInvariant extends attribute connect 
		State[0:1] -> Constraint[*];
edge class entry extends attribute connect 
		State[0:1] -> Behavior[*],
		ConnectionPointReference[0:*] -> Pseudostate[*];
edge class exit extends attribute connect 
		State[0:1] -> Behavior[*],
		ConnectionPointReference[0:*] -> Pseudostate[*];
edge class doActivity extends attribute connect 
		State[0:1] -> Behavior[*];
edge class deferrableTrigger extends attribute connect 
		State[0:*] -> Trigger[*];

//A transition is a directed relationship between a source vertex and a target vertex. It may be part of a compound transition, which takes the state machine from one state configuration to another, representing the complete response of the state machine to an occurrence of an event of a particular type.
node class Transition extends RedefinableElement, Namespace {
	
	kind : TransitionKind = TransitionKind::external;
	
}
edge class container extends attribute connect 
		Transition[1:1] -> Region[*],
		Vertex[0:1] -> Region[*];
edge class redefinedTransition extends attribute connect 
		Transition[0:1] -> Transition[*];
edge class effect extends attribute connect 
		Transition[0:1] -> Behavior[*];
edge class trigger extends attribute connect 
		Transition[0:*] -> Trigger[*];

//A vertex is an abstraction of a node in a state machine graph. In general, it can be the source or destination of any number of transitions.
abstract node class Vertex extends NamedElement {
	
	
}
edge class outgoing extends attribute connect 
		Vertex[0:*] -> Transition[*],
		ActivityNode[0:*] -> ActivityEdge[*];
edge class incoming extends attribute connect 
		Vertex[0:*] -> Transition[*],
		ActivityNode[0:*] -> ActivityEdge[*];

//A pseudostate is an abstraction that encompasses different types of transient vertices in the state machine graph.
node class Pseudostate extends Vertex {
	
	kind : PseudostateKind = PseudostateKind::initial;
	
}
edge class stateMachine extends attribute connect 
		Pseudostate[0:1] -> StateMachine[*],
		Region[0:1] -> StateMachine[*];
edge class state extends attribute connect 
		Pseudostate[0:1] -> State[*],
		ConnectionPointReference[0:1] -> State[*],
		Region[0:1] -> State[*];

//A special kind of state signifying that the enclosing region is completed. If the enclosing region is directly contained in a state machine and all other regions in the state machine also are completed, then it means that the entire state machine is completed.
node class FinalState extends State;

//A connection point reference represents a usage (as part of a submachine state) of an entry/exit point defined in the statemachine reference by the submachine state.
node class ConnectionPointReference extends Vertex {
	
	
}

//A region is an orthogonal part of either a composite state or a state machine. It contains states and transitions.
node class Region extends RedefinableElement, Namespace {
	
	
}
edge class subvertex extends attribute connect 
		Region[0:*] -> Vertex[*];
edge class transition extends attribute connect 
		Region[0:*] -> Transition[*];
edge class extendedRegion extends attribute connect 
		Region[0:1] -> Region[*];

//A time event specifies a point in time. At the specified time, the event occurs.
node class TimeEvent extends Event {
	
	isRelative : boolean = false;
	
}
edge class when extends attribute connect 
		TimeEvent[1:1] -> ValueSpecification[*];

//Variables are elements for passing data between actions indirectly. A local variable stores values shared by the actions within a structured activity group but not accessible outside it. The output of an action may be written to a variable and read for the input to a subsequent action, which is effectively an indirect data flow path. Because there is no predefined relationship between actions that read and write variables, these actions must be sequenced by control flows to prevent race conditions that may occur between actions that read or write the same variable.
node class Variable extends TypedElement, MultiplicityElement {
	
	
}
edge class scope extends attribute connect 
		Variable[0:1] -> StructuredActivityNode[*];
edge class activityScope extends attribute connect 
		Variable[0:1] -> Activity[*];

//A structured activity node is an executable activity node that may have an expansion into subordinate nodes as an activity group. The subordinate nodes must belong to only one structured activity node, although they may be nested.
node class StructuredActivityNode extends ActivityGroup, ExecutableNode, Namespace {
	
	
}
edge class variable extends attribute connect 
		StructuredActivityNode[0:*] -> Variable[*],
		Activity[0:*] -> Variable[*],
		VariableAction[1:1] -> Variable[*];

//A conditional node is a structured activity node that represents an exclusive choice among some number of alternatives.
node class ConditionalNode extends StructuredActivityNode {
	
	isDeterminate : boolean = false;
	isAssured : boolean = false;
	
}
edge class clause extends attribute connect 
		ConditionalNode[1:*] -> Clause[*];

//A loop node is a structured activity node that represents a loop with setup, test, and body sections.
node class LoopNode extends StructuredActivityNode {
	
	isTestedFirst : boolean = false;
	
}
edge class bodyPart extends attribute connect 
		LoopNode[0:*] -> ExecutableNode[*];
edge class setupPart extends attribute connect 
		LoopNode[0:*] -> ExecutableNode[*];
edge class decider extends attribute connect 
		LoopNode[1:1] -> OutputPin[*],
		Clause[1:1] -> OutputPin[*];
edge class test_ extends attribute connect 
		LoopNode[0:*] -> ExecutableNode[*],
		Clause[0:*] -> ExecutableNode[*];

//A clause is an element that represents a single branch of a conditional construct, including a test and a body section. The body section is executed only if (but not necessarily if) the test section evaluates true.
node class Clause extends Element {
	
	
}
edge class predecessorClause extends attribute connect 
		Clause[0:*] -> Clause[*];
edge class successorClause extends attribute connect 
		Clause[0:*] -> Clause[*];

//An activity is the specification of parameterized behavior as the coordinated sequencing of subordinate units whose individual elements are actions.
node class Activity extends Behavior {
	
	isReadOnly : boolean = false;
	
}
edge class partition extends attribute connect 
		Activity[0:*] -> ActivityPartition[*];
edge class structuredNode extends attribute connect 
		Activity[0:*] -> StructuredActivityNode[*];
edge class group extends attribute connect 
		Activity[0:*] -> ActivityGroup[*];

//ActivityNode is an abstract class for points in the flow of an activity connected by edges.
abstract node class ActivityNode extends RedefinableElement {
	
	
}
edge class redefinedNode extends attribute connect 
		ActivityNode[0:*] -> ActivityNode[*];
edge class inStructuredNode extends attribute connect 
		ActivityNode[0:1] -> StructuredActivityNode[*];

//An executable node is an abstract class for activity nodes that may be executed. It is used as an attachment point for exception handlers.
abstract node class ExecutableNode extends ActivityNode;

//A sequence node is a structured activity node that executes its actions in order.
node class SequenceNode extends StructuredActivityNode {
	
	
}
edge class executableNode extends attribute connect 
		SequenceNode[0:*] -> ExecutableNode[*];

//An action is a named element that is the fundamental unit of executable functionality. The execution of an action represents some transformation or processing in the modeled system, be it a computer system or otherwise.
abstract node class Action extends ExecutableNode {
	
	
}
edge class output extends attribute connect 
		Action[0:*] -> OutputPin[*];
edge class input extends attribute connect 
		Action[0:*] -> InputPin[*];

//ActivityGroup is an abstract class for defining sets of nodes and edges in an activity.
abstract node class ActivityGroup extends Element {
	
	
}
edge class subgroup extends attribute connect 
		ActivityGroup[0:*] -> ActivityGroup[*];
edge class superGroup extends attribute connect 
		ActivityGroup[0:1] -> ActivityGroup[*];
edge class containedEdge extends attribute connect 
		ActivityGroup[0:*] -> ActivityEdge[*];
edge class containedNode extends attribute connect 
		ActivityGroup[0:*] -> ActivityNode[*];
edge class inActivity extends attribute connect 
		ActivityGroup[0:1] -> Activity[*];

//An input pin is a pin that holds input values to be consumed by an action.
node class InputPin extends Pin;

//An output pin is a pin that holds output values produced by an action.
node class OutputPin extends Pin;

//A stereotype defines how an existing metaclass may be extended, and enables the use of platform or domain specific terminology or notation in place of, or in addition to, the ones used for the extended metaclass.
node class Stereotype extends Class {
	
	
}
edge class icon extends attribute connect 
		Stereotype[0:*] -> Image[*];

//A profile defines limited extensions to a reference metamodel with the purpose of adapting the metamodel to a specific platform or domain.
node class Profile extends Package {
	
	
}
edge class ownedStereotype extends attribute connect 
		Profile[0:*] -> Stereotype[*];
edge class metaclassReference extends attribute connect 
		Profile[0:*] -> ElementImport[*];
edge class metamodelReference extends attribute connect 
		Profile[0:*] -> PackageImport[*];

//A package is used to group elements, and provides a namespace for the grouped elements.
node class Package extends PackageableElement, Namespace {
	
	
}
edge class packageMerge extends attribute connect 
		Package[0:*] -> PackageMerge[*];
edge class packagedElement extends attribute connect 
		Package[0:*] -> PackageableElement[*];
edge class ownedType extends attribute connect 
		Package[0:*] -> Type[*];
edge class nestedPackage extends attribute connect 
		Package[0:*] -> Package[*];
edge class nestingPackage extends attribute connect 
		Package[0:1] -> Package[*];
edge class profileApplication extends attribute connect 
		Package[0:*] -> ProfileApplication[*];

//A class describes a set of objects that share the same specifications of features, constraints, and semantics.
node class Class extends BehavioredClassifier, EncapsulatedClassifier {
	
	isAbstract : boolean = false;
	isActive : boolean = false;
	
}
edge class superClass extends attribute connect 
		Class[0:*] -> Class[*];

//A profile application is used to show which profiles have been applied to a package.
node class ProfileApplication extends DirectedRelationship {
	
	isStrict : boolean = false;
	
}
edge class appliedProfile extends attribute connect 
		ProfileApplication[1:1] -> Profile[*];
edge class applyingPackage extends attribute connect 
		ProfileApplication[1:1] -> Package[*];

//An extension is used to indicate that the properties of a metaclass are extended through a stereotype, and gives the ability to flexibly add (and later remove) stereotypes to classes.
node class Extension extends Association {
	
	isRequired : boolean = false;
	
}
edge class metaclass extends attribute connect 
		Extension[1:1] -> Class[*];

//Physical definition of a graphical image.
node class Image extends Element {
	
	
}
edge class content extends association connect 
		Image[0:1] -> String[*];
edge class format extends association connect 
		Image[0:1] -> String[*];

//An element is a constituent of a model. As such, it has the capability of owning other elements.
abstract node class Element {
	
	
}
edge class ownedElement extends attribute connect 
		Element[0:*] -> Element[*];
edge class owner extends attribute connect 
		Element[0:1] -> Element[*];
edge class ownedComment extends attribute connect 
		Element[0:*] -> Comment[*];

//A named element is an element in a model that may have a name.
abstract node class NamedElement extends Element {
	
	
}
edge class name extends association connect 
		NamedElement[0:1] -> String[*];
edge class qualifiedName extends association connect 
		NamedElement[0:1] -> String[*];
edge class clientDependency extends attribute connect 
		NamedElement[0:*] -> Dependency[*];
edge class namespace extends attribute connect 
		NamedElement[0:1] -> Namespace[*];

//An extension end is used to tie an extension to a stereotype when extending a metaclass.
node class ExtensionEnd extends Property {
	
	
}

//VariableAction is an abstract class for actions that operate on a statically specified variable.
abstract node class VariableAction extends Action {
	
	
}

//A read variable action is a variable action that retrieves the values of a variable.
node class ReadVariableAction extends VariableAction {
	
	
}

//WriteVariableAction is an abstract class for variable actions that change variable values.
abstract node class WriteVariableAction extends VariableAction {
	
	
}

//A clear variable action is a variable action that removes all values of a variable.
node class ClearVariableAction extends VariableAction;

//An add variable value action is a write variable action for adding values to a variable.
node class AddVariableValueAction extends WriteVariableAction {
	
	isReplaceAll : boolean = false;
	
}

//A remove variable value action is a write variable action that removes values from variables.
node class RemoveVariableValueAction extends WriteVariableAction {
	
	isRemoveDuplicates : boolean = false;
	
}

//A raise exception action is an action that causes an exception to occur. The input value becomes the exception object.
node class RaiseExceptionAction extends Action {
	
	
}
edge class exception extends attribute connect 
		RaiseExceptionAction[1:1] -> InputPin[*];

//An action input pin is a kind of pin that executes an action to determine the values to input to another.
node class ActionInputPin extends InputPin {
	
	
}
edge class fromAction extends attribute connect 
		ActionInputPin[1:1] -> Action[*];