/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 4.5
 * Copyright (C) 2003-2020 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

// by Edgar Jakumeit

using System;
using System.Collections.Generic;
using de.unika.ipd.grGen.libGr;

namespace de.unika.ipd.grGen.lgsp
{
    /// <summary>
    /// The C#-part responsible for generating the post-matches filters.
    /// </summary>
    public static class FilterGenerator
    {
        public static void GenerateFilterStubs(SourceBuilder source, LGSPRulePattern rulePattern)
        {
            String rulePatternClassName = rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";

            foreach(IFilter filter in rulePattern.Filters)
            {
                if(filter is IFilterAutoGenerated)
                    continue;

                IFilterFunction filterFunction = (IFilterFunction)filter;
                if(!filterFunction.IsExternal)
                    continue;

                if(filter.Package != null)
                {
                    source.AppendFrontFormat("namespace {0}\n", filter.Package);
                    source.AppendFront("{\n");
                    source.Indent();
                }
                source.AppendFront("public partial class MatchFilters\n");
                source.AppendFront("{\n");
                source.Indent();

                source.AppendFrontFormat("//public static void Filter_{0}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {1} matches", filter.Name, matchesListType);
                for(int i = 0; i < filterFunction.Inputs.Length; ++i)
                {
                    source.AppendFormat(", {0} {1}", TypesHelper.TypeName(filterFunction.Inputs[i]), filterFunction.InputNames[i]);
                }
                source.Append(")\n");

                source.Unindent();
                source.AppendFront("}\n");
                if(filter.Package != null)
                {
                    source.Unindent();
                    source.AppendFront("}\n");
                }
            }
        }

        public static void GenerateFilters(SourceBuilder source, LGSPRulePattern rulePattern)
        {
            foreach(IFilter f in rulePattern.Filters)
            {
                if(f is IFilterAutoGenerated)
                {
                    IFilterAutoGenerated filter = (IFilterAutoGenerated)f;

                    if(filter.Package != null)
                    {
                        source.AppendFrontFormat("namespace {0}\n", filter.Package);
                        source.AppendFront("{\n");
                        source.Indent();
                    }
                    source.AppendFront("public partial class MatchFilters\n");
                    source.AppendFront("{\n");
                    source.Indent();

                    if(filter.Name == "auto")
                        GenerateAutomorphyFilter(source, rulePattern);
                    else
                    {
                        if(filter.Name == "orderAscendingBy")
                            GenerateOrderByFilter(source, rulePattern, (LGSPFilterAutoGenerated)filter, true);
                        if(filter.Name == "orderDescendingBy")
                            GenerateOrderByFilter(source, rulePattern, (LGSPFilterAutoGenerated)filter, false);
                        if(filter.Name == "groupBy")
                            GenerateGroupByFilter(source, rulePattern, filter.Entities[0]);
                        if(filter.Name == "keepSameAsFirst")
                            GenerateKeepSameFilter(source, rulePattern, filter.Entities[0], true);
                        if(filter.Name == "keepSameAsLast")
                            GenerateKeepSameFilter(source, rulePattern, filter.Entities[0], false);
                        if(filter.Name == "keepOneForEach")
                            GenerateKeepOneForEachFilter(source, rulePattern, filter.Entities[0]);
                    }

                    source.Unindent();
                    source.AppendFront("}\n");
                    if(filter.Package != null)
                    {
                        source.Unindent();
                        source.AppendFront("}\n");
                    }
                }
            }
        }

        private static void GenerateAutomorphyFilter(SourceBuilder source, LGSPRulePattern rulePattern)
        {
            String rulePatternClassName = TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchClassName = rulePatternClassName + "." + NamesOfEntities.MatchClassName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "auto";
            
            source.AppendFrontFormat("public static void Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n", 
                rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFront("if(matches.Count < 2)\n");
            source.AppendFront("\treturn;\n");
            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToList();\n", matchInterfaceName);

            source.AppendFrontFormat("if(matches.Count < 5 || {0}.Instance.patternGraph.nodes.Length + {0}.Instance.patternGraph.edges.Length < 1)\n", rulePatternClassName);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFront("for(int i = 0; i < matchesArray.Count; ++i)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("if(matchesArray[i] == null)\n");
            source.AppendFront("\tcontinue;\n");
            source.AppendFront("for(int j = i + 1; j < matchesArray.Count; ++j)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("if(matchesArray[j] == null)\n");
            source.AppendFront("\tcontinue;\n");
            source.AppendFront("if(GRGEN_LIBGR.SymmetryChecker.AreSymmetric(matchesArray[i], matchesArray[j], procEnv.graph))\n");
            source.AppendFront("\tmatchesArray[j] = null;\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.Unindent();
            source.AppendFront("}\n");

            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("else\n");
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("Dictionary<int, {0}> foundMatchesOfSameMainPatternHash = new Dictionary<int, {0}>();\n", 
                matchClassName);
            source.AppendFront("for(int i = 0; i < matchesArray.Count; ++i)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("{0} match = ({0})matchesArray[i];\n", matchClassName);
            source.AppendFront("int duplicateMatchHash = 0;\n");
            source.AppendFront("for(int j = 0; j < match.NumberOfNodes; ++j) duplicateMatchHash ^= match.getNodeAt(j).GetHashCode();\n");
            source.AppendFront("for(int j = 0; j < match.NumberOfEdges; ++j) duplicateMatchHash ^= match.getEdgeAt(j).GetHashCode();\n");
            source.AppendFront("bool contained = foundMatchesOfSameMainPatternHash.ContainsKey(duplicateMatchHash);\n");
            source.AppendFront("if(contained)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("{0} duplicateMatchCandidate = foundMatchesOfSameMainPatternHash[duplicateMatchHash];\n", matchClassName);
            source.AppendFront("do\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("if(GRGEN_LIBGR.SymmetryChecker.AreSymmetric(match, duplicateMatchCandidate, procEnv.graph))\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("matchesArray[i] = null;\n");
            source.AppendFrontFormat("goto label_auto_{0};\n", rulePatternClassName.Replace('.', '_'));
            source.Unindent();
            source.AppendFront("}\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("while((duplicateMatchCandidate = duplicateMatchCandidate.nextWithSameHash) != null);\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("if(!contained)\n");
            source.AppendFront("\tfoundMatchesOfSameMainPatternHash[duplicateMatchHash] = match;\n");
            source.AppendFront("else\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("{0} duplicateMatchCandidate = foundMatchesOfSameMainPatternHash[duplicateMatchHash];\n", matchClassName);
            source.AppendFront("while(duplicateMatchCandidate.nextWithSameHash != null) duplicateMatchCandidate = duplicateMatchCandidate.nextWithSameHash;\n");
            source.AppendFront("duplicateMatchCandidate.nextWithSameHash = match;\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFormat("label_auto_{0}: ;\n", rulePatternClassName.Replace('.', '_'));
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFrontFormat("foreach({0} toClean in foundMatchesOfSameMainPatternHash.Values) toClean.CleanNextWithSameHash();\n", matchClassName);
            
            source.Unindent();
            source.AppendFront("}\n");

            source.AppendFront("matches.FromList();\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateOrderByFilter(SourceBuilder source, LGSPRulePattern rulePattern, LGSPFilterAutoGenerated filter, bool ascending)
        {
            String rulePatternClassName = TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = ascending ? "orderAscendingBy_" + filter.EntitySuffixForName : "orderDescendingBy_" + filter.EntitySuffixForName;

            source.AppendFrontFormat("public static void Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n", 
                rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToList();\n", matchInterfaceName);
            source.AppendFrontFormat("matchesArray.Sort(new Comparer_{0}_{1}());\n", rulePattern.name, filterName);
            source.AppendFront("matches.FromList();\n");

            source.Unindent();
            source.AppendFront("}\n");

            source.AppendFrontFormat("class Comparer_{0}_{1} : Comparer<{2}>\n", rulePattern.name, filterName, matchInterfaceName);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("public override int Compare({0} left, {0} right)\n", matchInterfaceName);
            source.AppendFront("{\n");
            source.Indent();
            GenerateOrderByFilter(source, filter.Entities, ascending, false, 0);
            source.Unindent();
            source.AppendFront("}\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateOrderByFilter(SourceBuilder source, List<String> filterVariables, bool ascending, bool leaf, int pos)
        {
            String filterVariable = filterVariables[pos];
            if(pos + 1 < filterVariables.Count && !leaf)
            {
                source.AppendFrontFormat("if(left.{0}.CompareTo(right.{0})==0)", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                source.Indent();
                GenerateOrderByFilter(source, filterVariables, ascending, false, pos + 1);
                source.Unindent();
                source.AppendFrontFormat("else");
                source.Indent();
                GenerateOrderByFilter(source, filterVariables, ascending, true, pos);
                source.Unindent();
            }
            else
            {
                if(ascending)
                    source.AppendFrontFormat("return left.{0}.CompareTo(right.{0});\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                else
                    source.AppendFrontFormat("return -left.{0}.CompareTo(right.{0});\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
            }
        }

        private static void GenerateGroupByFilter(SourceBuilder source, LGSPRulePattern rulePattern, String filterVariable)
        {
            String rulePatternClassName = TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "groupBy_" + filterVariable;

            if(true) // does the type of the variable to group-by support ordering? then order, is more efficient than equality comparisons
            {
                source.AppendFrontFormat("public static void Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                    rulePattern.name, filterName, matchesListType);
                source.AppendFront("{\n");
                source.Indent();

                source.AppendFrontFormat("List<{0}> matchesArray = matches.ToList();\n", matchInterfaceName);
                source.AppendFrontFormat("matchesArray.Sort(new Comparer_{0}_{1}());\n", rulePattern.name, filterName);
                source.AppendFront("matches.FromList();\n");

                source.Unindent();
                source.AppendFront("}\n");

                source.AppendFrontFormat("class Comparer_{0}_{1} : Comparer<{2}>\n", rulePattern.name, filterName, matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();

                source.AppendFrontFormat("public override int Compare({0} left, {0} right)\n", matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();
                source.AppendFrontFormat("return left.{0}.CompareTo(right.{0});\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                source.Unindent();
                source.AppendFront("}\n");

                source.Unindent();
                source.AppendFront("}\n");
            }
            else
            {
                // ensure that if two elements are equal, they are neighbours or only separated by equal elements
                // not needed yet, as of now we only support numerical types and string, that support ordering in addition to equality comparison
                /*List<T> matchesArray;
                for(int i = 0; i < matchesArray.Count - 1; ++i)
                {
                    for(int j = i + 1; j < matchesArray.Count; ++j)
                    {
                        if(matchesArray[i] == matchesArray[j])
                        {
                            T tmp = matchesArray[i + 1];
                            matchesArray[i + 1] = matchesArray[j];
                            matchesArray[j] = tmp;
                            break;
                        }
                    }
                }*/
            }
        }

        private static void GenerateKeepSameFilter(SourceBuilder source, LGSPRulePattern rulePattern, String filterVariable, bool sameAsFirst)
        {
            String rulePatternClassName = TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = sameAsFirst ? "keepSameAsFirst_" + filterVariable : "keepSameAsLast_" + filterVariable;

            source.AppendFrontFormat("public static void Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n", 
                rulePattern.name, filterName, matchesListType);

            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToList();\n", matchInterfaceName);

            if(sameAsFirst)
            {
                source.AppendFront("int pos = 0 + 1;\n");
                source.AppendFrontFormat("while(pos < matchesArray.Count && matchesArray[pos].{0} == matchesArray[0].{0})\n", 
                    NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                source.AppendFront("{\n");
                source.AppendFront("\t++pos;\n");
                source.AppendFront("}\n");
                source.AppendFront("for(; pos < matchesArray.Count; ++pos)\n");
                source.AppendFront("{\n");
                source.AppendFront("\tmatchesArray[pos] = null;\n");
                source.AppendFront("}\n");
            }
            else
            {
                source.AppendFront("int pos = matchesArray.Count-1 - 1;\n");
                source.AppendFrontFormat("while(pos >= 0 && matchesArray[pos].{0} == matchesArray[matchesArray.Count-1].{0})\n",
                    NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                source.AppendFront("{\n");
                source.AppendFront("\t--pos;\n");
                source.AppendFront("}\n");
                source.AppendFront("for(; pos >= 0; --pos)\n");
                source.AppendFront("{\n");
                source.AppendFront("\tmatchesArray[pos] = null;\n");
                source.AppendFront("}\n");
            }

            source.AppendFront("matches.FromList();\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateKeepOneForEachFilter(SourceBuilder source, LGSPRulePattern rulePattern, String filterVariable)
        {
            String rulePatternClassName = TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "keepOneForEach_" + filterVariable;

            source.AppendFrontFormat("public static void Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                 rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToList();\n", matchInterfaceName);

            source.AppendFront("int cmpPos = 0;\n");
            source.AppendFront("int pos = 0 + 1;\n");
            source.AppendFront("for(; pos < matchesArray.Count; ++pos)\n");
            source.AppendFront("{\n");
            source.AppendFrontFormat("\tif(matchesArray[pos].{0} == matchesArray[cmpPos].{0})\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
            source.AppendFront("\t\tmatchesArray[pos] = null;\n");
            source.AppendFront("\telse\n");
            source.AppendFront("\t\tcmpPos = pos;\n");
            source.AppendFront("}\n");

            source.AppendFront("matches.FromList();\n");

            source.Unindent();
            source.AppendFront("}\n");
        }
    }
}
