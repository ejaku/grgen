/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 6.7
 * Copyright (C) 2003-2023 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

// by Edgar Jakumeit

using System;
using System.Collections.Generic;
using de.unika.ipd.grGen.libGr;

namespace de.unika.ipd.grGen.lgsp
{
    /// <summary>
    /// The C#-part responsible for generating the post-matches filters.
    /// </summary>
    public static class FilterGenerator
    {
        public static void GenerateFilterStubs(SourceBuilder source, LGSPRulePattern rulePattern)
        {
            String rulePatternClassName = rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";

            foreach(IFilter filter in rulePattern.Filters)
            {
                if(!(filter is IFilterFunction))
                    continue;

                IFilterFunction filterFunction = (IFilterFunction)filter;
                if(!filterFunction.IsExternal)
                    continue;

                EmitMatchFiltersClassBegin(source, filterFunction.Package);

                source.AppendFrontFormat("//public static {1} Filter_{0}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {1} matches", filter.Name, matchesListType);
                for(int i = 0; i < filterFunction.Inputs.Length; ++i)
                {
                    source.AppendFormat(", {0} {1}", TypesHelper.TypeName(filterFunction.Inputs[i]), filterFunction.InputNames[i]);
                }
                source.Append(")\n");

                EmitMatchFiltersClassEnd(source, filterFunction.Package);
            }
        }

        public static void GenerateFilters(SourceBuilder source, LGSPRulePattern rulePattern)
        {
            foreach(IFilter filter in rulePattern.Filters)
            {
                if(!(filter is IFilterAutoGenerated))
                    continue;

                IFilterAutoGenerated filterAutoGenerated = (IFilterAutoGenerated)filter;

                EmitMatchFiltersClassBegin(source, filterAutoGenerated.PackageOfApplyee);

                if(filterAutoGenerated.PlainName == "auto")
                    GenerateAutomorphyFilter(source, rulePattern);
                else
                {
                    if(filterAutoGenerated.PlainName == "orderAscendingBy")
                        GenerateOrderByFilter(source, rulePattern, (LGSPFilterAutoGenerated)filterAutoGenerated, true);
                    if(filterAutoGenerated.PlainName == "orderDescendingBy")
                        GenerateOrderByFilter(source, rulePattern, (LGSPFilterAutoGenerated)filterAutoGenerated, false);
                    if(filterAutoGenerated.PlainName == "groupBy")
                        GenerateGroupByFilter(source, rulePattern, filterAutoGenerated.Entities[0]);
                    if(filterAutoGenerated.PlainName == "keepSameAsFirst")
                        GenerateKeepSameFilter(source, rulePattern, filterAutoGenerated.Entities[0], true);
                    if(filterAutoGenerated.PlainName == "keepSameAsLast")
                        GenerateKeepSameFilter(source, rulePattern, filterAutoGenerated.Entities[0], false);
                    if(filterAutoGenerated.PlainName == "keepOneForEach")
                        GenerateKeepOneForEachFilter(source, rulePattern, filterAutoGenerated.Entities[0]);
                    if(filterAutoGenerated.PlainName == "keepOneForEachAccumulateBy")
                        GenerateKeepOneForEachAccumulateByFilter(source, rulePattern, filterAutoGenerated.Entities[0],
                            filterAutoGenerated.Entities[1], filterAutoGenerated.Entities[2]);
                }

                EmitMatchFiltersClassEnd(source, filterAutoGenerated.PackageOfApplyee);
            }
        }

        public static void GenerateFilters(SourceBuilder source, LGSPRulePattern rulePattern, IIterated iterated)
        {
            foreach(IFilter filter in iterated.Filters)
            {
                if(!(filter is IFilterAutoGenerated))
                    continue;

                IFilterAutoGenerated filterAutoGenerated = (IFilterAutoGenerated)filter;

                EmitMatchFiltersClassBegin(source, filterAutoGenerated.PackageOfApplyee);

                if(filterAutoGenerated.PlainName == "orderAscendingBy")
                    GenerateOrderByFilter(source, rulePattern, iterated, (LGSPFilterAutoGenerated)filterAutoGenerated, true);
                if(filterAutoGenerated.PlainName == "orderDescendingBy")
                    GenerateOrderByFilter(source, rulePattern, iterated, (LGSPFilterAutoGenerated)filterAutoGenerated, false);
                if(filterAutoGenerated.PlainName == "groupBy")
                    GenerateGroupByFilter(source, rulePattern, iterated, filterAutoGenerated.Entities[0]);
                if(filterAutoGenerated.PlainName == "keepSameAsFirst")
                    GenerateKeepSameFilter(source, rulePattern, iterated, filterAutoGenerated.Entities[0], true);
                if(filterAutoGenerated.PlainName == "keepSameAsLast")
                    GenerateKeepSameFilter(source, rulePattern, iterated, filterAutoGenerated.Entities[0], false);
                if(filterAutoGenerated.PlainName == "keepOneForEach")
                    GenerateKeepOneForEachFilter(source, rulePattern, iterated, filterAutoGenerated.Entities[0]);
                if(filterAutoGenerated.PlainName == "keepOneForEachAccumulateBy")
                    GenerateKeepOneForEachAccumulateByFilter(source, rulePattern, iterated, filterAutoGenerated.Entities[0],
                        filterAutoGenerated.Entities[1], filterAutoGenerated.Entities[2]);

                EmitMatchFiltersClassEnd(source, filterAutoGenerated.PackageOfApplyee);
            }
        }

        private static void EmitMatchFiltersClassBegin(SourceBuilder source, String package)
        {
            if(package != null)
            {
                source.AppendFrontFormat("namespace {0}\n", package);
                source.AppendFront("{\n");
                source.Indent();
            }

            source.AppendFront("public partial class MatchFilters\n");
            source.AppendFront("{\n");
            source.Indent();
        }

        private static void EmitMatchFiltersClassEnd(SourceBuilder source, String package)
        {
            source.Unindent();
            source.AppendFront("}\n");

            if(package != null)
            {
                source.Unindent();
                source.AppendFront("}\n");
            }
        }

        public static void GenerateMatchClassFilterStubs(SourceBuilder source, MatchClassInfo matchClass)
        {
            String matchClassName = matchClass.Name;
            String matchInterfaceName = NamesOfEntities.MatchInterfaceName(matchClassName);
            String matchesListType = "IList<GRGEN_LIBGR.IMatch>";

            foreach(IFilter filter in matchClass.Filters)
            {
                if(!(filter is IFilterFunction))
                    continue;

                IFilterFunction filterFunction = (IFilterFunction)filter;
                if(!filterFunction.IsExternal)
                    continue;

                EmitMatchClassFiltersClassBegin(source, filterFunction.Package);

                source.AppendFrontFormat("//public static {1} Filter_{0}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {1} matches", filter.Name, matchesListType);
                for(int i = 0; i < filterFunction.Inputs.Length; ++i)
                {
                    source.AppendFormat(", {0} {1}", TypesHelper.TypeName(filterFunction.Inputs[i]), filterFunction.InputNames[i]);
                }
                source.Append(")\n");

                EmitMatchClassFiltersClassEnd(source, filterFunction.Package);
            }
        }

        public static void GenerateMatchClassFilters(SourceBuilder source, MatchClassInfo matchClass)
        {
            foreach(IFilter filter in matchClass.Filters)
            {
                if(!(filter is IFilterAutoGenerated))
                    continue;

                IFilterAutoGenerated filterAutoGenerated = (IFilterAutoGenerated)filter;

                EmitMatchClassFiltersClassBegin(source, filterAutoGenerated.PackageOfApplyee);

                if(filterAutoGenerated.PlainName == "orderAscendingBy")
                    GenerateMatchClassOrderByFilter(source, matchClass, (LGSPFilterAutoGenerated)filterAutoGenerated, true);
                if(filterAutoGenerated.PlainName == "orderDescendingBy")
                    GenerateMatchClassOrderByFilter(source, matchClass, (LGSPFilterAutoGenerated)filterAutoGenerated, false);
                if(filterAutoGenerated.PlainName == "groupBy")
                    GenerateMatchClassGroupByFilter(source, matchClass, filterAutoGenerated.Entities[0]);
                if(filterAutoGenerated.PlainName == "keepSameAsFirst")
                    GenerateMatchClassKeepSameFilter(source, matchClass, filterAutoGenerated.Entities[0], true);
                if(filterAutoGenerated.PlainName == "keepSameAsLast")
                    GenerateMatchClassKeepSameFilter(source, matchClass, filterAutoGenerated.Entities[0], false);
                if(filterAutoGenerated.PlainName == "keepOneForEach")
                    GenerateMatchClassKeepOneForEachFilter(source, matchClass, filterAutoGenerated.Entities[0]);
                if(filterAutoGenerated.PlainName == "keepOneForEachAccumulateBy")
                    GenerateMatchClassKeepOneForEachAccumulateByFilter(source, matchClass, filterAutoGenerated.Entities[0],
                        filterAutoGenerated.Entities[1], filterAutoGenerated.Entities[2]);

                EmitMatchClassFiltersClassEnd(source, filterAutoGenerated.PackageOfApplyee);
            }
        }

        private static void EmitMatchClassFiltersClassBegin(SourceBuilder source, String package)
        {
            if(package != null)
            {
                source.AppendFrontFormat("namespace {0}\n", package);
                source.AppendFront("{\n");
                source.Indent();
            }

            source.AppendFront("public partial class MatchClassFilters\n");
            source.AppendFront("{\n");
            source.Indent();
        }

        private static void EmitMatchClassFiltersClassEnd(SourceBuilder source, String package)
        {
            source.Unindent();
            source.AppendFront("}\n");

            if(package != null)
            {
                source.Unindent();
                source.AppendFront("}\n");
            }
        }

        private static void GenerateAutomorphyFilter(SourceBuilder source, LGSPRulePattern rulePattern)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchClassName = rulePatternClassName + "." + NamesOfEntities.MatchClassName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "auto";
            
            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n", 
                rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFront("if(matches.Count < 2)\n");
            source.AppendFrontIndented("return matches;\n");
            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            source.AppendFrontFormat("if(matches.Count < 5 || {0}.Instance.patternGraph.nodes.Length + {0}.Instance.patternGraph.edges.Length < 1)\n", rulePatternClassName);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFront("for(int i = 0; i < matchesArray.Count; ++i)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("if(matchesArray[i] == null)\n");
            source.AppendFrontIndented("continue;\n");
            source.AppendFront("for(int j = i + 1; j < matchesArray.Count; ++j)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("if(matchesArray[j] == null)\n");
            source.AppendFrontIndented("continue;\n");
            source.AppendFront("if(GRGEN_LIBGR.SymmetryChecker.AreSymmetric(matchesArray[i], matchesArray[j], procEnv.graph))\n");
            source.AppendFrontIndented("matchesArray[j] = null;\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.Unindent();
            source.AppendFront("}\n");

            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("else\n");
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("Dictionary<int, {0}> foundMatchesOfSameMainPatternHash = new Dictionary<int, {0}>();\n", 
                matchClassName);
            source.AppendFront("for(int i = 0; i < matchesArray.Count; ++i)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("{0} match = ({0})matchesArray[i];\n", matchClassName);
            source.AppendFront("int duplicateMatchHash = 0;\n");
            source.AppendFront("for(int j = 0; j < match.NumberOfNodes; ++j) duplicateMatchHash ^= match.getNodeAt(j).GetHashCode();\n");
            source.AppendFront("for(int j = 0; j < match.NumberOfEdges; ++j) duplicateMatchHash ^= match.getEdgeAt(j).GetHashCode();\n");
            source.AppendFront("bool contained = foundMatchesOfSameMainPatternHash.ContainsKey(duplicateMatchHash);\n");
            source.AppendFront("if(contained)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("{0} duplicateMatchCandidate = foundMatchesOfSameMainPatternHash[duplicateMatchHash];\n", matchClassName);
            source.AppendFront("do\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("if(GRGEN_LIBGR.SymmetryChecker.AreSymmetric(match, duplicateMatchCandidate, procEnv.graph))\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFront("matchesArray[i] = null;\n");
            source.AppendFrontFormat("goto label_auto_{0};\n", rulePatternClassName.Replace('.', '_'));
            source.Unindent();
            source.AppendFront("}\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("while((duplicateMatchCandidate = duplicateMatchCandidate.nextWithSameHash) != null);\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("if(!contained)\n");
            source.AppendFrontIndented("foundMatchesOfSameMainPatternHash[duplicateMatchHash] = match;\n");
            source.AppendFront("else\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("{0} duplicateMatchCandidate = foundMatchesOfSameMainPatternHash[duplicateMatchHash];\n", matchClassName);
            source.AppendFront("while(duplicateMatchCandidate.nextWithSameHash != null) duplicateMatchCandidate = duplicateMatchCandidate.nextWithSameHash;\n");
            source.AppendFront("duplicateMatchCandidate.nextWithSameHash = match;\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFormat("label_auto_{0}: ;\n", rulePatternClassName.Replace('.', '_'));
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFrontFormat("foreach({0} toClean in foundMatchesOfSameMainPatternHash.Values) toClean.CleanNextWithSameHash();\n", matchClassName);
            
            source.Unindent();
            source.AppendFront("}\n");

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateOrderByFilter(SourceBuilder source, LGSPRulePattern rulePattern, LGSPFilterAutoGenerated filter, bool ascending)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = ascending ? "orderAscendingBy_" + filter.EntitySuffixUnderscore : "orderDescendingBy_" + filter.EntitySuffixUnderscore;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n", 
                rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);
            source.AppendFrontFormat("matchesArray.Sort(new Comparer_{0}_{1}());\n", rulePattern.name, filterName);
            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");

            if(filter.Entities.Count > 1) // Comparer for single element already generated by frontend
            {
                source.AppendFrontFormat("class Comparer_{0}_{1} : Comparer<{2}>\n", rulePattern.name, filterName, matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();

                if(ascending)
                    source.AppendFrontFormat("public override int Compare({0} left, {0} right)\n", matchInterfaceName);
                else
                    source.AppendFrontFormat("public override int Compare({0} right, {0} left)\n", matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();
                EmitOrderByComparer(source, filter.Entities, filter.EntityTypes, false, 0);
                source.Unindent();
                source.AppendFront("}\n");

                source.Unindent();
                source.AppendFront("}\n");
            }
        }

        private static void GenerateOrderByFilter(SourceBuilder source, LGSPRulePattern rulePattern, IIterated iterated, LGSPFilterAutoGenerated filter, bool ascending)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name, iterated.IteratedPattern.Name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = ascending ? "orderAscendingBy_" + filter.EntitySuffixUnderscore : "orderDescendingBy_" + filter.EntitySuffixUnderscore;

            source.AppendFrontFormat("public static {3} Filter_{0}_{1}_{2}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {3} matches)\n",
                rulePattern.name, iterated.IteratedPattern.Name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);
            source.AppendFrontFormat("matchesArray.Sort(new Comparer_{0}_{1}_{2}());\n",
                rulePattern.name, iterated.IteratedPattern.Name, filterName);
            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");

            if(filter.Entities.Count > 1) // Comparer for single element already generated by frontend
            {
                source.AppendFrontFormat("public class Comparer_{0}_{1}_{2} : Comparer<{3}>\n",
                    rulePattern.name, iterated.IteratedPattern.Name, filterName, matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();

                if(ascending)
                    source.AppendFrontFormat("public override int Compare({0} left, {0} right)\n", matchInterfaceName);
                else
                    source.AppendFrontFormat("public override int Compare({0} right, {0} left)\n", matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();
                EmitOrderByComparer(source, filter.Entities, filter.EntityTypes, false, 0);
                source.Unindent();
                source.AppendFront("}\n");

                source.Unindent();
                source.AppendFront("}\n");
            }
        }

        private static void GenerateMatchClassOrderByFilter(SourceBuilder source, MatchClassInfo matchClass, LGSPFilterAutoGenerated filter, bool ascending)
        {
            String matchInterfaceName = NamesOfEntities.MatchInterfaceName(matchClass.name);
            String matchesListType = "IList<GRGEN_LIBGR.IMatch>";
            String filterName = ascending ? "orderAscendingBy_" + filter.EntitySuffixUnderscore : "orderDescendingBy_" + filter.EntitySuffixUnderscore;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                matchClass.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = GRGEN_LIBGR.MatchListHelper.ToList<{0}>(matches);\n", matchInterfaceName);
            source.AppendFrontFormat("matchesArray.Sort(new Comparer_{0}_{1}());\n", matchClass.name, filterName);
            source.AppendFrontFormat("GRGEN_LIBGR.MatchListHelper.FromList(matches, matchesArray);\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");

            if(filter.Entities.Count > 1) // Comparer for single element already generated by frontend
            {
                source.AppendFrontFormat("class Comparer_{0}_{1} : Comparer<{2}>\n", matchClass.name, filterName, matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();

                if(ascending)
                    source.AppendFrontFormat("public override int Compare({0} left, {0} right)\n", matchInterfaceName);
                else
                    source.AppendFrontFormat("public override int Compare({0} right, {0} left)\n", matchInterfaceName);
                source.AppendFront("{\n");
                source.Indent();
                EmitOrderByComparer(source, filter.Entities, filter.EntityTypes, false, 0);
                source.Unindent();
                source.AppendFront("}\n");

                source.Unindent();
                source.AppendFront("}\n");
            }
        }

        private static void EmitOrderByComparer(SourceBuilder source, List<String> filterVariables, List<GrGenType> variableTypes, bool leaf, int pos)
        {
            String filterVariable = filterVariables[pos];
            GrGenType variableType = variableTypes[pos];
            if(pos + 1 < filterVariables.Count && !leaf)
            {
                if(variableType.Equals(VarType.GetVarType(typeof(string))))
                    source.AppendFrontFormat("if(StringComparer.InvariantCulture.Compare(left.{0}, right.{0})==0)", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                else if(variableType.Equals(VarType.GetVarType(typeof(object))))
                    source.AppendFrontFormat("if(AttributeTypeObjectCopierComparer.IsEqual(left.{0}, right.{0}, new Dictionary<object, object>()))", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                else
                    source.AppendFrontFormat("if(left.{0}.CompareTo(right.{0})==0)", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                source.Indent();
                EmitOrderByComparer(source, filterVariables, variableTypes, false, pos + 1);
                source.Unindent();
                source.AppendFrontFormat("else");
                source.Indent();
                EmitOrderByComparer(source, filterVariables, variableTypes, true, pos);
                source.Unindent();
            }
            else
            {
                if(variableType.Equals(VarType.GetVarType(typeof(string))))
                    source.AppendFrontFormat("return StringComparer.InvariantCulture.Compare(left.{0}, right.{0});\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                else if(variableType.Equals(VarType.GetVarType(typeof(object))))
                    source.AppendFrontFormat("return AttributeTypeObjectCopierComparer.IsEqual(left.{0}, right.{0}, new Dictionary<object, object>()) ? 0 : (AttributeTypeObjectCopierComparer.IsLower(left.{0}, right.{0}, new Dictionary<object, object>()) ? -1 : 1);\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
                else
                    source.AppendFrontFormat("return left.{0}.CompareTo(right.{0});\n", NamesOfEntities.MatchName(filterVariable, EntityType.Variable));
            }
        }

        private static void GenerateGroupByFilter(SourceBuilder source, LGSPRulePattern rulePattern, String filterEntity)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "groupBy_" + filterEntity;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(rulePattern, matchEntity);
            EmitGroupByFilter(source, matchEntity, typeOfEntity, matchInterfaceName);

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateGroupByFilter(SourceBuilder source, LGSPRulePattern rulePattern, IIterated iterated, String filterEntity)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name, iterated.IteratedPattern.Name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "groupBy_" + filterEntity;

            source.AppendFrontFormat("public static {3} Filter_{0}_{1}_{2}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {3} matches)\n",
                rulePattern.name, iterated.IteratedPattern.Name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, iterated, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(rulePattern, iterated, matchEntity);
            EmitGroupByFilter(source, matchEntity, typeOfEntity, matchInterfaceName);

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateMatchClassGroupByFilter(SourceBuilder source, MatchClassInfo matchClass, String filterEntity)
        {
            String matchInterfaceName = NamesOfEntities.MatchInterfaceName(matchClass.name);
            String matchesListType = "IList<GRGEN_LIBGR.IMatch>";
            String filterName = "groupBy_" + filterEntity;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                matchClass.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = GRGEN_LIBGR.MatchListHelper.ToList<{0}>(matches);\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(matchClass, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(matchClass, matchEntity);
            EmitGroupByFilter(source, matchEntity, typeOfEntity, matchInterfaceName);

            source.AppendFrontFormat("GRGEN_LIBGR.MatchListHelper.FromList(matches, matchesArray);\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void EmitGroupByFilter(SourceBuilder source, String matchEntity, String typeOfEntity, String typeOfMatch)
        {
            source.AppendFrontFormat("Dictionary<{0}, List<{1}>> seenValues = new Dictionary<{0}, List<{1}>>();\n",
                typeOfEntity, typeOfMatch);
            source.AppendFront("for(int pos = 0; pos < matchesArray.Count; ++pos)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("if(seenValues.ContainsKey(matchesArray[pos].{0}))\n", matchEntity);
            source.AppendFrontIndentedFormat("seenValues[matchesArray[pos].{0}].Add(matchesArray[pos]);\n", matchEntity);
            source.AppendFront("else {\n");
            source.Indent();
            source.AppendFrontFormat("List<{0}> newList = new List<{0}>();\n", typeOfMatch);
            source.AppendFront("newList.Add(matchesArray[pos]);\n");
            source.AppendFrontFormat("seenValues.Add(matchesArray[pos].{0}, newList);\n", matchEntity);
            source.Unindent();
            source.AppendFront("}\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("matchesArray.Clear();\n");
            source.AppendFrontFormat("foreach(List<{0}> entry in seenValues.Values)\n", typeOfMatch);
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("matchesArray.AddRange(entry);\n");
            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateKeepSameFilter(SourceBuilder source, LGSPRulePattern rulePattern, String filterEntity, bool sameAsFirst)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = sameAsFirst ? "keepSameAsFirst_" + filterEntity : "keepSameAsLast_" + filterEntity;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n", 
                rulePattern.name, filterName, matchesListType);

            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, filterEntity);
            EmitKeepSameFilter(source, matchEntity, sameAsFirst);

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateKeepSameFilter(SourceBuilder source, LGSPRulePattern rulePattern, IIterated iterated, String filterEntity, bool sameAsFirst)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name, iterated.IteratedPattern.Name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = sameAsFirst ? "keepSameAsFirst_" + filterEntity : "keepSameAsLast_" + filterEntity;

            source.AppendFrontFormat("public static {3} Filter_{0}_{1}_{2}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {3} matches)\n",
                rulePattern.name, iterated.IteratedPattern.Name, filterName, matchesListType);

            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, iterated, filterEntity);
            EmitKeepSameFilter(source, matchEntity, sameAsFirst);

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateMatchClassKeepSameFilter(SourceBuilder source, MatchClassInfo matchClass, String filterEntity, bool sameAsFirst)
        {
            String matchInterfaceName = NamesOfEntities.MatchInterfaceName(matchClass.name);
            String matchesListType = "IList<GRGEN_LIBGR.IMatch>";
            String filterName = sameAsFirst ? "keepSameAsFirst_" + filterEntity : "keepSameAsLast_" + filterEntity;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                matchClass.name, filterName, matchesListType);

            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = GRGEN_LIBGR.MatchListHelper.ToList<{0}>(matches);\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(matchClass, filterEntity);
            EmitKeepSameFilter(source, matchEntity, sameAsFirst);

            source.AppendFrontFormat("GRGEN_LIBGR.MatchListHelper.FromList(matches, matchesArray);\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void EmitKeepSameFilter(SourceBuilder source, String matchEntity, bool sameAsFirst)
        {
            if(sameAsFirst)
            {
                source.AppendFront("int pos = 0 + 1;\n");
                source.AppendFront("while(pos < matchesArray.Count)\n");
                source.AppendFront("{\n");
                source.Indent();
                source.AppendFrontFormat("if(matchesArray[pos].{0} != matchesArray[0].{0})\n", matchEntity);
                source.AppendFrontIndented("matchesArray[pos] = null;\n");
                source.AppendFront("++pos;\n");
                source.Unindent();
                source.AppendFront("}\n");
            }
            else
            {
                source.AppendFront("int pos = matchesArray.Count-1 - 1;\n");
                source.AppendFront("while(pos >= 0)\n");
                source.AppendFront("{\n");
                source.Indent();
                source.AppendFrontFormat("if(matchesArray[pos].{0} != matchesArray[matchesArray.Count-1].{0})\n", matchEntity);
                source.AppendFrontIndented("matchesArray[pos] = null;\n");
                source.AppendFront("--pos;\n");
                source.Unindent();
                source.AppendFront("}\n");
            }
        }

        private static void GenerateKeepOneForEachFilter(SourceBuilder source, LGSPRulePattern rulePattern, String filterEntity)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "keepOneForEach_" + filterEntity;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                 rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(rulePattern, matchEntity);
            EmitKeepOneForEachFilter(source, matchEntity, typeOfEntity);

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateKeepOneForEachFilter(SourceBuilder source, LGSPRulePattern rulePattern, IIterated iterated, String filterEntity)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name, iterated.IteratedPattern.Name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "keepOneForEach_" + filterEntity;

            source.AppendFrontFormat("public static {3} Filter_{0}_{1}_{2}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {3} matches)\n",
                 rulePattern.name, iterated.IteratedPattern.Name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, iterated, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(rulePattern, iterated, matchEntity);
            EmitKeepOneForEachFilter(source, matchEntity, typeOfEntity);

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateMatchClassKeepOneForEachFilter(SourceBuilder source, MatchClassInfo matchClass, String filterEntity)
        {
            String matchInterfaceName = NamesOfEntities.MatchInterfaceName(matchClass.name);
            String matchesListType = "IList<GRGEN_LIBGR.IMatch>";
            String filterName = "keepOneForEach_" + filterEntity;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                 matchClass.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = GRGEN_LIBGR.MatchListHelper.ToList<{0}>(matches);\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(matchClass, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(matchClass, matchEntity);
            EmitKeepOneForEachFilter(source, matchEntity, typeOfEntity);

            source.AppendFrontFormat("GRGEN_LIBGR.MatchListHelper.FromList(matches, matchesArray);\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void EmitKeepOneForEachFilter(SourceBuilder source, String matchEntity, String typeOfEntity)
        {
            source.AppendFrontFormat("Dictionary<{0}, object> seenValues = new Dictionary<{0}, object>();\n", typeOfEntity);
            source.AppendFront("for(int pos = 0; pos < matchesArray.Count; ++pos)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("if(seenValues.ContainsKey(matchesArray[pos].{0}))\n", matchEntity);
            source.AppendFrontIndented("matchesArray[pos] = null;\n");
            source.AppendFront("else\n");
            source.AppendFrontIndentedFormat("seenValues.Add(matchesArray[pos].{0}, null);\n", matchEntity);
            source.Unindent();
            source.AppendFront("}\n");
        }

        private static void GenerateKeepOneForEachAccumulateByFilter(SourceBuilder source, LGSPRulePattern rulePattern,
            String filterEntity, String accumulationVariable, String accumulationMethod)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "keepOneForEachAccumulateBy_" + filterEntity + "_" + accumulationVariable + "_" + accumulationMethod;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                 rulePattern.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(rulePattern, matchEntity);
            String accumulationMatchVariable = getFilterEntityName(rulePattern, accumulationVariable);
            String typeOfAccumulationVariable = getTypeOfFilterEntity(rulePattern, accumulationMatchVariable);

            EmitKeepOneForEachAccumulateByFilter(source,
                matchEntity, accumulationMatchVariable, typeOfEntity, typeOfAccumulationVariable,
                getArrayAccumulationMethodImplementation(accumulationMethod));

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static String getFilterEntityName(LGSPRulePattern rulePattern, String filterEntity)
        {
            IPatternElement patternElement = rulePattern.patternGraph.GetPatternElement(filterEntity);
            if(patternElement is IPatternNode)
                return NamesOfEntities.MatchName(filterEntity, EntityType.Node);
            else if(patternElement is IPatternEdge)
                return NamesOfEntities.MatchName(filterEntity, EntityType.Edge);
            else
                return NamesOfEntities.MatchName(filterEntity, EntityType.Variable);
        }

        private static String getTypeOfFilterEntity(LGSPRulePattern rulePattern, String matchEntity)
        {
            foreach(IPatternVariable var in rulePattern.patternGraph.variables)
            {
                if(var.Name == rulePattern.PatternGraph.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(var.Type);
            }
            foreach(IPatternNode node in rulePattern.patternGraph.nodes)
            {
                if(node.Name == rulePattern.patternGraph.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(node.Type);
            }
            foreach(IPatternEdge edge in rulePattern.patternGraph.edges)
            {
                if(edge.Name == rulePattern.patternGraph.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(edge.Type);
            }

            return null;
        }

        private static void GenerateKeepOneForEachAccumulateByFilter(SourceBuilder source, LGSPRulePattern rulePattern, IIterated iterated,
            String filterEntity, String accumulationVariable, String accumulationMethod)
        {
            String rulePatternClassName = "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(rulePattern.PatternGraph.Package) + rulePattern.GetType().Name;
            String matchInterfaceName = rulePatternClassName + "." + NamesOfEntities.MatchInterfaceName(rulePattern.name, iterated.IteratedPattern.Name);
            String matchesListType = "GRGEN_LIBGR.IMatchesExact<" + matchInterfaceName + ">";
            String filterName = "keepOneForEachAccumulateBy_" + filterEntity + "_" + accumulationVariable + "_" + accumulationMethod;

            source.AppendFrontFormat("public static {3} Filter_{0}_{1}_{2}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {3} matches)\n",
                 rulePattern.name, iterated.IteratedPattern.Name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = matches.ToListExact();\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(rulePattern, iterated, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(rulePattern, iterated, matchEntity);
            String accumulationMatchVariable = getFilterEntityName(rulePattern, iterated, accumulationVariable);
            String typeOfAccumulationVariable = getTypeOfFilterEntity(rulePattern, iterated, accumulationMatchVariable);

            EmitKeepOneForEachAccumulateByFilter(source,
                matchEntity, accumulationMatchVariable, typeOfEntity, typeOfAccumulationVariable,
                getArrayAccumulationMethodImplementation(accumulationMethod));

            source.AppendFront("matches.FromListExact();\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static String getFilterEntityName(LGSPRulePattern rulePattern, IIterated iterated, String filterEntity)
        {
            IPatternElement patternElement = iterated.IteratedPattern.GetPatternElement(filterEntity);
            if(patternElement is IPatternNode)
                return NamesOfEntities.MatchName(filterEntity, EntityType.Node);
            else if(patternElement is IPatternEdge)
                return NamesOfEntities.MatchName(filterEntity, EntityType.Edge);
            else
                return NamesOfEntities.MatchName(filterEntity, EntityType.Variable);
        }

        private static String getTypeOfFilterEntity(LGSPRulePattern rulePattern, IIterated iterated, String matchEntity)
        {
            foreach(IPatternVariable var in iterated.IteratedPattern.Variables)
            {
                if(var.Name == rulePattern.PatternGraph.Name + "_" + iterated.IteratedPattern.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(var.Type);
                if(var.Name == rulePattern.PatternGraph.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(var.Type);
            }
            foreach(IPatternNode node in iterated.IteratedPattern.Nodes)
            {
                if(node.Name == rulePattern.patternGraph.Name + "_" + iterated.IteratedPattern.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(node.Type);
                if(node.Name == rulePattern.patternGraph.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(node.Type);
            }
            foreach(IPatternEdge edge in iterated.IteratedPattern.Edges)
            {
                if(edge.Name == rulePattern.patternGraph.Name + "_" + iterated.IteratedPattern.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(edge.Type);
                if(edge.Name == rulePattern.patternGraph.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(edge.Type);
            }

            return null;
        }

        private static void GenerateMatchClassKeepOneForEachAccumulateByFilter(SourceBuilder source, MatchClassInfo matchClass, 
            String filterEntity, String accumulationVariable, String accumulationMethod)
        {
            String matchInterfaceName = NamesOfEntities.MatchInterfaceName(matchClass.name);
            String matchesListType = "IList<GRGEN_LIBGR.IMatch>";
            String filterName = "keepOneForEachAccumulateBy_" + filterEntity + "_" + accumulationVariable + "_" + accumulationMethod;

            source.AppendFrontFormat("public static {2} Filter_{0}_{1}(GRGEN_LGSP.LGSPGraphProcessingEnvironment procEnv, {2} matches)\n",
                 matchClass.name, filterName, matchesListType);
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFrontFormat("List<{0}> matchesArray = GRGEN_LIBGR.MatchListHelper.ToList<{0}>(matches);\n", matchInterfaceName);

            String matchEntity = getFilterEntityName(matchClass, filterEntity);
            String typeOfEntity = getTypeOfFilterEntity(matchClass, matchEntity);
            String accumulationMatchVariable = getFilterEntityName(matchClass, accumulationVariable);
            String typeOfAccumulationVariable = getTypeOfFilterEntity(matchClass, accumulationMatchVariable);

            EmitKeepOneForEachAccumulateByFilter(source,
                matchEntity, accumulationMatchVariable, typeOfEntity, typeOfAccumulationVariable,
                getArrayAccumulationMethodImplementation(accumulationMethod));

            source.AppendFrontFormat("GRGEN_LIBGR.MatchListHelper.FromList(matches, matchesArray);\n");
            source.AppendFront("return matches;\n");

            source.Unindent();
            source.AppendFront("}\n");
        }

        private static String getFilterEntityName(MatchClassInfo matchClass, String filterEntity)
        {
            IPatternElement patternElement = matchClass.GetPatternElement(filterEntity);
            if(patternElement is IPatternNode)
                return NamesOfEntities.MatchName(filterEntity, EntityType.Node);
            else if(patternElement is IPatternEdge)
                return NamesOfEntities.MatchName(filterEntity, EntityType.Edge);
            else
                return NamesOfEntities.MatchName(filterEntity, EntityType.Variable);
        }

        private static String getTypeOfFilterEntity(MatchClassInfo matchClass, String matchEntity)
        {
            foreach(IPatternVariable var in matchClass.variables)
            {
                if(var.Name == matchClass.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(var.Type);
            }
            foreach(IPatternNode node in matchClass.nodes)
            {
                if(node.Name == matchClass.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(node.Type);
            }
            foreach(IPatternEdge edge in matchClass.edges)
            {
                if(edge.Name == matchClass.Name + "_" + matchEntity)
                    return TypesHelper.TypeName(edge.Type);
            }

            return null;
        }

        private static void EmitKeepOneForEachAccumulateByFilter(SourceBuilder source,
            String matchEntity, String accumulationVariable, String typeOfEntity, String typeOfAccumulationVariable,
            String accumulationMethod)
        {
            source.AppendFrontFormat("Dictionary<{0}, List<{1}>> seenValues = new Dictionary<{0}, List<{1}>>();\n",
                typeOfEntity, typeOfAccumulationVariable);
            source.AppendFront("for(int pos = 0; pos < matchesArray.Count; ++pos)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("if(seenValues.ContainsKey(matchesArray[pos].{0}))\n", matchEntity);
            source.AppendFrontIndentedFormat("seenValues[matchesArray[pos].{0}].Add(matchesArray[pos].{1});\n",
                matchEntity, accumulationVariable);
            source.AppendFront("else {\n");
            source.Indent();
            source.AppendFrontFormat("List<{0}> newList = new List<{0}>();\n", typeOfAccumulationVariable);
            source.AppendFrontFormat("newList.Add(matchesArray[pos].{0});\n", accumulationVariable);
            source.AppendFrontFormat("seenValues.Add(matchesArray[pos].{0}, newList);\n", matchEntity);
            source.Unindent();
            source.AppendFront("}\n");
            source.Unindent();
            source.AppendFront("}\n");
            source.AppendFront("for(int pos = 0; pos < matchesArray.Count; ++pos)\n");
            source.AppendFront("{\n");
            source.Indent();
            source.AppendFrontFormat("if(seenValues.ContainsKey(matchesArray[pos].{0}))", matchEntity);
            source.Append(" {\n");
            source.Indent();
            source.AppendFrontFormat("matchesArray[pos].{0} = {1}(seenValues[matchesArray[pos].{2}]);\n",
                accumulationVariable, accumulationMethod, matchEntity);
            source.AppendFrontFormat("seenValues.Remove(matchesArray[pos].{0});\n", matchEntity);
            source.Unindent();
            source.AppendFront("} else\n");
            source.AppendFrontIndented("matchesArray[pos] = null;\n");
            source.Unindent();
            source.AppendFront("}\n");
        }

        private static String getArrayAccumulationMethodImplementation(String arrayAccumulationMethod)
        {
            switch(arrayAccumulationMethod)
            {
            case "sum": return "GRGEN_LIBGR.ContainerHelper.Sum";
            case "prod": return "GRGEN_LIBGR.ContainerHelper.Prod";
            case "min": return "GRGEN_LIBGR.ContainerHelper.Min";
            case "max": return "GRGEN_LIBGR.ContainerHelper.Max";
            case "avg": return "GRGEN_LIBGR.ContainerHelper.Avg";
            case "med": return "GRGEN_LIBGR.ContainerHelper.Med";
            case "medUnordered": return "GRGEN_LIBGR.ContainerHelper.MedUnordered";
            case "var": return "GRGEN_LIBGR.ContainerHelper.Var";
            case "dev": return "GRGEN_LIBGR.ContainerHelper.Dev";
            case "and": return "GRGEN_LIBGR.ContainerHelper.And";
            case "or": return "GRGEN_LIBGR.ContainerHelper.Or";
            default: return "INTERNAL ERROR";
            }
        }

        public static void GenerateMatchClassFilterers(SourceBuilder source, MatchClassInfo matchClass, IGraphModel model)
        {
            source.AppendFront("\n");

            String filtererClassName = "MatchClassFilterer_" + matchClass.Name;
            EmitMatchClassFiltererClassBegin(source, filtererClassName, matchClass.Package);

            String infoClassName = "MatchClassInfo_" + matchClass.Name;
            EmitMatchClassFiltererConstructor(source, filtererClassName, infoClassName);

            source.AppendFront("public override void Filter(GRGEN_LIBGR.IActionExecutionEnvironment actionEnv, IList<GRGEN_LIBGR.IMatch> matches, GRGEN_LIBGR.FilterCallWithArguments filter)\n");
            source.AppendFront("{\n");
            source.Indent();

            source.AppendFront("switch(filter.PackagePrefixedName) {\n");
            source.Indent();
            foreach(IFilter filter in matchClass.Filters)
            {
                EmitFilterCallDispatching(source, matchClass, filter);
            }
            source.AppendFront("default: throw new Exception(\"Unknown filter name \" + filter.PackagePrefixedName + \"!\");\n");
            source.Unindent();
            source.AppendFront("}\n");

            source.Unindent();
            source.AppendFront("}\n");

            EmitMatchClassFiltererClassEnd(source, matchClass.Package);
        }

        private static void EmitMatchClassFiltererClassBegin(SourceBuilder source, String filtererClassName, String package)
        {
            if(package != null)
            {
                source.AppendFrontFormat("namespace {0}\n", package);
                source.AppendFront("{\n");
                source.Indent();
            }

            source.AppendFront("public class " + filtererClassName + " : GRGEN_LIBGR.MatchClassFilterer\n");
            source.AppendFront("{\n");
            source.Indent();
        }

        private static void EmitMatchClassFiltererConstructor(SourceBuilder source, String filtererClassName, String infoClassName)
        {
            source.AppendFront("private static " + filtererClassName + " instance = null;\n");
            source.AppendFront("public static " + filtererClassName + " Instance { get { if (instance==null) { "
                    + "instance = new " + filtererClassName + "(); } return instance; } }\n");
            source.AppendFront("\n");

            source.AppendFront("private " + filtererClassName + "()\n");
            source.AppendFrontIndented(": base(" + infoClassName + ".Instance)\n");
            source.AppendFront("{\n");
            source.AppendFront("}\n");
            source.AppendFront("\n");
        }

        private static void EmitFilterCallDispatching(SourceBuilder source, MatchClassInfo matchClass, IFilter filter)
        {
            String matchClassName = matchClass.Name;
            String matchesType = "List<GRGEN_LIBGR.IMatch>";

            if(filter is IFilterAutoSupplied)
            {
                IFilterAutoSupplied filterAutoSupplied = (IFilterAutoSupplied)filter;
                source.AppendFrontFormat("case \"{0}\": ", filterAutoSupplied.Name);
                source.AppendFormat("GRGEN_LIBGR.MatchListHelper.Filter_{0}((List<GRGEN_LIBGR.IMatch>)matches",
                    filterAutoSupplied.Name);
                for(int i = 0; i < filterAutoSupplied.Inputs.Length; ++i)
                {
                    source.AppendFormat(", ({0})(filter.Arguments[{1}])", TypesHelper.TypeName(filterAutoSupplied.Inputs[i]), i);
                }
                source.Append("); break;\n");
            }
            else if(filter is IFilterAutoGenerated)
            {
                LGSPFilterAutoGenerated filterAutoGenerated = (LGSPFilterAutoGenerated)filter;
                source.AppendFrontFormat("case \"{0}\": ", filterAutoGenerated.Name);
                source.AppendFormat("GRGEN_ACTIONS.{0}MatchClassFilters.",
                    TypesHelper.GetPackagePrefixDot(filterAutoGenerated.PackageOfApplyee));
                source.AppendFormat("Filter_{0}_{1}((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, ({2})matches); break;\n",
                    matchClassName, filterAutoGenerated.NameWithUnderscoreSuffix, matchesType);
            }
            else if(filter is IFilterFunction)
            {
                IFilterFunction filterFunction = (IFilterFunction)filter;
                if(filterFunction.Package == null
                    || (matchClass.Package != null && filterFunction.Package == matchClass.Package && matchClass.GetFilter(filterFunction.Name) == null))
                {
                    source.AppendFrontFormat("case \"{0}\": ", filterFunction.Name);
                    source.AppendFormat("{0}MatchClassFilters.Filter_{1}((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, ({2})matches",
                        "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(filterFunction.Package), filterFunction.Name, matchesType);
                    for(int i = 0; i < filterFunction.Inputs.Length; ++i)
                    {
                        source.AppendFormat(", ({0})(filter.Arguments[{1}])", TypesHelper.TypeName(filterFunction.Inputs[i]), i);
                    }
                    source.Append("); break;\n");
                }
                if(filterFunction.Package != null)
                {
                    source.AppendFrontFormat("case \"{0}::{1}\": ", filterFunction.Package, filterFunction.Name);
                    source.AppendFormat("{0}MatchClassFilters.Filter_{1}((GRGEN_LGSP.LGSPGraphProcessingEnvironment)actionEnv, ({2})matches",
                        "GRGEN_ACTIONS." + TypesHelper.GetPackagePrefixDot(filterFunction.Package), filterFunction.Name, matchesType);
                    for(int i = 0; i < filterFunction.Inputs.Length; ++i)
                    {
                        source.AppendFormat(", ({0})(filter.Arguments[{1}])", TypesHelper.TypeName(filterFunction.Inputs[i]), i);
                    }
                    source.Append("); break;\n");
                }
            }
        }

        private static void EmitMatchClassFiltererClassEnd(SourceBuilder source, String package)
        {
            source.Unindent();
            source.AppendFront("}\n");

            if(package != null)
            {
                source.Unindent();
                source.AppendFront("}\n");
            }
        }
    }
}
