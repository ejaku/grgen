/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 6.7
 * Copyright (C) 2003-2023 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

// by Edgar Jakumeit

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace de.unika.ipd.grGen.libGr
{
    enum TokenKind
    {
        UNKNOWN, //internal state, lexing underway
        COLON, //:
        DOUBLECOLON, //::
        DOLLAR, //$
        PERCENT, //%
        EQUAL, //=
        DOT, //.
        COMMA, //,
        ARROW, //->
        MINUS, //-
        LPARENTHESIS, //(
        RPARENTHESIS, //)
        AT, //@
        ATAT, //@@
        LANGLE, //<
        RANGLE, //>
        LBRACE, //{
        RBRACE, //}
        LBOXBRACKET, //[
        RBOXBRACKET, //]
        NUMBER, //("-")? (["0"-"9"])+
        NUMBER_BYTE, //NUMBER ("y"|"Y")
        NUMBER_SHORT, //NUMBER ("s"|"S")
        NUMBER_LONG, //NUMBER ("l"|"L")
        HEXNUMBER, //0x (["0"-"9", "a"-"f", "A"-"F"])+
        HEXNUMBER_BYTE, //HEXNUMBER ("y"|"Y")
        HEXNUMBER_SHORT, //HEXNUMBER ("s"|"S")
        HEXNUMBER_LONG, //HEXNUMBER ("l"|"L")
        NUMFLOAT, //floating point number, with "f"|"F" suffix
        NUMDOUBLE, //floating point number (combination of sign, number, dot, fractional part, exponent)
        DOUBLEQUOTEDTEXT, // "\"" (~["\""])* "\""
        SINGLEQUOTEDTEXT, // "\'" (~["\'"])* "\'"
        IDENT, // LETTER (LETTER | DIGIT)*
        ADD, //add
        ARRAY, //array
        DELETE, //delete
        DEQUE, //deque
        EDGE, //edge
        EXTERNAL, //external attribute change
        FALSE, //false
        GRAPH, //graph
        IN, //in
        MAP, //map
        NEW, //new
        NODE, //node
        NULL, //null
        REM, //rem
        RETYPE, //retype
        SET, //set
        TRUE, //true
        EOF // end of file
    }

    /// <summary>
    /// Imports graphs from files in GRS format.
    /// Implementation note: this is a boring hand written lexer and parser,
    /// needed because the lexer/parser generated by CSharpCC that was replaced by it
    /// fired a multitude of "LookaheadSuccess"-exceptions, wreaking havoc on performance.
    /// </summary>
    public class GRSImport
    {
        INamedGraph graph; // current graph (host graph or subgraph)
        IBackend backend;
        IGraphModel model;
        String modelOverride;
        IActions actions;
        readonly TextReader reader; // the text reader containing the grs contents to import
        readonly long fileSize; // the size of the grs file, used to initialize the capacity of the name maps of the named graph
        int line; // the current line reached during parsing/lexing, for error messages
        int column; // the current column reached during parsing/lexing, for error messages
        bool tokenFound; // tells whether a token was matched lately, cleared by the parser when asking for the next one to be delivered
        TokenKind tokenKind; // gives the kind of token matched lately
        readonly StringBuilder tokenContent; // the buffer with the token matched lately
        readonly Dictionary<string, INamedGraph> nameToSubgraph = new Dictionary<string, INamedGraph>(); // maps subgraph name to subgraph
        readonly Dictionary<INamedGraph, Dictionary<string, IObject>> graphToNameToClassObject = new Dictionary<INamedGraph, Dictionary<string, IObject>>(); // indexed by graph, maps "persistent" name to class object
        readonly AttributeType intAttrType = new AttributeType(null, null, AttributeKind.IntegerAttr, null, null, null, null, null, null, typeof(int));

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="modelOverride">The graph model to be used, 
        ///     it must be conformant to the model used in the file to be imported.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>
        public static INamedGraph Import(String importFilename, String modelOverride, IBackend backend, out IActions actions)
        {
            FileInfo fi = new FileInfo(importFilename);
            long fileSize = fi.Length;
            return Import(new StreamReader(importFilename), fileSize, modelOverride, backend, out actions);
        }

        /// <summary>
        /// Imports the given graph from the given text reader input stream.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="reader">The text reader input stream import source.</param>
        /// <param name="fileSize">The size of the input file.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="modelOverride">The graph model to be used, 
        ///     it must be conformant to the model used in the file to be imported.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(TextReader reader, long fileSize, String modelOverride, IBackend backend, out IActions actions)
        {
            GRSImport importer = new GRSImport(reader, fileSize);
            importer.backend = backend;
            importer.modelOverride = modelOverride;
            importer.model = null;
            importer.ParseGraphBuildingScript();
            actions = importer.actions;
            return importer.graph;
        }

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, IBackend backend, out IActions actions)
        {
            return Import(importFilename, null, backend, out actions);
        }

        /// <summary>
        /// Imports the given graph from a file with the given filename.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="importFilename">The filename of the file to be imported.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="graphModel">The graph model to be used.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(String importFilename, IBackend backend, IGraphModel graphModel, out IActions actions)
        {
            FileInfo fi = new FileInfo(importFilename);
            long fileSize = fi.Length;
            return Import(new StreamReader(importFilename), fileSize, backend, graphModel, out actions);
        }
        
        /// <summary>
        /// Imports the given graph from the given text reader input stream.
        /// Any errors will be reported by exception.
        /// </summary>
        /// <param name="reader">The text reader input stream import source.</param>
        /// <param name="fileSize">The size of the input file.</param>
        /// <param name="backend">The backend to use to create the graph.</param>
        /// <param name="graphModel">The graph model to be used.</param>
        /// <param name="actions">Receives the actions object in case a .grg model is given.</param>
        /// <returns>The imported graph. 
        /// An INamedGraph is returned. If you don't need it: create an LGSPGraph from it and throw the named graph away.
        /// (the naming requires about the same amount of memory the raw graph behind it requires).</returns>		
        public static INamedGraph Import(TextReader reader, long fileSize, IBackend backend, IGraphModel graphModel, out IActions actions)
        {
            GRSImport importer = new GRSImport(reader, fileSize);
            importer.backend = backend;
            importer.modelOverride = null;
            importer.model = graphModel;
            importer.ParseGraphBuildingScript();
            actions = importer.actions;
            return importer.graph;
        }

        private GRSImport(TextReader reader, long fileSize) {
            this.reader = reader;
            this.fileSize = fileSize;
            this.line = 1;
            this.column = 1;
            this.tokenFound = false;
            this.tokenKind = TokenKind.UNKNOWN;
            this.tokenContent = new StringBuilder();
        }

        public static object Scan(AttributeType attrType, String input, IGraph graph)
        {
            GRSImport importer = new GRSImport(new StringReader(input), input.Length);
            importer.graph = (INamedGraph)graph;
            if(!IsScannable(attrType)
                || attrType.ValueType != null && !IsScannable(attrType.ValueType)
                || attrType.KeyType != null && !IsScannable(attrType.KeyType))
            {
                throw new Exception("Unsupported type to scan");
            }
            return importer.JustParseAttributeValue(attrType);
        }

        private static bool IsScannable(AttributeType attrType)
        {
            return attrType.Kind != AttributeKind.GraphAttr
                && attrType.Kind != AttributeKind.InternalClassObjectAttr
                && attrType.Kind != AttributeKind.InternalClassTransientObjectAttr;
        }

        public static bool TryScan(AttributeType attrType, String input, IGraph graph)
        {
            try
            {
                GRSImport importer = new GRSImport(new StringReader(input), input.Length);
                importer.graph = (INamedGraph)graph;
                if(!IsScannable(attrType)
                    || attrType.ValueType != null && !IsScannable(attrType.ValueType)
                    || attrType.KeyType != null && !IsScannable(attrType.KeyType))
                {
                    throw new Exception("Unsupported type to tryscan");
                }
                importer.JustParseAttributeValue(attrType);
                return true;
            }
            catch(Exception)
            {
                return false;
            }
        }

        private void ParseGraphBuildingScript()
        {
            ParseNewGraphCommand();
            while(LookaheadToken() != TokenKind.EOF)
            {
                switch(LookaheadToken())
                {
                case TokenKind.NEW:
                    ParseNewGraphElementCommand();
                    break;
                case TokenKind.DELETE:
                    ParseDeleteGraphElementCommand();
                    break;
                case TokenKind.RETYPE:
                    ParseRetypeGraphElementCommand();
                    break;
                case TokenKind.ADD:
                    ParseNewSubgraphCommand();
                    break;
                case TokenKind.IN:
                    ParseSwitchToSubgraph();
                    break;
                case TokenKind.EXTERNAL:
                    ParseExternalAttributeChange();
                    break;
                case TokenKind.AT:
                case TokenKind.ATAT:
                    ParseDeferredAttributeAssignment();
                    break;
                default:
                    throw GetSyntaxException("syntax error", "new command, or delete command, or retype command, or external attribute change, or deferred attribute assignment (assignment proper, or container element assignment, or container add, or container rem)");
                }
            }
        }

        private void ParseNewGraphCommand()
        {
            // new graph filename (graphname)?
            Match(TokenKind.NEW);
            Match(TokenKind.GRAPH);
            String modelFilename = MatchFilePath();
            String graphName = "";
            if(LookaheadText())
                graphName = ParseText();

            if(modelOverride!=null)
                modelFilename = modelOverride;
            else
                modelFilename += ".gm";

            // estimate a line creating one node or edge to 50 bytes
            int capacity = (int)(fileSize / 50);
            String capacityStr = "capacity=" + capacity.ToString();

            IGlobalVariables globalVariables = backend.CreateGlobalVariables();
            if(model!=null)
                graph = backend.CreateNamedGraph(model, globalVariables, graphName, capacityStr);
            else 
            {
                if(modelFilename.EndsWith(".grg"))
                    backend.CreateNamedFromSpec(modelFilename, globalVariables, graphName, null, ProcessSpecFlags.UseNoExistingFiles, new List<String>(), capacity,
                        out graph, out actions);
                else
                    graph = backend.CreateNamedGraph(modelFilename, globalVariables, graphName, capacityStr);
            }

            nameToSubgraph.Add(graph.Name, graph);
            graphToNameToClassObject[graph] = new Dictionary<string, IObject>();
        }

        private void ParseNewSubgraphCommand()
        {
            // add new graph graphname
            Match(TokenKind.ADD);
            Match(TokenKind.NEW);
            Match(TokenKind.GRAPH);
            String graphName = ParseText();

            graph = (INamedGraph)graph.CreateEmptyEquivalent(graphName);
            nameToSubgraph.Add(graphName, graph);
            graphToNameToClassObject[graph] = new Dictionary<string, IObject>();
        }

        private void ParseNewGraphElementCommand()
        {
            Match(TokenKind.NEW);
            if(LookaheadToken()==TokenKind.AT)
            {
                // new Node minus ElementDefinition arrow Node, for edge definition
                INode srcNode = ParseNode();
                Match(TokenKind.MINUS);
                string edgeName;
                EdgeType edgeType;
                IEdge edge = ParseEdgeDefinition(out edgeName, out edgeType);
                Match(TokenKind.ARROW);
                INode tgtNode = ParseNode();
                edgeType.SetSourceAndTarget(edge, srcNode, tgtNode);
                graph.AddEdge(edge, edgeName);
            }
            else if(LookaheadToken()==TokenKind.COLON)
            {
                // new ElementDefinition, for node definition
                string nodeName;
                INode node = ParseNodeDefinition(out nodeName);
                graph.AddNode(node, nodeName);
            }
            else if(LookaheadToken()==TokenKind.IDENT)
            {
                // new Object (overaccepting also null)
                IObject obj = ParseClassObjectValue(); // used for side effect: inserts object into nameToClassObject
            }
            else
                throw GetSyntaxException("Syntax error", "@ for node start in edge definition or : for node definition");
        }

        private void ParseDeleteGraphElementCommand()
        {
            Match(TokenKind.DELETE);
            if(LookaheadToken() == TokenKind.NODE)
            {
                Match(TokenKind.NODE);
                INode node = ParseNode();
                graph.Remove(node);
            }
            else
            {
                Match(TokenKind.EDGE);
                IEdge edge = ParseEdge();
                graph.Remove(edge);
            }
        }

        private void ParseRetypeGraphElementCommand()
        {
            Match(TokenKind.RETYPE);
            if(LookaheadToken() == TokenKind.AT)
            {
                INode node = ParseNode();
                Match(TokenKind.LANGLE);
                NodeType nodeType = ParseNodeType();
                Match(TokenKind.RANGLE);
                graph.Retype(node, nodeType);
            }
            else if(LookaheadToken() == TokenKind.MINUS)
            {
                Match(TokenKind.MINUS);
                IEdge edge = ParseEdge();
                Match(TokenKind.LANGLE);
                EdgeType edgeType = ParseEdgeType();
                Match(TokenKind.RANGLE);
                Match(TokenKind.ARROW);
                graph.Retype(edge, edgeType);
            }
            else
                throw GetSyntaxException("Syntax error", "@ for node or - for edge");
        }

        private void ParseSwitchToSubgraph()
        {
            Match(TokenKind.IN);
            graph = ParseGraph();
        }

        private void ParseDeferredAttributeAssignment()
        {
            IAttributeBearer owner;
            if(LookaheadToken()==TokenKind.ATAT)
                owner = ParseClassObjectElement();
            else //if(LookaheadToken()==TokenKind.AT)
                owner = ParseGraphElement();

            Match(TokenKind.DOT);
            string attrName = ParseText();
            AttributeType attrType = owner.Type.GetAttributeType(attrName);

            if(LookaheadToken()==TokenKind.EQUAL)
            {
                // Owner . Text = Value
                Match(TokenKind.EQUAL);
                ParseAttributeValue(owner, attrType);
            }
            else if(LookaheadToken()==TokenKind.LBOXBRACKET) // [ for indexed assignment to attribute
            {
                AttributeType indexAttrType;
                if(attrType.Kind == AttributeKind.ArrayAttr)
                    indexAttrType = intAttrType;
                else if(attrType.Kind == AttributeKind.DequeAttr)
                    indexAttrType = intAttrType;
                else if(attrType.Kind == AttributeKind.MapAttr)
                    indexAttrType = attrType.KeyType;
                else
                    throw GetSyntaxException("indexed assignment to type not offering indexed assignment", "map|array|deque type attribute");

                // GraphElement . Text [ Value ] = Value
                Match(TokenKind.LBOXBRACKET);
                object index = ParseAttributeSimpleValue(indexAttrType);
                Match(TokenKind.RBOXBRACKET);
                Match(TokenKind.EQUAL);
                ParseAttributeValueIndexed(owner, attrType.ValueType, attrType.Name, index);
            }
            else if(LookaheadToken()==TokenKind.DOT) // . for add/rem to/from container
            {
                // GraphElement . Text . add|rem ( ... )
                Match(TokenKind.DOT);
                if(LookaheadToken() == TokenKind.ADD)
                {
                    Match(TokenKind.ADD);
                    Match(TokenKind.LPARENTHESIS);
                    object param1 = ParseAttributeSimpleValue(attrType.Kind == AttributeKind.MapAttr ? attrType.KeyType : attrType.ValueType);
                    if(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        object param2 = ParseAttributeSimpleValue(attrType.Kind == AttributeKind.MapAttr ? attrType.ValueType : intAttrType);
                        ContainerAddIndexed(owner, attrName, param1, param2);
                    }
                    else
                        ContainerAdd(owner, attrName, param1);
                    Match(TokenKind.RPARENTHESIS);
                }
                else if(LookaheadToken() == TokenKind.REM)
                {
                    Match(TokenKind.REM);
                    Match(TokenKind.LPARENTHESIS);
                    if(LookaheadToken() != TokenKind.RPARENTHESIS)
                    {
                        object param = ParseAttributeSimpleValue(attrType.Kind == AttributeKind.MapAttr ? attrType.KeyType : attrType.Kind == AttributeKind.SetAttr ? attrType.ValueType : intAttrType);
                        ContainerRem(owner, attrName, param);
                    }
                    else
                        ContainerRem(owner, attrName, null);
                    Match(TokenKind.RPARENTHESIS);
                }
                else
                    throw GetSyntaxException("Syntax error", "only .add() and .rem() supported");
            }
            else
                throw GetSyntaxException("Syntax error", "= for assignment to attribute");
        }

        private void ContainerAdd(IAttributeBearer owner, String attrName, object keyObj)
        {
            object attr = owner.GetAttribute(attrName);

            if(attr is IDictionary)
            {
                IDictionary dict = attr as IDictionary;
                dict[keyObj] = null;
            }
            else if(attr is IList)
            {
                IList array = attr as IList;
                array.Add(keyObj);
            }
            else if(attr is IDeque)
            {
                IDeque deque = attr as IDeque;
                deque.Enqueue(keyObj);
            }
            else
                throw new Exception(GetOwnerName(owner) + "." + attrName + " is neither a set nor an array nor a deque.");
        }

        private void ContainerAddIndexed(IAttributeBearer owner, String attrName, object keyObj, object valueObj)
        {
            object attr = owner.GetAttribute(attrName);

            if(attr is IDictionary)
            {
                IDictionary dict = attr as IDictionary;
                dict[keyObj] = valueObj;
            }
            else if(attr is IList)
            {
                IList array = attr as IList;
                array.Insert((int)valueObj, keyObj);
            }
            else if(attr is IDeque)
            {
                IDeque deque = attr as IDeque;
                deque.EnqueueAt((int)valueObj, keyObj);
            }
            else
                throw new Exception(GetOwnerName(owner) + "." + attrName + " is neither a map nor an array nor a deque.");
        }

        private string GetOwnerName(IAttributeBearer owner)
        {
            if(owner is IGraphElement)
                return graph.GetElementName((IGraphElement)owner);
            else
                return ((IObject)owner).GetObjectName();
        }

        private void ContainerRem(IAttributeBearer owner, String attrName, object keyObj)
        {
            object attr = owner.GetAttribute(attrName);

            if(attr is IDictionary)
            {
                IDictionary dict = attr as IDictionary;
                dict.Remove(keyObj);
            }
            else if(attr is IList)
            {
                IList array = attr as IList;
                if(keyObj != null)
                    array.RemoveAt((int)keyObj);
                else
                    array.RemoveAt(array.Count - 1);
            }
            else if(attr is IDeque)
            {
                IDeque deque = attr as IDeque;
                if(keyObj != null)
                    deque.DequeueAt((int)keyObj);
                else
                    deque.Dequeue();
            }
            else
                throw new Exception(GetOwnerName(owner) + "." + attrName + " is not a container.");
        }

        private void ParseExternalAttributeChange()
        {
            Match(TokenKind.EXTERNAL);
            string line = MatchExternalLine();
            model.External(line, graph);
        }

        private bool LookaheadText()
        {
            if(LookaheadToken() == TokenKind.IDENT)
                return true;
            else if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                return true;
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                return true;
            else
                return false;
        }

        private string ParseText()
        {
            if(LookaheadToken() == TokenKind.IDENT)
                return MatchAndReturnToken(TokenKind.IDENT);
            else if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                return MatchAndReturnToken(TokenKind.DOUBLEQUOTEDTEXT);
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                return MatchAndReturnToken(TokenKind.SINGLEQUOTEDTEXT);
            else
                throw GetSyntaxException("Syntax error", "ident or double quoted text or single quoted text");
        }

        private string ParseTypeText()
        {
            string typeText;
            if(LookaheadToken() == TokenKind.IDENT)
                typeText = MatchAndReturnToken(TokenKind.IDENT);
            else if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                typeText = MatchAndReturnToken(TokenKind.DOUBLEQUOTEDTEXT);
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                typeText = MatchAndReturnToken(TokenKind.SINGLEQUOTEDTEXT);
            else
                throw GetSyntaxException("Syntax error", "ident or double quoted text or single quoted text");

            if(LookaheadToken() != TokenKind.DOUBLECOLON)
                return typeText;
            
            Match(TokenKind.DOUBLECOLON);
            string packageText = typeText;

            if(LookaheadToken() == TokenKind.IDENT)
                typeText = MatchAndReturnToken(TokenKind.IDENT);
            else if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                typeText = MatchAndReturnToken(TokenKind.DOUBLEQUOTEDTEXT);
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                typeText = MatchAndReturnToken(TokenKind.SINGLEQUOTEDTEXT);
            else
                throw GetSyntaxException("Syntax error", "ident or double quoted text or single quoted text");

            return packageText + "::" + typeText;
        }

        private INode ParseNode()
        {
            // at lparen Text rparen
            Match(TokenKind.AT);
            Match(TokenKind.LPARENTHESIS);
            string nodeName = ParseText();
            Match(TokenKind.RPARENTHESIS);
            return GetNodeByName(nodeName);
        }

        private IEdge ParseEdge()
        {
            // at lparen Text rparen
            Match(TokenKind.AT);
            Match(TokenKind.LPARENTHESIS);
            string edgeName = ParseText();
            Match(TokenKind.RPARENTHESIS);
            return GetEdgeByName(edgeName);
        }

        private IGraphElement ParseGraphElement()
        {
            // at lparen Text rparen
            Match(TokenKind.AT);
            Match(TokenKind.LPARENTHESIS);
            string elemName = ParseText();
            Match(TokenKind.RPARENTHESIS);
            return GetElemByName(elemName);
        }

        private IObject ParseClassObjectElement()
        {
            // atat lparen Text rparen
            Match(TokenKind.ATAT);
            Match(TokenKind.LPARENTHESIS);
            string elemName = ParseText();
            Match(TokenKind.RPARENTHESIS);
            return graphToNameToClassObject[graph][elemName];
        }

        private NodeType ParseNodeType()
        {
            string typeName = ParseTypeText();
            NodeType nodeType = graph.Model.NodeModel.GetType(typeName);
            if(nodeType == null)
                throw new Exception("Unknown node type: \"" + typeName + "\"");
            if(nodeType.IsAbstract)
                throw new Exception("Abstract node type \"" + typeName + "\" may not be instantiated!");
            return nodeType;
        }

        private EdgeType ParseEdgeType()
        {
            string typeName = ParseTypeText();
            EdgeType edgeType = graph.Model.EdgeModel.GetType(typeName);
            if(edgeType == null)
                throw new Exception("Unknown edge type: \"" + typeName + "\"");
            if(edgeType.IsAbstract)
                throw new Exception("Abstract edge type \"" + typeName + "\" may not be instantiated!");
            return edgeType;
        }

        private INamedGraph ParseGraph()
        {
            // Text | null
            if(LookaheadToken() == TokenKind.NULL)
            {
                Match(TokenKind.NULL);
                return null;
            }

            string graphName = ParseText();
            return GetGraphByName(graphName);
        }

        private INode ParseNodeDefinition(out string nodeName)
        {
            // colon Text lparen dollar equal Text Attributes rparen
            Match(TokenKind.COLON);
            string typeName = ParseTypeText();
            
            NodeType nodeType = graph.Model.NodeModel.GetType(typeName);
            if(nodeType == null)
                throw new Exception("Unknown node type: \"" + typeName + "\"");
            if(nodeType.IsAbstract)
                throw new Exception("Abstract node type \"" + typeName + "\" may not be instantiated!");
            
            Match(TokenKind.LPARENTHESIS);
            Match(TokenKind.DOLLAR);
            Match(TokenKind.EQUAL);
            nodeName = ParseText();

            INode node = nodeType.CreateNode();

            while(LookaheadToken() == TokenKind.COMMA)
            {
                Match(TokenKind.COMMA);
                string attribName = ParseText();
                Match(TokenKind.EQUAL);
                
                AttributeType attrType = node.Type.GetAttributeType(attribName);
                
                ParseAttributeValue(node, attrType);
            }
            Match(TokenKind.RPARENTHESIS);

            return node;
        }

        private IEdge ParseEdgeDefinition(out string edgeName, out EdgeType edgeType)
        {
            // colon Text lparen dollar equal Text Attributes rparen
            Match(TokenKind.COLON);
            string typeName = ParseTypeText();

            edgeType = graph.Model.EdgeModel.GetType(typeName);
            if(edgeType == null)
                throw new Exception("Unknown edge type: \"" + typeName + "\"");
            if(edgeType.IsAbstract)
                throw new Exception("Abstract edge type \"" + typeName + "\" may not be instantiated!");
            
            Match(TokenKind.LPARENTHESIS);
            Match(TokenKind.DOLLAR);
            Match(TokenKind.EQUAL);
            edgeName = ParseText();
            
            IEdge edge = edgeType.CreateEdge();

            while(LookaheadToken() == TokenKind.COMMA)
            {
                Match(TokenKind.COMMA);
                string attribName = ParseText();
                Match(TokenKind.EQUAL);
                
                AttributeType attrType = edge.Type.GetAttributeType(attribName);
                
                ParseAttributeValue(edge, attrType);
            }
            Match(TokenKind.RPARENTHESIS);

            return edge;
        }

        private void ParseAttributeValue(IAttributeBearer owner, AttributeType attrType)
        {
            object attributeValue = JustParseAttributeValue(attrType);

            /*AttributeChangeType changeType = AttributeChangeType.Assign;
            if(elem is INode)
                graph.ChangingNodeAttribute((INode)owner, attrType, changeType, value, null);
            else if(elem is IEdge)
                graph.ChangingEdgeAttribute((IEdge)owner, attrType, changeType, value, null);
            else
                graph.ChangingObjectAttribute((IObject)owner, attrType, changeType, value, null);
            */
            owner.SetAttribute(attrType.Name, attributeValue);
            /*if(elem is INode)
                graph.ChangedNodeAttribute((INode)owner, attrType);
            else if(elem is IEdge)
                graph.ChangedEdgeAttribute((IEdge)owner, attrType);
            */
        }

        private void ParseAttributeValueIndexed(IAttributeBearer owner, AttributeType attrType, string attrName, object index)
        {
            object value = ParseAttributeSimpleValue(attrType);
            object attr = owner.GetAttribute(attrName);

            if(attr is IList)
            {
                IList array = (IList)attr;
                array[(int)index] = value;
            }
            else if(attr is IDeque)
            {
                IDeque deque = (IDeque)attr;
                deque[(int)index] = value;
            }
            else
            {
                IDictionary setmap = (IDictionary)attr;
                setmap[index] = value;
            }
        }

        private object JustParseAttributeValue(AttributeType attrType)
        {
            object attributeValue;
            if(attrType.Kind == AttributeKind.SetAttr)
            {
                // set<type> { value * , } 
                Match(TokenKind.SET);
                Match(TokenKind.LANGLE);
                string type = ParseTypeText();
                Match(TokenKind.RANGLE);

                IDictionary set = ContainerHelper.NewDictionary(
                    TypesHelper.GetType(type, graph.Model),
                    typeof(SetValueType));

                Match(TokenKind.LBRACE);
                if(LookaheadToken() != TokenKind.RBRACE)
                {
                    object key = ParseAttributeSimpleValue(attrType.ValueType);
                    set[key] = null;
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        key = ParseAttributeSimpleValue(attrType.ValueType);
                        set[key] = null;
                    }
                }
                Match(TokenKind.RBRACE);

                attributeValue = set;
            }
            else if(attrType.Kind == AttributeKind.MapAttr)
            {
                // map<type,tgtType> { value -> tgtValue * , } 
                Match(TokenKind.MAP);
                Match(TokenKind.LANGLE);
                string type = ParseTypeText();
                Match(TokenKind.COMMA);
                string tgtType = ParseTypeText();
                Match(TokenKind.RANGLE);

                IDictionary map = ContainerHelper.NewDictionary(
                    TypesHelper.GetType(type, graph.Model),
                    TypesHelper.GetType(tgtType, graph.Model));

                Match(TokenKind.LBRACE);
                if(LookaheadToken() != TokenKind.RBRACE)
                {
                    object key = ParseAttributeSimpleValue(attrType.KeyType);
                    Match(TokenKind.ARROW);
                    object value = ParseAttributeSimpleValue(attrType.ValueType);
                    map[key] = value;
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        key = ParseAttributeSimpleValue(attrType.KeyType);
                        Match(TokenKind.ARROW);
                        value = ParseAttributeSimpleValue(attrType.ValueType);
                        map[key] = value;
                    }
                }
                Match(TokenKind.RBRACE);

                attributeValue = map;
            }
            else if(attrType.Kind == AttributeKind.ArrayAttr)
            {
                // array<type> [ value * , ]
                Match(TokenKind.ARRAY);
                Match(TokenKind.LANGLE);
                string type = ParseTypeText();
                Match(TokenKind.RANGLE);

                IList array = ContainerHelper.NewList(
                    TypesHelper.GetType(type, graph.Model));

                Match(TokenKind.LBOXBRACKET);
                if(LookaheadToken() != TokenKind.RBOXBRACKET)
                {
                    object value = ParseAttributeSimpleValue(attrType.ValueType);
                    array.Add(value);
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        value = ParseAttributeSimpleValue(attrType.ValueType);
                        array.Add(value);
                    }
                }
                Match(TokenKind.RBOXBRACKET);

                attributeValue = array;
            }
            else if(attrType.Kind == AttributeKind.DequeAttr)
            {
                // deque<type> [ value * , ]
                Match(TokenKind.DEQUE);
                Match(TokenKind.LANGLE);
                string type = ParseTypeText();
                Match(TokenKind.RANGLE);

                IDeque deque = ContainerHelper.NewDeque(
                    TypesHelper.GetType(type, graph.Model));

                Match(TokenKind.LBOXBRACKET);
                if(LookaheadToken() != TokenKind.RBOXBRACKET)
                {
                    object value = ParseAttributeSimpleValue(attrType.ValueType);
                    deque.Enqueue(value);
                    while(LookaheadToken() == TokenKind.COMMA)
                    {
                        Match(TokenKind.COMMA);
                        value = ParseAttributeSimpleValue(attrType.ValueType);
                        deque.Enqueue(value);
                    }
                }
                Match(TokenKind.RBOXBRACKET);

                attributeValue = deque;
            }
            else if(attrType.Kind == AttributeKind.InternalClassObjectAttr)
            {
                if(LookaheadToken() == TokenKind.NULL)
                {
                    Match(TokenKind.NULL);

                    attributeValue = null;
                }
                else
                {
                    Match(TokenKind.NEW);
                    string type = ParseTypeText();
                    Match(TokenKind.AT);
                    Match(TokenKind.LPARENTHESIS);
                    Match(TokenKind.PERCENT);
                    Match(TokenKind.EQUAL);
                    string persistentName = ParseStringValue();
                    ObjectType classObjectType = graph.Model.ObjectModel.GetType(type);
                    IObject classObject = classObjectType.CreateObject(graph, persistentName);
                    Debug.Assert(classObject.GetObjectName() == persistentName);
                    graphToNameToClassObject[graph][persistentName] = classObject;
                    while(LookaheadToken() == TokenKind.COMMA) // , AttrName = Value
                    {
                        Match(TokenKind.COMMA);
                        string attrName = ParseText();
                        AttributeType nestedAttrType = classObjectType.GetAttributeType(attrName);
                        Match(TokenKind.EQUAL);
                        object value = ParseAttributeSimpleValue(nestedAttrType);
                        classObject.SetAttribute(attrName, value);
                    }
                    Match(TokenKind.RPARENTHESIS);

                    attributeValue = classObject;
                }
            }
            else
            {
                // value
                attributeValue = ParseAttributeSimpleValue(attrType);
            }

            return attributeValue;
        }

        private object ParseAttributeSimpleValue(AttributeType attrType)
        {
            switch(attrType.Kind)
            {
            case AttributeKind.ByteAttr:
                return ParseByteValue();
            case AttributeKind.ShortAttr:
                return ParseShortValue();
            case AttributeKind.IntegerAttr:
                return ParseIntValue();
            case AttributeKind.LongAttr:
                return ParseLongValue();
            case AttributeKind.BooleanAttr:
                return ParseBooleanValue();
            case AttributeKind.StringAttr:
                return ParseStringValue();
            case AttributeKind.EnumAttr:
                return ParseEnumValue(attrType.EnumType);
            case AttributeKind.FloatAttr:
                return ParseFloatValue();
            case AttributeKind.DoubleAttr:
                return ParseDoubleValue();
            case AttributeKind.ObjectAttr:
                return ParseObjectValue(attrType);
            case AttributeKind.GraphAttr:
                return ParseGraphValue();
            case AttributeKind.NodeAttr:
                return ParseNodeValue(attrType.PackagePrefixedTypeName);
            case AttributeKind.EdgeAttr:
                return ParseEdgeValue(attrType.PackagePrefixedTypeName);
            case AttributeKind.InternalClassObjectAttr:
                return ParseClassObjectValue();
            case AttributeKind.MapAttr:
            case AttributeKind.SetAttr:
            case AttributeKind.ArrayAttr:
            case AttributeKind.DequeAttr:
                throw new Exception("Internal error, non-simple value in simple value parsing");
            default:
                throw new Exception("Unsupported attribute type " + attrType.ToString());
            }
        }

        private IObject ParseClassObjectValue()
        {
            if(LookaheadToken() == TokenKind.NULL)
            {
                Match(TokenKind.NULL);

                return null;
            }
            else if(LookaheadToken() == TokenKind.NEW)
            {
                Match(TokenKind.NEW);
                string type = ParseTypeText();
                if(LookaheadToken() == TokenKind.AT)
                    Match(TokenKind.AT);
                Match(TokenKind.LPARENTHESIS);
                Match(TokenKind.PERCENT);
                Match(TokenKind.EQUAL);
                string persistentName = ParseStringValue();
                ObjectType classObjectType = graph.Model.ObjectModel.GetType(type);
                IObject classObject = classObjectType.CreateObject(graph, persistentName);
                Debug.Assert(classObject.GetObjectName() == persistentName);
                graphToNameToClassObject[graph][persistentName] = classObject;
                while(LookaheadToken() == TokenKind.COMMA) // , AttrName = Value
                {
                    Match(TokenKind.COMMA);
                    string attrName = ParseText();
                    AttributeType nestedAttrType = classObjectType.GetAttributeType(attrName);
                    Match(TokenKind.EQUAL);
                    object value = ParseAttributeSimpleValue(nestedAttrType);
                    classObject.SetAttribute(attrName, value);
                }
                Match(TokenKind.RPARENTHESIS);

                return classObject;
            }
            else
            {
                return ParseClassObjectElement();
            }
        }

        private sbyte ParseByteValue()
        {
            TransformDoubleQuotedToByte();
            if(LookaheadToken() == TokenKind.HEXNUMBER_BYTE)
                return SByte.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER_BYTE)
                return SByte.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "byte number or hex byte number");
        }

        private short ParseShortValue()
        {
            TransformDoubleQuotedToShort();
            if(LookaheadToken() == TokenKind.HEXNUMBER_SHORT)
                return Int16.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER_SHORT)
                return Int16.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "short number or hex short number");
        }

        private int ParseIntValue()
        {
            TransformDoubleQuotedToInt();
            if(LookaheadToken() == TokenKind.HEXNUMBER)
                return Int32.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER)
                return Int32.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "int number or hex int number");
        }

        private long ParseLongValue()
        {
            TransformDoubleQuotedToLong();
            if(LookaheadToken() == TokenKind.HEXNUMBER_LONG)
                return Int64.Parse(EatAndReturnToken(), System.Globalization.NumberStyles.HexNumber);
            else if(LookaheadToken() == TokenKind.NUMBER_LONG)
                return Int64.Parse(EatAndReturnToken());
            else
                throw GetSyntaxException("Literal type error", "long number or hex long number");
        }

        private bool ParseBooleanValue()
        {
            TransformDoubleQuotedToBoolean();
            if(LookaheadToken() == TokenKind.TRUE)
            {
                EatToken();
                return true;
            }
            else if(LookaheadToken() == TokenKind.FALSE)
            {
                EatToken();
                return false;
            }
            else
                throw GetSyntaxException("Literal type error", "boolean literal (true|false)");
        }

        private string ParseStringValue()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
                return EatAndReturnToken();
            else if(LookaheadToken() == TokenKind.SINGLEQUOTEDTEXT)
                return EatAndReturnToken();
            else
                throw GetSyntaxException("Literal type error", "double quoted or single quoted string");
        }

        private object ParseEnumValue(EnumAttributeType enumAttrType)
        {
            string enumName = ParseText();
            string enumValue;
            if(LookaheadToken() == TokenKind.DOUBLECOLON)
            {
                Match(TokenKind.DOUBLECOLON);
                enumValue = ParseText();
                if(LookaheadToken() == TokenKind.DOUBLECOLON)
                {
                    enumName = enumName + "::" + enumValue; // package::type::value
                    Match(TokenKind.DOUBLECOLON);
                    enumValue = ParseText();
                }
            }
            else
            {
                if(enumName.Contains("::"))
                {
                    enumValue = enumName.Substring(enumName.LastIndexOf(':') + 1);
                    enumName = enumName.Substring(0, enumName.LastIndexOf(':') - 1);
                }
                else
                {
                    enumValue = enumName;
                    enumName = enumAttrType.PackagePrefixedName;
                }
            }

            if(enumAttrType.PackagePrefixedName != enumName)
                throw GetSyntaxException("", "enum type " + enumAttrType.PackagePrefixedName);

            object value;
            int val;
            if(Int32.TryParse(enumValue, out val))
                value = Enum.ToObject(enumAttrType.EnumType, val);
            else
                value = Enum.Parse(enumAttrType.EnumType, enumValue);
            if(value == null)
                throw GetSyntaxException("Unknown enum member", "member of " + enumAttrType.PackagePrefixedName);

            return value;
        }

        private float ParseFloatValue()
        {
            TransformDoubleQuotedToFloat();
            if(LookaheadToken() == TokenKind.NUMFLOAT)
                return Single.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else if(LookaheadToken() == TokenKind.NUMBER)
                return Single.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else
                throw GetSyntaxException("Literal type error", "float number");
        }

        private double ParseDoubleValue()
        {
            TransformDoubleQuotedToDouble();
            if(LookaheadToken() == TokenKind.NUMDOUBLE)
                return Double.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else if(LookaheadToken() == TokenKind.NUMBER)
                return Double.Parse(EatAndReturnToken(), System.Globalization.CultureInfo.InvariantCulture);
            else
                throw GetSyntaxException("Literal type error", "double number");
        }

        private object ParseObjectValue(AttributeType attrType)
        {
            while(Lookahead() == ' ' || Lookahead() == '\t')
            {
                EatCharWithoutIngesting();
            }

            if(model != null)
                return model.Parse(reader, attrType, graph);
            else
                return graph.Model.Parse(reader, attrType, graph);
        }

        private IGraph ParseGraphValue()
        {
            return ParseGraph();
        }

        private INode ParseNodeValue(string typeName)
        {
            String nodeName;
            if(LookaheadToken() == TokenKind.AT)
            {
                Match(TokenKind.AT);
                Match(TokenKind.LPARENTHESIS);
                nodeName = ParseText();
                Match(TokenKind.RPARENTHESIS);
            }
            else if(LookaheadToken() == TokenKind.DOLLAR)
            {
                Match(TokenKind.DOLLAR);
                TokenizeHexNumber();
                nodeName = "$" + EatAndReturnToken();
            }
            else
                nodeName = ParseText();
            return GetNodeByName(nodeName);
        }

        private IEdge ParseEdgeValue(string typeName)
        {
            String edgeName;
            if(LookaheadToken() == TokenKind.AT)
            {
                Match(TokenKind.AT);
                Match(TokenKind.LPARENTHESIS);
                edgeName = ParseText();
                Match(TokenKind.RPARENTHESIS);
            }
            else if(LookaheadToken() == TokenKind.DOLLAR)
            {
                Match(TokenKind.DOLLAR);
                TokenizeHexNumber();
                edgeName = "$" + EatAndReturnToken();
            }
            else
                edgeName = ParseText();
            return GetEdgeByName(edgeName);
        }

        void TransformDoubleQuotedToByte()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                if(tokenContent.Length >= 2 && tokenContent[0] == '0'
                    && (tokenContent[1] == 'x' || tokenContent[1] == 'X'))
                {
                    tokenKind = TokenKind.HEXNUMBER_BYTE;
                    tokenContent.Remove(0, 2);
                }
                else
                    tokenKind = TokenKind.NUMBER_BYTE;
                if(tokenContent[tokenContent.Length - 1] == 'y' || tokenContent[tokenContent.Length - 1] == 'Y')
                    tokenContent.Length = tokenContent.Length - 1;
            }
        }

        void TransformDoubleQuotedToShort()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                if(tokenContent.Length >= 2 && tokenContent[0] == '0'
                    && (tokenContent[1] == 'x' || tokenContent[1] == 'X'))
                {
                    tokenKind = TokenKind.HEXNUMBER_SHORT;
                    tokenContent.Remove(0, 2);
                }
                else
                    tokenKind = TokenKind.NUMBER_SHORT;
                if(tokenContent[tokenContent.Length - 1] == 's' || tokenContent[tokenContent.Length - 1] == 'S')
                    tokenContent.Length = tokenContent.Length - 1;
            }
        }

        void TransformDoubleQuotedToInt()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                if(tokenContent.Length >= 2 && tokenContent[0] == '0'
                    && (tokenContent[1] == 'x' || tokenContent[1] == 'X'))
                {
                    tokenKind = TokenKind.HEXNUMBER;
                    tokenContent.Remove(0, 2);
                }
                else
                    tokenKind = TokenKind.NUMBER;
            }
        }

        void TransformDoubleQuotedToLong()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                if(tokenContent.Length >= 2 && tokenContent[0] == '0'
                    && (tokenContent[1] == 'x' || tokenContent[1] == 'X'))
                {
                    tokenKind = TokenKind.HEXNUMBER_LONG;
                    tokenContent.Remove(0, 2);
                }
                else
                    tokenKind = TokenKind.NUMBER_LONG;
                if(tokenContent[tokenContent.Length - 1] == 'l' || tokenContent[tokenContent.Length - 1] == 'L')
                    tokenContent.Length = tokenContent.Length - 1;
            }
        }

        void TransformDoubleQuotedToBoolean()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                tokenKind = TokenKind.NUMBER_BYTE;
                if(tokenContent.Length == 4 && (tokenContent[0] == 't' || tokenContent[0] == 'T')
                    && tokenContent[1] == 'r' && tokenContent[2] == 'u' && tokenContent[3] == 'e')
                {
                    tokenKind = TokenKind.TRUE;
                }
                else if(tokenContent.Length == 5 && (tokenContent[0] == 'f' || tokenContent[0] == 'F')
                    && tokenContent[1] == 'a' && tokenContent[2] == 'l' && tokenContent[3] == 's' && tokenContent[4] == 'e')
                {
                    tokenKind = TokenKind.FALSE;
                }
            }
        }

        void TransformDoubleQuotedToFloat()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                tokenKind = TokenKind.NUMFLOAT;
                if(tokenContent[tokenContent.Length - 1] == 'f' || tokenContent[tokenContent.Length - 1] == 'F')
                    tokenContent.Length = tokenContent.Length - 1;
            }
        }

        void TransformDoubleQuotedToDouble()
        {
            if(LookaheadToken() == TokenKind.DOUBLEQUOTEDTEXT)
            {
                tokenKind = TokenKind.NUMDOUBLE;
                if(tokenContent[tokenContent.Length - 1] == 'd' || tokenContent[tokenContent.Length - 1] == 'D')
                    tokenContent.Length = tokenContent.Length - 1;
            }
        }

        private void ThrowSyntaxError(TokenKind kind)
        {
            switch(kind)
            {
            case TokenKind.DOUBLECOLON:
                throw GetSyntaxException("Syntax error", "::");
            case TokenKind.DOLLAR:
                throw GetSyntaxException("Syntax error", "$");
            case TokenKind.PERCENT:
                throw GetSyntaxException("Syntax error", "%");
            case TokenKind.EQUAL:
                throw GetSyntaxException("Syntax error", "=");
            case TokenKind.COMMA:
                throw GetSyntaxException("Syntax error", ",");
            case TokenKind.ARROW:
                throw GetSyntaxException("Syntax error", "->");
            case TokenKind.MINUS:
                throw GetSyntaxException("Syntax error", "-");
            case TokenKind.LPARENTHESIS:
                throw GetSyntaxException("Syntax error", "(");
            case TokenKind.RPARENTHESIS:
                throw GetSyntaxException("Syntax error", ")");
            case TokenKind.AT:
                throw GetSyntaxException("Syntax error", "@");
            case TokenKind.LANGLE:
                throw GetSyntaxException("Syntax error", "<");
            case TokenKind.RANGLE:
                throw GetSyntaxException("Syntax error", ">");
            case TokenKind.LBRACE:
                throw GetSyntaxException("Syntax error", "{");
            case TokenKind.RBRACE:
                throw GetSyntaxException("Syntax error", "}");
            case TokenKind.LBOXBRACKET:
                throw GetSyntaxException("Syntax error", "[");
            case TokenKind.RBOXBRACKET:
                throw GetSyntaxException("Syntax error", "]");
            case TokenKind.NUMBER:
            case TokenKind.NUMBER_BYTE:
            case TokenKind.NUMBER_SHORT:
            case TokenKind.NUMBER_LONG:
                throw GetSyntaxException("Syntax error", "number");
            case TokenKind.HEXNUMBER:
            case TokenKind.HEXNUMBER_BYTE:
            case TokenKind.HEXNUMBER_SHORT:
            case TokenKind.HEXNUMBER_LONG:
                throw GetSyntaxException("Syntax error", "number in hex notation");
            case TokenKind.NUMFLOAT:
            case TokenKind.NUMDOUBLE:
                throw GetSyntaxException("Syntax error", "floating point number");
            case TokenKind.DOUBLEQUOTEDTEXT:
                throw GetSyntaxException("Syntax error", "double quoted text");
            case TokenKind.SINGLEQUOTEDTEXT:
                throw GetSyntaxException("Syntax error", "single quoted text");
            case TokenKind.IDENT:
                throw GetSyntaxException("Syntax error", "identifier");
            case TokenKind.FALSE:
                throw GetSyntaxException("Syntax error", "false");
            case TokenKind.GRAPH:
                throw GetSyntaxException("Syntax error", "graph");
            case TokenKind.NEW:
                throw GetSyntaxException("Syntax error", "new");
            case TokenKind.DELETE:
                throw GetSyntaxException("Syntax error", "delete");
            case TokenKind.RETYPE:
                throw GetSyntaxException("Syntax error", "retype");
            case TokenKind.EXTERNAL:
                throw GetSyntaxException("Syntax error", "external");
            case TokenKind.NODE:
                throw GetSyntaxException("Syntax error", "node");
            case TokenKind.EDGE:
                throw GetSyntaxException("Syntax error", "edge");
            case TokenKind.NULL:
                throw GetSyntaxException("Syntax error", "null");
            case TokenKind.TRUE:
                throw GetSyntaxException("Syntax error", "true");
            case TokenKind.SET:
                throw GetSyntaxException("Syntax error", "set");
            case TokenKind.MAP:
                throw GetSyntaxException("Syntax error", "map");
            case TokenKind.ARRAY:
                throw GetSyntaxException("Syntax error", "array");
            case TokenKind.DEQUE:
                throw GetSyntaxException("Syntax error", "deque");
            }
        }

        private void Match(TokenKind kind)
        {
            if(LookaheadToken() != kind)
                ThrowSyntaxError(kind);

            EatToken();
        }

        private string MatchAndReturnToken(TokenKind kind)
        {
            if(LookaheadToken() != kind)
                ThrowSyntaxError(kind);

            return EatAndReturnToken();
        }

        private Exception GetSyntaxException(string what, string expected)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("at line ");
            sb.Append(line);
            sb.Append(", column ");
            sb.Append(column);
            sb.Append(": \"");
            sb.Append(what);
            sb.Append("\" -- expected ");
            sb.Append(expected);
            sb.Append(" but found ");
            sb.Append(tokenContent.ToString());
            return new Exception(sb.ToString());
        }

        private void EatToken()
        {
            tokenFound = false;
            tokenKind = TokenKind.UNKNOWN;
            tokenContent.Length = 0;
        }

        private string EatAndReturnToken()
        {
            string result = tokenContent.ToString();
            tokenFound = false;
            tokenKind = TokenKind.UNKNOWN;
            tokenContent.Length = 0;
            return result;
        }

        private string MatchFilePath()
        {
            while(Lookahead() == ' ' || Lookahead() == '\t')
            {
                EatCharWithoutIngesting();
            }
                        
            if(Lookahead() == '\"')
            {
                EatCharWithoutIngesting();
                while(Lookahead() != '\"' && Lookahead() != '\0')
                {
                    EatChar();
                }
                if(Lookahead() == '\0')
                    throw GetTokenException("Missing termination of double quoted string", "\"");
                EatCharWithoutIngesting();
                string path = tokenContent.ToString();
                EatToken();
                return path;
            }
            
            if(Lookahead() == '\'')
            {
                EatCharWithoutIngesting();
                while(Lookahead() != '\'' && Lookahead() != '\0')
                {
                    EatChar();
                }
                if(Lookahead() == '\0')
                    throw GetTokenException("Missing termination of double quoted string", "\"");
                EatCharWithoutIngesting();
                string path = tokenContent.ToString();
                EatToken();
                return path;
            }

            while(true)
            {
                if(char.IsLetterOrDigit(Lookahead()) || Lookahead()=='_')
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                case '-':
                case '.':
                case ',':
                case ':':
                case '/':
                case '\\':
                case '(':
                case ')':
                    EatChar();
                    break;
                default:
                    string path = tokenContent.ToString();
                    EatToken();
                    return path;
                }
            }
        }

        private string MatchExternalLine()
        {
            while(Lookahead() == ' ' || Lookahead() == '\t')
            {
                EatCharWithoutIngesting();
            }

            while(Lookahead() != '\n' && Lookahead() != '\r' && Lookahead() != '\0')
            {
                EatChar();
            }

            return EatAndReturnToken();
        }

        // if no token was matched yet or the last was not eaten yet: determines next token, yields filled tokenKind and tokenContent variables
        // if token was already matched it returns it (idempotent operation); use EatToken so the lastly matched gives way for ingesting the next one
        private TokenKind LookaheadToken()
        {
            if(tokenFound)
                return tokenKind;

            if(reader.Peek() == -1)
                return FoundToken(TokenKind.EOF);

            char lookahead = (char)reader.Peek();

            if(lookahead == '#' || lookahead == ' ' || lookahead == '\n' || lookahead == '\r' || lookahead == '\t')
            {
                SkipWhitespaceAndComment();
                
                if(reader.Peek() == -1)
                    return FoundToken(TokenKind.EOF);

                lookahead = (char)reader.Peek();
            }

            if(char.IsLetter(lookahead))
                return TokenizeIdentOrKeyword();

            if(char.IsDigit(lookahead))
                return TokenizeNumber();

            switch(lookahead)
            {
                case ':':
                    EatChar();
                    if(Lookahead() == ':')
                    {
                        EatChar();
                        return FoundToken(TokenKind.DOUBLECOLON);
                    }
                    return FoundToken(TokenKind.COLON);

                case '+':
                    EatChar();
                    return TokenizeNumber();

                case '-':
                    EatChar();
                    if(Lookahead() == '>')
                    {
                        EatChar();
                        return FoundToken(TokenKind.ARROW);
                    }
                    if(char.IsDigit(Lookahead()) || Lookahead() == '.')
                        return TokenizeNumber();
                    return FoundToken(TokenKind.MINUS);

                case '.':
                    EatChar();
                    if(char.IsDigit(Lookahead()))
                        return TokenizeFloatingPointNumber();
                    return FoundToken(TokenKind.DOT);

                case '$':
                    EatChar();
                    return FoundToken(TokenKind.DOLLAR);

                case '%':
                    EatChar();
                    return FoundToken(TokenKind.PERCENT);

                case '=':
                    EatChar();
                    return FoundToken(TokenKind.EQUAL);

                case ',':
                    EatChar();
                    return FoundToken(TokenKind.COMMA);

                case '(':
                    EatChar();
                    return FoundToken(TokenKind.LPARENTHESIS);

                case ')':
                    EatChar();
                    return FoundToken(TokenKind.RPARENTHESIS);

                case '@':
                    EatChar();
                    if(Lookahead() == '@')
                    {
                        EatChar();
                        return FoundToken(TokenKind.ATAT);
                    }
                    return FoundToken(TokenKind.AT);

                case '<':
                    EatChar();
                    return FoundToken(TokenKind.LANGLE);

                case '>':
                    EatChar();
                    return FoundToken(TokenKind.RANGLE);

                case '{':
                    EatChar();
                    return FoundToken(TokenKind.LBRACE);

                case '}':
                    EatChar();
                    return FoundToken(TokenKind.RBRACE);

                case '[':
                    EatChar();
                    return FoundToken(TokenKind.LBOXBRACKET);

                case ']':
                    EatChar();
                    return FoundToken(TokenKind.RBOXBRACKET);

                case '\"':
                    EatCharWithoutIngesting();
                    while(Lookahead() != '\"' && Lookahead() != '\0')
                    {
                        if(Lookahead() == '\\')
                            EatCharWithoutIngesting();
                        EatChar();
                    }
                    if(Lookahead() == '\0')
                        throw GetTokenException("Missing termination of double quoted string", "\"");
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.DOUBLEQUOTEDTEXT);

                case '\'':
                    EatCharWithoutIngesting();
                    while(Lookahead() != '\'' && Lookahead() != '\0')
                    {
                        if(Lookahead() == '\\')
                            EatCharWithoutIngesting();
                        EatChar();
                    }
                    if(Lookahead() == '\0')
                        throw GetTokenException("Missing termination of single quoted sring", "\'");
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.SINGLEQUOTEDTEXT);

                default:
                    throw GetTokenException("Unknown/unsupported character", "\"0-9,a-z,A-Z,:,+,-,.,$,=,\",\",(,),@,<,>,{,},[,],\",\',\\n,\\r,\\t, ,#\"");
            }
        }

        private TokenKind TokenizeIdentOrKeyword()
        {
            EatChar(); // lookahead was IsLetter
            while(char.IsLetterOrDigit(Lookahead()) || Lookahead()=='_')
            {
                EatChar();
            }

            if(tokenContent.Length < 2 || tokenContent.Length > 8)
                return FoundToken(TokenKind.IDENT);

            switch(tokenContent[0])
            {
                case 'a':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'd'
                        && tokenContent[2] == 'd')
                    {
                        return FoundToken(TokenKind.ADD);
                    }
                    else if(tokenContent.Length == 5
                        && tokenContent[1] == 'r'
                        && tokenContent[2] == 'r'
                        && tokenContent[3] == 'a'
                        && tokenContent[4] == 'y')
                    {
                        return FoundToken(TokenKind.ARRAY);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'd':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 'q'
                        && tokenContent[3] == 'u'
                        && tokenContent[4] == 'e')
                    {
                        return FoundToken(TokenKind.DEQUE);
                    }
                    else if(tokenContent.Length == 6
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 'l'
                        && tokenContent[3] == 'e'
                        && tokenContent[4] == 't'
                        && tokenContent[5] == 'e')
                    {
                        return FoundToken(TokenKind.DELETE);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'e':
                    if(tokenContent.Length == 4
                        && tokenContent[1] == 'd'
                        && tokenContent[2] == 'g'
                        && tokenContent[3] == 'e')
                    {
                        return FoundToken(TokenKind.EDGE);
                    }
                    else if(tokenContent.Length == 8
                        && tokenContent[1] == 'x'
                        && tokenContent[2] == 't'
                        && tokenContent[3] == 'e'
                        && tokenContent[4] == 'r'
                        && tokenContent[5] == 'n'
                        && tokenContent[6] == 'a'
                        && tokenContent[7] == 'l')
                    {
                        return FoundToken(TokenKind.EDGE);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'f':
                case 'F':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'a'
                        && tokenContent[2] == 'l'
                        && tokenContent[3] == 's'
                        && tokenContent[4] == 'e')
                    {
                        return FoundToken(TokenKind.FALSE);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'g':
                    if(tokenContent.Length == 5
                        && tokenContent[1] == 'r'
                        && tokenContent[2] == 'a'
                        && tokenContent[3] == 'p'
                        && tokenContent[4] == 'h')
                    {
                        return FoundToken(TokenKind.GRAPH);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'i':
                    if(tokenContent.Length == 2
                        && tokenContent[1] == 'n')
                    {
                        return FoundToken(TokenKind.IN);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'm':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'a'
                        && tokenContent[2] == 'p')
                    {
                        return FoundToken(TokenKind.MAP);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'n':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 'w')
                    {
                        return FoundToken(TokenKind.NEW);
                    }
                    else if(tokenContent.Length == 4
                        && tokenContent[1] == 'u'
                        && tokenContent[2] == 'l'
                        && tokenContent[3] == 'l')
                    {
                        return FoundToken(TokenKind.NULL);
                    }
                    else if(tokenContent.Length == 4
                        && tokenContent[1] == 'o'
                        && tokenContent[2] == 'd'
                        && tokenContent[3] == 'e')
                    {
                        return FoundToken(TokenKind.NODE);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 'r':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 'm')
                    {
                        return FoundToken(TokenKind.REM);
                    }
                    else if(tokenContent.Length == 6
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 't'
                        && tokenContent[3] == 'y'
                        && tokenContent[4] == 'p'
                        && tokenContent[5] == 'e')
                    {
                        return FoundToken(TokenKind.RETYPE);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 's':
                    if(tokenContent.Length == 3
                        && tokenContent[1] == 'e'
                        && tokenContent[2] == 't')
                    {
                        return FoundToken(TokenKind.SET);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                case 't':
                case 'T':
                    if(tokenContent.Length == 4
                        && tokenContent[1] == 'r'
                        && tokenContent[2] == 'u'
                        && tokenContent[3] == 'e')
                    {
                        return FoundToken(TokenKind.TRUE);
                    }
                    else
                        return FoundToken(TokenKind.IDENT);
                default:
                    return FoundToken(TokenKind.IDENT);
            }
        }

        private TokenKind TokenizeNumber()
        {
            if(Lookahead() == '0')
            {
                char eaten = EatCharWithoutIngesting();
                if(Lookahead() == 'x' || Lookahead() == 'X')
                {
                    EatCharWithoutIngesting();
                    return TokenizeHexNumber();
                }
                tokenContent.Append(eaten);
            }

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                case '.':
                    return TokenizeFloatingPointNumber();

                case 'e':
                case 'E':
                    return TokenizeFloatingPointNumber();

                case 'y':
                case 'Y':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMBER_BYTE);

                case 's':
                case 'S':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMBER_SHORT);

                case 'l':
                case 'L':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMBER_LONG);

                case 'f':
                case 'F':
                    return TokenizeFloatingPointNumber();

                case 'd':
                case 'D':
                    return TokenizeFloatingPointNumber();

                default:
                    return FoundToken(TokenKind.NUMBER);
                }
            }
        }

        private TokenKind TokenizeHexNumber()
        {
            // starts after 0x was eaten in TokenizeNumber

            if(!char.IsDigit(Lookahead()) && !char.IsLetter(Lookahead()))
                throw GetTokenException("No hex number following hex prefix 0x", "0-9,a-f,A-F");

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                    EatChar();
                    break;

                case 'y':
                case 'Y':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.HEXNUMBER_BYTE);

                case 's':
                case 'S':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.HEXNUMBER_SHORT);

                case 'l':
                case 'L':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.HEXNUMBER_LONG);

                default:
                    return FoundToken(TokenKind.HEXNUMBER);
                }
            }
        }

        private TokenKind TokenizeFloatingPointNumber()
        {
            // starts when . or e|E or f|F or d|D is seen in TokenizeNumber or after . was eaten in LookaheadToken

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                case '.':
                    EatChar();
                    break;

                case 'e':
                case 'E':
                    EatChar();
                    return TokenizeFloatingPointNumberExponent();

                case 'f':
                case 'F':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMFLOAT);

                case 'd':
                case 'D':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMDOUBLE);

                default:
                    return FoundToken(TokenKind.NUMDOUBLE);
                }
            }
        }

        private TokenKind TokenizeFloatingPointNumberExponent()
        {
            // starts after e|E was eaten in TokenizeFloatingPointNumber

            if(Lookahead() == '+' || Lookahead() == '-')
                EatChar();

            if(!char.IsDigit(Lookahead()))
                throw GetTokenException("No exponent number following exponent introduction e|E in floating point number", "+,-,0-9");

            while(true)
            {
                if(char.IsDigit(Lookahead()))
                {
                    EatChar();
                    continue;
                }

                switch(Lookahead())
                {
                case 'f':
                case 'F':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMFLOAT);

                case 'd':
                case 'D':
                    EatCharWithoutIngesting();
                    return FoundToken(TokenKind.NUMDOUBLE);

                default:
                    return FoundToken(TokenKind.NUMDOUBLE);
                }
            }
        }

        private void SkipWhitespaceAndComment()
        {
            while(true)
            {
                switch(Lookahead())
                {
                case ' ':
                case '\t':
                    EatCharWithoutIngesting();
                    break;

                case '\r':
                    EatCharWithoutIngesting();
                    if(Lookahead() == '\n')
                        EatCharWithoutIngesting();
                    ++line;
                    column = 0;
                    break;

                case '\n':
                    EatCharWithoutIngesting();
                    ++line;
                    column = 0;
                    break;

                case '#':
                    EatCharWithoutIngesting();
                    while(Lookahead() != '\n' && Lookahead() != '\r' && Lookahead() != '\0')
                    {
                        EatCharWithoutIngesting();
                    }
                    break;

                default:
                    return;
                }
            }
        }

        private char Lookahead()
        {
            if(reader.Peek() == -1)
                return '\0';
            else
                return (char)reader.Peek();
        }

        private void EatChar()
        {
            ++column;
            tokenContent.Append((char)reader.Read());
        }

        private char EatCharWithoutIngesting()
        {
            ++column;
            return (char)reader.Read();
        }

        private TokenKind FoundToken(TokenKind kind)
        {
            tokenFound = true;
            tokenKind = kind;
            return tokenKind;
        }

        private Exception GetTokenException(string what, string expected)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("at line ");
            sb.Append(line);
            sb.Append(", column ");
            sb.Append(column);
            sb.Append(": \"");
            sb.Append(what);
            sb.Append("\" -- expected ");
            sb.Append(expected);
            sb.Append(" but found ");
            sb.Append(Lookahead());
            return new Exception(sb.ToString());
        }

        private INode GetNodeByName(String elemName)
        {
            return (INode)GetElemByName(elemName);
        }

        private IEdge GetEdgeByName(String elemName)
        {
            return (IEdge)GetElemByName(elemName);
        }

        private IGraphElement GetElemByName(String elemName)
        {
            if(elemName == "null")
                return null;

            IGraphElement elem = graph.GetGraphElement(elemName);
            if(elem == null)
                throw new Exception("Unknown graph element " + elemName);
            return elem;
        }

        private INamedGraph GetGraphByName(String graphName)
        {
            if(graphName == "null")
                return null;

            return nameToSubgraph[graphName];
        }
    }
}
