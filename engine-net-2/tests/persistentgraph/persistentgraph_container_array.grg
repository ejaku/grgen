#using "persistentgraph_container_array.gm"

rule init
{
	modify {
		n:N -e:E-> n;
		n -e2:Edge-> n -e3:Edge-> n;
		eval {
			n.o = new O();
			e.o = new O();
		}
	}
}

rule deleteNodeAndIncidentEdges
{
	n:N;
	modify {
		delete(n); // edges implicitly
	}
}

test find : (N, E, O, O)
{
	n:N -e:E-> n;
	if{ n.o != e.o; }
	return(n,e,n.o,e.o);
}

test findExtended : (N, E, O, O, Edge, Edge)
{
	n:N -e:E-> n;
	n -e2:Edge-> n -e3:Edge-> n;
	if{ n.o != e.o; }
	return(n,e,n.o,e.o,e2,e3);
}

rule assignAttributes
{
	n:N -e:E-> n;
	n -e2:Edge-> n -e3:Edge-> n;
	
	modify {
		eval {
			n.a_s = null;
			n.a_by = array<byte>[ 42y ];
			n.a_sh = array<short>[ ];
			n.a_i = array<int>[ 1, 2, 3 ];
			n.a_l = array<long>[ 50L ];
			n.a_f = array<float>[ 1.0f, 0.0f ];
			n.a_d = array<double>[ 1337.1337 ];
			n.a_b = array<boolean>[ ];
			n.a_e = array<ENU>[ ENU::b ];
			
			n.a_N = array<N>[ n ];
			n.a_Ed = array<Edge>[ e, e2, e3 ];
			n.a_O = array<O>[ e.o ];
			
			e.a_s = null;
			e.a_by = array<byte>[ 42y ];
			e.a_sh = array<short>[ ];
			e.a_i = array<int>[ 1, 2, 3, 4, 5, 6, 7 ];
			e.a_l = array<long>[ 50L ];
			e.a_f = array<float>[ 1.0f, 0.0f ];
			e.a_d = array<double>[ 1337.1337 ];
			e.a_b = array<boolean>[ ];
			e.a_e = array<ENU>[ ENU::b ];
			
			e.a_N = array<N>[ n ];
			e.a_Ed = array<Edge>[ e, e2 ];
			e.a_O = array<O>[ n.o ];

			def ref o:O = n.o;
			o.a_s = null;
			o.a_by = array<byte>[ 42y ];
			o.a_sh = array<short>[ ];
			o.a_i = array<int>[ 1 ];
			o.a_l = array<long>[ 50L ];
			o.a_f = array<float>[ 1.0f, 0.5f, 0.0f ];
			o.a_d = array<double>[ 1337.1337 ];
			o.a_b = array<boolean>[ ];
			o.a_e = array<ENU>[ ENU::b ];
			
			o.a_N = array<N>[ n ];
			o.a_Ed = array<Edge>[ e, e2, e3 ];
			o.a_O = array<O>[ n.o, e.o ];
		}
	}
}
