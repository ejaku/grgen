#using "persistentgraph_dangling_references_subgraph.gm"

rule init
{
	modify {
		n:N -e:E-> n;

		eval {
			n.g = inducedSubgraph(set<Node>{});
			n.s.add(copy(n.g));
			n.s.add(copy(n.g));
		}
	}
}

rule initNested
{
	n:N -e:E-> n;
	
	modify {
	---
		exec( g:graph ;> { g = copy(n.g) } ;> in g { (::gn,::ge)=initInNested } ;> { n.n = ::gn; n.e = ::ge } );
		exec( in n.g { (::gn, ::ge)=initInNested } ;> { e.n = ::gn; e.e = ::ge; } );
		exec( in n.s.peek(0) { initInNested } );
		exec( g:graph ;> { g = n.s.peek(1) } ;> g.initInNested() );
	}
}

rule initInNested : (N, E)
{
	modify {
		n:N -e:E-> n;
		n2:N -e2:E-> n2;
		n3:N -e3:E-> n3;
		n --> n2 --> n3;

		eval {
			n.n = n2;
			n.e = e2;
			
			e.n = n3;
			e.e = e3;
			
			e.m.add(n2, e2);
		}
		
		return(n2, e2);
	}
}

test find : (N, E)
{
	n:N -e:E-> n;

	return(n,e);
}

rule createDanglingReferencesNested
{
	n:N -e:E-> n;
	
	modify {
	---
		exec( g:graph ;> { g = graphof(n.n) } ;> in g { createDanglingReferencesInNested } );
		exec( in n.g { createDanglingReferencesInNested } );
		exec( in n.s.peek(0) { createDanglingReferencesInNested } );
		exec( g:graph ;> { g = n.s.peek(1) } ;> g.createDanglingReferencesInNested() );
		exec( { n.s.rem(n.s.peek(1)) } );
	}
}

rule createDanglingReferencesInNested
{
	n:N -e:E-> n;
	n2:N -e2:E-> n2;
	n3:N -e3:E-> n3;
	n --> n2 --> n3;
	
	modify {
		delete(n2);
		new_n3:M<n3> -new_e3:D<e3>-> new_n3;
	}
}
