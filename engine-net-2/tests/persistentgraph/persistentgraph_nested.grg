#using "persistentgraph_nested.gm"

rule init : (N,N,N,N)
{
	modify {
		n1:N --> n2:N --> n3:N --> n1;
		n1 <-- n2;
		n4:N --> n4;
		return(n1,n2,n3,n4);
	}
}

rule initNestedPart
{
	n1:N -e1:Edge-> n2:N -e2:Edge-> n3:N -e3:Edge-> n1;
	n1 <-- n2;
	n4:N --> n4;
	
	modify {
	---
		eval {
			n4.nested = copy(this);
			File::export(definedSubgraph(set<Edge>{ e1, e2, e3 }), "triple.grs");
			n3.nested = File::import("triple.grs");
			n2.nested = inducedSubgraph(set<Node>{ n1, n2 });
		}
		exec( { ::g = inducedSubgraph(set<Node>{ }) } ;>  in ::g { { (::n)=add(N); add(Edge, ::n, ::n); ::gn = inducedSubgraph(set<Node>{ }) } ;> in ::gn { { (nn:N)=add(N); add(Edge, nn, nn) } } ;> {  ::n.nested = ::gn } } ;> { n1.nested = ::g });
	}
}

rule find : (N,N,N,N)
{
	n1:N --> n2:N --> n3:N --> n1;
	n1 <-- n2;
	n4:N --> n4;
	
	modify {
	---
		exec( in n1.nested { findSingle && { emit("the value of variable 'findSingle' of type dontcare is: true\n") } } );
		exec( in n1.nested { findPair && { emit("the value of variable 'findPair' of type dontcare is: false\n") } } );
		exec( in n1.nested { (::n)=findSingle && in ::n.nested { findSingle && { emit("the value of variable 'nestedFindSingle' of type dontcare is: true\n") } } } );
		exec( in n1.nested { (::n)=findSingle && in ::n.nested { findPair && { emit("the value of variable 'nestedFindPair' of type dontcare is: false\n") } } } );
		exec( in n2.nested { findPair && { emit("the value of variable 'findPair' of type dontcare is: true\n") } } );
		exec( in n2.nested { findTriple && { emit("the value of variable 'findTriple' of type dontcare is: false\n") } } );
		exec( in n3.nested { findTriple && { emit("the value of variable 'findTriple' of type dontcare is: true\n") } } );
		exec( in n3.nested { findQuadrupel && { emit("the value of variable 'findQuadrupel' of type dontcare is: false\n") } } );
		exec( in n4.nested { findQuadrupel && { emit("the value of variable 'findQuadrupel' of type dontcare is: true\n") } } );
		exec( in n4.nested { findQuint && { emit("the value of variable 'findQuint' of type dontcare is: false\n") } } );
		return(n1,n2,n3,n4);
	}
}

test findSingle : (N)
{
	n:N --> n;
	return(n);
}

test findPair
{
	n1:N --> n2:N;
	n1 <-- n2;
}

test findTriple
{
	n1:N --> n2:N --> n3:N --> n1;
}

test findQuadrupel
{
	n1:N --> n2:N --> n3:N --> n1;
	n1 <-- n2;
	n4:N --> n4;
}

test findQuint
{
	n1:N --> n2:N --> n3:N --> n1;
	n1 <-- n2;
	n4:N --> n4;
	n5:N;
}
