new graph statespaceMapping/statespace

include statespaceMapping/statespacelayout.grsi

exec init ;> ::statespaceRoot = new StatespaceObject@(gr=this)

# initial graph not added, won't be reached by always-adding insert rules, is altered in some scenarios (containing the statespace representation)
exec ::statespace = new set<graph>{}\
	;> ::statespaceGraphToObject = new map<graph, StatespaceObject>{}

exec ::stopLevel=2 ;> stateStepMappingGraphCompiled(0, ::statespaceRoot)

show var statestep
show var statespace

show var statespaceRoot
show object statespaceRoot

exec { ::statespaceRootChild0 = ::statespaceRoot.successors.peek(0) }
exec { ::statespaceRootChild1 = ::statespaceRoot.successors.peek(1) }
exec { ::statespaceRootChild2 = ::statespaceRoot.successors.peek(2) }
show object statespaceRootChild0
show object statespaceRootChild1
show object statespaceRootChild2

exec { ::statespaceRootChild00 = ::statespaceRootChild0.successors.peek(0) }
exec { ::statespaceRootChild01 = ::statespaceRootChild0.successors.peek(1) }
exec { ::statespaceRootChild02 = ::statespaceRootChild0.successors.peek(2) }
exec { ::statespaceRootChild03 = ::statespaceRootChild0.successors.peek(3) }
show object statespaceRootChild00
show object statespaceRootChild01
show object statespaceRootChild02
show object statespaceRootChild03

#note: the StatespaceObject are created in different graphs, have thus the same graph-based id
#building a common data structure from them is illegal, correct behavior would be to create them all in the root graph 
#(or to use them only in their corresponding subgraph, not building a shared data structure)

show num nodes Red
show num nodes Green
show num nodes Blue

exec for{g:graph in ::statespace; in g { { emit("The value of variable \"redgreenblue\" of type foobar is: ", nodes(Red).size(), nodes(Green).size(), nodes(Blue).size(), "\n") } } } 

exit
