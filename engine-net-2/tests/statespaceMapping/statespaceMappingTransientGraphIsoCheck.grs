new graph statespaceMapping/statespace

include statespaceMapping/statespacelayout.grsi

exec init ;> ::statespaceRoot = new TransientStatespaceObject@(gr=this)

# initial graph not added, won't be reached by always-adding insert rules, is altered in some scenarios (containing the statespace representation)
exec ::statespace = new set<graph>{}\
	;> ::statespaceGraphToObject = new map<graph, TransientStatespaceObject>{}

def linkAndAddIfNotExistingTransient(parent:TransientStatespaceObject) : (successor:TransientStatespaceObject) { false }
def linkAndAddIfNotExistingTransient(parent:TransientStatespaceObject) : (successor:TransientStatespaceObject) {\
	equivalent:graph ;> { equivalent = getEquivalent(this, ::statespace) } ;>\
	if { {{equivalent == null}};\
		{\
			::statespace.add(this);\
			successor = new TransientStatespaceObject@(gr=this);\
			parent.successors.add(successor);\
			::statespaceGraphToObject.add(this, successor);\
			{ true }\
		};\
		{\
			equivalentStatespaceObject:TransientStatespaceObject = ::statespaceGraphToObject[equivalent];\
			parent.successors.add(equivalentStatespaceObject);\
			successor = null;\
			{ false }\
		}\
	}\
}

def stateStepMappingTransientGraph(level:int, parent:TransientStatespaceObject) { false }
def stateStepMappingTransientGraph(level:int, parent:TransientStatespaceObject) {\
	if { {{level < ::stopLevel}};\
		{ ::statestep = [: for{insertRed; (successor:TransientStatespaceObject)=linkAndAddIfNotExistingTransient(parent) && stateStepMappingTransientGraph(level + 1, successor)},\
							for{insertGreen; (successor:TransientStatespaceObject)=linkAndAddIfNotExistingTransient(parent) && stateStepMappingTransientGraph(level + 1, successor)},\
							for{insertBlue; (successor:TransientStatespaceObject)=linkAndAddIfNotExistingTransient(parent) && stateStepMappingTransientGraph(level + 1, successor)}\
						:] }\
	}\
}

exec ::stopLevel=2 ;> stateStepMappingTransientGraph(0, ::statespaceRoot)

show var statestep
show var statespace

show var statespaceRoot
show transient object statespaceRoot

exec { ::statespaceRootChild0 = ::statespaceRoot.successors.peek(0) }
exec { ::statespaceRootChild1 = ::statespaceRoot.successors.peek(1) }
exec { ::statespaceRootChild2 = ::statespaceRoot.successors.peek(2) }
show transient object statespaceRootChild0
show transient object statespaceRootChild1
show transient object statespaceRootChild2

exec { ::statespaceRootChild00 = ::statespaceRootChild0.successors.peek(0) }
exec { ::statespaceRootChild01 = ::statespaceRootChild0.successors.peek(1) }
exec { ::statespaceRootChild02 = ::statespaceRootChild0.successors.peek(2) }
exec { ::statespaceRootChild03 = ::statespaceRootChild0.successors.peek(3) }
show transient object statespaceRootChild00
show transient object statespaceRootChild01
show transient object statespaceRootChild02
show transient object statespaceRootChild03

#note: the TransientStatespaceObject are created outside of the graphs (in contrast to the StatespaceObject of the non-transient tests)

show num nodes Red
show num nodes Green
show num nodes Blue

exec for{g:graph in ::statespace; in g { { emit("The value of variable \"redgreenblue\" of type foobar is: ", nodes(Red).size(), nodes(Green).size(), nodes(Blue).size(), "\n") } } } 

exit
