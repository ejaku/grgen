new graph statespaceMapping/statespace

include statespaceMapping/statespacelayout.grsi

exec init ;> ::statespaceRoot = new StatespaceObject@(gr=this)

exec { ::statespace = new set<graph>{} }

def stateStepMappingTree(level:int, parent:StatespaceObject) { false }
def stateStepMappingTree(level:int, parent:StatespaceObject) {\
	if { {{level < ::stopLevel}};\
		{ ::statestep = [: for{insertRed; child:StatespaceObject ;> {::statespace.add(this); child = new StatespaceObject@(gr=this); parent.successors.add(child) } ;> stateStepMappingTree(level + 1, child)},\
							for{insertGreen; child:StatespaceObject ;> {::statespace.add(this); child = new StatespaceObject@(gr=this); parent.successors.add(child) } ;> stateStepMappingTree(level + 1, child)},\
							for{insertBlue; child:StatespaceObject ;> {::statespace.add(this); child = new StatespaceObject@(gr=this); parent.successors.add(child) } ;> stateStepMappingTree(level + 1, child)}\
						:] }\
	}\
}

exec ::stopLevel=2 ;> stateStepMappingTree(0, ::statespaceRoot)

show var statestep
show var statespace

show var statespaceRoot
show object statespaceRoot

exec { ::statespaceRootChild0 = ::statespaceRoot.successors.peek(0) }
exec { ::statespaceRootChild1 = ::statespaceRoot.successors.peek(1) }
exec { ::statespaceRootChild2 = ::statespaceRoot.successors.peek(2) }
show object statespaceRootChild0
show object statespaceRootChild1
show object statespaceRootChild2

exec { ::statespaceRootChild00 = ::statespaceRootChild0.successors.peek(0) }
exec { ::statespaceRootChild01 = ::statespaceRootChild0.successors.peek(1) }
exec { ::statespaceRootChild02 = ::statespaceRootChild0.successors.peek(2) }
exec { ::statespaceRootChild03 = ::statespaceRootChild0.successors.peek(3) }
show object statespaceRootChild00
show object statespaceRootChild01
show object statespaceRootChild02
show object statespaceRootChild03

#note: the StatespaceObject are created in different graphs, have thus the same graph-based id
#building a common data structure from them is illegal, correct behavior would be to create them all in the root graph 
#(or to use them only in their corresponding subgraph, not building a shared data structure)

show num nodes Red
show num nodes Green
show num nodes Blue

exec for{g:graph in ::statespace; in g { { emit("The value of variable \"redgreenblue\" of type foobar is: ", nodes(Red).size(), nodes(Green).size(), nodes(Blue).size(), "\n") } } } 

exit
