/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 5.0
 * Copyright (C) 2003-2020 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author Edgar Jakumeit
 */

package de.unika.ipd.grgen.ast;

import java.util.Collection;
import java.util.Vector;

import de.unika.ipd.grgen.ast.decl.executable.FilterAutoGeneratedDeclNode;
import de.unika.ipd.grgen.ast.decl.executable.FilterAutoSuppliedDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.IteratedDeclNode;
import de.unika.ipd.grgen.ast.expr.ExprNode;
import de.unika.ipd.grgen.ast.util.DeclarationPairResolver;
import de.unika.ipd.grgen.ast.util.DeclarationResolver;
import de.unika.ipd.grgen.ast.util.Pair;
import de.unika.ipd.grgen.ir.FilterInvocation;
import de.unika.ipd.grgen.ir.IR;
import de.unika.ipd.grgen.ir.executable.FilterAutoGenerated;
import de.unika.ipd.grgen.ir.executable.FilterAutoSupplied;
import de.unika.ipd.grgen.ir.executable.Rule;
import de.unika.ipd.grgen.ir.expr.Expression;

public class FilterInvocationNode extends BaseNode
{
	static {
		setName(FilterInvocationNode.class, "filter invocation");
	}

	protected IdentNode iteratedUnresolved;
	protected IteratedDeclNode iterated;

	public IdentNode filterUnresolved;
	public FilterAutoGeneratedDeclNode filterAutoGenerated; // filter functions can only be applied on rules
	public FilterAutoSuppliedDeclNode filterAutoSupplied;
	private CollectNode<ExprNode> arguments;

	public FilterInvocationNode(IdentNode iteratedUnresolved, IdentNode filterUnresolved,
			CollectNode<ExprNode> arguments)
	{
		super(filterUnresolved.getCoords());
		this.iteratedUnresolved = becomeParent(iteratedUnresolved);
		this.filterUnresolved = becomeParent(filterUnresolved);
		this.arguments = becomeParent(arguments);
	}

	@Override
	public Collection<? extends BaseNode> getChildren()
	{
		Vector<BaseNode> children = new Vector<BaseNode>();
		children.add(getValidVersion(iteratedUnresolved, iterated));
		//children.add(methodIdent);	// HACK: We don't have a declaration, so avoid failure during check phase
		children.add(arguments);
		return children;
	}

	@Override
	public Collection<String> getChildrenNames()
	{
		Vector<String> childrenNames = new Vector<String>();
		childrenNames.add("iterated");
		//childrenNames.add("methodIdent");
		childrenNames.add("params");
		return childrenNames;
	}

	private static final DeclarationResolver<IteratedDeclNode> iteratedResolver =
			new DeclarationResolver<IteratedDeclNode>(IteratedDeclNode.class);
	private static final DeclarationPairResolver<FilterAutoGeneratedDeclNode, FilterAutoSuppliedDeclNode> filterResolver =
			new DeclarationPairResolver<FilterAutoGeneratedDeclNode, FilterAutoSuppliedDeclNode>(FilterAutoGeneratedDeclNode.class, FilterAutoSuppliedDeclNode.class);

	@Override
	protected boolean resolveLocal()
	{
		// owner
		iterated = iteratedResolver.resolve(iteratedUnresolved, this);
		if(iterated == null)
			return false;

		// member
		if(!(filterUnresolved instanceof PackageIdentNode)) {
			boolean res = fixupDefinition(filterUnresolved, iterated.getScope());
			if(!res)
				return false;
		}
		Pair<FilterAutoGeneratedDeclNode, FilterAutoSuppliedDeclNode> filter = filterResolver.resolve(filterUnresolved, this);
		if(filter == null)
			return false;
		filterAutoGenerated = filter.fst;
		filterAutoSupplied = filter.snd;
		return (filterAutoGenerated != null && filterAutoGenerated.resolve())
				|| (filterAutoSupplied != null && filterAutoSupplied.resolve());
	}

	@Override
	protected boolean checkLocal()
	{
		return true;
	}

	@Override
	protected IR constructIR()
	{
		FilterInvocation filterInvocation;
		if(filterAutoGenerated != null) {
			filterInvocation = new FilterInvocation(filterUnresolved.getIdent().toString(), filterUnresolved.getIdent(),
					filterAutoGenerated.checkIR(FilterAutoGenerated.class), iterated.checkIR(Rule.class));
		} else {
			filterInvocation = new FilterInvocation(filterUnresolved.getIdent().toString(), filterUnresolved.getIdent(),
					filterAutoSupplied.checkIR(FilterAutoSupplied.class), iterated.checkIR(Rule.class));
		}
		for(ExprNode expr : arguments.getChildren()) {
			filterInvocation.addArgument(expr.checkIR(Expression.class));
		}
		return filterInvocation;
	}
}
