/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 8.0
 * Copyright (C) 2003-2025 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.de / www.grgen.net
 */

/**
 * @author shack, Edgar Jakumeit
 */

package de.unika.ipd.grgen.ast.decl.executable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Set;
import java.util.Vector;

import de.unika.ipd.grgen.ast.BaseNode;
import de.unika.ipd.grgen.ast.CollectNode;
import de.unika.ipd.grgen.ast.IdentNode;
import de.unika.ipd.grgen.ast.PackageIdentNode;
import de.unika.ipd.grgen.ast.decl.DeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.ConstraintDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.EdgeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.NodeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.VarDeclNode;
import de.unika.ipd.grgen.ast.expr.DeclExprNode;
import de.unika.ipd.grgen.ast.expr.ExprNode;
import de.unika.ipd.grgen.ast.model.type.EdgeTypeNode;
import de.unika.ipd.grgen.ast.model.type.InheritanceTypeNode;
import de.unika.ipd.grgen.ast.model.type.NodeTypeNode;
import de.unika.ipd.grgen.ast.pattern.PatternGraphLhsNode;
import de.unika.ipd.grgen.ast.type.DefinedMatchTypeNode;
import de.unika.ipd.grgen.ast.type.TypeNode;
import de.unika.ipd.grgen.ast.util.CollectResolver;
import de.unika.ipd.grgen.ast.util.DeclarationTypeResolver;
import de.unika.ipd.grgen.ir.executable.FilterAutoGenerated;
import de.unika.ipd.grgen.ir.executable.FilterAutoSupplied;
import de.unika.ipd.grgen.ir.executable.MatchingAction;
import de.unika.ipd.grgen.ir.expr.Expression;

/**
 * base class for actions = tests + rules
 */
public abstract class ActionDeclNode extends TopLevelMatcherDeclNode
{
	static {
		setName(ActionDeclNode.class, "action declaration");
	}

	protected CollectNode<BaseNode> returnFormalParametersUnresolved;
	public CollectNode<TypeNode> returnFormalParameters;
	protected ArrayList<FilterAutoDeclNode> filters;
	protected CollectNode<IdentNode> implementedMatchTypesUnresolved;
	protected CollectNode<DefinedMatchTypeNode> implementedMatchTypes;

	protected ActionDeclNode(IdentNode id, TypeNode type, PatternGraphLhsNode pattern,
			CollectNode<IdentNode> implementedMatchTypes, CollectNode<BaseNode> rets)
	{
		super(id, type, pattern);
		this.returnFormalParametersUnresolved = rets;
		becomeParent(this.returnFormalParametersUnresolved);
		implementedMatchTypesUnresolved = implementedMatchTypes;
		becomeParent(implementedMatchTypesUnresolved);
		this.filters = new ArrayList<FilterAutoDeclNode>();
	}

	public void addFilters(ArrayList<FilterAutoDeclNode> filters)
	{
		this.filters.addAll(filters);
	}

	/** returns children of this node */
	@Override
	public Collection<BaseNode> getChildren()
	{
		Vector<BaseNode> children = new Vector<BaseNode>();
		children.add(ident);
		children.add(getValidVersion(returnFormalParametersUnresolved, returnFormalParameters));
		children.add(pattern);
		children.add(getValidVersion(implementedMatchTypesUnresolved, implementedMatchTypes));
		return children;
	}

	/** returns names of the children, same order as in getChildren */
	@Override
	public Collection<String> getChildrenNames()
	{
		Vector<String> childrenNames = new Vector<String>();
		childrenNames.add("ident");
		childrenNames.add("ret");
		childrenNames.add("pattern");
		childrenNames.add("implementedMatchTypes");
		return childrenNames;
	}

	private static final CollectResolver<DefinedMatchTypeNode> matchTypeResolver =
			new CollectResolver<DefinedMatchTypeNode>(new DeclarationTypeResolver<DefinedMatchTypeNode>(DefinedMatchTypeNode.class));
	private static final CollectResolver<TypeNode> retTypeResolver =
			new CollectResolver<TypeNode>(new DeclarationTypeResolver<TypeNode>(TypeNode.class));

	/** @see de.unika.ipd.grgen.ast.BaseNode#resolveLocal() */
	@Override
	protected boolean resolveLocal()
	{
		for(IdentNode mtid : implementedMatchTypesUnresolved.getChildren()) {
			if(!(mtid instanceof PackageIdentNode)) {
				fixupDefinition(mtid, mtid.getScope());
			}
		}
		implementedMatchTypes = matchTypeResolver.resolve(implementedMatchTypesUnresolved, this);
		returnFormalParameters = retTypeResolver.resolve(returnFormalParametersUnresolved, this);

		return returnFormalParameters != null
				& implementedMatchTypes != null
				& resolveFilters(filters);
	}

	/**
	 * Check if actual return arguments are conformant to the formal return parameters.
	 */
	protected boolean checkReturns(CollectNode<ExprNode> returnArgs)
	{
		boolean res = true;

		int declaredNumRets = returnFormalParameters.size();
		int actualNumRets = returnArgs.size();
		for(int i = 0; i < Math.min(declaredNumRets, actualNumRets); i++) {
			ExprNode retExpr = returnArgs.get(i);
			TypeNode retDeclType = returnFormalParameters.get(i);

			res &= checkReturns(i, retExpr, retDeclType);
		}

		//check the number of returned elements
		if(actualNumRets != declaredNumRets) {
			res = false;
			if(declaredNumRets == 0) {
				returnArgs.reportError("No return parameters are declared in " + getKind() + " " + ident +
						", but " + actualNumRets + " return arguments are given.");
			} else if(actualNumRets == 0) {
				reportError("A return statement is missing in " + getKind() + " " + ident +
						", which is declared with " + declaredNumRets + " return parameters.");
			} else {
				returnArgs.reportError("The return statement in " + getKind() + " " + ident + " has a wrong number of arguments,"
						+ " given are " + actualNumRets + " arguments," + " but declared are " + declaredNumRets + " parameters.");
			}
		}

		return res;
	}

	private boolean checkReturns(int i, ExprNode retExpr, TypeNode retDeclType)
	{
		boolean res = true;

		TypeNode retExprType = retExpr.getType();
		TypeNode retParameterType = returnFormalParameters.get(i);

		if(!retExprType.isCompatibleTo(retDeclType)) {
			res = false;
			String exprTypeName = retExprType.getTypeName();
			String parameterTypeName = retParameterType.getTypeName();
			ident.reportError("Cannot convert " + (i + 1) + ". return argument"
					+ " from "+ exprTypeName + " to the expected " + parameterTypeName
					+ " (in " + getKind() + " " + ident + ")"
					+ retExprType.toStringWithDeclarationCoordsIfCoordsAreOfInterest()
					+ retParameterType.toStringWithDeclarationCoordsIfCoordsAreOfInterest()
					+ ".");
			return res;
		}

		if(!(retExpr instanceof DeclExprNode))
			return res;
		ConstraintDeclNode retElem = ((DeclExprNode)retExpr).getConstraintDeclNode();
		if(retElem == null)
			return res;

		InheritanceTypeNode declaredRetType = retElem.getDeclType();

		Set<? extends ConstraintDeclNode> homSet;
		if(retElem instanceof NodeDeclNode)
			homSet = pattern.getHomomorphic((NodeDeclNode)retElem);
		else
			homSet = pattern.getHomomorphic((EdgeDeclNode)retElem);

		for(ConstraintDeclNode homElem : homSet) {
			if(homElem == retElem)
				continue;

			ConstraintDeclNode retypedElem = homElem.getRetypedElement();
			if(retypedElem == null)
				continue;

			InheritanceTypeNode retypedElemType = retypedElem.getDeclType();
			if(retypedElemType.isA(declaredRetType))
				continue;

			res = false;
			retExpr.reportError("Return argument " + retElem.getIdentNode() + " is homomorphic to "
					+ homElem.getIdentNode() + ", which gets retyped to the incompatible type "
					+ retypedElemType.toStringWithDeclarationCoords() + " (in " + getKind() + " " + ident + ").");
			return res;
		}

		return res;
	}

	@Override
	protected boolean checkLocal()
	{
		return checkLeft()
				& checkFilters(pattern, filters)
				& checkMatchTypesImplemented();
	}

	public boolean checkMatchTypesImplemented()
	{
		boolean isOk = true;

		for(DefinedMatchTypeNode matchType : implementedMatchTypes.getChildren()) {
			isOk &= checkMatchTypeImplemented(matchType);
		}

		return isOk;
	}

	public boolean checkMatchTypeImplemented(DefinedMatchTypeNode matchType)
	{
		boolean isOk = true;

		HashMap<String, NodeDeclNode> knownNodes = new HashMap<String, NodeDeclNode>();
		for(NodeDeclNode node : pattern.getNodes()) {
			knownNodes.put(node.getIdentNode().toString(), node);
		}
		for(NodeDeclNode node : matchType.getNodes()) {
			isOk = checkNodeImplemented(node, matchType, knownNodes);
		}

		HashMap<String, EdgeDeclNode> knownEdges = new HashMap<String, EdgeDeclNode>();
		for(EdgeDeclNode edge : pattern.getEdges()) {
			knownEdges.put(edge.getIdentNode().toString(), edge);
		}
		for(EdgeDeclNode edge : matchType.getEdges()) {
			isOk = checkEdgeImplemented(edge, matchType, knownEdges);
		}

		HashMap<String, VarDeclNode> knownVariables = new HashMap<String, VarDeclNode>();
		for(VarDeclNode var : pattern.getDefVariablesToBeYieldedTo().getChildren()) {
			knownVariables.put(var.getIdentNode().toString(), var);
		}
		for(DeclNode varCand : pattern.getParamDecls()) {
			if(!(varCand instanceof VarDeclNode))
				continue;
			VarDeclNode var = (VarDeclNode)varCand;
			knownVariables.put(var.getIdentNode().toString(), var);
		}
		for(VarDeclNode var : matchType.getVariables()) {
			isOk = checkVariableImplemented(var, matchType, knownVariables);
		}

		return isOk;
	}

	private boolean checkNodeImplemented(NodeDeclNode node, DefinedMatchTypeNode matchType,
			HashMap<String, NodeDeclNode> knownNodes)
	{
		boolean isOk = true;

		String actionName = getKind() + " " + getIdentNode().toString();
		String matchTypeName = matchType.getIdentNode().toString() + matchType.getDecl().getDeclarationCoords();
		String nodeName = node.getIdentNode().toString();
		if(!knownNodes.containsKey(nodeName)) {
			getIdentNode().reportError("The " + actionName + " does not implement the node " + nodeName
					+ " expected from the match class " + matchTypeName + ".");
			isOk = false;
		} else {
			NodeDeclNode nodeFromPattern = knownNodes.get(nodeName);
			NodeTypeNode type = node.getDeclType();
			NodeTypeNode typeOfNodeFromPattern = nodeFromPattern.getDeclType();
			if(!type.isEqual(typeOfNodeFromPattern)) {
				getIdentNode().reportError("The type of the node " + nodeName + " from the " + actionName
						+ " does not equal the type of the node from the match class " + matchTypeName + "."
						+ " In the match class, " + type.getTypeName() + " is declared, but in the pattern, "
						+ typeOfNodeFromPattern.getTypeName() + " is declared.");
				isOk = false;
			}
			if(nodeFromPattern.defEntityToBeYieldedTo && !node.defEntityToBeYieldedTo) {
				getIdentNode().reportError("The node " + nodeName + " from the " + actionName
						+ " is a def node, while it is a node in the match class "
						+ matchTypeName + ".");
				isOk = false;
			}
			if(!nodeFromPattern.defEntityToBeYieldedTo && node.defEntityToBeYieldedTo) {
				getIdentNode().reportError("The node " + nodeName + " from the " + actionName
						+ " is a node, while it is a def node in the match class "
						+ matchTypeName + ".");
				isOk = false;
			}
		}

		return isOk;
	}

	private boolean checkEdgeImplemented(EdgeDeclNode edge, DefinedMatchTypeNode matchType,
			HashMap<String, EdgeDeclNode> knownEdges)
	{
		boolean isOk = true;

		String actionName = getKind() + " " + getIdentNode().toString();
		String matchTypeName = matchType.getIdentNode().toString() + matchType.getDecl().getDeclarationCoords();
		String edgeName = edge.getIdentNode().toString();
		if(!knownEdges.containsKey(edgeName)) {
			getIdentNode().reportError("The " + actionName + " does not implement the edge " + edgeName
					+ " expected from the match class " + matchTypeName + ".");
			isOk = false;
		} else {
			EdgeDeclNode edgeFromPattern = knownEdges.get(edgeName);
			EdgeTypeNode type = edge.getDeclType();
			EdgeTypeNode typeOfEdgeFromPattern = edgeFromPattern.getDeclType();
			if(!type.isEqual(typeOfEdgeFromPattern)) {
				getIdentNode().reportError("The type of the edge " + edgeName + " from the " + actionName
						+ " does not equal the type of the edge from the match class " + matchTypeName + "."
						+ " In the match class, " + type.getTypeName() + " is declared, but in the pattern, "
						+ typeOfEdgeFromPattern.getTypeName() + " is declared.");
				isOk = false;
			}
			if(edgeFromPattern.defEntityToBeYieldedTo && !edge.defEntityToBeYieldedTo) {
				getIdentNode().reportError("The edge " + edgeName + " from the " + actionName
						+ " is a def edge, while it is an edge in the match class "
						+ matchTypeName + ".");
				isOk = false;
			}
			if(!edgeFromPattern.defEntityToBeYieldedTo && edge.defEntityToBeYieldedTo) {
				getIdentNode().reportError("The edge " + edgeName + " from the " + actionName
						+ " is an edge, while it is a def edge in the match class "
						+ matchTypeName + ".");
				isOk = false;
			}
		}

		return isOk;
	}

	private boolean checkVariableImplemented(VarDeclNode var, DefinedMatchTypeNode matchType,
			HashMap<String, VarDeclNode> knownVariables)
	{
		boolean isOk = true;

		String actionName = getKind() + " " + getIdentNode().toString();
		String matchTypeName = matchType.getIdentNode().toString() + matchType.getDecl().getDeclarationCoords();
		String varName = var.getIdentNode().toString();
		if(!knownVariables.containsKey(varName)) {
			getIdentNode().reportError("The " + actionName + " does not implement the variable " + varName
					+ " expected from the match class " + matchTypeName + ".");
			isOk = false;
		} else {
			VarDeclNode varFromPattern = knownVariables.get(varName);
			TypeNode type = var.getDeclType();
			TypeNode typeOfVarFromPattern = varFromPattern.getDeclType();
			if(!type.isEqual(typeOfVarFromPattern)) {
				getIdentNode().reportError("The type of the variable " + varName + " from the " + actionName
						+ " does not equal the type of the variable from the match class " + matchTypeName + "."
						+ " In the match class, " + type.getTypeName() + " is declared, but in the pattern, "
						+ typeOfVarFromPattern.getTypeName() + " is declared.");
				isOk = false;
			}
			if(varFromPattern.defEntityToBeYieldedTo && !var.defEntityToBeYieldedTo) {
				getIdentNode().reportError("The variable " + varName + " from the " + actionName
						+ " is a def variable, while it is a variable in the match class "
						+ matchTypeName + ".");
				isOk = false;
			}
			if(!varFromPattern.defEntityToBeYieldedTo && var.defEntityToBeYieldedTo) {
				getIdentNode().reportError("The variable " + varName + " from the " + actionName
						+ " is a variable, while it is a def variable in the match class "
						+ matchTypeName + ".");
				isOk = false;
			}
		}

		return isOk;
	}

	public Collection<DefinedMatchTypeNode> getImplementedMatchClasses()
	{
		return implementedMatchTypes.getChildren();
	}

	protected void constructIRaux(MatchingAction constructedMatchingAction, CollectNode<ExprNode> aReturns)
	{
		// add Params to the IR
		addParams(constructedMatchingAction);

		// add Return-Params to the IR
		for(ExprNode aReturnAST : aReturns.getChildren()) {
			ExprNode evaluatedReturn = aReturnAST.evaluate();
			Expression aReturn = evaluatedReturn.checkIR(Expression.class);
			// actual return-parameter
			constructedMatchingAction.addReturn(aReturn);
		}

		// filters add themselves to the rule when their IR is constructed
		for(FilterAutoDeclNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedDeclNode) {
				((FilterAutoSuppliedDeclNode)filter).checkIR(FilterAutoSupplied.class);
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				((FilterAutoGeneratedDeclNode)filter).checkIR(FilterAutoGenerated.class);
			}
		}
	}

	public static String getKindStr()
	{
		return "action";
	}
}
