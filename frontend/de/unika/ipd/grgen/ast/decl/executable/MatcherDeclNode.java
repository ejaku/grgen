/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 7.2
 * Copyright (C) 2003-2025 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author shack
 */

package de.unika.ipd.grgen.ast.decl.executable;

import de.unika.ipd.grgen.ast.BaseNode;
import de.unika.ipd.grgen.ast.CallActionNode;
import de.unika.ipd.grgen.ast.ExecNode;
import de.unika.ipd.grgen.ast.IdentNode;
import de.unika.ipd.grgen.ast.decl.DeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.AlternativeCaseDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.AlternativeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.ConstraintDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.EdgeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.EdgeTypeChangeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.IteratedDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.NodeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.NodeTypeChangeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.RhsDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.VarDeclNode;
import de.unika.ipd.grgen.ast.expr.ExprNode;
import de.unika.ipd.grgen.ast.expr.array.ArrayAccumulationMethodNode;
import de.unika.ipd.grgen.ast.pattern.ConnectionCharacter;
import de.unika.ipd.grgen.ast.pattern.ConnectionNode;
import de.unika.ipd.grgen.ast.pattern.ImplicitNegComputer;
import de.unika.ipd.grgen.ast.pattern.ImplicitNegComputerInduced;
import de.unika.ipd.grgen.ast.pattern.PatternGraphLhsNode;
import de.unika.ipd.grgen.ast.type.TypeNode;
import de.unika.ipd.grgen.ir.Entity;
import de.unika.ipd.grgen.ir.executable.MatchingAction;
import de.unika.ipd.grgen.ir.executable.Rule;
import de.unika.ipd.grgen.ir.pattern.Alternative;
import de.unika.ipd.grgen.ir.pattern.Node;
import de.unika.ipd.grgen.ir.pattern.PatternGraphLhs;
import de.unika.ipd.grgen.ir.pattern.PatternGraphRhs;
import de.unika.ipd.grgen.ir.pattern.Variable;
import de.unika.ipd.grgen.util.Pair;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;
import java.util.Vector;

/**
 * Base class for pattern matching related ast nodes
 */
public abstract class MatcherDeclNode extends DeclNode
{
	public PatternGraphLhsNode pattern;

	public MatcherDeclNode(IdentNode id, TypeNode type, PatternGraphLhsNode left)
	{
		super(id, type);

		this.pattern = left;
		becomeParent(this.pattern);
	}

	/**
	 * Get the IR object for this matcher decl node.
	 * The IR object is instance of Rule.
	 * @return The IR object.
	 */
	public Rule getMatcher()
	{
		return checkIR(Rule.class);
	}

	protected static boolean resolveFilters(ArrayList<FilterAutoDeclNode> filters)
	{
		boolean filtersOk = true;
		for(FilterAutoDeclNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedDeclNode) {
				filtersOk &= ((FilterAutoSuppliedDeclNode)filter).resolve();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedDeclNode)filter).resolve();
			}
		}
		return filtersOk;
	}

	protected boolean checkFilters(PatternGraphLhsNode pattern, ArrayList<FilterAutoDeclNode> filters)
	{
		boolean filtersOk = true;
		for(FilterAutoDeclNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedDeclNode) {
				filtersOk &= ((FilterAutoSuppliedDeclNode)filter).check();
			} else { //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedDeclNode)filter).check();
			}
		}
		boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
		HashSet<String> alreadySeenFilters = new HashSet<String>();
		for(FilterAutoDeclNode filter : filters) {
			if(filter instanceof FilterAutoGeneratedDeclNode) {
				FilterAutoGeneratedDeclNode filterAutoGenerated = (FilterAutoGeneratedDeclNode)filter;
				String filterNameWithEntitySuffix = filterAutoGenerated.getFilterNameWithEntitySuffix();
				if(alreadySeenFilters.contains(filterNameWithEntitySuffix)) {
					reportError("The filter " + filterNameWithEntitySuffix + " was already declared for " + pattern.nameOfGraph
							+ ", only one declaration is admissible.");
					allFilterEntitiesExistAndAreOfAdmissibleType = false;
				} else {
					alreadySeenFilters.add(filterNameWithEntitySuffix);
				}
				allFilterEntitiesExistAndAreOfAdmissibleType &= checkAutoGeneratedFilter(filterAutoGenerated);
			}
		}
		return filtersOk & allFilterEntitiesExistAndAreOfAdmissibleType;
	}

	protected boolean checkAutoGeneratedFilter(FilterAutoGeneratedDeclNode filter)
	{
		String filterNameWithEntitySuffix = filter.getFilterNameWithEntitySuffix();
		switch(filter.name) {
		case "orderAscendingBy":
		case "orderDescendingBy":
		{
			boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
			for(String filterEntity : filter.entities) {
				allFilterEntitiesExistAndAreOfAdmissibleType &= pattern.checkFilterVariable(getIdentNode(),
						filterNameWithEntitySuffix, filterEntity);
			}
			return allFilterEntitiesExistAndAreOfAdmissibleType;
		}
		case "keepOneForEach":
		case "groupBy":
		case "keepSameAsFirst":
		case "keepSameAsLast":
		{
			boolean allFilterEntitiesExistAndAreOfAdmissibleType = true;
			for(String filterEntity : filter.entities) {
				allFilterEntitiesExistAndAreOfAdmissibleType &= pattern.checkFilterEntity(getIdentNode(),
						filterNameWithEntitySuffix, filterEntity);
			}
			if(filter.entities.size() != 1) {
				reportError("The filter " + filter.getFilterName()
						+ " must be declared with exactly one variable, but is declared with "
						+ filter.entities.size() + " variables"
						+ filterSpecification(filterNameWithEntitySuffix) + ".");
				allFilterEntitiesExistAndAreOfAdmissibleType = false;
			}
			return allFilterEntitiesExistAndAreOfAdmissibleType;
		}
		case "keepOneForEachAccumulateBy":
			if(filter.entities.size() != 3) {
				getIdentNode().reportError("The filter " + filter.getFilterName()
						+ " must be declared with exactly one variable, one accumulation variable,"
						+ " and one accumulation method, but is declared with " + filter.entities.size() + " entities"
						+ filterSpecification(filterNameWithEntitySuffix) + ".");
				return false;
			} else {
				if(filter.entities.get(0).equals(filter.entities.get(1))) {
					getIdentNode().reportError("The accumulation variable"
							+ " must be different from the variable " + filter.entities.get(0)
							+ filterSpecification(filterNameWithEntitySuffix) + ".");
					return false;
				}
				boolean filterEntityExistsAndIsOfAdmissibleType = pattern.checkFilterEntity(getIdentNode(),
						filterNameWithEntitySuffix, filter.entities.get(0));
				if(!filterEntityExistsAndIsOfAdmissibleType)
					return false;
				ArrayAccumulationMethodNode accumulationMethod = 
						ArrayAccumulationMethodNode.getArrayMethodNode(filter.entities.get(2));
				if(accumulationMethod == null) {
					getIdentNode().reportError("The array accumulation method "
							+ filter.entities.get(2) + " is not known"
							+ filterSpecification(filterNameWithEntitySuffix) + ".");
					return false;
				}
				VarDeclNode filterAccumulationVariable = pattern.tryGetVar(filter.entities.get(1));
				if(filterAccumulationVariable == null) {
					getIdentNode().reportError("Unknown accumulation variable " + filter.entities.get(1)
							+ filterSpecification(filterNameWithEntitySuffix) + ".");
					return false;
				}
				TypeNode filterAccumulationVariableType = filterAccumulationVariable.getDeclType();
				if(!accumulationMethod.isValidTargetTypeOfAccumulation(filterAccumulationVariableType)) {
					getIdentNode().reportError("The array accumulation method " + filter.entities.get(2)
							+ " is not applicable to the type " + filterAccumulationVariableType.getTypeName()
							+ " of the accumulation variable " + filter.entities.get(1)
							+ " / its result cannot be assigned to the accumulation variable."
							+ " (Allowed are: " + accumulationMethod.getValidTargetTypesOfAccumulation() + ")"
							+ filterSpecification(filterNameWithEntitySuffix) + ".");
					return false;
				}
				return true;
			}
		case "auto":
			return true; // skip
		default:
			assert(false);
			return false;
		}
	}

	private String filterSpecification(String filterNameWithEntitySuffix)
	{
		return " (in filter " + filterNameWithEntitySuffix + " for " + pattern.nameOfGraph + ")";
	}

	protected boolean checkNonAction(RhsDeclNode right)
	{
		boolean leftHandGraphsOk = checkLeft();

		boolean rightHandGraphsOk = true;
		if(right != null)
			rightHandGraphsOk = right.checkAgainstLhsPattern(pattern);

		boolean noReturnInPattern = true;
		if(pattern.returns.size() > 0) {
			reportError("A return statement is not allowed in a " + getKind() + ".");
			noReturnInPattern = false;
		}

		boolean noReturnInNestedReplacement = true;
		if(right != null) {
			if(right.patternGraph.returns.size() > 0) {
				reportError("A return statement is not allowed in a " + getKind() + ".");
				noReturnInNestedReplacement = false;
			}
		}

		boolean rhsReuseOk = true;
		boolean execParamsNotDeleted = true;
		boolean sameNumberOfRewriteParts = sameNumberOfRewriteParts(right, getKind());
		boolean noNestedRewriteParameters = true;
		if(right != null) {
			rhsReuseOk = checkRhsReuse(right);
			execParamsNotDeleted = checkExecParamsNotDeleted(right);
			noNestedRewriteParameters = noNestedRewriteParameters(right, getKind());
		}

		return leftHandGraphsOk
				& rightHandGraphsOk
				& sameNumberOfRewriteParts
				& noNestedRewriteParameters
				& rhsReuseOk
				& noReturnInPattern
				& noReturnInNestedReplacement
				& execParamsNotDeleted;
	}

	protected boolean checkLeft()
	{
		// check if reused names of edges connect the same nodes in the same direction with the same edge kind for each usage
		boolean isLhsEdgeReuseOk = true;

		// get the negative and independent graphs and the pattern of this ActionDeclNode
		// NOTE: the order affect the error coords
		Collection<PatternGraphLhsNode> leftHandGraphs = new LinkedList<PatternGraphLhsNode>();
		leftHandGraphs.add(pattern);
		for(PatternGraphLhsNode negative : pattern.negs.getChildren()) {
			leftHandGraphs.add(negative);
		}
		for(PatternGraphLhsNode independent : pattern.idpts.getChildren()) {
			leftHandGraphs.add(independent);
		}

		PatternGraphLhsNode[] graphs = leftHandGraphs.toArray(new PatternGraphLhsNode[0]);
		Collection<EdgeDeclNode> alreadyReported = new HashSet<EdgeDeclNode>();

		for(int i = 0; i < graphs.length; i++) {
			for(ConnectionCharacter connectionCharacter : graphs[i].getConnections()) {
				if(!(connectionCharacter instanceof ConnectionNode)) {
					continue;
				}
				ConnectionNode connection = (ConnectionNode)connectionCharacter;

				for(int j = i + 1; j < graphs.length; j++) {
					for(ConnectionCharacter nestedConnectionCharacter : graphs[j].getConnections()) {
						if(!(nestedConnectionCharacter instanceof ConnectionNode)) {
							continue;
						}
						ConnectionNode nestedConnection = (ConnectionNode)nestedConnectionCharacter;

						if(connection.getEdge().equals(nestedConnection.getEdge()) && !alreadyReported.contains(connection.getEdge())) {
							isLhsEdgeReuseOk &= isLhsEdgeReuseOk(alreadyReported, connection, nestedConnection);
						}
					}
				}
			}
		}

		return isLhsEdgeReuseOk;
	}

	private static boolean isLhsEdgeReuseOk(Collection<EdgeDeclNode> alreadyReported,
			ConnectionNode connection, ConnectionNode nestedConnection)
	{
		boolean edgeReuse = true;

		NodeDeclNode source = connection.getSrc();
		NodeDeclNode target = connection.getTgt();
		NodeDeclNode nestedSource = nestedConnection.getSrc();
		NodeDeclNode nestedTarget = nestedConnection.getTgt();

		assert !(source instanceof NodeTypeChangeDeclNode) : "no type changes in test actions";
		assert !(target instanceof NodeTypeChangeDeclNode) : "no type changes in test actions";
		assert !(nestedSource instanceof NodeTypeChangeDeclNode) : "no type changes in test actions";
		assert !(nestedTarget instanceof NodeTypeChangeDeclNode) : "no type changes in test actions";

		//check only if there's no dangling edge
		if(!( (source instanceof NodeDeclNode) && ((NodeDeclNode)source).isDummy() )
			&& !( (nestedSource instanceof NodeDeclNode) && ((NodeDeclNode)nestedSource).isDummy() )
			&& source != nestedSource) {
			alreadyReported.add(connection.getEdge());
			nestedConnection.reportError("Reused edge " + connection.getEdge()
					+ " does not connect the same source nodes"
					+ differsFromSpecification(source, nestedSource, true) + ".");
			edgeReuse = false;
		}
		if(!( (target instanceof NodeDeclNode) && ((NodeDeclNode)target).isDummy() )
			&& !( (nestedTarget instanceof NodeDeclNode) && ((NodeDeclNode)nestedTarget).isDummy() )
			&& target != nestedTarget
			&& !alreadyReported.contains(connection.getEdge())) {
			alreadyReported.add(connection.getEdge());
			nestedConnection.reportError("Reused edge " + connection.getEdge()
					+ " does not connect the same target nodes"
					+ differsFromSpecification(target, nestedTarget, true) + ".");
			edgeReuse = false;
		}

		if(connection.getConnectionKind() != nestedConnection.getConnectionKind()) {
			alreadyReported.add(connection.getEdge());
			nestedConnection.reportError("Reused edge " + connection.getEdge()
					+ " does not have the same connection kind"
					+ " (" + ConnectionNode.toString(connection.getConnectionKind()) + " differs from nested " + ConnectionNode.toString(nestedConnection.getConnectionKind())+ ").");
			edgeReuse = false;
		}

		return edgeReuse;
	}

	private static String differsFromSpecification(NodeDeclNode leftNode, NodeDeclNode rightNode, boolean nested)
	{
		return " (" + leftNode.userFriendlyToString()
				+ " differs from " + (nested ? "nested " : "")
				+ rightNode.userFriendlyToString()
				+ ")";
	}

	/** Checks, whether the reused nodes and edges of the RHS are consistent with the LHS.
	 * If consistent, replace the dummy nodes with the nodes the pattern edge is
	 * incident to (if these aren't dummy nodes themselves, of course). */
	protected boolean checkRhsReuse(RhsDeclNode right)
	{
		boolean res = true;

		HashMap<EdgeDeclNode, NodeDeclNode> redirectedFrom = new HashMap<EdgeDeclNode, NodeDeclNode>();
		HashMap<EdgeDeclNode, NodeDeclNode> redirectedTo = new HashMap<EdgeDeclNode, NodeDeclNode>();

		Collection<EdgeDeclNode> alreadyReported = new HashSet<EdgeDeclNode>();
		for(ConnectionNode rightConnection : right.getConnectionsToReuse(pattern)) {
			EdgeDeclNode rightEdge = rightConnection.getEdge();

			if(rightEdge instanceof EdgeTypeChangeDeclNode) {
				rightEdge = ((EdgeTypeChangeDeclNode)rightEdge).getOldEdge();
			}

			for(ConnectionCharacter leftConnectionCharacter : pattern.getConnections()) {
				if(!(leftConnectionCharacter instanceof ConnectionNode)) {
					continue;
				}

				ConnectionNode leftConnection = (ConnectionNode)leftConnectionCharacter;

				EdgeDeclNode leftEdge = leftConnection.getEdge();

				if(!leftEdge.equals(rightEdge)) {
					continue;
				}

				if(leftConnection.getConnectionKind() != rightConnection.getConnectionKind()) {
					res = false;
					rightConnection.reportError("Reused edge " + rightEdge + " does not have the same connection kind"
							+ " (in pattern: " + ConnectionNode.toString(leftConnection.getConnectionKind())
							+ ", but in rewrite part: " + ConnectionNode.toString(rightConnection.getConnectionKind())+ ").");
					// if you don't add to alreadyReported erroneous errors can occur,
					// e.g. lhs=x-e->y, rhs=y-e-x
					alreadyReported.add(rightEdge);
				}

				res &= isLhsRhsReuseOk(alreadyReported, redirectedFrom, redirectedTo,
						right, leftConnection, rightConnection);
			}
		}

		return res;
	}

	private boolean isLhsRhsReuseOk(Collection<EdgeDeclNode> alreadyReported,
			HashMap<EdgeDeclNode, NodeDeclNode> redirectedFrom, HashMap<EdgeDeclNode, NodeDeclNode> redirectedTo,
			RhsDeclNode right, ConnectionNode leftConnection, ConnectionNode rightConnection)
	{
		NodeDeclNode rightSource = rightConnection.getSrc();
		NodeDeclNode rightTarget = rightConnection.getTgt();

		HashSet<BaseNode> rhsNodes = new HashSet<BaseNode>();
		rhsNodes.addAll(right.getNodesToReuse(pattern));

		if(rightSource instanceof NodeTypeChangeDeclNode) {
			rightSource = ((NodeTypeChangeDeclNode)rightSource).getOldNode();
			rhsNodes.add(rightSource);
		}
		if(rightTarget instanceof NodeTypeChangeDeclNode) {
			rightTarget = ((NodeTypeChangeDeclNode)rightTarget).getOldNode();
			rhsNodes.add(rightTarget);
		}

		boolean res = true;

		res &= isLhsRhsSourceReuseOk(alreadyReported, redirectedFrom, leftConnection, rightConnection, rightSource, rhsNodes);

		res &= isLhsRhsTargetReuseOk(alreadyReported, redirectedTo, leftConnection, rightConnection, rightTarget, rhsNodes);

		return res;
	}

	private boolean isLhsRhsSourceReuseOk(Collection<EdgeDeclNode> alreadyReported,
			HashMap<EdgeDeclNode, NodeDeclNode> redirectedFrom,
			ConnectionNode leftConnection, ConnectionNode rightConnection, 
			NodeDeclNode rightSource, HashSet<BaseNode> rhsNodes)
	{
		boolean res = true;

		EdgeDeclNode leftEdge = leftConnection.getEdge();
		EdgeDeclNode rightEdge = rightConnection.getEdge();

		NodeDeclNode leftSource = leftConnection.getSrc();

		if(!leftSource.isDummy()) {
			if(rightSource.isDummy()) {
				if(rhsNodes.contains(leftSource)) {
					//replace the dummy src node by the src node of the pattern connection
					rightConnection.setSrc(leftSource);
				} else if(!alreadyReported.contains(rightEdge)) {
					res = false;
					rightConnection.reportError("The source node" + leftSource.emptyWhenAnonymousInParenthesis(" ")
							+ " of reused/referenced edge " + leftEdge + " must be reused/referenced, too.");
					alreadyReported.add(rightEdge);
				}
			} else if(leftSource != rightSource
					&& (rightConnection.getRedirectionKind() & ConnectionNode.REDIRECT_SOURCE) != ConnectionNode.REDIRECT_SOURCE
					&& !alreadyReported.contains(rightEdge)) {
				res = false;
				rightConnection.reportError("Reused/referenced edge " + leftEdge
						+ " does not connect the same (source) nodes (and is not declared to redirect source)"
						+ differsFromSpecification(leftSource, rightSource, false) + ".");
				alreadyReported.add(rightEdge);
			}
		}

		if((rightConnection.getRedirectionKind() & ConnectionNode.REDIRECT_SOURCE) == ConnectionNode.REDIRECT_SOURCE) {
			if(rightSource.isDummy()) {
				res = false;
				rightConnection.reportError("A source redirection is specified for edge " + leftEdge + ", but no source node is given.");
			}

			if(leftSource.equals(rightSource)) {
				rightConnection.reportWarning("Redirecting edge " + leftEdge + " to the same source node again (" + rightSource + ").");
			}

			if(redirectedFrom.containsKey(leftEdge)) {
				res = false;
				NodeDeclNode rightSource2 = redirectedFrom.get(leftEdge);
				rightConnection.reportError("The source of edge " + leftEdge + " is redirected more than once"
						+ " (to " + rightSource.userFriendlyToString() + " and to " + rightSource2.userFriendlyToString() + ").");
			}
			redirectedFrom.put(leftEdge, rightSource);
		}

		//check, whether RHS "adds" a node to a dangling end of a edge
		if(!alreadyReported.contains(rightEdge)) {
			if(leftSource.isDummy() && !rightSource.isDummy()
					&& (rightConnection.getRedirectionKind() & ConnectionNode.REDIRECT_SOURCE) != ConnectionNode.REDIRECT_SOURCE) {
				res = false;
				rightConnection.reportError("Reused edge " + leftEdge + " dangles on LHS,"
						+ " but has a source node on RHS" + rightSource.emptyWhenAnonymousInParenthesis(" ") + ".");
				alreadyReported.add(rightEdge);
			}
		}

		return res;
	}

	private boolean isLhsRhsTargetReuseOk(Collection<EdgeDeclNode> alreadyReported,
			HashMap<EdgeDeclNode, NodeDeclNode> redirectedTo,
			ConnectionNode leftConnection, ConnectionNode rightConnection, 
			NodeDeclNode rightTarget, HashSet<BaseNode> rhsNodes)
	{
		boolean res = true;
	
		EdgeDeclNode leftEdge = leftConnection.getEdge();
		EdgeDeclNode rightEdge = rightConnection.getEdge();

		NodeDeclNode leftTarget = leftConnection.getTgt();

		if(!leftTarget.isDummy()) {
			if(rightTarget.isDummy()) {
				if(rhsNodes.contains(leftTarget)) {
					//replace the dummy tgt node by the tgt node of the pattern connection
					rightConnection.setTgt(leftTarget);
				} else if(!alreadyReported.contains(rightEdge)) {
					res = false;
					rightConnection.reportError("The target node" + leftTarget.emptyWhenAnonymousInParenthesis(" ")
							+ " of reused/referenced edge " + leftEdge + " must be reused/referenced, too.");
					alreadyReported.add(rightEdge);
				}
			} else if(leftTarget != rightTarget
					&& (rightConnection.getRedirectionKind() & ConnectionNode.REDIRECT_TARGET) != ConnectionNode.REDIRECT_TARGET
					&& !alreadyReported.contains(rightEdge)) {
				res = false;
				rightConnection.reportError("Reused/referenced edge " + leftEdge
						+ " does not connect the same (target) nodes (and is not declared to redirect target)"
						+ differsFromSpecification(leftTarget, rightTarget, false) + ".");
				alreadyReported.add(rightEdge);
			}
		}

		if((rightConnection.getRedirectionKind() & ConnectionNode.REDIRECT_TARGET) == ConnectionNode.REDIRECT_TARGET) {
			if(rightTarget.isDummy()) {
				res = false;
				rightConnection.reportError("A target redirection is specified for edge " + leftEdge + ", but no target node is given.");
			}

			if(leftTarget.equals(rightTarget)) {
				rightConnection.reportWarning("Redirecting edge " + leftEdge + " to the same target node again (" + rightTarget + ").");
			}

			if(redirectedTo.containsKey(leftEdge)) {
				res = false;
				NodeDeclNode rightTarget2 = redirectedTo.get(leftEdge);
				rightConnection.reportError("The target of edge " + leftEdge + " is redirected more than once"
						+ " (to " + rightTarget.userFriendlyToString() + " and to " + rightTarget2.userFriendlyToString() + ").");
			}
			redirectedTo.put(leftEdge, rightTarget);
		}

		//check, whether RHS "adds" a node to a dangling end of a edge
		if(!alreadyReported.contains(rightEdge)) {
			if(leftTarget.isDummy() && !rightTarget.isDummy()
					&& (rightConnection.getRedirectionKind() & ConnectionNode.REDIRECT_TARGET) != ConnectionNode.REDIRECT_TARGET) {
				res = false;
				rightConnection.reportError("Reused edge " + leftEdge + " dangles on LHS,"
						+ " but has a target node on RHS" + rightTarget.emptyWhenAnonymousInParenthesis(" ") + ".");
				alreadyReported.add(rightEdge);
			}
		}

		return res;
	}

	/**
	 * Check that exec parameters are not deleted.
	 *
	 * The check consider the case that parameters are deleted due to
	 * homomorphic matching.
	 */
	protected boolean checkExecParamsNotDeleted(RhsDeclNode right)
	{
		assert isResolved();

		boolean valid = true;

		Set<ConstraintDeclNode> deletedElements = right.getElementsToDelete(pattern);
		Set<ConstraintDeclNode> maybeDeletedElements = right.getMaybeDeletedElements(pattern);

		for(BaseNode imperativeStatement : right.patternGraph.imperativeStmts.getChildren()) {
			if(!(imperativeStatement instanceof ExecNode))
				continue;

			ExecNode exec = (ExecNode)imperativeStatement;
			for(CallActionNode callAction : exec.callActions.getChildren()) {
				for(ExprNode arg : callAction.params.getChildren()) {
					HashSet<ConstraintDeclNode> potentiallyResultingElements = new HashSet<ConstraintDeclNode>();
					arg.getPotentiallyResultingElements(potentiallyResultingElements);
					for(ConstraintDeclNode potentiallyResultingElement : potentiallyResultingElements) {
						valid &= checkExecParamNotDeleted(potentiallyResultingElement, deletedElements, maybeDeletedElements);
					}
				}
			}
		}

		return valid;
	}

	private static boolean checkExecParamNotDeleted(ConstraintDeclNode declNode,
			Set<ConstraintDeclNode> deletedElements, Set<ConstraintDeclNode> maybeDeletedElements)
	{
		if(deletedElements.contains(declNode)) {
			declNode.reportError("The deleted " + declNode.getKind() + " " + declNode
					+ " is not allowed to be passed to an exec statement.");
			return false;
		} else if(maybeDeletedElements.contains(declNode)) {
			declNode.maybeDeleted = true;

			if(!declNode.getIdentNode().getAnnotations().isFlagSet("maybeDeleted")) {
				String errorMessage = "The parameter " + declNode + " of the exec statement may be deleted.";
				errorMessage += " Possibly it is homomorphic with a deleted " + declNode.getKind();
				errorMessage += " (use a [maybeDeleted] annotation if you think that this does not cause problems)";

				if(declNode instanceof EdgeDeclNode) {
					errorMessage += ", or " + declNode + " is a dangling edge and a deleted node exists";
				}
				errorMessage += ".";
				declNode.reportError(errorMessage);
				
				return false;
			}
		}

		return true;
	}

	//potential TODO: use name of top-level entity, compare with top-level instead of two neighboring levels in nesting tree
	protected boolean sameNumberOfRewriteParts(RhsDeclNode right, String actionKind)
	{
		boolean res = true;

		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				if(right == null && alternativeCase.right != null) {
					alternativeCase.reportError("No rewrite part is specified in the " + actionKind + (ident.getCurrOcc().isAnonymous() ? "" : " " + ident)
							+ ", but one is given in the nested " + alternativeCase.getKind() + " " + alternativeCase.ident + ".");
					res = false;
				}
				if(right != null && alternativeCase.right == null) {
					alternativeCase.reportError("A rewrite part is specified in the " + actionKind + (ident.getCurrOcc().isAnonymous() ? "" : " " + ident)
							+ ", but none is given in the nested " + alternativeCase.getKind() + " " + alternativeCase.ident + ".");
					res = false;
				}
			}
		}

		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			if(right == null && iterated.right != null) {
				iterated.reportError("No rewrite part is specified in the " + actionKind + (ident.getCurrOcc().isAnonymous() ? "" : " " + ident)
						+ ", but one is given in the nested " + iterated.getKind() + iterated.emptyWhenAnonymousPostfix(" ") + ".");
				res = false;
			}
			if(right != null && iterated.right == null) {
				iterated.reportError("A rewrite part is specified in the " + actionKind + (ident.getCurrOcc().isAnonymous() ? "" : " " + ident)
						+ ", but none is given in the nested " + iterated.getKind() + iterated.emptyWhenAnonymousPostfix(" ") + ".");
				res = false;
			}
		}

		return res;
	}

	protected boolean noNestedRewriteParameters(RhsDeclNode right, String actionKind)
	{
		boolean res = true;

		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				if(alternativeCase.right == null)
					continue;

				Vector<DeclNode> parametersInNestedAlternativeCase = alternativeCase.right.patternGraph.getParamDecls();

				if(parametersInNestedAlternativeCase.size() != 0) {
					alternativeCase.reportError("No rewrite parameters are allowed in nested alternative cases,"
							+ " but " + parametersInNestedAlternativeCase.size() + " are given"
							+ " in " + alternativeCase.ident + ".");
					res = false;
				}
			}
		}

		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			if(iterated.right == null)
				continue;

			Vector<DeclNode> parametersInNestedIterated = iterated.right.patternGraph.getParamDecls();

			if(parametersInNestedIterated.size() != 0) {
				iterated.reportError("No rewrite parameters are allowed in nested " + iterated.getKind() + " parts,"
						+ " but " + parametersInNestedIterated.size() + " are given"
						+ iterated.emptyWhenAnonymous(" in " + iterated.ident) + ".");
				res = false;
			}
		}

		return res;
	}
	
	protected boolean noAmbiguousRetypes(RhsDeclNode right)
	{
		if(right == null)
			return false;
		boolean result = true;
		for(NodeDeclNode node : pattern.getNodes()) {
			if(node.directlyNestingLHSGraph == pattern)
				result &= noAmbiguousRetypes(right, node);
		}
		for(EdgeDeclNode edge : pattern.getEdges()) {
			if(edge.directlyNestingLHSGraph == pattern)
				result &= noAmbiguousRetypes(right, edge);
		}
		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				result &= alternativeCase.noAmbiguousRetypes(alternativeCase.right);
			}
		}
		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			result &= iterated.noAmbiguousRetypes(iterated.right);
		}
		return result;
	}
	
	protected boolean noAmbiguousRetypes(RhsDeclNode right, NodeDeclNode node)
	{
		boolean noAmbiguousRetypes = true;
		NodeTypeChangeDeclNode retypeOfNode = null;
		Pair<Boolean, NodeTypeChangeDeclNode> result = right.getRhsGraph().noAmbiguousRetypes(node, retypeOfNode);
		noAmbiguousRetypes &= result.first.booleanValue();
		retypeOfNode = result.second;
		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			NodeTypeChangeDeclNode tempRetype = null;
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				result = alternativeCase.noAmbiguousRetypes(alternativeCase.right, node, retypeOfNode);
				noAmbiguousRetypes &= result.first.booleanValue();
				if(tempRetype == null)
					tempRetype = result.second;
			}
			if(retypeOfNode == null)
				retypeOfNode = tempRetype;
		}
		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			result = iterated.noAmbiguousRetypes(iterated.right, node, retypeOfNode);
			noAmbiguousRetypes &= result.first.booleanValue();
			if(retypeOfNode == null)
				retypeOfNode = result.second;
		}
		return noAmbiguousRetypes;
	}

	protected boolean noAmbiguousRetypes(RhsDeclNode right, EdgeDeclNode edge)
	{
		boolean noAmbiguousRetypes = true;
		EdgeTypeChangeDeclNode retypeOfEdge = null;
		Pair<Boolean, EdgeTypeChangeDeclNode> result = right.getRhsGraph().noAmbiguousRetypes(edge, retypeOfEdge);
		noAmbiguousRetypes &= result.first.booleanValue();
		retypeOfEdge = result.second;
		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			EdgeTypeChangeDeclNode tempRetype = null;
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				result = alternativeCase.noAmbiguousRetypes(alternativeCase.right, edge, retypeOfEdge);
				noAmbiguousRetypes &= result.first.booleanValue();
				if(tempRetype == null)
					tempRetype = result.second;
			}
			if(retypeOfEdge == null)
				retypeOfEdge = tempRetype;
		}
		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			result = iterated.noAmbiguousRetypes(iterated.right, edge, retypeOfEdge);
			noAmbiguousRetypes &= result.first.booleanValue();
			if(retypeOfEdge == null)
				retypeOfEdge = result.second;
		}
		return noAmbiguousRetypes;
	}

	protected Pair<Boolean, NodeTypeChangeDeclNode> noAmbiguousRetypes(RhsDeclNode right, NodeDeclNode node, NodeTypeChangeDeclNode retypeOfNode)
	{
		if(right == null)
			return new Pair<Boolean, NodeTypeChangeDeclNode>(Boolean.valueOf(false), retypeOfNode);
		boolean noAmbiguousRetypes = true;
		Pair<Boolean, NodeTypeChangeDeclNode> result = right.getRhsGraph().noAmbiguousRetypes(node, retypeOfNode);
		noAmbiguousRetypes &= result.first.booleanValue();
		retypeOfNode = result.second;
		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			NodeTypeChangeDeclNode tempRetype = null;
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				result = alternativeCase.noAmbiguousRetypes(alternativeCase.right, node, retypeOfNode);
				noAmbiguousRetypes &= result.first.booleanValue();
				if(tempRetype == null)
					tempRetype = result.second;
			}
			if(retypeOfNode == null)
				retypeOfNode = tempRetype;
		}
		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			result = iterated.noAmbiguousRetypes(iterated.right, node, retypeOfNode);
			noAmbiguousRetypes &= result.first.booleanValue();
			if(retypeOfNode == null)
				retypeOfNode = result.second;
		}		
		return new Pair<Boolean, NodeTypeChangeDeclNode>(Boolean.valueOf(noAmbiguousRetypes), retypeOfNode);
	}

	protected Pair<Boolean, EdgeTypeChangeDeclNode> noAmbiguousRetypes(RhsDeclNode right, EdgeDeclNode edge, EdgeTypeChangeDeclNode retypeOfEdge)
	{
		if(right == null)
			return new Pair<Boolean, EdgeTypeChangeDeclNode>(Boolean.valueOf(false), retypeOfEdge);
		boolean noAmbiguousRetypes = true;
		Pair<Boolean, EdgeTypeChangeDeclNode> result = right.getRhsGraph().noAmbiguousRetypes(edge, retypeOfEdge);
		noAmbiguousRetypes &= result.first.booleanValue();
		retypeOfEdge = result.second;
		for(AlternativeDeclNode alternative : pattern.alts.getChildren()) {
			EdgeTypeChangeDeclNode tempRetype = null;
			for(AlternativeCaseDeclNode alternativeCase : alternative.getChildren()) {
				result = alternativeCase.noAmbiguousRetypes(alternativeCase.right, edge, retypeOfEdge);
				noAmbiguousRetypes &= result.first.booleanValue();
				if(tempRetype == null)
					tempRetype = result.second;
			}
			if(retypeOfEdge == null)
				retypeOfEdge = tempRetype;
		}
		for(IteratedDeclNode iterated : pattern.iters.getChildren()) {
			result = iterated.noAmbiguousRetypes(iterated.right, edge, retypeOfEdge);
			noAmbiguousRetypes &= result.first.booleanValue();
			if(retypeOfEdge == null)
				retypeOfEdge = result.second;
		}		
		return new Pair<Boolean, EdgeTypeChangeDeclNode>(Boolean.valueOf(noAmbiguousRetypes), retypeOfEdge);
	}

	protected void constructIRaux(Rule constructedRule, RhsDeclNode right)
	{
		// add Params to the IR
		addParams(constructedRule);

		// add replacement parameters to the IR
		PatternGraphRhs rightPattern = null;
		if(right != null) {
			rightPattern = right.getPatternGraph(pattern.getPatternGraph());
		} else {
			return;
		}

		// add replacement parameters to the current graph
		for(DeclNode decl : right.patternGraph.getParamDecls()) {
			if(decl instanceof NodeDeclNode) {
				rightPattern.addReplParameter(decl.checkIR(Node.class));
				rightPattern.addSingleNode(((NodeDeclNode)decl).getNode());
			} else if(decl instanceof VarDeclNode) {
				rightPattern.addReplParameter(decl.checkIR(Variable.class));
				rightPattern.addVariable(((VarDeclNode)decl).getVariable());
			} else {
				throw new IllegalArgumentException("unknown Class: " + decl);
			}
		}

		// and also to the nested alternatives and iterateds
		addReplacementParamsToNestedAlternativesAndIterateds(constructedRule, right);
	}

	protected void addParams(MatchingAction constructedMatchingAction)
	{
		PatternGraphLhs patternGraph = constructedMatchingAction.getPattern();

		for(DeclNode decl : pattern.getParamDecls()) {
			Entity entity = decl.checkIR(Entity.class);
			if(entity.isDefToBeYieldedTo())
				constructedMatchingAction.addDefParameter(entity);
			else
				constructedMatchingAction.addParameter(entity);
			
			if(decl instanceof VarDeclNode) { // nodes/edges already have been added
				patternGraph.addVariable(((VarDeclNode)decl).getVariable());
			}
		}
	}

	protected static void addReplacementParamsToNestedAlternativesAndIterateds(Rule constructedRule, RhsDeclNode right)
	{
		// add replacement parameters to the nested alternatives and iterateds
		PatternGraphLhs patternGraph = constructedRule.getPattern();
		for(DeclNode decl : right.patternGraph.getParamDecls()) {
			if(decl instanceof NodeDeclNode) {
				addReplacementNodeParamToNestedAlternativesAndIterateds((NodeDeclNode)decl, patternGraph);
			} else if(decl instanceof VarDeclNode) {
				addReplacementVarParamToNestedAlternativesAndIterateds((VarDeclNode)decl, patternGraph);
			} else {
				throw new IllegalArgumentException("unknown Class: " + decl);
			}
		}
	}

	private static void addReplacementNodeParamToNestedAlternativesAndIterateds(NodeDeclNode decl, PatternGraphLhs patternGraph)
	{
		for(Alternative alternative : patternGraph.getAlts()) {
			for(Rule alternativeCase : alternative.getAlternativeCases()) {
				alternativeCase.getRight().addReplParameter(decl.checkIR(Node.class));
				alternativeCase.getRight().addSingleNode(decl.getNode());
			}
		}
		for(Rule iterated : patternGraph.getIters()) {
			iterated.getRight().addReplParameter(decl.checkIR(Node.class));
			iterated.getRight().addSingleNode(decl.getNode());
		}
	}

	private static void addReplacementVarParamToNestedAlternativesAndIterateds(VarDeclNode decl, PatternGraphLhs patternGraph)
	{
		for(Alternative alternative : patternGraph.getAlts()) {
			for(Rule alternativeCase : alternative.getAlternativeCases()) {
				alternativeCase.getRight().addReplParameter(decl.checkIR(Variable.class));
				alternativeCase.getRight().addVariable(decl.getVariable());
			}
		}
		for(Rule iterated : patternGraph.getIters()) {
			iterated.getRight().addReplParameter(decl.checkIR(Variable.class));
			iterated.getRight().addVariable(decl.getVariable());
		}
	}

	/**
	 * add NACs for induced- or DPO-semantic
	 */
	protected void constructImplicitNegs(PatternGraphLhs left)
	{
		PatternGraphLhsNode leftNode = pattern;
		ImplicitNegComputer implicitNegComputer = new ImplicitNegComputer(leftNode);
		ImplicitNegComputerInduced implicitNegComputerInduced = new ImplicitNegComputerInduced(leftNode);
		
		for(PatternGraphLhs neg : implicitNegComputer.getImplicitNegGraphs()) {
			left.addNegGraph(neg);
		}
		for(PatternGraphLhs neg : implicitNegComputerInduced.getImplicitNegGraphs()) {
			left.addNegGraph(neg);
		}
	}

	// TODO use this to create IR patterns, that is currently not supported by
	//      any backend
	/*private IR constructPatternIR() {
		PatternGraph left = pattern.getPatternGraph();
	
		// return if the pattern graph already constructed the IR object
		// that may happens in recursive patterns
		if (isIRAlreadySet()) {
			return getIR();
		}
	
		Vector<PatternGraph> right = new Vector<PatternGraph>();
		for (int i = 0; i < this.right.children.size(); i++) {
			right.add(this.right.children.get(i).getPatternGraph(left));
		}
	
		// return if the pattern graph already constructed the IR object
		// that may happens in recursive patterns
		if (isIRAlreadySet()) {
			return getIR();
		}
	
		Pattern pattern = new Pattern(getIdentNode().getIdent(), left, right);
	
		constructImplicitNegs(left);
		constructIRaux(pattern);
	
		// add Eval statements to the IR
		for (int i = 0; i < this.right.children.size(); i++) {
			for (Assignment n : this.right.children.get(i).getAssignments()) {
				pattern.addEval(i,n);
			}
		}
	
		return pattern;
	}*/
}
