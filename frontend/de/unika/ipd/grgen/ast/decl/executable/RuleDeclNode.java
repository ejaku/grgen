/*
 * GrGen: graph rewrite generator tool -- release GrGen.NET 7.0
 * Copyright (C) 2003-2024 Universitaet Karlsruhe, Institut fuer Programmstrukturen und Datenorganisation, LS Goos; and free programmers
 * licensed under LGPL v3 (see LICENSE.txt included in the packaging of this file)
 * www.grgen.net
 */

/**
 * @author Sebastian Hack, Daniel Grund
 */

package de.unika.ipd.grgen.ast.decl.executable;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.Vector;

import de.unika.ipd.grgen.ast.BaseNode;
import de.unika.ipd.grgen.ast.CollectNode;
import de.unika.ipd.grgen.ast.EmitNode;
import de.unika.ipd.grgen.ast.IdentNode;
import de.unika.ipd.grgen.ast.decl.DeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.ConstraintDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.EdgeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.NodeDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.RhsDeclNode;
import de.unika.ipd.grgen.ast.decl.pattern.VarDeclNode;
import de.unika.ipd.grgen.ast.expr.DeclExprNode;
import de.unika.ipd.grgen.ast.expr.ExprNode;
import de.unika.ipd.grgen.ast.expr.MemberAccessExprNode;
import de.unika.ipd.grgen.ast.model.type.InheritanceTypeNode;
import de.unika.ipd.grgen.ast.pattern.PatternGraphRhsNode;
import de.unika.ipd.grgen.ast.pattern.PatternGraphLhsNode;
import de.unika.ipd.grgen.ast.type.DefinedMatchTypeNode;
import de.unika.ipd.grgen.ast.type.TypeNode;
import de.unika.ipd.grgen.ast.type.executable.RuleTypeNode;
import de.unika.ipd.grgen.ast.util.DeclarationTypeResolver;
import de.unika.ipd.grgen.ir.IR;
import de.unika.ipd.grgen.ir.executable.Rule;
import de.unika.ipd.grgen.ir.executable.Rule.RuleKind;
import de.unika.ipd.grgen.ir.pattern.PatternGraphLhs;
import de.unika.ipd.grgen.ir.pattern.PatternGraphRhs;
import de.unika.ipd.grgen.ir.pattern.Variable;
import de.unika.ipd.grgen.ir.stmt.EvalStatements;
import de.unika.ipd.grgen.ir.type.DefinedMatchType;

/**
 * AST node for a replacement rule.
 */
public class RuleDeclNode extends ActionDeclNode
{
	static {
		setName(RuleDeclNode.class, "rule declaration");
	}

	public RhsDeclNode right;
	
	/** Type for this declaration. */
	private RuleTypeNode type;
	private static final TypeNode ruleType = new RuleTypeNode();


	/**
	 * Make a new rule.
	 * @param id The identifier of this rule.
	 * @param left The left hand side (The pattern to match).
	 * @param right The right hand side.
	 */
	public RuleDeclNode(IdentNode id, PatternGraphLhsNode left, CollectNode<IdentNode> implementedMatchTypes,
			RhsDeclNode right, CollectNode<BaseNode> rets)
	{
		super(id, ruleType, left, implementedMatchTypes, rets);
		this.right = right;
		becomeParent(this.right);
	}

	/** returns children of this node */
	@Override
	public Collection<BaseNode> getChildren()
	{
		Vector<BaseNode> children = new Vector<BaseNode>();
		children.add(ident);
		children.add(getValidVersion(typeUnresolved, type));
		children.add(getValidVersion(returnFormalParametersUnresolved, returnFormalParameters));
		children.add(pattern);
		children.add(getValidVersion(implementedMatchTypesUnresolved, implementedMatchTypes));
		children.add(right);
		return children;
	}

	/** returns names of the children, same order as in getChildren */
	@Override
	public Collection<String> getChildrenNames()
	{
		Vector<String> childrenNames = new Vector<String>();
		childrenNames.add("ident");
		childrenNames.add("type");
		childrenNames.add("ret");
		childrenNames.add("pattern");
		childrenNames.add("implementedMatchTypes");
		childrenNames.add("right");
		return childrenNames;
	}

	protected static final DeclarationTypeResolver<RuleTypeNode> typeResolver =
			new DeclarationTypeResolver<RuleTypeNode>(RuleTypeNode.class);

	/** @see de.unika.ipd.grgen.ast.BaseNode#resolveLocal() */
	@Override
	protected boolean resolveLocal()
	{
		boolean matchAndReturnTypesAreOk = super.resolveLocal();

		type = typeResolver.resolve(typeUnresolved, this);

		boolean filtersOk = true;
		for(FilterAutoDeclNode filter : filters) {
			if(filter instanceof FilterAutoSuppliedDeclNode)
				filtersOk &= ((FilterAutoSuppliedDeclNode)filter).resolve();
			else //if(filter instanceof FilterAutoGeneratedNode)
				filtersOk &= ((FilterAutoGeneratedDeclNode)filter).resolve();
		}

		return matchAndReturnTypesAreOk
				& type != null
				& filtersOk;
	}

	public Set<ConstraintDeclNode> getDeletedElements()
	{
		return right.getElementsToDelete(pattern);
	}

	/**
	 * Check that only graph elements are returned, that are not deleted.
	 *
	 * The check also consider the case that a node is returned and homomorphic
	 * matching is allowed with a deleted node.
	 */
	private boolean checkReturnedElementsNotDeleted()
	{
		assert isResolved();

		boolean valid = true;
		Set<ConstraintDeclNode> deletedElements = right.getElementsToDelete(pattern);
		Set<ConstraintDeclNode> maybeDeletedElements = right.getMaybeDeletedElements(pattern);

		for(ExprNode expr : right.patternGraph.returns.getChildren()) {
			HashSet<ConstraintDeclNode> potentiallyResultingElements = new HashSet<ConstraintDeclNode>();
			expr.getPotentiallyResultingElements(potentiallyResultingElements);
			for(ConstraintDeclNode potentiallyResultingElement : potentiallyResultingElements) {
				valid &= checkReturnedElementNotDeleted(potentiallyResultingElement, deletedElements, maybeDeletedElements);
			}
		}

		return valid;
	}

	private static boolean checkReturnedElementNotDeleted(ConstraintDeclNode retElem,
			Set<ConstraintDeclNode> deletedElements, Set<ConstraintDeclNode> maybeDeletedElements)
	{
		if(deletedElements.contains(retElem)) {
			retElem.reportError("The deleted " + retElem.getKind() + " " + retElem
					+ " is not allowed to be returned.");
			return false;
		} else if(maybeDeletedElements.contains(retElem)) {
			retElem.maybeDeleted = true;

			if(!retElem.getIdentNode().getAnnotations().isFlagSet("maybeDeleted")) {
				String errorMessage = "Returning " + retElem.getKind() + " " + retElem + " that may be deleted.";
				errorMessage += " Possibly it is homomorphic with a deleted " + retElem.getKind();
				errorMessage += " (use a [maybeDeleted] annotation if you think that this does not cause problems)";

				if(retElem instanceof EdgeDeclNode) {
					errorMessage += ", or " + retElem + " is a dangling edge and a deleted node exists";
				}
				errorMessage += ".";
				retElem.reportError(errorMessage);
				return false;
 			}
		}

		return true;
	}

	/**
	 * Check that only graph elements are returned, that are not retyped.
	 *
	 * The check also consider the case that a node is returned and homomorphic
	 * matching is allowed with a retyped node.
	 */
	private boolean checkReturnedElementsNotRetyped()
	{
		assert isResolved();

		boolean valid = true;

		for(ExprNode expr : right.patternGraph.returns.getChildren()) {
			if(!(expr instanceof DeclExprNode))
				continue;

			ConstraintDeclNode retElem = ((DeclExprNode)expr).getConstraintDeclNode();
			if(retElem == null)
				continue;

			if(retElem.getRetypedElement() != null) {
				valid = false;

				expr.reportError("The retyped " + retElem.getKind() + " " + retElem
						+ " is not allowed to be returned.");
			}
		}

		return valid;
	}

	/**
	 * Check that every graph element is retyped to at most one type.
	 */
	private boolean checkElementsNotRetypedToDifferentTypes()
	{
		assert isResolved();

		boolean valid = true;

		for(Set<ConstraintDeclNode> homSet : pattern.getHoms()) {
			valid &= checkElementsInHomSetNotRetypedToDifferentTypes(homSet);
		}

		return valid;
	}

	private static boolean checkElementsInHomSetNotRetypedToDifferentTypes(Set<ConstraintDeclNode> homSet)
	{
		ConstraintDeclNode element = null;
		ConstraintDeclNode retypedElement = null;
		ConstraintDeclNode anotherElement = null;
		ConstraintDeclNode anotherRetypedElement = null;

		for(ConstraintDeclNode currentElement : homSet) {
			ConstraintDeclNode currentRetypedElement = currentElement.getRetypedElement();

			if(currentRetypedElement != null) {
				InheritanceTypeNode currentType = currentRetypedElement.getDeclType();

				if(retypedElement == null) {
					element = currentElement;
					retypedElement = currentRetypedElement;
				} else if(currentType != retypedElement.getDeclType()) {
					anotherElement = currentElement;
					anotherRetypedElement = currentRetypedElement;
					break;
				}
			}
		}

		boolean multipleRetypes = anotherElement != null;
		if(multipleRetypes) {
			retypedElement.reportError("The " + element.getKind() + " " + element
					+ " is retyped to " + retypedElement.getDeclType().getTypeName() + ","
					+ " but the " + anotherElement.getKind() + " " + anotherElement
					+ " it may be homomorphic to is retyped to " + anotherRetypedElement.getDeclType().getTypeName()
					+ ".");
		}

		return !multipleRetypes;
	}

	/**
	 * Check that only graph elements are retyped, that are not deleted.
	 */
	private boolean checkRetypedElementsNotDeleted()
	{
		assert isResolved();

		boolean valid = true;

		for(DeclNode decl : getDeletedElements()) {
			if(!(decl instanceof ConstraintDeclNode))
				continue;

			ConstraintDeclNode retElem = ((ConstraintDeclNode)decl);

			if(retElem.getRetypedElement() != null) {
				valid = false;

				retElem.reportError("The retyped " + retElem.getKind() + " " + retElem
						+ " is not allowed to be deleted.");
			}
		}

		return valid;
	}

	private HashSet<ConstraintDeclNode> collectNeededElements(ExprNode expr)
	{
		HashSet<ConstraintDeclNode> neededElements = new HashSet<ConstraintDeclNode>();
		if(expr instanceof MemberAccessExprNode) // attribute access is decoupled via temporary variable, so deletion of element is ok
			return neededElements;

		for(BaseNode child : expr.getChildren()) {
			if(child instanceof ExprNode)
				neededElements.addAll(collectNeededElements((ExprNode)child));

			if(child instanceof DeclExprNode)
				neededElements.add(((DeclExprNode)child).getConstraintDeclNode());
			else if(child instanceof ConstraintDeclNode)
				neededElements.add((ConstraintDeclNode)child);
		}

		return neededElements;
	}

	/**
	 * Check that emit elements are not deleted.
	 * The check considers the case that parameters are deleted due to homomorphic matching.
	 */
	private boolean checkEmitElementsNotDeleted()
	{
		assert isResolved();

		boolean valid = true;
		Set<ConstraintDeclNode> delete = right.getElementsToDelete(pattern);
		Set<ConstraintDeclNode> maybeDeleted = right.getMaybeDeletedElements(pattern);

		for(BaseNode imperativeStmt : right.patternGraph.imperativeStmts.getChildren()) {
			if(!(imperativeStmt instanceof EmitNode))
				continue;

			EmitNode emit = (EmitNode)imperativeStmt;
			for(BaseNode child : emit.getChildren()) {
				ExprNode expr = (ExprNode)child;
				for(ConstraintDeclNode declNode : collectNeededElements(expr)) {
					valid &= checkEmitElementNotDeleted(declNode, expr, delete, maybeDeleted, emit);
				}
			}
		}

		return valid;
	}

	private static boolean checkEmitElementNotDeleted(ConstraintDeclNode declNode, ExprNode expr,
			Set<ConstraintDeclNode> delete, Set<ConstraintDeclNode> maybeDeleted, EmitNode emit)
	{
		String emitVersion = emit.isDebug ? "emitdebug" : "emit";
		String emitHereVersion = emit.isDebug ? "emitheredebug" : "emithere";
		if(delete.contains(declNode)) {
			expr.reportError("The deleted " + declNode.getKind() + " " + declNode
					+ " is not allowed to be referenced in an " + emitVersion + " statement"
					+ " (you may use an " + emitHereVersion + " instead).");
			return false;
		}
		if(maybeDeleted.contains(declNode)) {
			declNode.maybeDeleted = true;

			if(!declNode.getIdentNode().getAnnotations().isFlagSet("maybeDeleted")) {
				String errorMessage = "The " + declNode.getKind() + " " + declNode + " used in an " + emitVersion + " statement may be deleted.";
				errorMessage += " Possibly it is homomorphic with a deleted " + declNode.getKind();
				errorMessage += " (use a [maybeDeleted] annotation if you think that this does not cause problems)";

				if(declNode instanceof EdgeDeclNode) {
					errorMessage += ", or " + declNode + " is a dangling edge and a deleted node exists";
				}

				errorMessage += " (you may use an " + emitHereVersion + " instead).";

				expr.reportError(errorMessage);

				return false;
			}
		}

		return true;
	}

	private void calcMaybeRetyped()
	{
		for(Set<ConstraintDeclNode> homSet : pattern.getHoms()) {
			boolean containsRetypedElem = false;
			for(ConstraintDeclNode elem : homSet) {
				if(elem.getRetypedElement() != null) {
					containsRetypedElem = true;
					break;
				}
			}

			// If there was one homomorphic element, which is retyped,
			// all non-retyped elements in the same hom group are marked
			// as maybeRetyped.
			if(containsRetypedElem) {
				for(ConstraintDeclNode elem : homSet) {
					if(elem.getRetypedElement() == null)
						elem.maybeRetyped = true;
				}
			}
		}
	}

	/**
	 * Check, if the rule type node is right.
	 * The children of a rule type are
	 * 1) a pattern for the left side.
	 * 2) a pattern for the right side.
	 * @see de.unika.ipd.grgen.ast.BaseNode#checkLocal()
	 */
	@Override
	protected boolean checkLocal()
	{
		boolean leftHandGraphsOk = super.checkLocal();

		boolean rightHandGraphsOk = right.checkAgainstLhsPattern(pattern);

		PatternGraphRhsNode right = this.right.patternGraph;

		// check if the pattern name equals the rule name
		// named rewrite parts are only allowed in subpatterns
		String ruleName = ident.toString();
		if(!right.nameOfGraph.equals(ruleName))
			this.right.reportError("Named rewrite parts are not allowed in rules (only in (sub)patterns).");

		// check if parameters only exists for subpatterns
		if(right.params.getChildren().size() > 0)
			this.right.reportError("Parameters for the rewrite part are not allowed in rules (only in (sub)patterns).");

		boolean noReturnInPatternOk = true;
		if(pattern.returns.size() > 0) {
			reportError("A return statement is not allowed in the pattern part of a rule.");
			noReturnInPatternOk = false;
		}

		calcMaybeRetyped();

		return leftHandGraphsOk
				& rightHandGraphsOk
				& checkRhsReuse(this.right)
				& sameNumberOfRewriteParts(this.right, "rule")
				& noReturnInPatternOk
				& noAbstractElementInstantiated(this.right)
				& checkRetypedElementsNotDeleted()
				& checkReturnedElementsNotDeleted()
				& checkElementsNotRetypedToDifferentTypes()
				& checkReturnedElementsNotRetyped()
				& checkExecParamsNotDeleted(this.right)
				& checkEmitElementsNotDeleted()
				& checkReturns(right.returns)
				& noAmbiguousRetypes(this.right);
	}
	
	public NodeDeclNode tryGetNode(IdentNode ident)
	{
		for(NodeDeclNode node : pattern.getNodes()) {
			if(node.ident.toString().equals(ident.toString()))
				return node;
		}
		for(NodeDeclNode node : right.patternGraph.getNodes()) {
			if(node.ident.toString().equals(ident.toString()))
				return node;
		}
		return null;
	}

	public EdgeDeclNode tryGetEdge(IdentNode ident)
	{
		for(EdgeDeclNode edge : pattern.getEdges()) {
			if(edge.ident.toString().equals(ident.toString()))
				return edge;
		}
		for(EdgeDeclNode edge : right.patternGraph.getEdges()) {
			if(edge.ident.toString().equals(ident.toString()))
				return edge;
		}
		return null;
	}

	public VarDeclNode tryGetVar(IdentNode ident)
	{
		for(VarDeclNode var : pattern.defVariablesToBeYieldedTo.getChildren()) {
			if(var.ident.toString().equals(ident.toString()))
				return var;
		}
		for(DeclNode varCand : pattern.getParamDecls()) {
			if(!(varCand instanceof VarDeclNode))
				continue;
			VarDeclNode var = (VarDeclNode)varCand;
			if(var.ident.toString().equals(ident.toString()))
				return var;
		}
		for(VarDeclNode var : right.patternGraph.defVariablesToBeYieldedTo.getChildren()) {
			if(var.ident.toString().equals(ident.toString()))
				return var;
		}
		for(DeclNode varCand : right.patternGraph.getParamDecls()) {
			if(!(varCand instanceof VarDeclNode))
				continue;
			VarDeclNode var = (VarDeclNode)varCand;
			if(var.ident.toString().equals(ident.toString()))
				return var;
		}
		return null;
	}

	public static String getKindStr()
	{
		return "rule";
	}

	/**
	 * @see de.unika.ipd.grgen.ast.BaseNode#constructIR()
	 */
	@Override
	protected IR constructIR()
	{
		// return if the pattern graph already constructed the IR object
		// that may happen in recursive patterns (and other usages/references)
		if(isIRAlreadySet()) {
			return getIR();
		}

		Rule rule = new Rule(getIdentNode().getIdent(), RuleKind.Rule);

		// mark this node as already visited
		setIR(rule);

		PatternGraphLhs left = pattern.getPatternGraph();
		for(DeclNode varCand : pattern.getParamDecls()) {
			if(!(varCand instanceof VarDeclNode))
				continue;
			VarDeclNode var = (VarDeclNode)varCand;
			left.addVariable(var.checkIR(Variable.class));
		}

		PatternGraphRhs right = this.right.getPatternGraph(left);

		rule.initialize(left, right);

		for(DefinedMatchTypeNode implementedMatchClassNode : implementedMatchTypes.getChildren()) {
			DefinedMatchType implementedMatchClass = implementedMatchClassNode.checkIR(DefinedMatchType.class);
			rule.addImplementedMatchClass(implementedMatchClass);
		}

		constructImplicitNegs(left);
		constructIRaux(rule, this.right.patternGraph.returns);

		// add eval statements to the IR
		for(EvalStatements evalStatement : this.right.getRhsGraph().getEvalStatements()) {
			rule.addEval(evalStatement);
		}

		return rule;
	}

	@Override
	public RuleTypeNode getDeclType()
	{
		assert isResolved();

		return type;
	}
}
